import android
import android.content
import android.graphics
import android.graphics.drawable
import android.graphics.text
import android.icu.util
import android.os
import android.util
import android.view
import java
import java.chaquopy
import java.lang
import java.util
import java.util.regex
import org.xml.sax
import typing



class AlteredCharSequence(java.lang.CharSequence, GetChars):
    def charAt(self, off: int | java.jint | java.lang.Integer, /) -> str: ...
    def getChars(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, dest: java.chaquopy.JavaArrayJChar, off: int | java.jint | java.lang.Integer, /) -> None: ...
    def length(self) -> int: ...
    @staticmethod
    def make(source: java.lang.CharSequence, sub: java.chaquopy.JavaArrayJChar, substart: int | java.jint | java.lang.Integer, subend: int | java.jint | java.lang.Integer, /) -> AlteredCharSequence: ...
    def subSequence(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> java.lang.CharSequence: ...
    def toString(self) -> str: ...

class AndroidCharacter(java.lang.Object):
    EAST_ASIAN_WIDTH_AMBIGUOUS: typing.ClassVar[int] = ...
    EAST_ASIAN_WIDTH_FULL_WIDTH: typing.ClassVar[int] = ...
    EAST_ASIAN_WIDTH_HALF_WIDTH: typing.ClassVar[int] = ...
    EAST_ASIAN_WIDTH_NARROW: typing.ClassVar[int] = ...
    EAST_ASIAN_WIDTH_NEUTRAL: typing.ClassVar[int] = ...
    EAST_ASIAN_WIDTH_WIDE: typing.ClassVar[int] = ...
    def __init__(self) -> None: ...
    @staticmethod
    def getDirectionalities(arg1: java.chaquopy.JavaArrayJChar, arg2: java.chaquopy.JavaArrayJByte, arg3: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def getEastAsianWidth(arg1: str | java.jchar | java.lang.Character, /) -> int: ...
    @staticmethod
    def getEastAsianWidths(arg1: java.chaquopy.JavaArrayJChar, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, arg4: java.chaquopy.JavaArrayJByte, /) -> None: ...
    @staticmethod
    def getMirror(arg1: str | java.jchar | java.lang.Character, /) -> str: ...
    @staticmethod
    def mirror(arg1: java.chaquopy.JavaArrayJChar, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> bool: ...

class Annotation(ParcelableSpan):
    @typing.overload
    def __init__(self, src: android.os.Parcel, /) -> None: ...
    @typing.overload
    def __init__(self, key: str | java.lang.String, value: str | java.lang.String, /) -> None: ...
    def describeContents(self) -> int: ...
    def getKey(self) -> str: ...
    def getSpanTypeId(self) -> int: ...
    def getValue(self) -> str: ...
    def writeToParcel(self, dest: android.os.Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...

class AutoText(java.lang.Object):
    @staticmethod
    def get(src: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, view: android.view.View, /) -> str: ...
    @staticmethod
    def getSize(view: android.view.View, /) -> int: ...

class BidiFormatter(java.lang.Object):
    @typing.overload
    @staticmethod
    def getInstance() -> BidiFormatter: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, /) -> BidiFormatter: ...
    @typing.overload
    @staticmethod
    def getInstance(rtlContext: bool | java.jboolean | java.lang.Boolean, /) -> BidiFormatter: ...
    def getStereoReset(self) -> bool: ...
    @typing.overload
    def isRtl(self, str: java.lang.CharSequence, /) -> bool: ...
    @typing.overload
    def isRtl(self, str: str | java.lang.String, /) -> bool: ...
    def isRtlContext(self) -> bool: ...
    @typing.overload
    def unicodeWrap(self, str: java.lang.CharSequence, /) -> java.lang.CharSequence | None: ...
    @typing.overload
    def unicodeWrap(self, str: str | java.lang.String, /) -> str | None: ...
    @typing.overload
    def unicodeWrap(self, str: java.lang.CharSequence, heuristic: TextDirectionHeuristic, /) -> java.lang.CharSequence | None: ...
    @typing.overload
    def unicodeWrap(self, str: java.lang.CharSequence, isolate: bool | java.jboolean | java.lang.Boolean, /) -> java.lang.CharSequence | None: ...
    @typing.overload
    def unicodeWrap(self, str: str | java.lang.String, heuristic: TextDirectionHeuristic, /) -> str | None: ...
    @typing.overload
    def unicodeWrap(self, str: str | java.lang.String, isolate: bool | java.jboolean | java.lang.Boolean, /) -> str | None: ...
    @typing.overload
    def unicodeWrap(self, str: java.lang.CharSequence, heuristic: TextDirectionHeuristic, isolate: bool | java.jboolean | java.lang.Boolean, /) -> java.lang.CharSequence | None: ...
    @typing.overload
    def unicodeWrap(self, str: str | java.lang.String, heuristic: TextDirectionHeuristic, isolate: bool | java.jboolean | java.lang.Boolean, /) -> str | None: ...

    class Builder(java.lang.Object):
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, locale: java.util.Locale, /) -> None: ...
        @typing.overload
        def __init__(self, rtlContext: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
        def build(self) -> BidiFormatter: ...
        def setTextDirectionHeuristic(self, heuristic: TextDirectionHeuristic, /) -> BidiFormatter.Builder: ...
        def stereoReset(self, stereoReset: bool | java.jboolean | java.lang.Boolean, /) -> BidiFormatter.Builder: ...

class BoringLayout(Layout, android.text.TextUtils.EllipsizeCallback):
    @typing.overload
    def __init__(self, source: java.lang.CharSequence, paint: TextPaint, outerwidth: int | java.jint | java.lang.Integer, align: Layout.Alignment, spacingMult: float | java.jfloat | java.lang.Float, spacingAdd: float | java.jfloat | java.lang.Float, metrics: BoringLayout.Metrics, includePad: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def __init__(self, source: java.lang.CharSequence, paint: TextPaint, outerWidth: int | java.jint | java.lang.Integer, align: Layout.Alignment, spacingMult: float | java.jfloat | java.lang.Float, spacingAdd: float | java.jfloat | java.lang.Float, metrics: BoringLayout.Metrics, includePad: bool | java.jboolean | java.lang.Boolean, ellipsize: TextUtils.TruncateAt, ellipsizedWidth: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, source: java.lang.CharSequence, paint: TextPaint, outerWidth: int | java.jint | java.lang.Integer, align: Layout.Alignment, spacingMult: float | java.jfloat | java.lang.Float, spacingAdd: float | java.jfloat | java.lang.Float, metrics: BoringLayout.Metrics, includePad: bool | java.jboolean | java.lang.Boolean, ellipsize: TextUtils.TruncateAt, ellipsizedWidth: int | java.jint | java.lang.Integer, useFallbackLineSpacing: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def computeDrawingBoundingBox(self) -> android.graphics.RectF: ...
    def draw(self, c: android.graphics.Canvas, highlight: android.graphics.Path, highlightpaint: android.graphics.Paint, cursorOffset: int | java.jint | java.lang.Integer, /) -> None: ...
    def ellipsized(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> None: ...
    def getBottomPadding(self) -> int: ...
    def getEllipsisCount(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getEllipsisStart(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getEllipsizedWidth(self) -> int: ...
    def getHeight(self) -> int: ...
    def getLineContainsTab(self, line: int | java.jint | java.lang.Integer, /) -> bool: ...
    def getLineCount(self) -> int: ...
    def getLineDescent(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineDirections(self, line: int | java.jint | java.lang.Integer, /) -> Layout.Directions: ...
    def getLineMax(self, line: int | java.jint | java.lang.Integer, /) -> float: ...
    def getLineStart(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineTop(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineWidth(self, line: int | java.jint | java.lang.Integer, /) -> float: ...
    def getParagraphDirection(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getTopPadding(self) -> int: ...
    @typing.overload
    @staticmethod
    def isBoring(text: java.lang.CharSequence, paint: TextPaint, /) -> BoringLayout.Metrics | None: ...
    @typing.overload
    @staticmethod
    def isBoring(text: java.lang.CharSequence, paint: TextPaint, metrics: BoringLayout.Metrics, /) -> BoringLayout.Metrics | None: ...
    @typing.overload
    @staticmethod
    def isBoring(text: java.lang.CharSequence, paint: TextPaint, textDir: TextDirectionHeuristic, useFallbackLineSpacing: bool | java.jboolean | java.lang.Boolean, metrics: BoringLayout.Metrics, /) -> BoringLayout.Metrics | None: ...
    def isFallbackLineSpacingEnabled(self) -> bool: ...
    @typing.overload
    @staticmethod
    def make(source: java.lang.CharSequence, paint: TextPaint, outerWidth: int | java.jint | java.lang.Integer, align: Layout.Alignment, spacingMult: float | java.jfloat | java.lang.Float, spacingAdd: float | java.jfloat | java.lang.Float, metrics: BoringLayout.Metrics, includePad: bool | java.jboolean | java.lang.Boolean, /) -> BoringLayout: ...
    @typing.overload
    @staticmethod
    def make(source: java.lang.CharSequence, paint: TextPaint, outerWidth: int | java.jint | java.lang.Integer, align: Layout.Alignment, metrics: BoringLayout.Metrics, includePad: bool | java.jboolean | java.lang.Boolean, ellipsize: TextUtils.TruncateAt, ellipsizedWidth: int | java.jint | java.lang.Integer, useFallbackLineSpacing: bool | java.jboolean | java.lang.Boolean, /) -> BoringLayout: ...
    @typing.overload
    @staticmethod
    def make(source: java.lang.CharSequence, paint: TextPaint, outerWidth: int | java.jint | java.lang.Integer, align: Layout.Alignment, spacingmult: float | java.jfloat | java.lang.Float, spacingadd: float | java.jfloat | java.lang.Float, metrics: BoringLayout.Metrics, includePad: bool | java.jboolean | java.lang.Boolean, ellipsize: TextUtils.TruncateAt, ellipsizedWidth: int | java.jint | java.lang.Integer, /) -> BoringLayout: ...
    @typing.overload
    def replaceOrMake(self, source: java.lang.CharSequence, paint: TextPaint, outerwidth: int | java.jint | java.lang.Integer, align: Layout.Alignment, spacingMult: float | java.jfloat | java.lang.Float, spacingAdd: float | java.jfloat | java.lang.Float, metrics: BoringLayout.Metrics, includePad: bool | java.jboolean | java.lang.Boolean, /) -> BoringLayout: ...
    @typing.overload
    def replaceOrMake(self, source: java.lang.CharSequence, paint: TextPaint, outerWidth: int | java.jint | java.lang.Integer, align: Layout.Alignment, metrics: BoringLayout.Metrics, includePad: bool | java.jboolean | java.lang.Boolean, ellipsize: TextUtils.TruncateAt, ellipsizedWidth: int | java.jint | java.lang.Integer, useFallbackLineSpacing: bool | java.jboolean | java.lang.Boolean, /) -> BoringLayout: ...
    @typing.overload
    def replaceOrMake(self, source: java.lang.CharSequence, paint: TextPaint, outerWidth: int | java.jint | java.lang.Integer, align: Layout.Alignment, spacingMult: float | java.jfloat | java.lang.Float, spacingAdd: float | java.jfloat | java.lang.Float, metrics: BoringLayout.Metrics, includePad: bool | java.jboolean | java.lang.Boolean, ellipsize: TextUtils.TruncateAt, ellipsizedWidth: int | java.jint | java.lang.Integer, /) -> BoringLayout: ...

    class Metrics(android.graphics.Paint.FontMetricsInt):
        width: int = ...
        def __init__(self) -> None: ...
        def getDrawingBoundingBox(self) -> android.graphics.RectF: ...
        def toString(self) -> str: ...

class ClipboardManager(java.lang.Object):
    def __init__(self) -> None: ...
    def getText(self) -> java.lang.CharSequence: ...
    def hasText(self) -> bool: ...
    def setText(self, arg1: java.lang.CharSequence, /) -> None: ...

class DynamicLayout(Layout):
    @typing.overload
    def __init__(self, base: java.lang.CharSequence, paint: TextPaint, width: int | java.jint | java.lang.Integer, align: Layout.Alignment, spacingmult: float | java.jfloat | java.lang.Float, spacingadd: float | java.jfloat | java.lang.Float, includepad: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def __init__(self, base: java.lang.CharSequence, display: java.lang.CharSequence, paint: TextPaint, width: int | java.jint | java.lang.Integer, align: Layout.Alignment, spacingmult: float | java.jfloat | java.lang.Float, spacingadd: float | java.jfloat | java.lang.Float, includepad: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def __init__(self, base: java.lang.CharSequence, display: java.lang.CharSequence, paint: TextPaint, width: int | java.jint | java.lang.Integer, align: Layout.Alignment, spacingmult: float | java.jfloat | java.lang.Float, spacingadd: float | java.jfloat | java.lang.Float, includepad: bool | java.jboolean | java.lang.Boolean, ellipsize: TextUtils.TruncateAt, ellipsizedWidth: int | java.jint | java.lang.Integer, /) -> None: ...
    def getBottomPadding(self) -> int: ...
    def getEllipsisCount(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getEllipsisStart(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getEllipsizedWidth(self) -> int: ...
    def getLineBreakConfig(self) -> android.graphics.text.LineBreakConfig: ...
    def getLineContainsTab(self, line: int | java.jint | java.lang.Integer, /) -> bool: ...
    def getLineCount(self) -> int: ...
    def getLineDescent(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineDirections(self, line: int | java.jint | java.lang.Integer, /) -> Layout.Directions: ...
    def getLineStart(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineTop(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getParagraphDirection(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getTopPadding(self) -> int: ...

    class Builder(java.lang.Object):
        def build(self) -> DynamicLayout: ...
        @staticmethod
        def obtain(base: java.lang.CharSequence, paint: TextPaint, width: int | java.jint | java.lang.Integer, /) -> DynamicLayout.Builder: ...
        def setAlignment(self, alignment: Layout.Alignment, /) -> DynamicLayout.Builder: ...
        def setBreakStrategy(self, breakStrategy: int | java.jint | java.lang.Integer, /) -> DynamicLayout.Builder: ...
        def setDisplayText(self, display: java.lang.CharSequence, /) -> DynamicLayout.Builder: ...
        def setEllipsize(self, ellipsize: TextUtils.TruncateAt, /) -> DynamicLayout.Builder: ...
        def setEllipsizedWidth(self, ellipsizedWidth: int | java.jint | java.lang.Integer, /) -> DynamicLayout.Builder: ...
        def setHyphenationFrequency(self, hyphenationFrequency: int | java.jint | java.lang.Integer, /) -> DynamicLayout.Builder: ...
        def setIncludePad(self, includePad: bool | java.jboolean | java.lang.Boolean, /) -> DynamicLayout.Builder: ...
        def setJustificationMode(self, justificationMode: int | java.jint | java.lang.Integer, /) -> DynamicLayout.Builder: ...
        def setLineBreakConfig(self, lineBreakConfig: android.graphics.text.LineBreakConfig, /) -> DynamicLayout.Builder: ...
        def setLineSpacing(self, spacingAdd: float | java.jfloat | java.lang.Float, spacingMult: float | java.jfloat | java.lang.Float, /) -> DynamicLayout.Builder: ...
        def setMinimumFontMetrics(self, minimumFontMetrics: android.graphics.Paint.FontMetrics, /) -> DynamicLayout.Builder: ...
        def setShiftDrawingOffsetForStartOverhang(self, shiftDrawingOffsetForStartOverhang: bool | java.jboolean | java.lang.Boolean, /) -> DynamicLayout.Builder: ...
        def setTextDirection(self, textDir: TextDirectionHeuristic, /) -> DynamicLayout.Builder: ...
        def setUseBoundsForWidth(self, useBoundsForWidth: bool | java.jboolean | java.lang.Boolean, /) -> DynamicLayout.Builder: ...
        def setUseLineSpacingFromFallbacks(self, useLineSpacingFromFallbacks: bool | java.jboolean | java.lang.Boolean, /) -> DynamicLayout.Builder: ...

class Editable(java.lang.Appendable, java.lang.CharSequence, GetChars, Spannable):
    @typing.overload
    def append(self, arg1: str | java.jchar | java.lang.Character, /) -> Editable: ...
    @typing.overload
    def append(self, arg1: java.lang.CharSequence, /) -> Editable: ...
    @typing.overload
    def append(self, arg1: java.lang.CharSequence, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> Editable: ...
    def clear(self) -> None: ...
    def clearSpans(self) -> None: ...
    def delete(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, /) -> Editable: ...
    def getFilters(self) -> java.chaquopy.JavaArray[InputFilter]: ...
    @typing.overload
    def insert(self, arg1: int | java.jint | java.lang.Integer, arg2: java.lang.CharSequence, /) -> Editable: ...
    @typing.overload
    def insert(self, arg1: int | java.jint | java.lang.Integer, arg2: java.lang.CharSequence, arg3: int | java.jint | java.lang.Integer, arg4: int | java.jint | java.lang.Integer, /) -> Editable: ...
    @typing.overload
    def replace(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, arg3: java.lang.CharSequence, /) -> Editable: ...
    @typing.overload
    def replace(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, arg3: java.lang.CharSequence, arg4: int | java.jint | java.lang.Integer, arg5: int | java.jint | java.lang.Integer, /) -> Editable: ...
    def setFilters(self, arg1: java.chaquopy.JavaArray[InputFilter], /) -> None: ...

    class Factory(java.lang.Object):
        def __init__(self) -> None: ...
        @staticmethod
        def getInstance() -> Editable.Factory: ...
        def newEditable(self, source: java.lang.CharSequence, /) -> Editable: ...

class EmojiConsistency(java.lang.Object):
    @staticmethod
    def getEmojiConsistencySet() -> java.util.Set[java.chaquopy.JavaArrayJInt]: ...

class GetChars(java.lang.CharSequence):
    def getChars(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, arg3: java.chaquopy.JavaArrayJChar, arg4: int | java.jint | java.lang.Integer, /) -> None: ...

class GraphemeClusterSegmentFinder(SegmentFinder):
    def __init__(self, text: java.lang.CharSequence, textPaint: TextPaint, /) -> None: ...
    def nextEndBoundary(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...
    def nextStartBoundary(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...
    def previousEndBoundary(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...
    def previousStartBoundary(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...

class Highlights(java.lang.Object):
    def getPaint(self, index: int | java.jint | java.lang.Integer, /) -> android.graphics.Paint: ...
    def getRanges(self, index: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJInt: ...
    def getSize(self) -> int: ...

    class Builder(java.lang.Object):
        def __init__(self) -> None: ...
        def addRange(self, paint: android.graphics.Paint, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> Highlights.Builder: ...
        def addRanges(self, paint: android.graphics.Paint, /, *ranges: java.chaquopy.JavaArrayJInt) -> Highlights.Builder: ...
        def build(self) -> Highlights: ...

class Html(java.lang.Object):
    FROM_HTML_MODE_COMPACT: typing.ClassVar[int] = ...
    FROM_HTML_MODE_LEGACY: typing.ClassVar[int] = ...
    FROM_HTML_OPTION_USE_CSS_COLORS: typing.ClassVar[int] = ...
    FROM_HTML_SEPARATOR_LINE_BREAK_BLOCKQUOTE: typing.ClassVar[int] = ...
    FROM_HTML_SEPARATOR_LINE_BREAK_DIV: typing.ClassVar[int] = ...
    FROM_HTML_SEPARATOR_LINE_BREAK_HEADING: typing.ClassVar[int] = ...
    FROM_HTML_SEPARATOR_LINE_BREAK_LIST: typing.ClassVar[int] = ...
    FROM_HTML_SEPARATOR_LINE_BREAK_LIST_ITEM: typing.ClassVar[int] = ...
    FROM_HTML_SEPARATOR_LINE_BREAK_PARAGRAPH: typing.ClassVar[int] = ...
    TO_HTML_PARAGRAPH_LINES_CONSECUTIVE: typing.ClassVar[int] = ...
    TO_HTML_PARAGRAPH_LINES_INDIVIDUAL: typing.ClassVar[int] = ...
    @staticmethod
    def escapeHtml(text: java.lang.CharSequence, /) -> str: ...
    @typing.overload
    @staticmethod
    def fromHtml(source: str | java.lang.String, /) -> Spanned: ...
    @typing.overload
    @staticmethod
    def fromHtml(source: str | java.lang.String, flags: int | java.jint | java.lang.Integer, /) -> Spanned: ...
    @typing.overload
    @staticmethod
    def fromHtml(source: str | java.lang.String, imageGetter: Html.ImageGetter, tagHandler: Html.TagHandler, /) -> Spanned: ...
    @typing.overload
    @staticmethod
    def fromHtml(source: str | java.lang.String, flags: int | java.jint | java.lang.Integer, imageGetter: Html.ImageGetter, tagHandler: Html.TagHandler, /) -> Spanned: ...
    @typing.overload
    @staticmethod
    def toHtml(text: Spanned, /) -> str: ...
    @typing.overload
    @staticmethod
    def toHtml(text: Spanned, option: int | java.jint | java.lang.Integer, /) -> str: ...

    class TagHandler(java.lang.Object):
        def handleTag(self, arg1: bool | java.jboolean | java.lang.Boolean, arg2: str | java.lang.String, arg3: Editable, arg4: org.xml.sax.XMLReader, /) -> None: ...

    class ImageGetter(java.lang.Object):
        def getDrawable(self, arg1: str | java.lang.String, /) -> android.graphics.drawable.Drawable: ...

class InputFilter(java.lang.Object):
    def filter(self, arg1: java.lang.CharSequence, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, arg4: Spanned, arg5: int | java.jint | java.lang.Integer, arg6: int | java.jint | java.lang.Integer, /) -> java.lang.CharSequence: ...

    class LengthFilter(InputFilter):
        def __init__(self, max: int | java.jint | java.lang.Integer, /) -> None: ...
        def filter(self, source: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, dest: Spanned, dstart: int | java.jint | java.lang.Integer, dend: int | java.jint | java.lang.Integer, /) -> java.lang.CharSequence: ...
        def getMax(self) -> int: ...

    class AllCaps(InputFilter):
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, locale: java.util.Locale, /) -> None: ...
        def filter(self, source: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, dest: Spanned, dstart: int | java.jint | java.lang.Integer, dend: int | java.jint | java.lang.Integer, /) -> java.lang.CharSequence: ...

class InputType(java.lang.Object):
    TYPE_CLASS_DATETIME: typing.ClassVar[int] = ...
    TYPE_CLASS_NUMBER: typing.ClassVar[int] = ...
    TYPE_CLASS_PHONE: typing.ClassVar[int] = ...
    TYPE_CLASS_TEXT: typing.ClassVar[int] = ...
    TYPE_DATETIME_VARIATION_DATE: typing.ClassVar[int] = ...
    TYPE_DATETIME_VARIATION_NORMAL: typing.ClassVar[int] = ...
    TYPE_DATETIME_VARIATION_TIME: typing.ClassVar[int] = ...
    TYPE_MASK_CLASS: typing.ClassVar[int] = ...
    TYPE_MASK_FLAGS: typing.ClassVar[int] = ...
    TYPE_MASK_VARIATION: typing.ClassVar[int] = ...
    TYPE_NULL: typing.ClassVar[int] = ...
    TYPE_NUMBER_FLAG_DECIMAL: typing.ClassVar[int] = ...
    TYPE_NUMBER_FLAG_SIGNED: typing.ClassVar[int] = ...
    TYPE_NUMBER_VARIATION_NORMAL: typing.ClassVar[int] = ...
    TYPE_NUMBER_VARIATION_PASSWORD: typing.ClassVar[int] = ...
    TYPE_TEXT_FLAG_AUTO_COMPLETE: typing.ClassVar[int] = ...
    TYPE_TEXT_FLAG_AUTO_CORRECT: typing.ClassVar[int] = ...
    TYPE_TEXT_FLAG_CAP_CHARACTERS: typing.ClassVar[int] = ...
    TYPE_TEXT_FLAG_CAP_SENTENCES: typing.ClassVar[int] = ...
    TYPE_TEXT_FLAG_CAP_WORDS: typing.ClassVar[int] = ...
    TYPE_TEXT_FLAG_ENABLE_TEXT_CONVERSION_SUGGESTIONS: typing.ClassVar[int] = ...
    TYPE_TEXT_FLAG_IME_MULTI_LINE: typing.ClassVar[int] = ...
    TYPE_TEXT_FLAG_MULTI_LINE: typing.ClassVar[int] = ...
    TYPE_TEXT_FLAG_NO_SUGGESTIONS: typing.ClassVar[int] = ...
    TYPE_TEXT_VARIATION_EMAIL_ADDRESS: typing.ClassVar[int] = ...
    TYPE_TEXT_VARIATION_EMAIL_SUBJECT: typing.ClassVar[int] = ...
    TYPE_TEXT_VARIATION_FILTER: typing.ClassVar[int] = ...
    TYPE_TEXT_VARIATION_LONG_MESSAGE: typing.ClassVar[int] = ...
    TYPE_TEXT_VARIATION_NORMAL: typing.ClassVar[int] = ...
    TYPE_TEXT_VARIATION_PASSWORD: typing.ClassVar[int] = ...
    TYPE_TEXT_VARIATION_PERSON_NAME: typing.ClassVar[int] = ...
    TYPE_TEXT_VARIATION_PHONETIC: typing.ClassVar[int] = ...
    TYPE_TEXT_VARIATION_POSTAL_ADDRESS: typing.ClassVar[int] = ...
    TYPE_TEXT_VARIATION_SHORT_MESSAGE: typing.ClassVar[int] = ...
    TYPE_TEXT_VARIATION_URI: typing.ClassVar[int] = ...
    TYPE_TEXT_VARIATION_VISIBLE_PASSWORD: typing.ClassVar[int] = ...
    TYPE_TEXT_VARIATION_WEB_EDIT_TEXT: typing.ClassVar[int] = ...
    TYPE_TEXT_VARIATION_WEB_EMAIL_ADDRESS: typing.ClassVar[int] = ...
    TYPE_TEXT_VARIATION_WEB_PASSWORD: typing.ClassVar[int] = ...

class Layout(java.lang.Object):
    BREAK_STRATEGY_BALANCED: typing.ClassVar[int] = ...
    BREAK_STRATEGY_HIGH_QUALITY: typing.ClassVar[int] = ...
    BREAK_STRATEGY_SIMPLE: typing.ClassVar[int] = ...
    DEFAULT_LINESPACING_ADDITION: typing.ClassVar[float] = ...
    DEFAULT_LINESPACING_MULTIPLIER: typing.ClassVar[float] = ...
    DIR_LEFT_TO_RIGHT: typing.ClassVar[int] = ...
    DIR_RIGHT_TO_LEFT: typing.ClassVar[int] = ...
    HYPHENATION_FREQUENCY_FULL: typing.ClassVar[int] = ...
    HYPHENATION_FREQUENCY_FULL_FAST: typing.ClassVar[int] = ...
    HYPHENATION_FREQUENCY_NONE: typing.ClassVar[int] = ...
    HYPHENATION_FREQUENCY_NORMAL: typing.ClassVar[int] = ...
    HYPHENATION_FREQUENCY_NORMAL_FAST: typing.ClassVar[int] = ...
    INCLUSION_STRATEGY_ANY_OVERLAP: typing.ClassVar[Layout.TextInclusionStrategy] = ...
    INCLUSION_STRATEGY_CONTAINS_ALL: typing.ClassVar[Layout.TextInclusionStrategy] = ...
    INCLUSION_STRATEGY_CONTAINS_CENTER: typing.ClassVar[Layout.TextInclusionStrategy] = ...
    JUSTIFICATION_MODE_INTER_CHARACTER: typing.ClassVar[int] = ...
    JUSTIFICATION_MODE_INTER_WORD: typing.ClassVar[int] = ...
    JUSTIFICATION_MODE_NONE: typing.ClassVar[int] = ...
    def __init__(self, text: java.lang.CharSequence, paint: TextPaint, width: int | java.jint | java.lang.Integer, align: Layout.Alignment, spacingMult: float | java.jfloat | java.lang.Float, spacingAdd: float | java.jfloat | java.lang.Float, /) -> None: ...
    def computeDrawingBoundingBox(self) -> android.graphics.RectF: ...
    @typing.overload
    def draw(self, c: android.graphics.Canvas, /) -> None: ...
    @typing.overload
    def draw(self, canvas: android.graphics.Canvas, selectionHighlight: android.graphics.Path, selectionHighlightPaint: android.graphics.Paint, cursorOffsetVertical: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def draw(self, canvas: android.graphics.Canvas, highlightPaths: java.util.List[android.graphics.Path], highlightPaints: java.util.List[android.graphics.Paint], selectionPath: android.graphics.Path, selectionPaint: android.graphics.Paint, cursorOffsetVertical: int | java.jint | java.lang.Integer, /) -> None: ...
    def drawBackground(self, canvas: android.graphics.Canvas, /) -> None: ...
    def drawText(self, canvas: android.graphics.Canvas, /) -> None: ...
    def fillCharacterBounds(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, bounds: java.chaquopy.JavaArrayJFloat, boundsStart: int | java.jint | java.lang.Integer, /) -> None: ...
    def getAlignment(self) -> Layout.Alignment: ...
    def getBottomPadding(self) -> int: ...
    def getBreakStrategy(self) -> int: ...
    def getCursorPath(self, point: int | java.jint | java.lang.Integer, dest: android.graphics.Path, editingBuffer: java.lang.CharSequence, /) -> None: ...
    @typing.overload
    @staticmethod
    def getDesiredWidth(source: java.lang.CharSequence, paint: TextPaint, /) -> float: ...
    @typing.overload
    @staticmethod
    def getDesiredWidth(source: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, paint: TextPaint, /) -> float: ...
    def getEllipsisCount(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def getEllipsisStart(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def getEllipsize(self) -> TextUtils.TruncateAt | None: ...
    def getEllipsizedWidth(self) -> int: ...
    def getHeight(self) -> int: ...
    def getHyphenationFrequency(self) -> int: ...
    def getJustificationMode(self) -> int: ...
    def getLeftIndents(self) -> java.chaquopy.JavaArrayJInt | None: ...
    def getLineAscent(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineBaseline(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def getLineBottom(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def getLineBottom(self, line: int | java.jint | java.lang.Integer, includeLineSpacing: bool | java.jboolean | java.lang.Boolean, /) -> int: ...
    def getLineBounds(self, line: int | java.jint | java.lang.Integer, bounds: android.graphics.Rect, /) -> int: ...
    def getLineBreakConfig(self) -> android.graphics.text.LineBreakConfig: ...
    def getLineContainsTab(self, arg1: int | java.jint | java.lang.Integer, /) -> bool: ...
    def getLineCount(self) -> int: ...
    def getLineDescent(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineDirections(self, arg1: int | java.jint | java.lang.Integer, /) -> Layout.Directions: ...
    def getLineEnd(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineForOffset(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineForVertical(self, vertical: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineLeft(self, line: int | java.jint | java.lang.Integer, /) -> float: ...
    def getLineLetterSpacingUnitCount(self, line: int | java.jint | java.lang.Integer, includeTrailingWhitespace: bool | java.jboolean | java.lang.Boolean, /) -> int: ...
    def getLineMax(self, line: int | java.jint | java.lang.Integer, /) -> float: ...
    def getLineRight(self, line: int | java.jint | java.lang.Integer, /) -> float: ...
    def getLineSpacingAmount(self) -> float: ...
    def getLineSpacingMultiplier(self) -> float: ...
    def getLineStart(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineTop(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineVisibleEnd(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineWidth(self, line: int | java.jint | java.lang.Integer, /) -> float: ...
    def getMaxLines(self) -> int: ...
    def getMinimumFontMetrics(self) -> android.graphics.Paint.FontMetrics | None: ...
    def getOffsetForHorizontal(self, line: int | java.jint | java.lang.Integer, horiz: float | java.jfloat | java.lang.Float, /) -> int: ...
    def getOffsetToLeftOf(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...
    def getOffsetToRightOf(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...
    def getPaint(self) -> TextPaint: ...
    def getParagraphAlignment(self, line: int | java.jint | java.lang.Integer, /) -> Layout.Alignment: ...
    def getParagraphDirection(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def getParagraphLeft(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getParagraphRight(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getPrimaryHorizontal(self, offset: int | java.jint | java.lang.Integer, /) -> float: ...
    def getRangeForRect(self, area: android.graphics.RectF, segmentFinder: SegmentFinder, inclusionStrategy: Layout.TextInclusionStrategy, /) -> java.chaquopy.JavaArrayJInt | None: ...
    def getRightIndents(self) -> java.chaquopy.JavaArrayJInt | None: ...
    def getSecondaryHorizontal(self, offset: int | java.jint | java.lang.Integer, /) -> float: ...
    def getSelectionPath(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, dest: android.graphics.Path, /) -> None: ...
    def getShiftDrawingOffsetForStartOverhang(self) -> bool: ...
    def getSpacingAdd(self) -> float: ...
    def getSpacingMultiplier(self) -> float: ...
    def getText(self) -> java.lang.CharSequence: ...
    def getTextDirectionHeuristic(self) -> TextDirectionHeuristic: ...
    def getTopPadding(self) -> int: ...
    def getUseBoundsForWidth(self) -> bool: ...
    def getWidth(self) -> int: ...
    def increaseWidthTo(self, wid: int | java.jint | java.lang.Integer, /) -> None: ...
    def isFallbackLineSpacingEnabled(self) -> bool: ...
    def isFontPaddingIncluded(self) -> bool: ...
    def isRtlCharAt(self, offset: int | java.jint | java.lang.Integer, /) -> bool: ...
    def isSpanned(self) -> bool: ...

    class TextInclusionStrategy(java.lang.Object):
        def isSegmentInside(self, arg1: android.graphics.RectF, arg2: android.graphics.RectF, /) -> bool: ...

    class Directions(java.lang.Object): ...

    class Builder(java.lang.Object):
        def __init__(self, text: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, paint: TextPaint, width: int | java.jint | java.lang.Integer, /) -> None: ...
        def build(self) -> Layout: ...
        def setAlignment(self, alignment: Layout.Alignment, /) -> Layout.Builder: ...
        def setBreakStrategy(self, breakStrategy: int | java.jint | java.lang.Integer, /) -> Layout.Builder: ...
        def setEllipsize(self, ellipsize: TextUtils.TruncateAt, /) -> Layout.Builder: ...
        def setEllipsizedWidth(self, ellipsizeWidth: int | java.jint | java.lang.Integer, /) -> Layout.Builder: ...
        def setFallbackLineSpacingEnabled(self, fallbackLineSpacing: bool | java.jboolean | java.lang.Boolean, /) -> Layout.Builder: ...
        def setFontPaddingIncluded(self, includeFontPadding: bool | java.jboolean | java.lang.Boolean, /) -> Layout.Builder: ...
        def setHyphenationFrequency(self, hyphenationFrequency: int | java.jint | java.lang.Integer, /) -> Layout.Builder: ...
        def setJustificationMode(self, justificationMode: int | java.jint | java.lang.Integer, /) -> Layout.Builder: ...
        def setLeftIndents(self, leftIndents: java.chaquopy.JavaArrayJInt, /) -> Layout.Builder: ...
        def setLineBreakConfig(self, lineBreakConfig: android.graphics.text.LineBreakConfig, /) -> Layout.Builder: ...
        def setLineSpacingAmount(self, amount: float | java.jfloat | java.lang.Float, /) -> Layout.Builder: ...
        def setLineSpacingMultiplier(self, multiplier: float | java.jfloat | java.lang.Float, /) -> Layout.Builder: ...
        def setMaxLines(self, maxLines: int | java.jint | java.lang.Integer, /) -> Layout.Builder: ...
        def setMinimumFontMetrics(self, minimumFontMetrics: android.graphics.Paint.FontMetrics, /) -> Layout.Builder: ...
        def setRightIndents(self, rightIndents: java.chaquopy.JavaArrayJInt, /) -> Layout.Builder: ...
        def setShiftDrawingOffsetForStartOverhang(self, shiftDrawingOffsetForStartOverhang: bool | java.jboolean | java.lang.Boolean, /) -> Layout.Builder: ...
        def setTextDirectionHeuristic(self, textDirection: TextDirectionHeuristic, /) -> Layout.Builder: ...
        def setUseBoundsForWidth(self, useBoundsForWidth: bool | java.jboolean | java.lang.Boolean, /) -> Layout.Builder: ...

    class Alignment(java.lang.Enum[Layout.Alignment]):
        ALIGN_CENTER: typing.ClassVar[Layout.Alignment] = ...
        ALIGN_NORMAL: typing.ClassVar[Layout.Alignment] = ...
        ALIGN_OPPOSITE: typing.ClassVar[Layout.Alignment] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> Layout.Alignment: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[Layout.Alignment]: ...

class LoginFilter(InputFilter):
    def filter(self, source: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, dest: Spanned, dstart: int | java.jint | java.lang.Integer, dend: int | java.jint | java.lang.Integer, /) -> java.lang.CharSequence: ...
    def isAllowed(self, arg1: str | java.jchar | java.lang.Character, /) -> bool: ...
    def onInvalidCharacter(self, c: str | java.jchar | java.lang.Character, /) -> None: ...
    def onStart(self) -> None: ...
    def onStop(self) -> None: ...

    class UsernameFilterGeneric(LoginFilter):
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, appendInvalid: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
        def isAllowed(self, c: str | java.jchar | java.lang.Character, /) -> bool: ...

    class UsernameFilterGMail(LoginFilter):
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, appendInvalid: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
        def isAllowed(self, c: str | java.jchar | java.lang.Character, /) -> bool: ...

    class PasswordFilterGMail(LoginFilter):
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, appendInvalid: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
        def isAllowed(self, c: str | java.jchar | java.lang.Character, /) -> bool: ...

class NoCopySpan(java.lang.Object):

    class Concrete(NoCopySpan):
        def __init__(self) -> None: ...

class ParcelableSpan(android.os.Parcelable):
    def getSpanTypeId(self) -> int: ...

class PrecomputedText(Spannable):
    def charAt(self, index: int | java.jint | java.lang.Integer, /) -> str: ...
    @staticmethod
    def create(text: java.lang.CharSequence, params: PrecomputedText.Params, /) -> PrecomputedText: ...
    def getBounds(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, bounds: android.graphics.Rect, /) -> None: ...
    def getFontMetricsInt(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, outMetrics: android.graphics.Paint.FontMetricsInt, /) -> None: ...
    def getParagraphCount(self) -> int: ...
    def getParagraphEnd(self, paraIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    def getParagraphStart(self, paraIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    def getParams(self) -> PrecomputedText.Params: ...
    def getSpanEnd(self, tag: java.lang.Object | int | bool | float | str, /) -> int: ...
    def getSpanFlags(self, tag: java.lang.Object | int | bool | float | str, /) -> int: ...
    def getSpanStart(self, tag: java.lang.Object | int | bool | float | str, /) -> int: ...
    _getSpans__T = typing.TypeVar('_getSpans__T')  # <T>
    def getSpans(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, type: typing.Type[_getSpans__T], /) -> java.chaquopy.JavaArray[_getSpans__T]: ...
    def getWidth(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> float: ...
    def length(self) -> int: ...
    def nextSpanTransition(self, start: int | java.jint | java.lang.Integer, limit: int | java.jint | java.lang.Integer, type: typing.Type, /) -> int: ...
    def removeSpan(self, what: java.lang.Object | int | bool | float | str, /) -> None: ...
    def setSpan(self, what: java.lang.Object | int | bool | float | str, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, flags: int | java.jint | java.lang.Integer, /) -> None: ...
    def subSequence(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> java.lang.CharSequence: ...
    def toString(self) -> str: ...

    class Params(java.lang.Object):
        def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
        def getBreakStrategy(self) -> int: ...
        def getHyphenationFrequency(self) -> int: ...
        def getLineBreakConfig(self) -> android.graphics.text.LineBreakConfig: ...
        def getTextDirection(self) -> TextDirectionHeuristic: ...
        def getTextPaint(self) -> TextPaint: ...
        def hashCode(self) -> int: ...
        def toString(self) -> str: ...

        class Builder(java.lang.Object):
            @typing.overload
            def __init__(self, params: PrecomputedText.Params, /) -> None: ...
            @typing.overload
            def __init__(self, paint: TextPaint, /) -> None: ...
            def build(self) -> PrecomputedText.Params: ...
            def setBreakStrategy(self, strategy: int | java.jint | java.lang.Integer, /) -> PrecomputedText.Params.Builder: ...
            def setHyphenationFrequency(self, frequency: int | java.jint | java.lang.Integer, /) -> PrecomputedText.Params.Builder: ...
            def setLineBreakConfig(self, lineBreakConfig: android.graphics.text.LineBreakConfig, /) -> PrecomputedText.Params.Builder: ...
            def setTextDirection(self, textDir: TextDirectionHeuristic, /) -> PrecomputedText.Params.Builder: ...

class SegmentFinder(java.lang.Object):
    DONE: typing.ClassVar[int] = ...
    def __init__(self) -> None: ...
    def nextEndBoundary(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def nextStartBoundary(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def previousEndBoundary(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def previousStartBoundary(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...

    class PrescribedSegmentFinder(SegmentFinder):
        def __init__(self, segments: java.chaquopy.JavaArrayJInt, /) -> None: ...
        def nextEndBoundary(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...
        def nextStartBoundary(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...
        def previousEndBoundary(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...
        def previousStartBoundary(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...

class Selection(java.lang.Object):
    SELECTION_END: typing.ClassVar[java.lang.Object] = ...
    SELECTION_START: typing.ClassVar[java.lang.Object] = ...
    @staticmethod
    def extendDown(text: Spannable, layout: Layout, /) -> bool: ...
    @staticmethod
    def extendLeft(text: Spannable, layout: Layout, /) -> bool: ...
    @staticmethod
    def extendRight(text: Spannable, layout: Layout, /) -> bool: ...
    @staticmethod
    def extendSelection(text: Spannable, index: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def extendToLeftEdge(text: Spannable, layout: Layout, /) -> bool: ...
    @staticmethod
    def extendToParagraphEnd(text: Spannable, /) -> bool: ...
    @staticmethod
    def extendToParagraphStart(text: Spannable, /) -> bool: ...
    @staticmethod
    def extendToRightEdge(text: Spannable, layout: Layout, /) -> bool: ...
    @staticmethod
    def extendUp(text: Spannable, layout: Layout, /) -> bool: ...
    @staticmethod
    def getSelectionEnd(text: java.lang.CharSequence, /) -> int: ...
    @staticmethod
    def getSelectionStart(text: java.lang.CharSequence, /) -> int: ...
    @staticmethod
    def moveDown(text: Spannable, layout: Layout, /) -> bool: ...
    @staticmethod
    def moveLeft(text: Spannable, layout: Layout, /) -> bool: ...
    @staticmethod
    def moveRight(text: Spannable, layout: Layout, /) -> bool: ...
    @staticmethod
    def moveToLeftEdge(text: Spannable, layout: Layout, /) -> bool: ...
    @staticmethod
    def moveToParagraphEnd(text: Spannable, layout: Layout, /) -> bool: ...
    @staticmethod
    def moveToParagraphStart(text: Spannable, layout: Layout, /) -> bool: ...
    @staticmethod
    def moveToRightEdge(text: Spannable, layout: Layout, /) -> bool: ...
    @staticmethod
    def moveUp(text: Spannable, layout: Layout, /) -> bool: ...
    @staticmethod
    def removeSelection(text: Spannable, /) -> None: ...
    @staticmethod
    def selectAll(text: Spannable, /) -> None: ...
    @typing.overload
    @staticmethod
    def setSelection(text: Spannable, index: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def setSelection(text: Spannable, start: int | java.jint | java.lang.Integer, stop: int | java.jint | java.lang.Integer, /) -> None: ...

class SpanWatcher(NoCopySpan):
    def onSpanAdded(self, arg1: Spannable, arg2: java.lang.Object | int | bool | float | str, arg3: int | java.jint | java.lang.Integer, arg4: int | java.jint | java.lang.Integer, /) -> None: ...
    def onSpanChanged(self, arg1: Spannable, arg2: java.lang.Object | int | bool | float | str, arg3: int | java.jint | java.lang.Integer, arg4: int | java.jint | java.lang.Integer, arg5: int | java.jint | java.lang.Integer, arg6: int | java.jint | java.lang.Integer, /) -> None: ...
    def onSpanRemoved(self, arg1: Spannable, arg2: java.lang.Object | int | bool | float | str, arg3: int | java.jint | java.lang.Integer, arg4: int | java.jint | java.lang.Integer, /) -> None: ...

class Spannable(Spanned):
    def removeSpan(self, arg1: java.lang.Object | int | bool | float | str, /) -> None: ...
    def setSpan(self, arg1: java.lang.Object | int | bool | float | str, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, arg4: int | java.jint | java.lang.Integer, /) -> None: ...

    class Factory(java.lang.Object):
        def __init__(self) -> None: ...
        @staticmethod
        def getInstance() -> Spannable.Factory: ...
        def newSpannable(self, source: java.lang.CharSequence, /) -> Spannable: ...

class SpannableString(java.lang.CharSequence, GetChars, Spannable):
    def __init__(self, source: java.lang.CharSequence, /) -> None: ...
    def charAt(self, i: int | java.jint | java.lang.Integer, /) -> str: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getChars(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, dest: java.chaquopy.JavaArrayJChar, off: int | java.jint | java.lang.Integer, /) -> None: ...
    def getSpanEnd(self, what: java.lang.Object | int | bool | float | str, /) -> int: ...
    def getSpanFlags(self, what: java.lang.Object | int | bool | float | str, /) -> int: ...
    def getSpanStart(self, what: java.lang.Object | int | bool | float | str, /) -> int: ...
    _getSpans__T = typing.TypeVar('_getSpans__T')  # <T>
    def getSpans(self, queryStart: int | java.jint | java.lang.Integer, queryEnd: int | java.jint | java.lang.Integer, kind: typing.Type[_getSpans__T], /) -> java.chaquopy.JavaArray[_getSpans__T]: ...
    def hashCode(self) -> int: ...
    def length(self) -> int: ...
    def nextSpanTransition(self, start: int | java.jint | java.lang.Integer, limit: int | java.jint | java.lang.Integer, kind: typing.Type, /) -> int: ...
    def removeSpan(self, what: java.lang.Object | int | bool | float | str, /) -> None: ...
    def setSpan(self, what: java.lang.Object | int | bool | float | str, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, flags: int | java.jint | java.lang.Integer, /) -> None: ...
    def subSequence(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> java.lang.CharSequence: ...
    def toString(self) -> str: ...
    @staticmethod
    def valueOf(source: java.lang.CharSequence, /) -> SpannableString: ...

class SpannableStringBuilder(java.lang.Appendable, java.lang.CharSequence, Editable, GetChars, Spannable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, text: java.lang.CharSequence, /) -> None: ...
    @typing.overload
    def __init__(self, text: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def append(self, text: str | java.jchar | java.lang.Character, /) -> SpannableStringBuilder: ...
    @typing.overload
    def append(self, text: java.lang.CharSequence, /) -> SpannableStringBuilder: ...
    @typing.overload
    def append(self, text: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> SpannableStringBuilder: ...
    @typing.overload
    def append(self, text: java.lang.CharSequence, what: java.lang.Object | int | bool | float | str, flags: int | java.jint | java.lang.Integer, /) -> SpannableStringBuilder: ...
    def charAt(self, where: int | java.jint | java.lang.Integer, /) -> str: ...
    def clear(self) -> None: ...
    def clearSpans(self) -> None: ...
    def delete(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> SpannableStringBuilder: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getChars(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, dest: java.chaquopy.JavaArrayJChar, destoff: int | java.jint | java.lang.Integer, /) -> None: ...
    def getFilters(self) -> java.chaquopy.JavaArray[InputFilter]: ...
    def getSpanEnd(self, what: java.lang.Object | int | bool | float | str, /) -> int: ...
    def getSpanFlags(self, what: java.lang.Object | int | bool | float | str, /) -> int: ...
    def getSpanStart(self, what: java.lang.Object | int | bool | float | str, /) -> int: ...
    _getSpans__T = typing.TypeVar('_getSpans__T')  # <T>
    def getSpans(self, queryStart: int | java.jint | java.lang.Integer, queryEnd: int | java.jint | java.lang.Integer, kind: typing.Type[_getSpans__T], /) -> java.chaquopy.JavaArray[_getSpans__T]: ...
    def getTextRunCursor(self, contextStart: int | java.jint | java.lang.Integer, contextEnd: int | java.jint | java.lang.Integer, dir: int | java.jint | java.lang.Integer, offset: int | java.jint | java.lang.Integer, cursorOpt: int | java.jint | java.lang.Integer, p: android.graphics.Paint, /) -> int: ...
    def getTextWatcherDepth(self) -> int: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def insert(self, where: int | java.jint | java.lang.Integer, tb: java.lang.CharSequence, /) -> SpannableStringBuilder: ...
    @typing.overload
    def insert(self, where: int | java.jint | java.lang.Integer, tb: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> SpannableStringBuilder: ...
    def length(self) -> int: ...
    def nextSpanTransition(self, start: int | java.jint | java.lang.Integer, limit: int | java.jint | java.lang.Integer, kind: typing.Type, /) -> int: ...
    def removeSpan(self, what: java.lang.Object | int | bool | float | str, /) -> None: ...
    @typing.overload
    def replace(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, tb: java.lang.CharSequence, /) -> SpannableStringBuilder: ...
    @typing.overload
    def replace(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, tb: java.lang.CharSequence, tbstart: int | java.jint | java.lang.Integer, tbend: int | java.jint | java.lang.Integer, /) -> SpannableStringBuilder: ...
    def setFilters(self, filters: java.chaquopy.JavaArray[InputFilter], /) -> None: ...
    def setSpan(self, what: java.lang.Object | int | bool | float | str, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, flags: int | java.jint | java.lang.Integer, /) -> None: ...
    def subSequence(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> java.lang.CharSequence: ...
    def toString(self) -> str: ...
    @staticmethod
    def valueOf(source: java.lang.CharSequence, /) -> SpannableStringBuilder: ...

class Spanned(java.lang.CharSequence):
    SPAN_COMPOSING: typing.ClassVar[int] = ...
    SPAN_EXCLUSIVE_EXCLUSIVE: typing.ClassVar[int] = ...
    SPAN_EXCLUSIVE_INCLUSIVE: typing.ClassVar[int] = ...
    SPAN_INCLUSIVE_EXCLUSIVE: typing.ClassVar[int] = ...
    SPAN_INCLUSIVE_INCLUSIVE: typing.ClassVar[int] = ...
    SPAN_INTERMEDIATE: typing.ClassVar[int] = ...
    SPAN_MARK_MARK: typing.ClassVar[int] = ...
    SPAN_MARK_POINT: typing.ClassVar[int] = ...
    SPAN_PARAGRAPH: typing.ClassVar[int] = ...
    SPAN_POINT_MARK: typing.ClassVar[int] = ...
    SPAN_POINT_MARK_MASK: typing.ClassVar[int] = ...
    SPAN_POINT_POINT: typing.ClassVar[int] = ...
    SPAN_PRIORITY: typing.ClassVar[int] = ...
    SPAN_PRIORITY_SHIFT: typing.ClassVar[int] = ...
    SPAN_USER: typing.ClassVar[int] = ...
    SPAN_USER_SHIFT: typing.ClassVar[int] = ...
    def getSpanEnd(self, arg1: java.lang.Object | int | bool | float | str, /) -> int: ...
    def getSpanFlags(self, arg1: java.lang.Object | int | bool | float | str, /) -> int: ...
    def getSpanStart(self, arg1: java.lang.Object | int | bool | float | str, /) -> int: ...
    _getSpans__T = typing.TypeVar('_getSpans__T')  # <T>
    def getSpans(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, arg3: typing.Type[_getSpans__T], /) -> java.chaquopy.JavaArray[_getSpans__T]: ...
    def nextSpanTransition(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, arg3: typing.Type, /) -> int: ...

class SpannedString(java.lang.CharSequence, GetChars, Spanned):
    def __init__(self, source: java.lang.CharSequence, /) -> None: ...
    def charAt(self, i: int | java.jint | java.lang.Integer, /) -> str: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getChars(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, dest: java.chaquopy.JavaArrayJChar, off: int | java.jint | java.lang.Integer, /) -> None: ...
    def getSpanEnd(self, what: java.lang.Object | int | bool | float | str, /) -> int: ...
    def getSpanFlags(self, what: java.lang.Object | int | bool | float | str, /) -> int: ...
    def getSpanStart(self, what: java.lang.Object | int | bool | float | str, /) -> int: ...
    _getSpans__T = typing.TypeVar('_getSpans__T')  # <T>
    def getSpans(self, queryStart: int | java.jint | java.lang.Integer, queryEnd: int | java.jint | java.lang.Integer, kind: typing.Type[_getSpans__T], /) -> java.chaquopy.JavaArray[_getSpans__T]: ...
    def hashCode(self) -> int: ...
    def length(self) -> int: ...
    def nextSpanTransition(self, start: int | java.jint | java.lang.Integer, limit: int | java.jint | java.lang.Integer, kind: typing.Type, /) -> int: ...
    def subSequence(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> java.lang.CharSequence: ...
    def toString(self) -> str: ...
    @staticmethod
    def valueOf(source: java.lang.CharSequence, /) -> SpannedString: ...

class StaticLayout(Layout):
    @typing.overload
    def __init__(self, source: java.lang.CharSequence, paint: TextPaint, width: int | java.jint | java.lang.Integer, align: Layout.Alignment, spacingmult: float | java.jfloat | java.lang.Float, spacingadd: float | java.jfloat | java.lang.Float, includepad: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def __init__(self, source: java.lang.CharSequence, bufstart: int | java.jint | java.lang.Integer, bufend: int | java.jint | java.lang.Integer, paint: TextPaint, outerwidth: int | java.jint | java.lang.Integer, align: Layout.Alignment, spacingmult: float | java.jfloat | java.lang.Float, spacingadd: float | java.jfloat | java.lang.Float, includepad: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def __init__(self, source: java.lang.CharSequence, bufstart: int | java.jint | java.lang.Integer, bufend: int | java.jint | java.lang.Integer, paint: TextPaint, outerwidth: int | java.jint | java.lang.Integer, align: Layout.Alignment, spacingmult: float | java.jfloat | java.lang.Float, spacingadd: float | java.jfloat | java.lang.Float, includepad: bool | java.jboolean | java.lang.Boolean, ellipsize: TextUtils.TruncateAt, ellipsizedWidth: int | java.jint | java.lang.Integer, /) -> None: ...
    def computeDrawingBoundingBox(self) -> android.graphics.RectF: ...
    def getBottomPadding(self) -> int: ...
    def getEllipsisCount(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getEllipsisStart(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineContainsTab(self, line: int | java.jint | java.lang.Integer, /) -> bool: ...
    def getLineCount(self) -> int: ...
    def getLineDescent(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineDirections(self, line: int | java.jint | java.lang.Integer, /) -> Layout.Directions: ...
    def getLineForVertical(self, vertical: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineStart(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLineTop(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getParagraphDirection(self, line: int | java.jint | java.lang.Integer, /) -> int: ...
    def getTopPadding(self) -> int: ...

    class Builder(java.lang.Object):
        def build(self) -> StaticLayout: ...
        @staticmethod
        def obtain(source: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, paint: TextPaint, width: int | java.jint | java.lang.Integer, /) -> StaticLayout.Builder: ...
        def setAlignment(self, alignment: Layout.Alignment, /) -> StaticLayout.Builder: ...
        def setBreakStrategy(self, breakStrategy: int | java.jint | java.lang.Integer, /) -> StaticLayout.Builder: ...
        def setEllipsize(self, ellipsize: TextUtils.TruncateAt, /) -> StaticLayout.Builder: ...
        def setEllipsizedWidth(self, ellipsizedWidth: int | java.jint | java.lang.Integer, /) -> StaticLayout.Builder: ...
        def setHyphenationFrequency(self, hyphenationFrequency: int | java.jint | java.lang.Integer, /) -> StaticLayout.Builder: ...
        def setIncludePad(self, includePad: bool | java.jboolean | java.lang.Boolean, /) -> StaticLayout.Builder: ...
        def setIndents(self, leftIndents: java.chaquopy.JavaArrayJInt, rightIndents: java.chaquopy.JavaArrayJInt, /) -> StaticLayout.Builder: ...
        def setJustificationMode(self, justificationMode: int | java.jint | java.lang.Integer, /) -> StaticLayout.Builder: ...
        def setLineBreakConfig(self, lineBreakConfig: android.graphics.text.LineBreakConfig, /) -> StaticLayout.Builder: ...
        def setLineSpacing(self, spacingAdd: float | java.jfloat | java.lang.Float, spacingMult: float | java.jfloat | java.lang.Float, /) -> StaticLayout.Builder: ...
        def setMaxLines(self, maxLines: int | java.jint | java.lang.Integer, /) -> StaticLayout.Builder: ...
        def setMinimumFontMetrics(self, minimumFontMetrics: android.graphics.Paint.FontMetrics, /) -> StaticLayout.Builder: ...
        def setShiftDrawingOffsetForStartOverhang(self, shiftDrawingOffsetForStartOverhang: bool | java.jboolean | java.lang.Boolean, /) -> StaticLayout.Builder: ...
        def setText(self, source: java.lang.CharSequence, /) -> StaticLayout.Builder: ...
        def setTextDirection(self, textDir: TextDirectionHeuristic, /) -> StaticLayout.Builder: ...
        def setUseBoundsForWidth(self, useBoundsForWidth: bool | java.jboolean | java.lang.Boolean, /) -> StaticLayout.Builder: ...
        def setUseLineSpacingFromFallbacks(self, useLineSpacingFromFallbacks: bool | java.jboolean | java.lang.Boolean, /) -> StaticLayout.Builder: ...

class TextDirectionHeuristic(java.lang.Object):
    @typing.overload
    def isRtl(self, arg1: java.lang.CharSequence, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    def isRtl(self, arg1: java.chaquopy.JavaArrayJChar, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> bool: ...

class TextDirectionHeuristics(java.lang.Object):
    ANYRTL_LTR: typing.ClassVar[TextDirectionHeuristic] = ...
    FIRSTSTRONG_LTR: typing.ClassVar[TextDirectionHeuristic] = ...
    FIRSTSTRONG_RTL: typing.ClassVar[TextDirectionHeuristic] = ...
    LOCALE: typing.ClassVar[TextDirectionHeuristic] = ...
    LTR: typing.ClassVar[TextDirectionHeuristic] = ...
    RTL: typing.ClassVar[TextDirectionHeuristic] = ...
    def __init__(self) -> None: ...

class TextPaint(android.graphics.Paint):
    baselineShift: int = ...
    bgColor: int = ...
    density: float = ...
    drawableState: java.chaquopy.JavaArrayJInt = ...
    linkColor: int = ...
    underlineColor: int = ...
    underlineThickness: float = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, flags: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, p: android.graphics.Paint, /) -> None: ...
    def getUnderlineThickness(self) -> float: ...
    def set(self, tp: TextPaint, /) -> None: ...

class TextShaper(java.lang.Object):
    @staticmethod
    def shapeText(text: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, count: int | java.jint | java.lang.Integer, dir: TextDirectionHeuristic, paint: TextPaint, consumer: TextShaper.GlyphsConsumer, /) -> None: ...

    class GlyphsConsumer(java.lang.Object):
        def accept(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, arg3: android.graphics.text.PositionedGlyphs, arg4: TextPaint, /) -> None: ...

class TextUtils(java.lang.Object):
    CAP_MODE_CHARACTERS: typing.ClassVar[int] = ...
    CAP_MODE_SENTENCES: typing.ClassVar[int] = ...
    CAP_MODE_WORDS: typing.ClassVar[int] = ...
    CHAR_SEQUENCE_CREATOR: typing.ClassVar[android.os.Parcelable.Creator[java.lang.CharSequence]] = ...
    SAFE_STRING_FLAG_FIRST_LINE: typing.ClassVar[int] = ...
    SAFE_STRING_FLAG_SINGLE_LINE: typing.ClassVar[int] = ...
    SAFE_STRING_FLAG_TRIM: typing.ClassVar[int] = ...
    @staticmethod
    def commaEllipsize(text: java.lang.CharSequence, p: TextPaint, avail: float | java.jfloat | java.lang.Float, oneMore: str | java.lang.String, more: str | java.lang.String, /) -> java.lang.CharSequence: ...
    @staticmethod
    def concat(*text: java.lang.CharSequence) -> java.lang.CharSequence: ...
    @staticmethod
    def copySpansFrom(source: Spanned, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, kind: typing.Type, dest: Spannable, destoff: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def dumpSpans(cs: java.lang.CharSequence, printer: android.util.Printer, prefix: str | java.lang.String, /) -> None: ...
    @typing.overload
    @staticmethod
    def ellipsize(text: java.lang.CharSequence, p: TextPaint, avail: float | java.jfloat | java.lang.Float, where: TextUtils.TruncateAt, /) -> java.lang.CharSequence | None: ...
    @typing.overload
    @staticmethod
    def ellipsize(text: java.lang.CharSequence, paint: TextPaint, avail: float | java.jfloat | java.lang.Float, where: TextUtils.TruncateAt, preserveLength: bool | java.jboolean | java.lang.Boolean, callback: TextUtils.EllipsizeCallback, /) -> java.lang.CharSequence | None: ...
    @staticmethod
    def equals(a: java.lang.CharSequence, b: java.lang.CharSequence, /) -> bool: ...
    @staticmethod
    def expandTemplate(template: java.lang.CharSequence, /, *values: java.lang.CharSequence) -> java.lang.CharSequence: ...
    @staticmethod
    def getCapsMode(cs: java.lang.CharSequence, off: int | java.jint | java.lang.Integer, reqModes: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def getChars(s: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, dest: java.chaquopy.JavaArrayJChar, destoff: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def getLayoutDirectionFromLocale(locale: java.util.Locale, /) -> int: ...
    @staticmethod
    def getOffsetAfter(text: java.lang.CharSequence, offset: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def getOffsetBefore(text: java.lang.CharSequence, offset: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def getReverse(source: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> java.lang.CharSequence: ...
    @staticmethod
    def getTrimmedLength(s: java.lang.CharSequence, /) -> int: ...
    @staticmethod
    def htmlEncode(s: str | java.lang.String, /) -> str: ...
    @typing.overload
    @staticmethod
    def indexOf(s: java.lang.CharSequence, ch: str | java.jchar | java.lang.Character, /) -> int: ...
    @typing.overload
    @staticmethod
    def indexOf(s: java.lang.CharSequence, needle: java.lang.CharSequence, /) -> int: ...
    @typing.overload
    @staticmethod
    def indexOf(s: java.lang.CharSequence, ch: str | java.jchar | java.lang.Character, start: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def indexOf(s: java.lang.CharSequence, needle: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def indexOf(s: java.lang.CharSequence, ch: str | java.jchar | java.lang.Character, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def indexOf(s: java.lang.CharSequence, needle: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def isDigitsOnly(str: java.lang.CharSequence, /) -> bool: ...
    @staticmethod
    def isEmpty(str: java.lang.CharSequence, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isGraphic(c: str | java.jchar | java.lang.Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isGraphic(str: java.lang.CharSequence, /) -> bool: ...
    @typing.overload
    @staticmethod
    def join(delimiter: java.lang.CharSequence, tokens: java.lang.Iterable, /) -> str: ...
    @typing.overload
    @staticmethod
    def join(delimiter: java.lang.CharSequence, tokens: java.chaquopy.JavaArray[java.lang.Object], /) -> str: ...
    @typing.overload
    @staticmethod
    def lastIndexOf(s: java.lang.CharSequence, ch: str | java.jchar | java.lang.Character, /) -> int: ...
    @typing.overload
    @staticmethod
    def lastIndexOf(s: java.lang.CharSequence, ch: str | java.jchar | java.lang.Character, last: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def lastIndexOf(s: java.lang.CharSequence, ch: str | java.jchar | java.lang.Character, start: int | java.jint | java.lang.Integer, last: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def listEllipsize(context: android.content.Context, elements: java.util.List[java.lang.CharSequence], separator: str | java.lang.String, paint: TextPaint, avail: float | java.jfloat | java.lang.Float, moreId: int | java.jint | java.lang.Integer, /) -> java.lang.CharSequence: ...
    @staticmethod
    def makeSafeForPresentation(unclean: str | java.lang.String, maxCharactersToConsider: int | java.jint | java.lang.Integer, ellipsizeDip: float | java.jfloat | java.lang.Float, flags: int | java.jint | java.lang.Integer, /) -> java.lang.CharSequence: ...
    @staticmethod
    def regionMatches(one: java.lang.CharSequence, toffset: int | java.jint | java.lang.Integer, two: java.lang.CharSequence, ooffset: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def replace(template: java.lang.CharSequence, sources: java.chaquopy.JavaArray[java.lang.String], destinations: java.chaquopy.JavaArray[java.lang.CharSequence], /) -> java.lang.CharSequence: ...
    @typing.overload
    @staticmethod
    def split(text: str | java.lang.String, expression: str | java.lang.String, /) -> java.chaquopy.JavaArray[java.lang.String]: ...
    @typing.overload
    @staticmethod
    def split(text: str | java.lang.String, pattern: java.util.regex.Pattern, /) -> java.chaquopy.JavaArray[java.lang.String]: ...
    @staticmethod
    def stringOrSpannedString(source: java.lang.CharSequence, /) -> java.lang.CharSequence: ...
    @staticmethod
    def substring(source: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> str: ...
    @staticmethod
    def writeToParcel(cs: java.lang.CharSequence, p: android.os.Parcel, parcelableFlags: int | java.jint | java.lang.Integer, /) -> None: ...

    class TruncateAt(java.lang.Enum[TextUtils.TruncateAt]):
        END: typing.ClassVar[TextUtils.TruncateAt] = ...
        MARQUEE: typing.ClassVar[TextUtils.TruncateAt] = ...
        MIDDLE: typing.ClassVar[TextUtils.TruncateAt] = ...
        START: typing.ClassVar[TextUtils.TruncateAt] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> TextUtils.TruncateAt: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[TextUtils.TruncateAt]: ...

    class StringSplitter(java.lang.Iterable[java.lang.String]):
        def setString(self, arg1: str | java.lang.String, /) -> None: ...

    class SimpleStringSplitter(java.util.Iterator[java.lang.String], android.text.TextUtils.StringSplitter):
        def __init__(self, delimiter: str | java.jchar | java.lang.Character, /) -> None: ...
        def hasNext(self) -> bool: ...
        def iterator(self) -> java.util.Iterator[java.lang.String]: ...
        def next(self) -> str: ...
        def remove(self) -> None: ...
        def setString(self, string: str | java.lang.String, /) -> None: ...

    class EllipsizeCallback(java.lang.Object):
        def ellipsized(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, /) -> None: ...

class TextWatcher(NoCopySpan):
    def afterTextChanged(self, arg1: Editable, /) -> None: ...
    def beforeTextChanged(self, arg1: java.lang.CharSequence, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, arg4: int | java.jint | java.lang.Integer, /) -> None: ...
    def onTextChanged(self, arg1: java.lang.CharSequence, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, arg4: int | java.jint | java.lang.Integer, /) -> None: ...

class WordSegmentFinder(SegmentFinder):
    def __init__(self, text: java.lang.CharSequence, locale: android.icu.util.ULocale, /) -> None: ...
    def nextEndBoundary(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...
    def nextStartBoundary(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...
    def previousEndBoundary(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...
    def previousStartBoundary(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...
