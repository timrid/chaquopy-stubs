import android.content
import android.graphics
import android.os
import android.util
import android.view
import android.widget
import java
import java.chaquopy
import java.io
import java.lang
import java.util
import typing



class Gesture(android.os.Parcelable):
    CREATOR: typing.ClassVar[android.os.Parcelable.Creator[Gesture]] = ...
    def __init__(self) -> None: ...
    def addStroke(self, stroke: GestureStroke, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def describeContents(self) -> int: ...
    def getBoundingBox(self) -> android.graphics.RectF: ...
    def getID(self) -> int: ...
    def getLength(self) -> float: ...
    def getStrokes(self) -> java.util.ArrayList[GestureStroke]: ...
    def getStrokesCount(self) -> int: ...
    @typing.overload
    def toBitmap(self, width: int | java.jint | java.lang.Integer, height: int | java.jint | java.lang.Integer, inset: int | java.jint | java.lang.Integer, color: int | java.jint | java.lang.Integer, /) -> android.graphics.Bitmap: ...
    @typing.overload
    def toBitmap(self, width: int | java.jint | java.lang.Integer, height: int | java.jint | java.lang.Integer, edge: int | java.jint | java.lang.Integer, numSample: int | java.jint | java.lang.Integer, color: int | java.jint | java.lang.Integer, /) -> android.graphics.Bitmap: ...
    @typing.overload
    def toPath(self) -> android.graphics.Path: ...
    @typing.overload
    def toPath(self, path: android.graphics.Path, /) -> android.graphics.Path: ...
    @typing.overload
    def toPath(self, width: int | java.jint | java.lang.Integer, height: int | java.jint | java.lang.Integer, edge: int | java.jint | java.lang.Integer, numSample: int | java.jint | java.lang.Integer, /) -> android.graphics.Path: ...
    @typing.overload
    def toPath(self, path: android.graphics.Path, width: int | java.jint | java.lang.Integer, height: int | java.jint | java.lang.Integer, edge: int | java.jint | java.lang.Integer, numSample: int | java.jint | java.lang.Integer, /) -> android.graphics.Path: ...
    def writeToParcel(self, out: android.os.Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...

class GestureLibraries(java.lang.Object):
    @typing.overload
    @staticmethod
    def fromFile(path: java.io.File, /) -> GestureLibrary: ...
    @typing.overload
    @staticmethod
    def fromFile(path: str | java.lang.String, /) -> GestureLibrary: ...
    @staticmethod
    def fromFileDescriptor(pfd: android.os.ParcelFileDescriptor, /) -> GestureLibrary: ...
    @staticmethod
    def fromPrivateFile(context: android.content.Context, name: str | java.lang.String, /) -> GestureLibrary: ...
    @staticmethod
    def fromRawResource(context: android.content.Context, resourceId: int | java.jint | java.lang.Integer, /) -> GestureLibrary: ...

class GestureLibrary(java.lang.Object):
    mStore: GestureStore = ...
    def __init__(self) -> None: ...
    def addGesture(self, entryName: str | java.lang.String, gesture: Gesture, /) -> None: ...
    def getGestureEntries(self) -> java.util.Set[java.lang.String]: ...
    def getGestures(self, entryName: str | java.lang.String, /) -> java.util.ArrayList[Gesture]: ...
    def getOrientationStyle(self) -> int: ...
    def getSequenceType(self) -> int: ...
    def isReadOnly(self) -> bool: ...
    def load(self) -> bool: ...
    def recognize(self, gesture: Gesture, /) -> java.util.ArrayList[Prediction]: ...
    def removeEntry(self, entryName: str | java.lang.String, /) -> None: ...
    def removeGesture(self, entryName: str | java.lang.String, gesture: Gesture, /) -> None: ...
    def save(self) -> bool: ...
    def setOrientationStyle(self, style: int | java.jint | java.lang.Integer, /) -> None: ...
    def setSequenceType(self, type: int | java.jint | java.lang.Integer, /) -> None: ...

class GestureOverlayView(android.widget.FrameLayout):
    GESTURE_STROKE_TYPE_MULTIPLE: typing.ClassVar[int] = ...
    GESTURE_STROKE_TYPE_SINGLE: typing.ClassVar[int] = ...
    ORIENTATION_HORIZONTAL: typing.ClassVar[int] = ...
    ORIENTATION_VERTICAL: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, context: android.content.Context, /) -> None: ...
    @typing.overload
    def __init__(self, context: android.content.Context, attrs: android.util.AttributeSet, /) -> None: ...
    @typing.overload
    def __init__(self, context: android.content.Context, attrs: android.util.AttributeSet, defStyleAttr: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, context: android.content.Context, attrs: android.util.AttributeSet, defStyleAttr: int | java.jint | java.lang.Integer, defStyleRes: int | java.jint | java.lang.Integer, /) -> None: ...
    def addOnGestureListener(self, listener: GestureOverlayView.OnGestureListener, /) -> None: ...
    def addOnGesturePerformedListener(self, listener: GestureOverlayView.OnGesturePerformedListener, /) -> None: ...
    def addOnGesturingListener(self, listener: GestureOverlayView.OnGesturingListener, /) -> None: ...
    def cancelClearAnimation(self) -> None: ...
    def cancelGesture(self) -> None: ...
    def clear(self, animated: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def dispatchTouchEvent(self, event: android.view.MotionEvent, /) -> bool: ...
    def draw(self, canvas: android.graphics.Canvas, /) -> None: ...
    def getCurrentStroke(self) -> java.util.ArrayList[GesturePoint]: ...
    def getFadeOffset(self) -> int: ...
    def getGesture(self) -> Gesture: ...
    def getGestureColor(self) -> int: ...
    @typing.overload
    def getGesturePath(self) -> android.graphics.Path: ...
    @typing.overload
    def getGesturePath(self, path: android.graphics.Path, /) -> android.graphics.Path: ...
    def getGestureStrokeAngleThreshold(self) -> float: ...
    def getGestureStrokeLengthThreshold(self) -> float: ...
    def getGestureStrokeSquarenessTreshold(self) -> float: ...
    def getGestureStrokeType(self) -> int: ...
    def getGestureStrokeWidth(self) -> float: ...
    def getOrientation(self) -> int: ...
    def getUncertainGestureColor(self) -> int: ...
    def isEventsInterceptionEnabled(self) -> bool: ...
    def isFadeEnabled(self) -> bool: ...
    def isGestureVisible(self) -> bool: ...
    def isGesturing(self) -> bool: ...
    def onDetachedFromWindow(self) -> None: ...
    def removeAllOnGestureListeners(self) -> None: ...
    def removeAllOnGesturePerformedListeners(self) -> None: ...
    def removeAllOnGesturingListeners(self) -> None: ...
    def removeOnGestureListener(self, listener: GestureOverlayView.OnGestureListener, /) -> None: ...
    def removeOnGesturePerformedListener(self, listener: GestureOverlayView.OnGesturePerformedListener, /) -> None: ...
    def removeOnGesturingListener(self, listener: GestureOverlayView.OnGesturingListener, /) -> None: ...
    def setEventsInterceptionEnabled(self, enabled: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setFadeEnabled(self, fadeEnabled: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setFadeOffset(self, fadeOffset: int | java.jlong | java.lang.Long, /) -> None: ...
    def setGesture(self, gesture: Gesture, /) -> None: ...
    def setGestureColor(self, color: int | java.jint | java.lang.Integer, /) -> None: ...
    def setGestureStrokeAngleThreshold(self, gestureStrokeAngleThreshold: float | java.jfloat | java.lang.Float, /) -> None: ...
    def setGestureStrokeLengthThreshold(self, gestureStrokeLengthThreshold: float | java.jfloat | java.lang.Float, /) -> None: ...
    def setGestureStrokeSquarenessTreshold(self, gestureStrokeSquarenessTreshold: float | java.jfloat | java.lang.Float, /) -> None: ...
    def setGestureStrokeType(self, gestureStrokeType: int | java.jint | java.lang.Integer, /) -> None: ...
    def setGestureStrokeWidth(self, gestureStrokeWidth: float | java.jfloat | java.lang.Float, /) -> None: ...
    def setGestureVisible(self, visible: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setOrientation(self, orientation: int | java.jint | java.lang.Integer, /) -> None: ...
    def setUncertainGestureColor(self, color: int | java.jint | java.lang.Integer, /) -> None: ...

    class OnGesturingListener(java.lang.Object):
        def onGesturingEnded(self, arg1: GestureOverlayView, /) -> None: ...
        def onGesturingStarted(self, arg1: GestureOverlayView, /) -> None: ...

    class OnGesturePerformedListener(java.lang.Object):
        def onGesturePerformed(self, arg1: GestureOverlayView, arg2: Gesture, /) -> None: ...

    class OnGestureListener(java.lang.Object):
        def onGesture(self, arg1: GestureOverlayView, arg2: android.view.MotionEvent, /) -> None: ...
        def onGestureCancelled(self, arg1: GestureOverlayView, arg2: android.view.MotionEvent, /) -> None: ...
        def onGestureEnded(self, arg1: GestureOverlayView, arg2: android.view.MotionEvent, /) -> None: ...
        def onGestureStarted(self, arg1: GestureOverlayView, arg2: android.view.MotionEvent, /) -> None: ...

class GesturePoint(java.lang.Object):
    timestamp: int = ...
    x: float = ...
    y: float = ...
    def __init__(self, x: float | java.jfloat | java.lang.Float, y: float | java.jfloat | java.lang.Float, t: int | java.jlong | java.lang.Long, /) -> None: ...
    def clone(self) -> java.lang.Object: ...

class GestureStore(java.lang.Object):
    ORIENTATION_INVARIANT: typing.ClassVar[int] = ...
    ORIENTATION_SENSITIVE: typing.ClassVar[int] = ...
    SEQUENCE_INVARIANT: typing.ClassVar[int] = ...
    SEQUENCE_SENSITIVE: typing.ClassVar[int] = ...
    def __init__(self) -> None: ...
    def addGesture(self, entryName: str | java.lang.String, gesture: Gesture, /) -> None: ...
    def getGestureEntries(self) -> java.util.Set[java.lang.String]: ...
    def getGestures(self, entryName: str | java.lang.String, /) -> java.util.ArrayList[Gesture]: ...
    def getOrientationStyle(self) -> int: ...
    def getSequenceType(self) -> int: ...
    def hasChanged(self) -> bool: ...
    @typing.overload
    def load(self, stream: java.io.InputStream, /) -> None: ...
    @typing.overload
    def load(self, stream: java.io.InputStream, closeStream: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def recognize(self, gesture: Gesture, /) -> java.util.ArrayList[Prediction]: ...
    def removeEntry(self, entryName: str | java.lang.String, /) -> None: ...
    def removeGesture(self, entryName: str | java.lang.String, gesture: Gesture, /) -> None: ...
    @typing.overload
    def save(self, stream: java.io.OutputStream, /) -> None: ...
    @typing.overload
    def save(self, stream: java.io.OutputStream, closeStream: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setOrientationStyle(self, style: int | java.jint | java.lang.Integer, /) -> None: ...
    def setSequenceType(self, type: int | java.jint | java.lang.Integer, /) -> None: ...

class GestureStroke(java.lang.Object):
    boundingBox: android.graphics.RectF = ...
    length: float = ...
    points: java.chaquopy.JavaArrayJFloat = ...
    def __init__(self, points: java.util.ArrayList[GesturePoint], /) -> None: ...
    def clearPath(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def computeOrientedBoundingBox(self) -> OrientedBoundingBox: ...
    def getPath(self) -> android.graphics.Path: ...
    def toPath(self, width: float | java.jfloat | java.lang.Float, height: float | java.jfloat | java.lang.Float, numSample: int | java.jint | java.lang.Integer, /) -> android.graphics.Path: ...

class GestureUtils(java.lang.Object):
    @typing.overload
    @staticmethod
    def computeOrientedBoundingBox(originalPoints: java.util.ArrayList[GesturePoint], /) -> OrientedBoundingBox: ...
    @typing.overload
    @staticmethod
    def computeOrientedBoundingBox(originalPoints: java.chaquopy.JavaArrayJFloat, /) -> OrientedBoundingBox: ...
    @typing.overload
    @staticmethod
    def spatialSampling(gesture: Gesture, bitmapSize: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJFloat: ...
    @typing.overload
    @staticmethod
    def spatialSampling(gesture: Gesture, bitmapSize: int | java.jint | java.lang.Integer, keepAspectRatio: bool | java.jboolean | java.lang.Boolean, /) -> java.chaquopy.JavaArrayJFloat: ...
    @staticmethod
    def temporalSampling(stroke: GestureStroke, numPoints: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJFloat: ...

class OrientedBoundingBox(java.lang.Object):
    centerX: float = ...
    centerY: float = ...
    height: float = ...
    orientation: float = ...
    squareness: float = ...
    width: float = ...

class Prediction(java.lang.Object):
    name: str = ...
    score: float = ...
    def toString(self) -> str: ...
