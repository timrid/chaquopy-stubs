import java
import java.chaquopy
import java.io
import java.lang
import java.util
import typing



class BigDecimal(java.lang.Number, java.lang.Comparable[BigDecimal]):
    ONE: typing.ClassVar[BigDecimal] = ...
    ROUND_CEILING: typing.ClassVar[int] = ...
    ROUND_DOWN: typing.ClassVar[int] = ...
    ROUND_FLOOR: typing.ClassVar[int] = ...
    ROUND_HALF_DOWN: typing.ClassVar[int] = ...
    ROUND_HALF_EVEN: typing.ClassVar[int] = ...
    ROUND_HALF_UP: typing.ClassVar[int] = ...
    ROUND_UNNECESSARY: typing.ClassVar[int] = ...
    ROUND_UP: typing.ClassVar[int] = ...
    TEN: typing.ClassVar[BigDecimal] = ...
    ZERO: typing.ClassVar[BigDecimal] = ...
    @typing.overload
    def __init__(self, val: float | java.jdouble | java.lang.Double, /) -> None: ...
    @typing.overload
    def __init__(self, val: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, val: int | java.jlong | java.lang.Long, /) -> None: ...
    @typing.overload
    def __init__(self, val: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, val: BigInteger, /) -> None: ...
    @typing.overload
    def __init__(self, in_: java.chaquopy.JavaArrayJChar, /) -> None: ...
    @typing.overload
    def __init__(self, val: float | java.jdouble | java.lang.Double, mc: MathContext, /) -> None: ...
    @typing.overload
    def __init__(self, val: int | java.jint | java.lang.Integer, mc: MathContext, /) -> None: ...
    @typing.overload
    def __init__(self, val: int | java.jlong | java.lang.Long, mc: MathContext, /) -> None: ...
    @typing.overload
    def __init__(self, val: str | java.lang.String, mc: MathContext, /) -> None: ...
    @typing.overload
    def __init__(self, unscaledVal: BigInteger, scale: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, val: BigInteger, mc: MathContext, /) -> None: ...
    @typing.overload
    def __init__(self, in_: java.chaquopy.JavaArrayJChar, mc: MathContext, /) -> None: ...
    @typing.overload
    def __init__(self, unscaledVal: BigInteger, scale: int | java.jint | java.lang.Integer, mc: MathContext, /) -> None: ...
    @typing.overload
    def __init__(self, in_: java.chaquopy.JavaArrayJChar, offset: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, in_: java.chaquopy.JavaArrayJChar, offset: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, mc: MathContext, /) -> None: ...
    @typing.overload
    def abs(self) -> BigDecimal: ...
    @typing.overload
    def abs(self, mc: MathContext, /) -> BigDecimal: ...
    @typing.overload
    def add(self, augend: BigDecimal, /) -> BigDecimal: ...
    @typing.overload
    def add(self, augend: BigDecimal, mc: MathContext, /) -> BigDecimal: ...
    def byteValueExact(self) -> int: ...
    def compareTo(self, val: BigDecimal, /) -> int: ...
    @typing.overload
    def divide(self, divisor: BigDecimal, /) -> BigDecimal: ...
    @typing.overload
    def divide(self, divisor: BigDecimal, roundingMode: int | java.jint | java.lang.Integer, /) -> BigDecimal: ...
    @typing.overload
    def divide(self, divisor: BigDecimal, mc: MathContext, /) -> BigDecimal: ...
    @typing.overload
    def divide(self, divisor: BigDecimal, roundingMode: RoundingMode, /) -> BigDecimal: ...
    @typing.overload
    def divide(self, divisor: BigDecimal, scale: int | java.jint | java.lang.Integer, roundingMode: int | java.jint | java.lang.Integer, /) -> BigDecimal: ...
    @typing.overload
    def divide(self, divisor: BigDecimal, scale: int | java.jint | java.lang.Integer, roundingMode: RoundingMode, /) -> BigDecimal: ...
    @typing.overload
    def divideAndRemainder(self, divisor: BigDecimal, /) -> java.chaquopy.JavaArray[BigDecimal]: ...
    @typing.overload
    def divideAndRemainder(self, divisor: BigDecimal, mc: MathContext, /) -> java.chaquopy.JavaArray[BigDecimal]: ...
    @typing.overload
    def divideToIntegralValue(self, divisor: BigDecimal, /) -> BigDecimal: ...
    @typing.overload
    def divideToIntegralValue(self, divisor: BigDecimal, mc: MathContext, /) -> BigDecimal: ...
    def doubleValue(self) -> float: ...
    def equals(self, x: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def floatValue(self) -> float: ...
    def hashCode(self) -> int: ...
    def intValue(self) -> int: ...
    def intValueExact(self) -> int: ...
    def longValue(self) -> int: ...
    def longValueExact(self) -> int: ...
    def max(self, val: BigDecimal, /) -> BigDecimal: ...
    def min(self, val: BigDecimal, /) -> BigDecimal: ...
    def movePointLeft(self, n: int | java.jint | java.lang.Integer, /) -> BigDecimal: ...
    def movePointRight(self, n: int | java.jint | java.lang.Integer, /) -> BigDecimal: ...
    @typing.overload
    def multiply(self, multiplicand: BigDecimal, /) -> BigDecimal: ...
    @typing.overload
    def multiply(self, multiplicand: BigDecimal, mc: MathContext, /) -> BigDecimal: ...
    @typing.overload
    def negate(self) -> BigDecimal: ...
    @typing.overload
    def negate(self, mc: MathContext, /) -> BigDecimal: ...
    @typing.overload
    def plus(self) -> BigDecimal: ...
    @typing.overload
    def plus(self, mc: MathContext, /) -> BigDecimal: ...
    @typing.overload
    def pow(self, n: int | java.jint | java.lang.Integer, /) -> BigDecimal: ...
    @typing.overload
    def pow(self, n: int | java.jint | java.lang.Integer, mc: MathContext, /) -> BigDecimal: ...
    def precision(self) -> int: ...
    @typing.overload
    def remainder(self, divisor: BigDecimal, /) -> BigDecimal: ...
    @typing.overload
    def remainder(self, divisor: BigDecimal, mc: MathContext, /) -> BigDecimal: ...
    def round(self, mc: MathContext, /) -> BigDecimal: ...
    def scale(self) -> int: ...
    def scaleByPowerOfTen(self, n: int | java.jint | java.lang.Integer, /) -> BigDecimal: ...
    @typing.overload
    def setScale(self, newScale: int | java.jint | java.lang.Integer, /) -> BigDecimal: ...
    @typing.overload
    def setScale(self, newScale: int | java.jint | java.lang.Integer, roundingMode: int | java.jint | java.lang.Integer, /) -> BigDecimal: ...
    @typing.overload
    def setScale(self, newScale: int | java.jint | java.lang.Integer, roundingMode: RoundingMode, /) -> BigDecimal: ...
    def shortValueExact(self) -> int: ...
    def signum(self) -> int: ...
    def sqrt(self, mc: MathContext, /) -> BigDecimal: ...
    def stripTrailingZeros(self) -> BigDecimal: ...
    @typing.overload
    def subtract(self, subtrahend: BigDecimal, /) -> BigDecimal: ...
    @typing.overload
    def subtract(self, subtrahend: BigDecimal, mc: MathContext, /) -> BigDecimal: ...
    def toBigInteger(self) -> BigInteger: ...
    def toBigIntegerExact(self) -> BigInteger: ...
    def toEngineeringString(self) -> str: ...
    def toPlainString(self) -> str: ...
    def toString(self) -> str: ...
    def ulp(self) -> BigDecimal: ...
    def unscaledValue(self) -> BigInteger: ...
    @typing.overload
    @staticmethod
    def valueOf(val: float | java.jdouble | java.lang.Double, /) -> BigDecimal: ...
    @typing.overload
    @staticmethod
    def valueOf(val: int | java.jlong | java.lang.Long, /) -> BigDecimal: ...
    @typing.overload
    @staticmethod
    def valueOf(unscaledVal: int | java.jlong | java.lang.Long, scale: int | java.jint | java.lang.Integer, /) -> BigDecimal: ...

class BigInteger(java.lang.Number, java.lang.Comparable[BigInteger]):
    ONE: typing.ClassVar[BigInteger] = ...
    TEN: typing.ClassVar[BigInteger] = ...
    TWO: typing.ClassVar[BigInteger] = ...
    ZERO: typing.ClassVar[BigInteger] = ...
    @typing.overload
    def __init__(self, val: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, val: java.chaquopy.JavaArrayJByte, /) -> None: ...
    @typing.overload
    def __init__(self, numBits: int | java.jint | java.lang.Integer, rnd: java.util.Random, /) -> None: ...
    @typing.overload
    def __init__(self, signum: int | java.jint | java.lang.Integer, magnitude: java.chaquopy.JavaArrayJByte, /) -> None: ...
    @typing.overload
    def __init__(self, val: str | java.lang.String, radix: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, bitLength: int | java.jint | java.lang.Integer, certainty: int | java.jint | java.lang.Integer, rnd: java.util.Random, /) -> None: ...
    @typing.overload
    def __init__(self, val: java.chaquopy.JavaArrayJByte, off: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, signum: int | java.jint | java.lang.Integer, magnitude: java.chaquopy.JavaArrayJByte, off: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, /) -> None: ...
    def abs(self) -> BigInteger: ...
    def add(self, val: BigInteger, /) -> BigInteger: ...
    def andNot(self, val: BigInteger, /) -> BigInteger: ...
    def and_(self, val: BigInteger, /) -> BigInteger: ...
    def bitCount(self) -> int: ...
    def bitLength(self) -> int: ...
    def byteValueExact(self) -> int: ...
    def clearBit(self, n: int | java.jint | java.lang.Integer, /) -> BigInteger: ...
    def compareTo(self, val: BigInteger, /) -> int: ...
    def divide(self, val: BigInteger, /) -> BigInteger: ...
    def divideAndRemainder(self, val: BigInteger, /) -> java.chaquopy.JavaArray[BigInteger]: ...
    def doubleValue(self) -> float: ...
    def equals(self, x: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def flipBit(self, n: int | java.jint | java.lang.Integer, /) -> BigInteger: ...
    def floatValue(self) -> float: ...
    def gcd(self, val: BigInteger, /) -> BigInteger: ...
    def getLowestSetBit(self) -> int: ...
    def hashCode(self) -> int: ...
    def intValue(self) -> int: ...
    def intValueExact(self) -> int: ...
    def isProbablePrime(self, certainty: int | java.jint | java.lang.Integer, /) -> bool: ...
    def longValue(self) -> int: ...
    def longValueExact(self) -> int: ...
    def max(self, val: BigInteger, /) -> BigInteger: ...
    def min(self, val: BigInteger, /) -> BigInteger: ...
    def mod(self, m: BigInteger, /) -> BigInteger: ...
    def modInverse(self, m: BigInteger, /) -> BigInteger: ...
    def modPow(self, exponent: BigInteger, m: BigInteger, /) -> BigInteger: ...
    def multiply(self, val: BigInteger, /) -> BigInteger: ...
    def negate(self) -> BigInteger: ...
    def nextProbablePrime(self) -> BigInteger: ...
    def not_(self) -> BigInteger: ...
    def or_(self, val: BigInteger, /) -> BigInteger: ...
    def pow(self, exponent: int | java.jint | java.lang.Integer, /) -> BigInteger: ...
    @staticmethod
    def probablePrime(bitLength: int | java.jint | java.lang.Integer, rnd: java.util.Random, /) -> BigInteger: ...
    def remainder(self, val: BigInteger, /) -> BigInteger: ...
    def setBit(self, n: int | java.jint | java.lang.Integer, /) -> BigInteger: ...
    def shiftLeft(self, n: int | java.jint | java.lang.Integer, /) -> BigInteger: ...
    def shiftRight(self, n: int | java.jint | java.lang.Integer, /) -> BigInteger: ...
    def shortValueExact(self) -> int: ...
    def signum(self) -> int: ...
    def sqrt(self) -> BigInteger: ...
    def sqrtAndRemainder(self) -> java.chaquopy.JavaArray[BigInteger]: ...
    def subtract(self, val: BigInteger, /) -> BigInteger: ...
    def testBit(self, n: int | java.jint | java.lang.Integer, /) -> bool: ...
    def toByteArray(self) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    def toString(self, radix: int | java.jint | java.lang.Integer, /) -> str: ...
    @staticmethod
    def valueOf(val: int | java.jlong | java.lang.Long, /) -> BigInteger: ...
    def xor(self, val: BigInteger, /) -> BigInteger: ...

class MathContext(java.io.Serializable):
    DECIMAL128: typing.ClassVar[MathContext] = ...
    DECIMAL32: typing.ClassVar[MathContext] = ...
    DECIMAL64: typing.ClassVar[MathContext] = ...
    UNLIMITED: typing.ClassVar[MathContext] = ...
    @typing.overload
    def __init__(self, setPrecision: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, val: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, setPrecision: int | java.jint | java.lang.Integer, setRoundingMode: RoundingMode, /) -> None: ...
    def equals(self, x: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getPrecision(self) -> int: ...
    def getRoundingMode(self) -> RoundingMode: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class RoundingMode(java.lang.Enum[RoundingMode]):
    CEILING: typing.ClassVar[RoundingMode] = ...
    DOWN: typing.ClassVar[RoundingMode] = ...
    FLOOR: typing.ClassVar[RoundingMode] = ...
    HALF_DOWN: typing.ClassVar[RoundingMode] = ...
    HALF_EVEN: typing.ClassVar[RoundingMode] = ...
    HALF_UP: typing.ClassVar[RoundingMode] = ...
    UNNECESSARY: typing.ClassVar[RoundingMode] = ...
    UP: typing.ClassVar[RoundingMode] = ...
    @typing.overload
    @staticmethod
    def valueOf(rm: int | java.jint | java.lang.Integer, /) -> RoundingMode: ...
    @typing.overload
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> RoundingMode: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[RoundingMode]: ...
