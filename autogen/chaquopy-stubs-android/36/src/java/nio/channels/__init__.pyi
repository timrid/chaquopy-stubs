import java
import java.chaquopy
import java.io
import java.lang
import java.net
import java.nio
import java.nio.channels.spi
import java.nio.charset
import java.nio.file
import java.nio.file.attribute
import java.util
import java.util.concurrent
import java.util.function
import typing



class AcceptPendingException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class AlreadyBoundException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class AlreadyConnectedException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class AsynchronousByteChannel(AsynchronousChannel):
    _read_1__A = typing.TypeVar('_read_1__A')  # <A>
    @typing.overload
    def read(self, arg1: java.nio.ByteBuffer, /) -> java.util.concurrent.Future[java.lang.Integer]: ...
    @typing.overload
    def read(self, arg1: java.nio.ByteBuffer, arg2: _read_1__A, arg3: CompletionHandler[java.lang.Integer, _read_1__A], /) -> None: ...
    _write_1__A = typing.TypeVar('_write_1__A')  # <A>
    @typing.overload
    def write(self, arg1: java.nio.ByteBuffer, /) -> java.util.concurrent.Future[java.lang.Integer]: ...
    @typing.overload
    def write(self, arg1: java.nio.ByteBuffer, arg2: _write_1__A, arg3: CompletionHandler[java.lang.Integer, _write_1__A], /) -> None: ...

class AsynchronousChannel(Channel):
    def close(self) -> None: ...

class AsynchronousChannelGroup(java.lang.Object):
    def __init__(self, provider: java.nio.channels.spi.AsynchronousChannelProvider, /) -> None: ...
    def awaitTermination(self, arg1: int | java.jlong | java.lang.Long, arg2: java.util.concurrent.TimeUnit, /) -> bool: ...
    def isShutdown(self) -> bool: ...
    def isTerminated(self) -> bool: ...
    def provider(self) -> java.nio.channels.spi.AsynchronousChannelProvider: ...
    def shutdown(self) -> None: ...
    def shutdownNow(self) -> None: ...
    @staticmethod
    def withCachedThreadPool(executor: java.util.concurrent.ExecutorService, initialSize: int | java.jint | java.lang.Integer, /) -> AsynchronousChannelGroup: ...
    @staticmethod
    def withFixedThreadPool(nThreads: int | java.jint | java.lang.Integer, threadFactory: java.util.concurrent.ThreadFactory, /) -> AsynchronousChannelGroup: ...
    @staticmethod
    def withThreadPool(executor: java.util.concurrent.ExecutorService, /) -> AsynchronousChannelGroup: ...

class AsynchronousCloseException(ClosedChannelException):
    def __init__(self) -> None: ...

class AsynchronousFileChannel(AsynchronousChannel):
    def __init__(self) -> None: ...
    def force(self, arg1: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    _lock_1__A = typing.TypeVar('_lock_1__A')  # <A>
    _lock_3__A = typing.TypeVar('_lock_3__A')  # <A>
    @typing.overload
    def lock(self) -> java.util.concurrent.Future[FileLock]: ...
    @typing.overload
    def lock(self, attachment: _lock_1__A, handler: CompletionHandler[FileLock, _lock_1__A], /) -> None: ...
    @typing.overload
    def lock(self, arg1: int | java.jlong | java.lang.Long, arg2: int | java.jlong | java.lang.Long, arg3: bool | java.jboolean | java.lang.Boolean, /) -> java.util.concurrent.Future[FileLock]: ...
    @typing.overload
    def lock(self, arg1: int | java.jlong | java.lang.Long, arg2: int | java.jlong | java.lang.Long, arg3: bool | java.jboolean | java.lang.Boolean, arg4: _lock_3__A, arg5: CompletionHandler[FileLock, _lock_3__A], /) -> None: ...
    @typing.overload
    @staticmethod
    def open(file: java.nio.file.Path, /, *options: java.nio.file.OpenOption) -> AsynchronousFileChannel: ...
    @typing.overload
    @staticmethod
    def open(file: java.nio.file.Path, options: java.util.Set[java.nio.file.OpenOption], executor: java.util.concurrent.ExecutorService, /, *attrs: java.nio.file.attribute.FileAttribute[java.lang.Object]) -> AsynchronousFileChannel: ...
    _read_1__A = typing.TypeVar('_read_1__A')  # <A>
    @typing.overload
    def read(self, arg1: java.nio.ByteBuffer, arg2: int | java.jlong | java.lang.Long, /) -> java.util.concurrent.Future[java.lang.Integer]: ...
    @typing.overload
    def read(self, arg1: java.nio.ByteBuffer, arg2: int | java.jlong | java.lang.Long, arg3: _read_1__A, arg4: CompletionHandler[java.lang.Integer, _read_1__A], /) -> None: ...
    def size(self) -> int: ...
    def truncate(self, arg1: int | java.jlong | java.lang.Long, /) -> AsynchronousFileChannel: ...
    @typing.overload
    def tryLock(self) -> FileLock: ...
    @typing.overload
    def tryLock(self, arg1: int | java.jlong | java.lang.Long, arg2: int | java.jlong | java.lang.Long, arg3: bool | java.jboolean | java.lang.Boolean, /) -> FileLock: ...
    _write_1__A = typing.TypeVar('_write_1__A')  # <A>
    @typing.overload
    def write(self, arg1: java.nio.ByteBuffer, arg2: int | java.jlong | java.lang.Long, /) -> java.util.concurrent.Future[java.lang.Integer]: ...
    @typing.overload
    def write(self, arg1: java.nio.ByteBuffer, arg2: int | java.jlong | java.lang.Long, arg3: _write_1__A, arg4: CompletionHandler[java.lang.Integer, _write_1__A], /) -> None: ...

class AsynchronousServerSocketChannel(AsynchronousChannel, NetworkChannel):
    def __init__(self, provider: java.nio.channels.spi.AsynchronousChannelProvider, /) -> None: ...
    _accept_1__A = typing.TypeVar('_accept_1__A')  # <A>
    @typing.overload
    def accept(self) -> java.util.concurrent.Future[AsynchronousSocketChannel]: ...
    @typing.overload
    def accept(self, arg1: _accept_1__A, arg2: CompletionHandler[AsynchronousSocketChannel, _accept_1__A], /) -> None: ...
    @typing.overload
    def bind(self, local: java.net.SocketAddress, /) -> AsynchronousServerSocketChannel: ...
    @typing.overload
    def bind(self, arg1: java.net.SocketAddress, arg2: int | java.jint | java.lang.Integer, /) -> AsynchronousServerSocketChannel: ...
    def getLocalAddress(self) -> java.net.SocketAddress: ...
    @typing.overload
    @staticmethod
    def open() -> AsynchronousServerSocketChannel: ...
    @typing.overload
    @staticmethod
    def open(group: AsynchronousChannelGroup, /) -> AsynchronousServerSocketChannel: ...
    def provider(self) -> java.nio.channels.spi.AsynchronousChannelProvider: ...
    _setOption__T = typing.TypeVar('_setOption__T')  # <T>
    def setOption(self, arg1: java.net.SocketOption[_setOption__T], arg2: _setOption__T, /) -> AsynchronousServerSocketChannel: ...

class AsynchronousSocketChannel(AsynchronousByteChannel, NetworkChannel):
    def __init__(self, provider: java.nio.channels.spi.AsynchronousChannelProvider, /) -> None: ...
    def bind(self, arg1: java.net.SocketAddress, /) -> AsynchronousSocketChannel: ...
    _connect_1__A = typing.TypeVar('_connect_1__A')  # <A>
    @typing.overload
    def connect(self, arg1: java.net.SocketAddress, /) -> java.util.concurrent.Future[java.lang.Void]: ...
    @typing.overload
    def connect(self, arg1: java.net.SocketAddress, arg2: _connect_1__A, arg3: CompletionHandler[java.lang.Void, _connect_1__A], /) -> None: ...
    def getLocalAddress(self) -> java.net.SocketAddress: ...
    def getRemoteAddress(self) -> java.net.SocketAddress: ...
    @typing.overload
    @staticmethod
    def open() -> AsynchronousSocketChannel: ...
    @typing.overload
    @staticmethod
    def open(group: AsynchronousChannelGroup, /) -> AsynchronousSocketChannel: ...
    def provider(self) -> java.nio.channels.spi.AsynchronousChannelProvider: ...
    _read_1__A = typing.TypeVar('_read_1__A')  # <A>
    _read_2__A = typing.TypeVar('_read_2__A')  # <A>
    _read_3__A = typing.TypeVar('_read_3__A')  # <A>
    @typing.overload
    def read(self, arg1: java.nio.ByteBuffer, /) -> java.util.concurrent.Future[java.lang.Integer]: ...
    @typing.overload
    def read(self, dst: java.nio.ByteBuffer, attachment: _read_1__A, handler: CompletionHandler[java.lang.Integer, _read_1__A], /) -> None: ...
    @typing.overload
    def read(self, arg1: java.nio.ByteBuffer, arg2: int | java.jlong | java.lang.Long, arg3: java.util.concurrent.TimeUnit, arg4: _read_2__A, arg5: CompletionHandler[java.lang.Integer, _read_2__A], /) -> None: ...
    @typing.overload
    def read(self, arg1: java.chaquopy.JavaArray[java.nio.ByteBuffer], arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, arg4: int | java.jlong | java.lang.Long, arg5: java.util.concurrent.TimeUnit, arg6: _read_3__A, arg7: CompletionHandler[java.lang.Long, _read_3__A], /) -> None: ...
    _setOption__T = typing.TypeVar('_setOption__T')  # <T>
    def setOption(self, arg1: java.net.SocketOption[_setOption__T], arg2: _setOption__T, /) -> AsynchronousSocketChannel: ...
    def shutdownInput(self) -> AsynchronousSocketChannel: ...
    def shutdownOutput(self) -> AsynchronousSocketChannel: ...
    _write_1__A = typing.TypeVar('_write_1__A')  # <A>
    _write_2__A = typing.TypeVar('_write_2__A')  # <A>
    _write_3__A = typing.TypeVar('_write_3__A')  # <A>
    @typing.overload
    def write(self, arg1: java.nio.ByteBuffer, /) -> java.util.concurrent.Future[java.lang.Integer]: ...
    @typing.overload
    def write(self, src: java.nio.ByteBuffer, attachment: _write_1__A, handler: CompletionHandler[java.lang.Integer, _write_1__A], /) -> None: ...
    @typing.overload
    def write(self, arg1: java.nio.ByteBuffer, arg2: int | java.jlong | java.lang.Long, arg3: java.util.concurrent.TimeUnit, arg4: _write_2__A, arg5: CompletionHandler[java.lang.Integer, _write_2__A], /) -> None: ...
    @typing.overload
    def write(self, arg1: java.chaquopy.JavaArray[java.nio.ByteBuffer], arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, arg4: int | java.jlong | java.lang.Long, arg5: java.util.concurrent.TimeUnit, arg6: _write_3__A, arg7: CompletionHandler[java.lang.Long, _write_3__A], /) -> None: ...

class ByteChannel(ReadableByteChannel, WritableByteChannel): ...

class CancelledKeyException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class Channel(java.io.Closeable):
    def close(self) -> None: ...
    def isOpen(self) -> bool: ...

class Channels(java.lang.Object):
    @typing.overload
    @staticmethod
    def newChannel(in_: java.io.InputStream, /) -> ReadableByteChannel: ...
    @typing.overload
    @staticmethod
    def newChannel(out: java.io.OutputStream, /) -> WritableByteChannel: ...
    @typing.overload
    @staticmethod
    def newInputStream(ch: AsynchronousByteChannel, /) -> java.io.InputStream: ...
    @typing.overload
    @staticmethod
    def newInputStream(ch: ReadableByteChannel, /) -> java.io.InputStream: ...
    @typing.overload
    @staticmethod
    def newOutputStream(ch: AsynchronousByteChannel, /) -> java.io.OutputStream: ...
    @typing.overload
    @staticmethod
    def newOutputStream(ch: WritableByteChannel, /) -> java.io.OutputStream: ...
    @typing.overload
    @staticmethod
    def newReader(ch: ReadableByteChannel, csName: str | java.lang.String, /) -> java.io.Reader: ...
    @typing.overload
    @staticmethod
    def newReader(ch: ReadableByteChannel, charset: java.nio.charset.Charset, /) -> java.io.Reader: ...
    @typing.overload
    @staticmethod
    def newReader(ch: ReadableByteChannel, dec: java.nio.charset.CharsetDecoder, minBufferCap: int | java.jint | java.lang.Integer, /) -> java.io.Reader: ...
    @typing.overload
    @staticmethod
    def newWriter(ch: WritableByteChannel, csName: str | java.lang.String, /) -> java.io.Writer: ...
    @typing.overload
    @staticmethod
    def newWriter(ch: WritableByteChannel, charset: java.nio.charset.Charset, /) -> java.io.Writer: ...
    @typing.overload
    @staticmethod
    def newWriter(ch: WritableByteChannel, enc: java.nio.charset.CharsetEncoder, minBufferCap: int | java.jint | java.lang.Integer, /) -> java.io.Writer: ...

class ClosedByInterruptException(AsynchronousCloseException):
    def __init__(self) -> None: ...

class ClosedChannelException(java.io.IOException):
    def __init__(self) -> None: ...

class ClosedSelectorException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

_CompletionHandler__V = typing.TypeVar('_CompletionHandler__V')  # <V>
_CompletionHandler__A = typing.TypeVar('_CompletionHandler__A')  # <A>
class CompletionHandler(java.lang.Object, typing.Generic[_CompletionHandler__V, _CompletionHandler__A]):
    def completed(self, arg1: _CompletionHandler__V, arg2: _CompletionHandler__A, /) -> None: ...
    def failed(self, arg1: java.lang.Throwable, arg2: _CompletionHandler__A, /) -> None: ...

class ConnectionPendingException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class DatagramChannel(java.nio.channels.spi.AbstractSelectableChannel, ByteChannel, GatheringByteChannel, MulticastChannel, ScatteringByteChannel):
    def __init__(self, provider: java.nio.channels.spi.SelectorProvider, /) -> None: ...
    def bind(self, arg1: java.net.SocketAddress, /) -> DatagramChannel: ...
    def connect(self, arg1: java.net.SocketAddress, /) -> DatagramChannel: ...
    def disconnect(self) -> DatagramChannel: ...
    def getLocalAddress(self) -> java.net.SocketAddress: ...
    def getRemoteAddress(self) -> java.net.SocketAddress: ...
    def isConnected(self) -> bool: ...
    @typing.overload
    @staticmethod
    def open() -> DatagramChannel: ...
    @typing.overload
    @staticmethod
    def open(family: java.net.ProtocolFamily, /) -> DatagramChannel: ...
    @typing.overload
    def read(self, arg1: java.nio.ByteBuffer, /) -> int: ...
    @typing.overload
    def read(self, dsts: java.chaquopy.JavaArray[java.nio.ByteBuffer], /) -> int: ...
    @typing.overload
    def read(self, arg1: java.chaquopy.JavaArray[java.nio.ByteBuffer], arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> int: ...
    def receive(self, arg1: java.nio.ByteBuffer, /) -> java.net.SocketAddress: ...
    def send(self, arg1: java.nio.ByteBuffer, arg2: java.net.SocketAddress, /) -> int: ...
    _setOption__T = typing.TypeVar('_setOption__T')  # <T>
    def setOption(self, arg1: java.net.SocketOption[_setOption__T], arg2: _setOption__T, /) -> DatagramChannel: ...
    def socket(self) -> java.net.DatagramSocket: ...
    def validOps(self) -> int: ...
    @typing.overload
    def write(self, arg1: java.nio.ByteBuffer, /) -> int: ...
    @typing.overload
    def write(self, srcs: java.chaquopy.JavaArray[java.nio.ByteBuffer], /) -> int: ...
    @typing.overload
    def write(self, arg1: java.chaquopy.JavaArray[java.nio.ByteBuffer], arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> int: ...

class FileChannel(java.nio.channels.spi.AbstractInterruptibleChannel, GatheringByteChannel, ScatteringByteChannel, SeekableByteChannel):
    def __init__(self) -> None: ...
    def force(self, arg1: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def lock(self) -> FileLock: ...
    @typing.overload
    def lock(self, arg1: int | java.jlong | java.lang.Long, arg2: int | java.jlong | java.lang.Long, arg3: bool | java.jboolean | java.lang.Boolean, /) -> FileLock: ...
    def map(self, arg1: FileChannel.MapMode, arg2: int | java.jlong | java.lang.Long, arg3: int | java.jlong | java.lang.Long, /) -> java.nio.MappedByteBuffer: ...
    @typing.overload
    @staticmethod
    def open(path: java.nio.file.Path, /, *options: java.nio.file.OpenOption) -> FileChannel: ...
    @typing.overload
    @staticmethod
    def open(path: java.nio.file.Path, options: java.util.Set[java.nio.file.OpenOption], /, *attrs: java.nio.file.attribute.FileAttribute[java.lang.Object]) -> FileChannel: ...
    @typing.overload
    def position(self) -> int: ...
    @typing.overload
    def position(self, arg1: int | java.jlong | java.lang.Long, /) -> FileChannel: ...
    @typing.overload
    def read(self, arg1: java.nio.ByteBuffer, /) -> int: ...
    @typing.overload
    def read(self, dsts: java.chaquopy.JavaArray[java.nio.ByteBuffer], /) -> int: ...
    @typing.overload
    def read(self, arg1: java.nio.ByteBuffer, arg2: int | java.jlong | java.lang.Long, /) -> int: ...
    @typing.overload
    def read(self, arg1: java.chaquopy.JavaArray[java.nio.ByteBuffer], arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> int: ...
    def size(self) -> int: ...
    def transferFrom(self, arg1: ReadableByteChannel, arg2: int | java.jlong | java.lang.Long, arg3: int | java.jlong | java.lang.Long, /) -> int: ...
    def transferTo(self, arg1: int | java.jlong | java.lang.Long, arg2: int | java.jlong | java.lang.Long, arg3: WritableByteChannel, /) -> int: ...
    def truncate(self, arg1: int | java.jlong | java.lang.Long, /) -> FileChannel: ...
    @typing.overload
    def tryLock(self) -> FileLock: ...
    @typing.overload
    def tryLock(self, arg1: int | java.jlong | java.lang.Long, arg2: int | java.jlong | java.lang.Long, arg3: bool | java.jboolean | java.lang.Boolean, /) -> FileLock: ...
    @typing.overload
    def write(self, arg1: java.nio.ByteBuffer, /) -> int: ...
    @typing.overload
    def write(self, srcs: java.chaquopy.JavaArray[java.nio.ByteBuffer], /) -> int: ...
    @typing.overload
    def write(self, arg1: java.nio.ByteBuffer, arg2: int | java.jlong | java.lang.Long, /) -> int: ...
    @typing.overload
    def write(self, arg1: java.chaquopy.JavaArray[java.nio.ByteBuffer], arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> int: ...

    class MapMode(java.lang.Object):
        PRIVATE: typing.ClassVar[FileChannel.MapMode] = ...
        READ_ONLY: typing.ClassVar[FileChannel.MapMode] = ...
        READ_WRITE: typing.ClassVar[FileChannel.MapMode] = ...
        def toString(self) -> str: ...

class FileLock(java.lang.AutoCloseable):
    @typing.overload
    def __init__(self, channel: AsynchronousFileChannel, position: int | java.jlong | java.lang.Long, size: int | java.jlong | java.lang.Long, shared: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def __init__(self, channel: FileChannel, position: int | java.jlong | java.lang.Long, size: int | java.jlong | java.lang.Long, shared: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def acquiredBy(self) -> Channel: ...
    def channel(self) -> FileChannel: ...
    def close(self) -> None: ...
    def isShared(self) -> bool: ...
    def isValid(self) -> bool: ...
    def overlaps(self, position: int | java.jlong | java.lang.Long, size: int | java.jlong | java.lang.Long, /) -> bool: ...
    def position(self) -> int: ...
    def release(self) -> None: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...

class FileLockInterruptionException(java.io.IOException):
    def __init__(self) -> None: ...

class GatheringByteChannel(WritableByteChannel):
    @typing.overload
    def write(self, arg1: java.chaquopy.JavaArray[java.nio.ByteBuffer], /) -> int: ...
    @typing.overload
    def write(self, arg1: java.chaquopy.JavaArray[java.nio.ByteBuffer], arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> int: ...

class IllegalBlockingModeException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class IllegalChannelGroupException(java.lang.IllegalArgumentException):
    def __init__(self) -> None: ...

class IllegalSelectorException(java.lang.IllegalArgumentException):
    def __init__(self) -> None: ...

class InterruptedByTimeoutException(java.io.IOException):
    def __init__(self) -> None: ...

class InterruptibleChannel(Channel):
    def close(self) -> None: ...

class MembershipKey(java.lang.Object):
    def __init__(self) -> None: ...
    def block(self, arg1: java.net.InetAddress, /) -> MembershipKey: ...
    def channel(self) -> MulticastChannel: ...
    def drop(self) -> None: ...
    def group(self) -> java.net.InetAddress: ...
    def isValid(self) -> bool: ...
    def networkInterface(self) -> java.net.NetworkInterface: ...
    def sourceAddress(self) -> java.net.InetAddress: ...
    def unblock(self, arg1: java.net.InetAddress, /) -> MembershipKey: ...

class MulticastChannel(NetworkChannel):
    def close(self) -> None: ...
    @typing.overload
    def join(self, arg1: java.net.InetAddress, arg2: java.net.NetworkInterface, /) -> MembershipKey: ...
    @typing.overload
    def join(self, arg1: java.net.InetAddress, arg2: java.net.NetworkInterface, arg3: java.net.InetAddress, /) -> MembershipKey: ...

class NetworkChannel(Channel):
    def bind(self, arg1: java.net.SocketAddress, /) -> NetworkChannel: ...
    def getLocalAddress(self) -> java.net.SocketAddress: ...
    _getOption__T = typing.TypeVar('_getOption__T')  # <T>
    def getOption(self, arg1: java.net.SocketOption[_getOption__T], /) -> _getOption__T: ...
    _setOption__T = typing.TypeVar('_setOption__T')  # <T>
    def setOption(self, arg1: java.net.SocketOption[_setOption__T], arg2: _setOption__T, /) -> NetworkChannel: ...
    def supportedOptions(self) -> java.util.Set[java.net.SocketOption[java.lang.Object]]: ...

class NoConnectionPendingException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class NonReadableChannelException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class NonWritableChannelException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class NotYetBoundException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class NotYetConnectedException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class OverlappingFileLockException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class Pipe(java.lang.Object):
    def __init__(self) -> None: ...
    @staticmethod
    def open() -> Pipe: ...
    def sink(self) -> Pipe.SinkChannel: ...
    def source(self) -> Pipe.SourceChannel: ...

    class SourceChannel(java.nio.channels.spi.AbstractSelectableChannel, ReadableByteChannel, ScatteringByteChannel):
        def __init__(self, provider: java.nio.channels.spi.SelectorProvider, /) -> None: ...
        def validOps(self) -> int: ...

    class SinkChannel(java.nio.channels.spi.AbstractSelectableChannel, GatheringByteChannel, WritableByteChannel):
        def __init__(self, provider: java.nio.channels.spi.SelectorProvider, /) -> None: ...
        def validOps(self) -> int: ...

class ReadPendingException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class ReadableByteChannel(Channel):
    def read(self, arg1: java.nio.ByteBuffer, /) -> int: ...

class ScatteringByteChannel(ReadableByteChannel):
    @typing.overload
    def read(self, arg1: java.chaquopy.JavaArray[java.nio.ByteBuffer], /) -> int: ...
    @typing.overload
    def read(self, arg1: java.chaquopy.JavaArray[java.nio.ByteBuffer], arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> int: ...

class SeekableByteChannel(ByteChannel):
    @typing.overload
    def position(self) -> int: ...
    @typing.overload
    def position(self, arg1: int | java.jlong | java.lang.Long, /) -> SeekableByteChannel: ...
    def read(self, arg1: java.nio.ByteBuffer, /) -> int: ...
    def size(self) -> int: ...
    def truncate(self, arg1: int | java.jlong | java.lang.Long, /) -> SeekableByteChannel: ...
    def write(self, arg1: java.nio.ByteBuffer, /) -> int: ...

class SelectableChannel(java.nio.channels.spi.AbstractInterruptibleChannel, Channel):
    def __init__(self) -> None: ...
    def blockingLock(self) -> java.lang.Object: ...
    def configureBlocking(self, arg1: bool | java.jboolean | java.lang.Boolean, /) -> SelectableChannel: ...
    def isBlocking(self) -> bool: ...
    def isRegistered(self) -> bool: ...
    def keyFor(self, arg1: Selector, /) -> SelectionKey: ...
    def provider(self) -> java.nio.channels.spi.SelectorProvider: ...
    @typing.overload
    def register(self, sel: Selector, ops: int | java.jint | java.lang.Integer, /) -> SelectionKey: ...
    @typing.overload
    def register(self, arg1: Selector, arg2: int | java.jint | java.lang.Integer, arg3: java.lang.Object | int | bool | float | str, /) -> SelectionKey: ...
    def validOps(self) -> int: ...

class SelectionKey(java.lang.Object):
    OP_ACCEPT: typing.ClassVar[int] = ...
    OP_CONNECT: typing.ClassVar[int] = ...
    OP_READ: typing.ClassVar[int] = ...
    OP_WRITE: typing.ClassVar[int] = ...
    def __init__(self) -> None: ...
    def attach(self, ob: java.lang.Object | int | bool | float | str, /) -> java.lang.Object: ...
    def attachment(self) -> java.lang.Object: ...
    def cancel(self) -> None: ...
    def channel(self) -> SelectableChannel: ...
    @typing.overload
    def interestOps(self) -> int: ...
    @typing.overload
    def interestOps(self, arg1: int | java.jint | java.lang.Integer, /) -> SelectionKey: ...
    def interestOpsAnd(self, ops: int | java.jint | java.lang.Integer, /) -> int: ...
    def interestOpsOr(self, ops: int | java.jint | java.lang.Integer, /) -> int: ...
    def isAcceptable(self) -> bool: ...
    def isConnectable(self) -> bool: ...
    def isReadable(self) -> bool: ...
    def isValid(self) -> bool: ...
    def isWritable(self) -> bool: ...
    def readyOps(self) -> int: ...
    def selector(self) -> Selector: ...

class Selector(java.io.Closeable):
    def __init__(self) -> None: ...
    def close(self) -> None: ...
    def isOpen(self) -> bool: ...
    def keys(self) -> java.util.Set[SelectionKey]: ...
    @staticmethod
    def open() -> Selector: ...
    def provider(self) -> java.nio.channels.spi.SelectorProvider: ...
    @typing.overload
    def select(self) -> int: ...
    @typing.overload
    def select(self, arg1: int | java.jlong | java.lang.Long, /) -> int: ...
    @typing.overload
    def select(self, action: java.util.function.Consumer[SelectionKey], /) -> int: ...
    @typing.overload
    def select(self, action: java.util.function.Consumer[SelectionKey], timeout: int | java.jlong | java.lang.Long, /) -> int: ...
    @typing.overload
    def selectNow(self) -> int: ...
    @typing.overload
    def selectNow(self, action: java.util.function.Consumer[SelectionKey], /) -> int: ...
    def selectedKeys(self) -> java.util.Set[SelectionKey]: ...
    def wakeup(self) -> Selector: ...

class ServerSocketChannel(java.nio.channels.spi.AbstractSelectableChannel, NetworkChannel):
    def __init__(self, provider: java.nio.channels.spi.SelectorProvider, /) -> None: ...
    def accept(self) -> SocketChannel: ...
    @typing.overload
    def bind(self, local: java.net.SocketAddress, /) -> ServerSocketChannel: ...
    @typing.overload
    def bind(self, arg1: java.net.SocketAddress, arg2: int | java.jint | java.lang.Integer, /) -> ServerSocketChannel: ...
    def getLocalAddress(self) -> java.net.SocketAddress: ...
    @staticmethod
    def open() -> ServerSocketChannel: ...
    _setOption__T = typing.TypeVar('_setOption__T')  # <T>
    def setOption(self, arg1: java.net.SocketOption[_setOption__T], arg2: _setOption__T, /) -> ServerSocketChannel: ...
    def socket(self) -> java.net.ServerSocket: ...
    def validOps(self) -> int: ...

class ShutdownChannelGroupException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class SocketChannel(java.nio.channels.spi.AbstractSelectableChannel, ByteChannel, GatheringByteChannel, NetworkChannel, ScatteringByteChannel):
    def __init__(self, provider: java.nio.channels.spi.SelectorProvider, /) -> None: ...
    def bind(self, arg1: java.net.SocketAddress, /) -> SocketChannel: ...
    def connect(self, arg1: java.net.SocketAddress, /) -> bool: ...
    def finishConnect(self) -> bool: ...
    def getLocalAddress(self) -> java.net.SocketAddress: ...
    def getRemoteAddress(self) -> java.net.SocketAddress: ...
    def isConnected(self) -> bool: ...
    def isConnectionPending(self) -> bool: ...
    @typing.overload
    @staticmethod
    def open() -> SocketChannel: ...
    @typing.overload
    @staticmethod
    def open(remote: java.net.SocketAddress, /) -> SocketChannel: ...
    @typing.overload
    def read(self, arg1: java.nio.ByteBuffer, /) -> int: ...
    @typing.overload
    def read(self, dsts: java.chaquopy.JavaArray[java.nio.ByteBuffer], /) -> int: ...
    @typing.overload
    def read(self, arg1: java.chaquopy.JavaArray[java.nio.ByteBuffer], arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> int: ...
    _setOption__T = typing.TypeVar('_setOption__T')  # <T>
    def setOption(self, arg1: java.net.SocketOption[_setOption__T], arg2: _setOption__T, /) -> SocketChannel: ...
    def shutdownInput(self) -> SocketChannel: ...
    def shutdownOutput(self) -> SocketChannel: ...
    def socket(self) -> java.net.Socket: ...
    def validOps(self) -> int: ...
    @typing.overload
    def write(self, arg1: java.nio.ByteBuffer, /) -> int: ...
    @typing.overload
    def write(self, srcs: java.chaquopy.JavaArray[java.nio.ByteBuffer], /) -> int: ...
    @typing.overload
    def write(self, arg1: java.chaquopy.JavaArray[java.nio.ByteBuffer], arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> int: ...

class UnresolvedAddressException(java.lang.IllegalArgumentException):
    def __init__(self) -> None: ...

class UnsupportedAddressTypeException(java.lang.IllegalArgumentException):
    def __init__(self) -> None: ...

class WritableByteChannel(Channel):
    def write(self, arg1: java.nio.ByteBuffer, /) -> int: ...

class WritePendingException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...
