import java
import java.chaquopy
import java.io
import java.lang
import java.net
import java.nio.channels
import java.nio.charset
import java.nio.file.attribute
import java.nio.file.spi
import java.security
import java.util
import java.util.concurrent
import java.util.function
import java.util.stream
import typing



class AccessDeniedException(FileSystemException):
    @typing.overload
    def __init__(self, file: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, file: str | java.lang.String, other: str | java.lang.String, reason: str | java.lang.String, /) -> None: ...

class AccessMode(java.lang.Enum[AccessMode]):
    EXECUTE: typing.ClassVar[AccessMode] = ...
    READ: typing.ClassVar[AccessMode] = ...
    WRITE: typing.ClassVar[AccessMode] = ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> AccessMode: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[AccessMode]: ...

class AtomicMoveNotSupportedException(FileSystemException):
    def __init__(self, source: str | java.lang.String, target: str | java.lang.String, reason: str | java.lang.String, /) -> None: ...

class ClosedDirectoryStreamException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class ClosedFileSystemException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class ClosedWatchServiceException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class CopyOption(java.lang.Object): ...

class DirectoryIteratorException(java.util.ConcurrentModificationException):
    def __init__(self, cause: java.io.IOException, /) -> None: ...
    def getCause(self) -> java.io.IOException: ...

class DirectoryNotEmptyException(FileSystemException):
    def __init__(self, dir: str | java.lang.String, /) -> None: ...

_DirectoryStream__T = typing.TypeVar('_DirectoryStream__T')  # <T>

_DirectoryStream__Filter__T = typing.TypeVar('_DirectoryStream__Filter__T')  # <T>
class DirectoryStream(java.io.Closeable, java.lang.Iterable[_DirectoryStream__T], typing.Generic[_DirectoryStream__T]):
    def iterator(self) -> java.util.Iterator[_DirectoryStream__T]: ...
    class Filter(java.lang.Object, typing.Generic[_DirectoryStream__Filter__T]):
        def accept(self, arg1: _DirectoryStream__Filter__T, /) -> bool: ...

class FileAlreadyExistsException(FileSystemException):
    @typing.overload
    def __init__(self, file: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, file: str | java.lang.String, other: str | java.lang.String, reason: str | java.lang.String, /) -> None: ...

class FileStore(java.lang.Object):
    def __init__(self) -> None: ...
    def getAttribute(self, arg1: str | java.lang.String, /) -> java.lang.Object: ...
    def getBlockSize(self) -> int: ...
    _getFileStoreAttributeView__V = typing.TypeVar('_getFileStoreAttributeView__V')  # <V>
    def getFileStoreAttributeView(self, arg1: typing.Type[_getFileStoreAttributeView__V], /) -> _getFileStoreAttributeView__V: ...
    def getTotalSpace(self) -> int: ...
    def getUnallocatedSpace(self) -> int: ...
    def getUsableSpace(self) -> int: ...
    def isReadOnly(self) -> bool: ...
    def name(self) -> str: ...
    @typing.overload
    def supportsFileAttributeView(self, arg1: typing.Type[java.nio.file.attribute.FileAttributeView], /) -> bool: ...
    @typing.overload
    def supportsFileAttributeView(self, arg1: str | java.lang.String, /) -> bool: ...
    def type(self) -> str: ...

class FileSystem(java.io.Closeable):
    def __init__(self) -> None: ...
    def close(self) -> None: ...
    def getFileStores(self) -> java.lang.Iterable[FileStore]: ...
    def getPath(self, arg1: str | java.lang.String, /, *arg2: java.lang.String) -> Path: ...
    def getPathMatcher(self, arg1: str | java.lang.String, /) -> PathMatcher: ...
    def getRootDirectories(self) -> java.lang.Iterable[Path]: ...
    def getSeparator(self) -> str: ...
    def getUserPrincipalLookupService(self) -> java.nio.file.attribute.UserPrincipalLookupService: ...
    def isOpen(self) -> bool: ...
    def isReadOnly(self) -> bool: ...
    def newWatchService(self) -> WatchService: ...
    def provider(self) -> java.nio.file.spi.FileSystemProvider: ...
    def supportedFileAttributeViews(self) -> java.util.Set[java.lang.String]: ...

class FileSystemAlreadyExistsException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class FileSystemException(java.io.IOException):
    @typing.overload
    def __init__(self, file: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, file: str | java.lang.String, other: str | java.lang.String, reason: str | java.lang.String, /) -> None: ...
    def getFile(self) -> str: ...
    def getMessage(self) -> str: ...
    def getOtherFile(self) -> str: ...
    def getReason(self) -> str: ...

class FileSystemLoopException(FileSystemException):
    def __init__(self, file: str | java.lang.String, /) -> None: ...

class FileSystemNotFoundException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class FileSystems(java.lang.Object):
    @staticmethod
    def getDefault() -> FileSystem: ...
    @staticmethod
    def getFileSystem(uri: java.net.URI, /) -> FileSystem: ...
    @typing.overload
    @staticmethod
    def newFileSystem(uri: java.net.URI, env: java.util.Map[java.lang.String, java.lang.Object], /) -> FileSystem: ...
    @typing.overload
    @staticmethod
    def newFileSystem(path: Path, loader: java.lang.ClassLoader, /) -> FileSystem: ...
    @typing.overload
    @staticmethod
    def newFileSystem(uri: java.net.URI, env: java.util.Map[java.lang.String, java.lang.Object], loader: java.lang.ClassLoader, /) -> FileSystem: ...

class FileVisitOption(java.lang.Enum[FileVisitOption]):
    FOLLOW_LINKS: typing.ClassVar[FileVisitOption] = ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> FileVisitOption: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[FileVisitOption]: ...

class FileVisitResult(java.lang.Enum[FileVisitResult]):
    CONTINUE: typing.ClassVar[FileVisitResult] = ...
    SKIP_SIBLINGS: typing.ClassVar[FileVisitResult] = ...
    SKIP_SUBTREE: typing.ClassVar[FileVisitResult] = ...
    TERMINATE: typing.ClassVar[FileVisitResult] = ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> FileVisitResult: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[FileVisitResult]: ...

_FileVisitor__T = typing.TypeVar('_FileVisitor__T')  # <T>
class FileVisitor(java.lang.Object, typing.Generic[_FileVisitor__T]):
    def postVisitDirectory(self, arg1: _FileVisitor__T, arg2: java.io.IOException, /) -> FileVisitResult: ...
    def preVisitDirectory(self, arg1: _FileVisitor__T, arg2: java.nio.file.attribute.BasicFileAttributes, /) -> FileVisitResult: ...
    def visitFile(self, arg1: _FileVisitor__T, arg2: java.nio.file.attribute.BasicFileAttributes, /) -> FileVisitResult: ...
    def visitFileFailed(self, arg1: _FileVisitor__T, arg2: java.io.IOException, /) -> FileVisitResult: ...

class Files(java.lang.Object):
    @typing.overload
    @staticmethod
    def copy(source: Path, out: java.io.OutputStream, /) -> int: ...
    @typing.overload
    @staticmethod
    def copy(in_: java.io.InputStream, target: Path, /, *options: CopyOption) -> int: ...
    @typing.overload
    @staticmethod
    def copy(source: Path, target: Path, /, *options: CopyOption) -> Path: ...
    @staticmethod
    def createDirectories(dir: Path, /, *attrs: java.nio.file.attribute.FileAttribute[java.lang.Object]) -> Path: ...
    @staticmethod
    def createDirectory(dir: Path, /, *attrs: java.nio.file.attribute.FileAttribute[java.lang.Object]) -> Path: ...
    @staticmethod
    def createFile(path: Path, /, *attrs: java.nio.file.attribute.FileAttribute[java.lang.Object]) -> Path: ...
    @staticmethod
    def createLink(link: Path, existing: Path, /) -> Path: ...
    @staticmethod
    def createSymbolicLink(link: Path, target: Path, /, *attrs: java.nio.file.attribute.FileAttribute[java.lang.Object]) -> Path: ...
    @typing.overload
    @staticmethod
    def createTempDirectory(prefix: str | java.lang.String, /, *attrs: java.nio.file.attribute.FileAttribute[java.lang.Object]) -> Path: ...
    @typing.overload
    @staticmethod
    def createTempDirectory(dir: Path, prefix: str | java.lang.String, /, *attrs: java.nio.file.attribute.FileAttribute[java.lang.Object]) -> Path: ...
    @typing.overload
    @staticmethod
    def createTempFile(prefix: str | java.lang.String, suffix: str | java.lang.String, /, *attrs: java.nio.file.attribute.FileAttribute[java.lang.Object]) -> Path: ...
    @typing.overload
    @staticmethod
    def createTempFile(dir: Path, prefix: str | java.lang.String, suffix: str | java.lang.String, /, *attrs: java.nio.file.attribute.FileAttribute[java.lang.Object]) -> Path: ...
    @staticmethod
    def delete(path: Path, /) -> None: ...
    @staticmethod
    def deleteIfExists(path: Path, /) -> bool: ...
    @staticmethod
    def exists(path: Path, /, *options: LinkOption) -> bool: ...
    @staticmethod
    def find(start: Path, maxDepth: int | java.jint | java.lang.Integer, matcher: java.util.function.BiPredicate[Path, java.nio.file.attribute.BasicFileAttributes], /, *options: FileVisitOption) -> java.util.stream.Stream[Path]: ...
    @staticmethod
    def getAttribute(path: Path, attribute: str | java.lang.String, /, *options: LinkOption) -> java.lang.Object: ...
    _getFileAttributeView__V = typing.TypeVar('_getFileAttributeView__V')  # <V>
    @staticmethod
    def getFileAttributeView(path: Path, type: typing.Type[_getFileAttributeView__V], /, *options: LinkOption) -> _getFileAttributeView__V: ...
    @staticmethod
    def getFileStore(path: Path, /) -> FileStore: ...
    @staticmethod
    def getLastModifiedTime(path: Path, /, *options: LinkOption) -> java.nio.file.attribute.FileTime: ...
    @staticmethod
    def getOwner(path: Path, /, *options: LinkOption) -> java.nio.file.attribute.UserPrincipal: ...
    @staticmethod
    def getPosixFilePermissions(path: Path, /, *options: LinkOption) -> java.util.Set[java.nio.file.attribute.PosixFilePermission]: ...
    @staticmethod
    def isDirectory(path: Path, /, *options: LinkOption) -> bool: ...
    @staticmethod
    def isExecutable(path: Path, /) -> bool: ...
    @staticmethod
    def isHidden(path: Path, /) -> bool: ...
    @staticmethod
    def isReadable(path: Path, /) -> bool: ...
    @staticmethod
    def isRegularFile(path: Path, /, *options: LinkOption) -> bool: ...
    @staticmethod
    def isSameFile(path: Path, path2: Path, /) -> bool: ...
    @staticmethod
    def isSymbolicLink(path: Path, /) -> bool: ...
    @staticmethod
    def isWritable(path: Path, /) -> bool: ...
    @typing.overload
    @staticmethod
    def lines(path: Path, /) -> java.util.stream.Stream[java.lang.String]: ...
    @typing.overload
    @staticmethod
    def lines(path: Path, cs: java.nio.charset.Charset, /) -> java.util.stream.Stream[java.lang.String]: ...
    @staticmethod
    def list(dir: Path, /) -> java.util.stream.Stream[Path]: ...
    @staticmethod
    def move(source: Path, target: Path, /, *options: CopyOption) -> Path: ...
    @typing.overload
    @staticmethod
    def newBufferedReader(path: Path, /) -> java.io.BufferedReader: ...
    @typing.overload
    @staticmethod
    def newBufferedReader(path: Path, cs: java.nio.charset.Charset, /) -> java.io.BufferedReader: ...
    @typing.overload
    @staticmethod
    def newBufferedWriter(path: Path, /, *options: OpenOption) -> java.io.BufferedWriter: ...
    @typing.overload
    @staticmethod
    def newBufferedWriter(path: Path, cs: java.nio.charset.Charset, /, *options: OpenOption) -> java.io.BufferedWriter: ...
    @typing.overload
    @staticmethod
    def newByteChannel(path: Path, /, *options: OpenOption) -> java.nio.channels.SeekableByteChannel: ...
    @typing.overload
    @staticmethod
    def newByteChannel(path: Path, options: java.util.Set[OpenOption], /, *attrs: java.nio.file.attribute.FileAttribute[java.lang.Object]) -> java.nio.channels.SeekableByteChannel: ...
    @typing.overload
    @staticmethod
    def newDirectoryStream(dir: Path, /) -> DirectoryStream[Path]: ...
    @typing.overload
    @staticmethod
    def newDirectoryStream(dir: Path, glob: str | java.lang.String, /) -> DirectoryStream[Path]: ...
    @typing.overload
    @staticmethod
    def newDirectoryStream(dir: Path, filter: DirectoryStream.Filter[Path], /) -> DirectoryStream[Path]: ...
    @staticmethod
    def newInputStream(path: Path, /, *options: OpenOption) -> java.io.InputStream: ...
    @staticmethod
    def newOutputStream(path: Path, /, *options: OpenOption) -> java.io.OutputStream: ...
    @staticmethod
    def notExists(path: Path, /, *options: LinkOption) -> bool: ...
    @staticmethod
    def probeContentType(path: Path, /) -> str: ...
    @staticmethod
    def readAllBytes(path: Path, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    @staticmethod
    def readAllLines(path: Path, /) -> java.util.List[java.lang.String]: ...
    @typing.overload
    @staticmethod
    def readAllLines(path: Path, cs: java.nio.charset.Charset, /) -> java.util.List[java.lang.String]: ...
    _readAttributes_0__A = typing.TypeVar('_readAttributes_0__A')  # <A>
    @typing.overload
    @staticmethod
    def readAttributes(path: Path, type: typing.Type[_readAttributes_0__A], /, *options: LinkOption) -> _readAttributes_0__A: ...
    @typing.overload
    @staticmethod
    def readAttributes(path: Path, attributes: str | java.lang.String, /, *options: LinkOption) -> java.util.Map[java.lang.String, java.lang.Object]: ...
    @staticmethod
    def readSymbolicLink(link: Path, /) -> Path: ...
    @staticmethod
    def setAttribute(path: Path, attribute: str | java.lang.String, value: java.lang.Object | int | bool | float | str, /, *options: LinkOption) -> Path: ...
    @staticmethod
    def setLastModifiedTime(path: Path, time: java.nio.file.attribute.FileTime, /) -> Path: ...
    @staticmethod
    def setOwner(path: Path, owner: java.nio.file.attribute.UserPrincipal, /) -> Path: ...
    @staticmethod
    def setPosixFilePermissions(path: Path, perms: java.util.Set[java.nio.file.attribute.PosixFilePermission], /) -> Path: ...
    @staticmethod
    def size(path: Path, /) -> int: ...
    @typing.overload
    @staticmethod
    def walk(start: Path, /, *options: FileVisitOption) -> java.util.stream.Stream[Path]: ...
    @typing.overload
    @staticmethod
    def walk(start: Path, maxDepth: int | java.jint | java.lang.Integer, /, *options: FileVisitOption) -> java.util.stream.Stream[Path]: ...
    @typing.overload
    @staticmethod
    def walkFileTree(start: Path, visitor: FileVisitor[Path], /) -> Path: ...
    @typing.overload
    @staticmethod
    def walkFileTree(start: Path, options: java.util.Set[FileVisitOption], maxDepth: int | java.jint | java.lang.Integer, visitor: FileVisitor[Path], /) -> Path: ...
    @typing.overload
    @staticmethod
    def write(path: Path, lines: java.lang.Iterable[java.lang.CharSequence], /, *options: OpenOption) -> Path: ...
    @typing.overload
    @staticmethod
    def write(path: Path, bytes: java.chaquopy.JavaArrayJByte, /, *options: OpenOption) -> Path: ...
    @typing.overload
    @staticmethod
    def write(path: Path, lines: java.lang.Iterable[java.lang.CharSequence], cs: java.nio.charset.Charset, /, *options: OpenOption) -> Path: ...

class InvalidPathException(java.lang.IllegalArgumentException):
    @typing.overload
    def __init__(self, input: str | java.lang.String, reason: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, input: str | java.lang.String, reason: str | java.lang.String, index: int | java.jint | java.lang.Integer, /) -> None: ...
    def getIndex(self) -> int: ...
    def getInput(self) -> str: ...
    def getMessage(self) -> str: ...
    def getReason(self) -> str: ...

class LinkOption(java.lang.Enum[LinkOption], CopyOption, OpenOption):
    NOFOLLOW_LINKS: typing.ClassVar[LinkOption] = ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> LinkOption: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[LinkOption]: ...

class LinkPermission(java.security.BasicPermission):
    @typing.overload
    def __init__(self, name: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, name: str | java.lang.String, actions: str | java.lang.String, /) -> None: ...

class NoSuchFileException(FileSystemException):
    @typing.overload
    def __init__(self, file: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, file: str | java.lang.String, other: str | java.lang.String, reason: str | java.lang.String, /) -> None: ...

class NotDirectoryException(FileSystemException):
    def __init__(self, file: str | java.lang.String, /) -> None: ...

class NotLinkException(FileSystemException):
    @typing.overload
    def __init__(self, file: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, file: str | java.lang.String, other: str | java.lang.String, reason: str | java.lang.String, /) -> None: ...

class OpenOption(java.lang.Object): ...

class Path(java.lang.Comparable[Path], java.lang.Iterable[Path], Watchable):
    def compareTo(self, arg1: Path, /) -> int: ...
    @typing.overload
    def endsWith(self, arg1: str | java.lang.String, /) -> bool: ...
    @typing.overload
    def endsWith(self, arg1: Path, /) -> bool: ...
    def equals(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getFileName(self) -> Path: ...
    def getFileSystem(self) -> FileSystem: ...
    def getName(self, arg1: int | java.jint | java.lang.Integer, /) -> Path: ...
    def getNameCount(self) -> int: ...
    def getParent(self) -> Path: ...
    def getRoot(self) -> Path: ...
    def hashCode(self) -> int: ...
    def isAbsolute(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[Path]: ...
    def normalize(self) -> Path: ...
    @typing.overload
    @staticmethod
    def of(uri: java.net.URI, /) -> Path: ...
    @typing.overload
    @staticmethod
    def of(first: str | java.lang.String, /, *more: java.lang.String) -> Path: ...
    @typing.overload
    def register(self, arg1: WatchService, /, *arg2: WatchEvent.Kind[java.lang.Object]) -> WatchKey: ...
    @typing.overload
    def register(self, arg1: WatchService, arg2: java.chaquopy.JavaArray[WatchEvent.Kind[java.lang.Object]], /, *arg3: WatchEvent.Modifier) -> WatchKey: ...
    def relativize(self, arg1: Path, /) -> Path: ...
    @typing.overload
    def resolve(self, arg1: str | java.lang.String, /) -> Path: ...
    @typing.overload
    def resolve(self, arg1: Path, /) -> Path: ...
    @typing.overload
    def resolveSibling(self, arg1: str | java.lang.String, /) -> Path: ...
    @typing.overload
    def resolveSibling(self, arg1: Path, /) -> Path: ...
    @typing.overload
    def startsWith(self, arg1: str | java.lang.String, /) -> bool: ...
    @typing.overload
    def startsWith(self, arg1: Path, /) -> bool: ...
    def subpath(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, /) -> Path: ...
    def toAbsolutePath(self) -> Path: ...
    def toFile(self) -> java.io.File: ...
    def toRealPath(self, *arg1: LinkOption) -> Path: ...
    def toString(self) -> str: ...
    def toUri(self) -> java.net.URI: ...

class PathMatcher(java.lang.Object):
    def matches(self, arg1: Path, /) -> bool: ...

class Paths(java.lang.Object):
    @typing.overload
    @staticmethod
    def get(uri: java.net.URI, /) -> Path: ...
    @typing.overload
    @staticmethod
    def get(first: str | java.lang.String, /, *more: java.lang.String) -> Path: ...

class ProviderMismatchException(java.lang.IllegalArgumentException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class ProviderNotFoundException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class ReadOnlyFileSystemException(java.lang.UnsupportedOperationException):
    def __init__(self) -> None: ...

_SecureDirectoryStream__T = typing.TypeVar('_SecureDirectoryStream__T')  # <T>
class SecureDirectoryStream(DirectoryStream[_SecureDirectoryStream__T], typing.Generic[_SecureDirectoryStream__T]):
    def deleteDirectory(self, arg1: _SecureDirectoryStream__T, /) -> None: ...
    def deleteFile(self, arg1: _SecureDirectoryStream__T, /) -> None: ...
    _getFileAttributeView_0__V = typing.TypeVar('_getFileAttributeView_0__V')  # <V>
    _getFileAttributeView_1__V = typing.TypeVar('_getFileAttributeView_1__V')  # <V>
    @typing.overload
    def getFileAttributeView(self, arg1: typing.Type[_getFileAttributeView_0__V], /) -> _getFileAttributeView_0__V: ...
    @typing.overload
    def getFileAttributeView(self, arg1: _SecureDirectoryStream__T, arg2: typing.Type[_getFileAttributeView_1__V], /, *arg3: LinkOption) -> _getFileAttributeView_1__V: ...
    def move(self, arg1: _SecureDirectoryStream__T, arg2: SecureDirectoryStream[_SecureDirectoryStream__T], arg3: _SecureDirectoryStream__T, /) -> None: ...
    def newByteChannel(self, arg1: _SecureDirectoryStream__T, arg2: java.util.Set[OpenOption], /, *arg3: java.nio.file.attribute.FileAttribute[java.lang.Object]) -> java.nio.channels.SeekableByteChannel: ...
    def newDirectoryStream(self, arg1: _SecureDirectoryStream__T, /, *arg2: LinkOption) -> SecureDirectoryStream[_SecureDirectoryStream__T]: ...

_SimpleFileVisitor__T = typing.TypeVar('_SimpleFileVisitor__T')  # <T>
class SimpleFileVisitor(FileVisitor[_SimpleFileVisitor__T], typing.Generic[_SimpleFileVisitor__T]):
    def __init__(self) -> None: ...
    def postVisitDirectory(self, dir: _SimpleFileVisitor__T, exc: java.io.IOException, /) -> FileVisitResult: ...
    def preVisitDirectory(self, dir: _SimpleFileVisitor__T, attrs: java.nio.file.attribute.BasicFileAttributes, /) -> FileVisitResult: ...
    def visitFile(self, file: _SimpleFileVisitor__T, attrs: java.nio.file.attribute.BasicFileAttributes, /) -> FileVisitResult: ...
    def visitFileFailed(self, file: _SimpleFileVisitor__T, exc: java.io.IOException, /) -> FileVisitResult: ...

class StandardCopyOption(java.lang.Enum[StandardCopyOption], CopyOption):
    ATOMIC_MOVE: typing.ClassVar[StandardCopyOption] = ...
    COPY_ATTRIBUTES: typing.ClassVar[StandardCopyOption] = ...
    REPLACE_EXISTING: typing.ClassVar[StandardCopyOption] = ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> StandardCopyOption: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[StandardCopyOption]: ...

class StandardOpenOption(java.lang.Enum[StandardOpenOption], OpenOption):
    APPEND: typing.ClassVar[StandardOpenOption] = ...
    CREATE: typing.ClassVar[StandardOpenOption] = ...
    CREATE_NEW: typing.ClassVar[StandardOpenOption] = ...
    DELETE_ON_CLOSE: typing.ClassVar[StandardOpenOption] = ...
    DSYNC: typing.ClassVar[StandardOpenOption] = ...
    READ: typing.ClassVar[StandardOpenOption] = ...
    SPARSE: typing.ClassVar[StandardOpenOption] = ...
    SYNC: typing.ClassVar[StandardOpenOption] = ...
    TRUNCATE_EXISTING: typing.ClassVar[StandardOpenOption] = ...
    WRITE: typing.ClassVar[StandardOpenOption] = ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> StandardOpenOption: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[StandardOpenOption]: ...

class StandardWatchEventKinds(java.lang.Object):
    ENTRY_CREATE: typing.ClassVar[WatchEvent.Kind[Path]] = ...
    ENTRY_DELETE: typing.ClassVar[WatchEvent.Kind[Path]] = ...
    ENTRY_MODIFY: typing.ClassVar[WatchEvent.Kind[Path]] = ...
    OVERFLOW: typing.ClassVar[WatchEvent.Kind[java.lang.Object]] = ...

_WatchEvent__T = typing.TypeVar('_WatchEvent__T')  # <T>

_WatchEvent__Kind__T = typing.TypeVar('_WatchEvent__Kind__T')  # <T>
class WatchEvent(java.lang.Object, typing.Generic[_WatchEvent__T]):
    def context(self) -> _WatchEvent__T: ...
    def count(self) -> int: ...
    def kind(self) -> WatchEvent.Kind[_WatchEvent__T]: ...

    class Modifier(java.lang.Object):
        def name(self) -> str: ...
    class Kind(java.lang.Object, typing.Generic[_WatchEvent__Kind__T]):
        def name(self) -> str: ...
        def type(self) -> typing.Type[_WatchEvent__Kind__T]: ...

class WatchKey(java.lang.Object):
    def cancel(self) -> None: ...
    def isValid(self) -> bool: ...
    def pollEvents(self) -> java.util.List[WatchEvent[java.lang.Object]]: ...
    def reset(self) -> bool: ...
    def watchable(self) -> Watchable: ...

class WatchService(java.io.Closeable):
    def close(self) -> None: ...
    @typing.overload
    def poll(self) -> WatchKey: ...
    @typing.overload
    def poll(self, arg1: int | java.jlong | java.lang.Long, arg2: java.util.concurrent.TimeUnit, /) -> WatchKey: ...
    def take(self) -> WatchKey: ...

class Watchable(java.lang.Object):
    @typing.overload
    def register(self, arg1: WatchService, /, *arg2: WatchEvent.Kind[java.lang.Object]) -> WatchKey: ...
    @typing.overload
    def register(self, arg1: WatchService, arg2: java.chaquopy.JavaArray[WatchEvent.Kind[java.lang.Object]], /, *arg3: WatchEvent.Modifier) -> WatchKey: ...
