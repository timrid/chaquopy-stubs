import java
import java.chaquopy
import java.io
import java.lang
import java.time
import java.time.format
import java.time.temporal
import java.util
import typing



class AbstractChronology(Chronology):
    def __init__(self) -> None: ...
    def compareTo(self, other: Chronology, /) -> int: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def hashCode(self) -> int: ...
    def resolveDate(self, fieldValues: java.util.Map[java.time.temporal.TemporalField, java.lang.Long], resolverStyle: java.time.format.ResolverStyle, /) -> ChronoLocalDate: ...
    def toString(self) -> str: ...

class ChronoLocalDate(java.lang.Comparable[ChronoLocalDate], java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster):
    def adjustInto(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    def atTime(self, localTime: java.time.LocalTime, /) -> ChronoLocalDateTime[java.lang.Object]: ...
    def compareTo(self, other: ChronoLocalDate, /) -> int: ...
    def equals(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def format(self, formatter: java.time.format.DateTimeFormatter, /) -> str: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> ChronoLocalDate: ...
    def getChronology(self) -> Chronology: ...
    def getEra(self) -> Era: ...
    def hashCode(self) -> int: ...
    def isAfter(self, other: ChronoLocalDate, /) -> bool: ...
    def isBefore(self, other: ChronoLocalDate, /) -> bool: ...
    def isEqual(self, other: ChronoLocalDate, /) -> bool: ...
    def isLeapYear(self) -> bool: ...
    @typing.overload
    def isSupported(self, field: java.time.temporal.TemporalField, /) -> bool: ...
    @typing.overload
    def isSupported(self, unit: java.time.temporal.TemporalUnit, /) -> bool: ...
    def lengthOfMonth(self) -> int: ...
    def lengthOfYear(self) -> int: ...
    @typing.overload
    def minus(self, amount: java.time.temporal.TemporalAmount, /) -> ChronoLocalDate: ...
    @typing.overload
    def minus(self, amountToSubtract: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> ChronoLocalDate: ...
    @typing.overload
    def plus(self, amount: java.time.temporal.TemporalAmount, /) -> ChronoLocalDate: ...
    @typing.overload
    def plus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> ChronoLocalDate: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    @staticmethod
    def timeLineOrder() -> java.util.Comparator[ChronoLocalDate]: ...
    def toEpochDay(self) -> int: ...
    def toString(self) -> str: ...
    @typing.overload
    def until(self, arg1: ChronoLocalDate, /) -> ChronoPeriod: ...
    @typing.overload
    def until(self, arg1: java.time.temporal.Temporal, arg2: java.time.temporal.TemporalUnit, /) -> int: ...
    @typing.overload
    def with_(self, adjuster: java.time.temporal.TemporalAdjuster, /) -> ChronoLocalDate: ...
    @typing.overload
    def with_(self, field: java.time.temporal.TemporalField, newValue: int | java.jlong | java.lang.Long, /) -> ChronoLocalDate: ...

_ChronoLocalDateTime__D = typing.TypeVar('_ChronoLocalDateTime__D')  # <D>
class ChronoLocalDateTime(java.lang.Comparable[ChronoLocalDateTime[java.lang.Object]], java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, typing.Generic[_ChronoLocalDateTime__D]):
    def adjustInto(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    def atZone(self, arg1: java.time.ZoneId, /) -> ChronoZonedDateTime[_ChronoLocalDateTime__D]: ...
    def compareTo(self, other: ChronoLocalDateTime[java.lang.Object], /) -> int: ...
    def equals(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def format(self, formatter: java.time.format.DateTimeFormatter, /) -> str: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> ChronoLocalDateTime[java.lang.Object]: ...
    def getChronology(self) -> Chronology: ...
    def hashCode(self) -> int: ...
    def isAfter(self, other: ChronoLocalDateTime[java.lang.Object], /) -> bool: ...
    def isBefore(self, other: ChronoLocalDateTime[java.lang.Object], /) -> bool: ...
    def isEqual(self, other: ChronoLocalDateTime[java.lang.Object], /) -> bool: ...
    @typing.overload
    def isSupported(self, arg1: java.time.temporal.TemporalField, /) -> bool: ...
    @typing.overload
    def isSupported(self, unit: java.time.temporal.TemporalUnit, /) -> bool: ...
    @typing.overload
    def minus(self, amount: java.time.temporal.TemporalAmount, /) -> ChronoLocalDateTime[_ChronoLocalDateTime__D]: ...
    @typing.overload
    def minus(self, amountToSubtract: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> ChronoLocalDateTime[_ChronoLocalDateTime__D]: ...
    @typing.overload
    def plus(self, amount: java.time.temporal.TemporalAmount, /) -> ChronoLocalDateTime[_ChronoLocalDateTime__D]: ...
    @typing.overload
    def plus(self, arg1: int | java.jlong | java.lang.Long, arg2: java.time.temporal.TemporalUnit, /) -> ChronoLocalDateTime[_ChronoLocalDateTime__D]: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    @staticmethod
    def timeLineOrder() -> java.util.Comparator[ChronoLocalDateTime[java.lang.Object]]: ...
    def toEpochSecond(self, offset: java.time.ZoneOffset, /) -> int: ...
    def toInstant(self, offset: java.time.ZoneOffset, /) -> java.time.Instant: ...
    def toLocalDate(self) -> _ChronoLocalDateTime__D: ...
    def toLocalTime(self) -> java.time.LocalTime: ...
    def toString(self) -> str: ...
    @typing.overload
    def with_(self, adjuster: java.time.temporal.TemporalAdjuster, /) -> ChronoLocalDateTime[_ChronoLocalDateTime__D]: ...
    @typing.overload
    def with_(self, arg1: java.time.temporal.TemporalField, arg2: int | java.jlong | java.lang.Long, /) -> ChronoLocalDateTime[_ChronoLocalDateTime__D]: ...

class ChronoPeriod(java.time.temporal.TemporalAmount):
    def addTo(self, arg1: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    @staticmethod
    def between(startDateInclusive: ChronoLocalDate, endDateExclusive: ChronoLocalDate, /) -> ChronoPeriod: ...
    def equals(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def get(self, arg1: java.time.temporal.TemporalUnit, /) -> int: ...
    def getChronology(self) -> Chronology: ...
    def getUnits(self) -> java.util.List[java.time.temporal.TemporalUnit]: ...
    def hashCode(self) -> int: ...
    def isNegative(self) -> bool: ...
    def isZero(self) -> bool: ...
    def minus(self, arg1: java.time.temporal.TemporalAmount, /) -> ChronoPeriod: ...
    def multipliedBy(self, arg1: int | java.jint | java.lang.Integer, /) -> ChronoPeriod: ...
    def negated(self) -> ChronoPeriod: ...
    def normalized(self) -> ChronoPeriod: ...
    def plus(self, arg1: java.time.temporal.TemporalAmount, /) -> ChronoPeriod: ...
    def subtractFrom(self, arg1: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    def toString(self) -> str: ...

_ChronoZonedDateTime__D = typing.TypeVar('_ChronoZonedDateTime__D')  # <D>
class ChronoZonedDateTime(java.lang.Comparable[ChronoZonedDateTime[java.lang.Object]], java.time.temporal.Temporal, typing.Generic[_ChronoZonedDateTime__D]):
    def compareTo(self, other: ChronoZonedDateTime[java.lang.Object], /) -> int: ...
    def equals(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def format(self, formatter: java.time.format.DateTimeFormatter, /) -> str: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> ChronoZonedDateTime[java.lang.Object]: ...
    def get(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getChronology(self) -> Chronology: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getOffset(self) -> java.time.ZoneOffset: ...
    def getZone(self) -> java.time.ZoneId: ...
    def hashCode(self) -> int: ...
    def isAfter(self, other: ChronoZonedDateTime[java.lang.Object], /) -> bool: ...
    def isBefore(self, other: ChronoZonedDateTime[java.lang.Object], /) -> bool: ...
    def isEqual(self, other: ChronoZonedDateTime[java.lang.Object], /) -> bool: ...
    @typing.overload
    def isSupported(self, arg1: java.time.temporal.TemporalField, /) -> bool: ...
    @typing.overload
    def isSupported(self, unit: java.time.temporal.TemporalUnit, /) -> bool: ...
    @typing.overload
    def minus(self, amount: java.time.temporal.TemporalAmount, /) -> ChronoZonedDateTime[_ChronoZonedDateTime__D]: ...
    @typing.overload
    def minus(self, amountToSubtract: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> ChronoZonedDateTime[_ChronoZonedDateTime__D]: ...
    @typing.overload
    def plus(self, amount: java.time.temporal.TemporalAmount, /) -> ChronoZonedDateTime[_ChronoZonedDateTime__D]: ...
    @typing.overload
    def plus(self, arg1: int | java.jlong | java.lang.Long, arg2: java.time.temporal.TemporalUnit, /) -> ChronoZonedDateTime[_ChronoZonedDateTime__D]: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    @staticmethod
    def timeLineOrder() -> java.util.Comparator[ChronoZonedDateTime[java.lang.Object]]: ...
    def toEpochSecond(self) -> int: ...
    def toInstant(self) -> java.time.Instant: ...
    def toLocalDate(self) -> _ChronoZonedDateTime__D: ...
    def toLocalDateTime(self) -> ChronoLocalDateTime[_ChronoZonedDateTime__D]: ...
    def toLocalTime(self) -> java.time.LocalTime: ...
    def toString(self) -> str: ...
    def withEarlierOffsetAtOverlap(self) -> ChronoZonedDateTime[_ChronoZonedDateTime__D]: ...
    def withLaterOffsetAtOverlap(self) -> ChronoZonedDateTime[_ChronoZonedDateTime__D]: ...
    def withZoneSameInstant(self, arg1: java.time.ZoneId, /) -> ChronoZonedDateTime[_ChronoZonedDateTime__D]: ...
    def withZoneSameLocal(self, arg1: java.time.ZoneId, /) -> ChronoZonedDateTime[_ChronoZonedDateTime__D]: ...
    @typing.overload
    def with_(self, adjuster: java.time.temporal.TemporalAdjuster, /) -> ChronoZonedDateTime[_ChronoZonedDateTime__D]: ...
    @typing.overload
    def with_(self, arg1: java.time.temporal.TemporalField, arg2: int | java.jlong | java.lang.Long, /) -> ChronoZonedDateTime[_ChronoZonedDateTime__D]: ...

class Chronology(java.lang.Comparable[Chronology]):
    def compareTo(self, arg1: Chronology, /) -> int: ...
    @typing.overload
    def date(self, arg1: java.time.temporal.TemporalAccessor, /) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> ChronoLocalDate: ...
    @typing.overload
    def date(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> ChronoLocalDate: ...
    def dateEpochDay(self, arg1: int | java.jlong | java.lang.Long, /) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock, /) -> ChronoLocalDate: ...
    @typing.overload
    def dateNow(self, zone: java.time.ZoneId, /) -> ChronoLocalDate: ...
    @typing.overload
    def dateYearDay(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, /) -> ChronoLocalDate: ...
    @typing.overload
    def dateYearDay(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, dayOfYear: int | java.jint | java.lang.Integer, /) -> ChronoLocalDate: ...
    @typing.overload
    def epochSecond(self, prolepticYear: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, zoneOffset: java.time.ZoneOffset, /) -> int: ...
    @typing.overload
    def epochSecond(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, zoneOffset: java.time.ZoneOffset, /) -> int: ...
    def equals(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def eraOf(self, arg1: int | java.jint | java.lang.Integer, /) -> Era: ...
    def eras(self) -> java.util.List[Era]: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> Chronology: ...
    @staticmethod
    def getAvailableChronologies() -> java.util.Set[Chronology]: ...
    def getCalendarType(self) -> str: ...
    def getDisplayName(self, style: java.time.format.TextStyle, locale: java.util.Locale, /) -> str: ...
    def getId(self) -> str: ...
    def hashCode(self) -> int: ...
    def isLeapYear(self, arg1: int | java.jlong | java.lang.Long, /) -> bool: ...
    def localDateTime(self, temporal: java.time.temporal.TemporalAccessor, /) -> ChronoLocalDateTime[ChronoLocalDate]: ...
    @staticmethod
    def of(id: str | java.lang.String, /) -> Chronology: ...
    @staticmethod
    def ofLocale(locale: java.util.Locale, /) -> Chronology: ...
    def period(self, years: int | java.jint | java.lang.Integer, months: int | java.jint | java.lang.Integer, days: int | java.jint | java.lang.Integer, /) -> ChronoPeriod: ...
    def prolepticYear(self, arg1: Era, arg2: int | java.jint | java.lang.Integer, /) -> int: ...
    def range(self, arg1: java.time.temporal.ChronoField, /) -> java.time.temporal.ValueRange: ...
    def resolveDate(self, arg1: java.util.Map[java.time.temporal.TemporalField, java.lang.Long], arg2: java.time.format.ResolverStyle, /) -> ChronoLocalDate: ...
    def toString(self) -> str: ...
    @typing.overload
    def zonedDateTime(self, temporal: java.time.temporal.TemporalAccessor, /) -> ChronoZonedDateTime[ChronoLocalDate]: ...
    @typing.overload
    def zonedDateTime(self, instant: java.time.Instant, zone: java.time.ZoneId, /) -> ChronoZonedDateTime[ChronoLocalDate]: ...

class Era(java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster):
    def adjustInto(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    def get(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getDisplayName(self, style: java.time.format.TextStyle, locale: java.util.Locale, /) -> str: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getValue(self) -> int: ...
    def isSupported(self, field: java.time.temporal.TemporalField, /) -> bool: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...

class HijrahChronology(AbstractChronology, java.io.Serializable):
    INSTANCE: typing.ClassVar[HijrahChronology] = ...
    @typing.overload
    def date(self, temporal: java.time.temporal.TemporalAccessor, /) -> HijrahDate: ...
    @typing.overload
    def date(self, prolepticYear: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> HijrahDate: ...
    @typing.overload
    def date(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> HijrahDate: ...
    def dateEpochDay(self, epochDay: int | java.jlong | java.lang.Long, /) -> HijrahDate: ...
    @typing.overload
    def dateNow(self) -> HijrahDate: ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock, /) -> HijrahDate: ...
    @typing.overload
    def dateNow(self, zone: java.time.ZoneId, /) -> HijrahDate: ...
    @typing.overload
    def dateYearDay(self, prolepticYear: int | java.jint | java.lang.Integer, dayOfYear: int | java.jint | java.lang.Integer, /) -> HijrahDate: ...
    @typing.overload
    def dateYearDay(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, dayOfYear: int | java.jint | java.lang.Integer, /) -> HijrahDate: ...
    def eraOf(self, eraValue: int | java.jint | java.lang.Integer, /) -> HijrahEra: ...
    def eras(self) -> java.util.List[Era]: ...
    def getCalendarType(self) -> str: ...
    def getId(self) -> str: ...
    def isLeapYear(self, prolepticYear: int | java.jlong | java.lang.Long, /) -> bool: ...
    def localDateTime(self, temporal: java.time.temporal.TemporalAccessor, /) -> ChronoLocalDateTime[HijrahDate]: ...
    def prolepticYear(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, /) -> int: ...
    def range(self, field: java.time.temporal.ChronoField, /) -> java.time.temporal.ValueRange: ...
    def resolveDate(self, fieldValues: java.util.Map[java.time.temporal.TemporalField, java.lang.Long], resolverStyle: java.time.format.ResolverStyle, /) -> HijrahDate: ...
    @typing.overload
    def zonedDateTime(self, temporal: java.time.temporal.TemporalAccessor, /) -> ChronoZonedDateTime[HijrahDate]: ...
    @typing.overload
    def zonedDateTime(self, instant: java.time.Instant, zone: java.time.ZoneId, /) -> ChronoZonedDateTime[HijrahDate]: ...

class HijrahDate(ChronoLocalDate, java.io.Serializable, java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster):
    def atTime(self, localTime: java.time.LocalTime, /) -> ChronoLocalDateTime[HijrahDate]: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> HijrahDate: ...
    def getChronology(self) -> HijrahChronology: ...
    def getEra(self) -> HijrahEra: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def hashCode(self) -> int: ...
    def isLeapYear(self) -> bool: ...
    def lengthOfMonth(self) -> int: ...
    def lengthOfYear(self) -> int: ...
    @typing.overload
    def minus(self, amount: java.time.temporal.TemporalAmount, /) -> HijrahDate: ...
    @typing.overload
    def minus(self, amountToSubtract: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> HijrahDate: ...
    @typing.overload
    @staticmethod
    def now() -> HijrahDate: ...
    @typing.overload
    @staticmethod
    def now(clock: java.time.Clock, /) -> HijrahDate: ...
    @typing.overload
    @staticmethod
    def now(zone: java.time.ZoneId, /) -> HijrahDate: ...
    @staticmethod
    def of(prolepticYear: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> HijrahDate: ...
    @typing.overload
    def plus(self, amount: java.time.temporal.TemporalAmount, /) -> HijrahDate: ...
    @typing.overload
    def plus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> HijrahDate: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    def toEpochDay(self) -> int: ...
    def toString(self) -> str: ...
    @typing.overload
    def until(self, endDate: ChronoLocalDate, /) -> ChronoPeriod: ...
    @typing.overload
    def until(self, endExclusive: java.time.temporal.Temporal, unit: java.time.temporal.TemporalUnit, /) -> int: ...
    def withVariant(self, chronology: HijrahChronology, /) -> HijrahDate: ...
    @typing.overload
    def with_(self, adjuster: java.time.temporal.TemporalAdjuster, /) -> HijrahDate: ...
    @typing.overload
    def with_(self, field: java.time.temporal.TemporalField, newValue: int | java.jlong | java.lang.Long, /) -> HijrahDate: ...

class HijrahEra(java.lang.Enum[HijrahEra], Era):
    AH: typing.ClassVar[HijrahEra] = ...
    def getDisplayName(self, style: java.time.format.TextStyle, locale: java.util.Locale, /) -> str: ...
    def getValue(self) -> int: ...
    @staticmethod
    def of(hijrahEra: int | java.jint | java.lang.Integer, /) -> HijrahEra: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> HijrahEra: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[HijrahEra]: ...

class IsoChronology(AbstractChronology, java.io.Serializable):
    INSTANCE: typing.ClassVar[IsoChronology] = ...
    @typing.overload
    def date(self, temporal: java.time.temporal.TemporalAccessor, /) -> java.time.LocalDate: ...
    @typing.overload
    def date(self, prolepticYear: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> java.time.LocalDate: ...
    @typing.overload
    def date(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> java.time.LocalDate: ...
    def dateEpochDay(self, epochDay: int | java.jlong | java.lang.Long, /) -> java.time.LocalDate: ...
    @typing.overload
    def dateNow(self) -> java.time.LocalDate: ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock, /) -> java.time.LocalDate: ...
    @typing.overload
    def dateNow(self, zone: java.time.ZoneId, /) -> java.time.LocalDate: ...
    @typing.overload
    def dateYearDay(self, prolepticYear: int | java.jint | java.lang.Integer, dayOfYear: int | java.jint | java.lang.Integer, /) -> java.time.LocalDate: ...
    @typing.overload
    def dateYearDay(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, dayOfYear: int | java.jint | java.lang.Integer, /) -> java.time.LocalDate: ...
    def epochSecond(self, prolepticYear: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, zoneOffset: java.time.ZoneOffset, /) -> int: ...
    def eraOf(self, eraValue: int | java.jint | java.lang.Integer, /) -> IsoEra: ...
    def eras(self) -> java.util.List[Era]: ...
    def getCalendarType(self) -> str: ...
    def getId(self) -> str: ...
    def isLeapYear(self, prolepticYear: int | java.jlong | java.lang.Long, /) -> bool: ...
    def localDateTime(self, temporal: java.time.temporal.TemporalAccessor, /) -> java.time.LocalDateTime: ...
    def period(self, years: int | java.jint | java.lang.Integer, months: int | java.jint | java.lang.Integer, days: int | java.jint | java.lang.Integer, /) -> java.time.Period: ...
    def prolepticYear(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, /) -> int: ...
    def range(self, field: java.time.temporal.ChronoField, /) -> java.time.temporal.ValueRange: ...
    def resolveDate(self, fieldValues: java.util.Map[java.time.temporal.TemporalField, java.lang.Long], resolverStyle: java.time.format.ResolverStyle, /) -> java.time.LocalDate: ...
    @typing.overload
    def zonedDateTime(self, temporal: java.time.temporal.TemporalAccessor, /) -> java.time.ZonedDateTime: ...
    @typing.overload
    def zonedDateTime(self, instant: java.time.Instant, zone: java.time.ZoneId, /) -> java.time.ZonedDateTime: ...

class IsoEra(java.lang.Enum[IsoEra], Era):
    BCE: typing.ClassVar[IsoEra] = ...
    CE: typing.ClassVar[IsoEra] = ...
    def getValue(self) -> int: ...
    @staticmethod
    def of(isoEra: int | java.jint | java.lang.Integer, /) -> IsoEra: ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> IsoEra: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[IsoEra]: ...

class JapaneseChronology(AbstractChronology, java.io.Serializable):
    INSTANCE: typing.ClassVar[JapaneseChronology] = ...
    @typing.overload
    def date(self, temporal: java.time.temporal.TemporalAccessor, /) -> JapaneseDate: ...
    @typing.overload
    def date(self, prolepticYear: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> JapaneseDate: ...
    @typing.overload
    def date(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> JapaneseDate: ...
    def dateEpochDay(self, epochDay: int | java.jlong | java.lang.Long, /) -> JapaneseDate: ...
    @typing.overload
    def dateNow(self) -> JapaneseDate: ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock, /) -> JapaneseDate: ...
    @typing.overload
    def dateNow(self, zone: java.time.ZoneId, /) -> JapaneseDate: ...
    @typing.overload
    def dateYearDay(self, prolepticYear: int | java.jint | java.lang.Integer, dayOfYear: int | java.jint | java.lang.Integer, /) -> JapaneseDate: ...
    @typing.overload
    def dateYearDay(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, dayOfYear: int | java.jint | java.lang.Integer, /) -> JapaneseDate: ...
    def eraOf(self, eraValue: int | java.jint | java.lang.Integer, /) -> JapaneseEra: ...
    def eras(self) -> java.util.List[Era]: ...
    def getCalendarType(self) -> str: ...
    def getId(self) -> str: ...
    def isLeapYear(self, prolepticYear: int | java.jlong | java.lang.Long, /) -> bool: ...
    def localDateTime(self, temporal: java.time.temporal.TemporalAccessor, /) -> ChronoLocalDateTime[JapaneseDate]: ...
    def prolepticYear(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, /) -> int: ...
    def range(self, field: java.time.temporal.ChronoField, /) -> java.time.temporal.ValueRange: ...
    def resolveDate(self, fieldValues: java.util.Map[java.time.temporal.TemporalField, java.lang.Long], resolverStyle: java.time.format.ResolverStyle, /) -> JapaneseDate: ...
    @typing.overload
    def zonedDateTime(self, temporal: java.time.temporal.TemporalAccessor, /) -> ChronoZonedDateTime[JapaneseDate]: ...
    @typing.overload
    def zonedDateTime(self, instant: java.time.Instant, zone: java.time.ZoneId, /) -> ChronoZonedDateTime[JapaneseDate]: ...

class JapaneseDate(ChronoLocalDate, java.io.Serializable, java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster):
    def atTime(self, localTime: java.time.LocalTime, /) -> ChronoLocalDateTime[JapaneseDate]: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> JapaneseDate: ...
    def getChronology(self) -> JapaneseChronology: ...
    def getEra(self) -> JapaneseEra: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def hashCode(self) -> int: ...
    def isSupported(self, field: java.time.temporal.TemporalField, /) -> bool: ...
    def lengthOfMonth(self) -> int: ...
    def lengthOfYear(self) -> int: ...
    @typing.overload
    def minus(self, amount: java.time.temporal.TemporalAmount, /) -> JapaneseDate: ...
    @typing.overload
    def minus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> JapaneseDate: ...
    @typing.overload
    @staticmethod
    def now() -> JapaneseDate: ...
    @typing.overload
    @staticmethod
    def now(clock: java.time.Clock, /) -> JapaneseDate: ...
    @typing.overload
    @staticmethod
    def now(zone: java.time.ZoneId, /) -> JapaneseDate: ...
    @typing.overload
    @staticmethod
    def of(prolepticYear: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> JapaneseDate: ...
    @typing.overload
    @staticmethod
    def of(era: JapaneseEra, yearOfEra: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> JapaneseDate: ...
    @typing.overload
    def plus(self, amount: java.time.temporal.TemporalAmount, /) -> JapaneseDate: ...
    @typing.overload
    def plus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> JapaneseDate: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    def toEpochDay(self) -> int: ...
    def toString(self) -> str: ...
    @typing.overload
    def until(self, endDate: ChronoLocalDate, /) -> ChronoPeriod: ...
    @typing.overload
    def until(self, endExclusive: java.time.temporal.Temporal, unit: java.time.temporal.TemporalUnit, /) -> int: ...
    @typing.overload
    def with_(self, adjuster: java.time.temporal.TemporalAdjuster, /) -> JapaneseDate: ...
    @typing.overload
    def with_(self, field: java.time.temporal.TemporalField, newValue: int | java.jlong | java.lang.Long, /) -> JapaneseDate: ...

class JapaneseEra(Era, java.io.Serializable):
    HEISEI: typing.ClassVar[JapaneseEra] = ...
    MEIJI: typing.ClassVar[JapaneseEra] = ...
    REIWA: typing.ClassVar[JapaneseEra] = ...
    SHOWA: typing.ClassVar[JapaneseEra] = ...
    TAISHO: typing.ClassVar[JapaneseEra] = ...
    def getDisplayName(self, style: java.time.format.TextStyle, locale: java.util.Locale, /) -> str: ...
    def getValue(self) -> int: ...
    @staticmethod
    def of(japaneseEra: int | java.jint | java.lang.Integer, /) -> JapaneseEra: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    def toString(self) -> str: ...
    @staticmethod
    def valueOf(japaneseEra: str | java.lang.String, /) -> JapaneseEra: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[JapaneseEra]: ...

class MinguoChronology(AbstractChronology, java.io.Serializable):
    INSTANCE: typing.ClassVar[MinguoChronology] = ...
    @typing.overload
    def date(self, temporal: java.time.temporal.TemporalAccessor, /) -> MinguoDate: ...
    @typing.overload
    def date(self, prolepticYear: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> MinguoDate: ...
    @typing.overload
    def date(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> MinguoDate: ...
    def dateEpochDay(self, epochDay: int | java.jlong | java.lang.Long, /) -> MinguoDate: ...
    @typing.overload
    def dateNow(self) -> MinguoDate: ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock, /) -> MinguoDate: ...
    @typing.overload
    def dateNow(self, zone: java.time.ZoneId, /) -> MinguoDate: ...
    @typing.overload
    def dateYearDay(self, prolepticYear: int | java.jint | java.lang.Integer, dayOfYear: int | java.jint | java.lang.Integer, /) -> MinguoDate: ...
    @typing.overload
    def dateYearDay(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, dayOfYear: int | java.jint | java.lang.Integer, /) -> MinguoDate: ...
    def eraOf(self, eraValue: int | java.jint | java.lang.Integer, /) -> MinguoEra: ...
    def eras(self) -> java.util.List[Era]: ...
    def getCalendarType(self) -> str: ...
    def getId(self) -> str: ...
    def isLeapYear(self, prolepticYear: int | java.jlong | java.lang.Long, /) -> bool: ...
    def localDateTime(self, temporal: java.time.temporal.TemporalAccessor, /) -> ChronoLocalDateTime[MinguoDate]: ...
    def prolepticYear(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, /) -> int: ...
    def range(self, field: java.time.temporal.ChronoField, /) -> java.time.temporal.ValueRange: ...
    def resolveDate(self, fieldValues: java.util.Map[java.time.temporal.TemporalField, java.lang.Long], resolverStyle: java.time.format.ResolverStyle, /) -> MinguoDate: ...
    @typing.overload
    def zonedDateTime(self, temporal: java.time.temporal.TemporalAccessor, /) -> ChronoZonedDateTime[MinguoDate]: ...
    @typing.overload
    def zonedDateTime(self, instant: java.time.Instant, zone: java.time.ZoneId, /) -> ChronoZonedDateTime[MinguoDate]: ...

class MinguoDate(ChronoLocalDate, java.io.Serializable, java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster):
    def atTime(self, localTime: java.time.LocalTime, /) -> ChronoLocalDateTime[MinguoDate]: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> MinguoDate: ...
    def getChronology(self) -> MinguoChronology: ...
    def getEra(self) -> MinguoEra: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def hashCode(self) -> int: ...
    def lengthOfMonth(self) -> int: ...
    @typing.overload
    def minus(self, amount: java.time.temporal.TemporalAmount, /) -> MinguoDate: ...
    @typing.overload
    def minus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> MinguoDate: ...
    @typing.overload
    @staticmethod
    def now() -> MinguoDate: ...
    @typing.overload
    @staticmethod
    def now(clock: java.time.Clock, /) -> MinguoDate: ...
    @typing.overload
    @staticmethod
    def now(zone: java.time.ZoneId, /) -> MinguoDate: ...
    @staticmethod
    def of(prolepticYear: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> MinguoDate: ...
    @typing.overload
    def plus(self, amount: java.time.temporal.TemporalAmount, /) -> MinguoDate: ...
    @typing.overload
    def plus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> MinguoDate: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    def toEpochDay(self) -> int: ...
    def toString(self) -> str: ...
    @typing.overload
    def until(self, endDate: ChronoLocalDate, /) -> ChronoPeriod: ...
    @typing.overload
    def until(self, endExclusive: java.time.temporal.Temporal, unit: java.time.temporal.TemporalUnit, /) -> int: ...
    @typing.overload
    def with_(self, adjuster: java.time.temporal.TemporalAdjuster, /) -> MinguoDate: ...
    @typing.overload
    def with_(self, field: java.time.temporal.TemporalField, newValue: int | java.jlong | java.lang.Long, /) -> MinguoDate: ...

class MinguoEra(java.lang.Enum[MinguoEra], Era):
    BEFORE_ROC: typing.ClassVar[MinguoEra] = ...
    ROC: typing.ClassVar[MinguoEra] = ...
    def getDisplayName(self, style: java.time.format.TextStyle, locale: java.util.Locale, /) -> str: ...
    def getValue(self) -> int: ...
    @staticmethod
    def of(minguoEra: int | java.jint | java.lang.Integer, /) -> MinguoEra: ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> MinguoEra: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[MinguoEra]: ...

class ThaiBuddhistChronology(AbstractChronology, java.io.Serializable):
    INSTANCE: typing.ClassVar[ThaiBuddhistChronology] = ...
    @typing.overload
    def date(self, temporal: java.time.temporal.TemporalAccessor, /) -> ThaiBuddhistDate: ...
    @typing.overload
    def date(self, prolepticYear: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> ThaiBuddhistDate: ...
    @typing.overload
    def date(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> ThaiBuddhistDate: ...
    def dateEpochDay(self, epochDay: int | java.jlong | java.lang.Long, /) -> ThaiBuddhistDate: ...
    @typing.overload
    def dateNow(self) -> ThaiBuddhistDate: ...
    @typing.overload
    def dateNow(self, clock: java.time.Clock, /) -> ThaiBuddhistDate: ...
    @typing.overload
    def dateNow(self, zone: java.time.ZoneId, /) -> ThaiBuddhistDate: ...
    @typing.overload
    def dateYearDay(self, prolepticYear: int | java.jint | java.lang.Integer, dayOfYear: int | java.jint | java.lang.Integer, /) -> ThaiBuddhistDate: ...
    @typing.overload
    def dateYearDay(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, dayOfYear: int | java.jint | java.lang.Integer, /) -> ThaiBuddhistDate: ...
    def eraOf(self, eraValue: int | java.jint | java.lang.Integer, /) -> ThaiBuddhistEra: ...
    def eras(self) -> java.util.List[Era]: ...
    def getCalendarType(self) -> str: ...
    def getId(self) -> str: ...
    def isLeapYear(self, prolepticYear: int | java.jlong | java.lang.Long, /) -> bool: ...
    def localDateTime(self, temporal: java.time.temporal.TemporalAccessor, /) -> ChronoLocalDateTime[ThaiBuddhistDate]: ...
    def prolepticYear(self, era: Era, yearOfEra: int | java.jint | java.lang.Integer, /) -> int: ...
    def range(self, field: java.time.temporal.ChronoField, /) -> java.time.temporal.ValueRange: ...
    def resolveDate(self, fieldValues: java.util.Map[java.time.temporal.TemporalField, java.lang.Long], resolverStyle: java.time.format.ResolverStyle, /) -> ThaiBuddhistDate: ...
    @typing.overload
    def zonedDateTime(self, temporal: java.time.temporal.TemporalAccessor, /) -> ChronoZonedDateTime[ThaiBuddhistDate]: ...
    @typing.overload
    def zonedDateTime(self, instant: java.time.Instant, zone: java.time.ZoneId, /) -> ChronoZonedDateTime[ThaiBuddhistDate]: ...

class ThaiBuddhistDate(ChronoLocalDate, java.io.Serializable, java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster):
    def atTime(self, localTime: java.time.LocalTime, /) -> ChronoLocalDateTime[ThaiBuddhistDate]: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> ThaiBuddhistDate: ...
    def getChronology(self) -> ThaiBuddhistChronology: ...
    def getEra(self) -> ThaiBuddhistEra: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def hashCode(self) -> int: ...
    def lengthOfMonth(self) -> int: ...
    @typing.overload
    def minus(self, amount: java.time.temporal.TemporalAmount, /) -> ThaiBuddhistDate: ...
    @typing.overload
    def minus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> ThaiBuddhistDate: ...
    @typing.overload
    @staticmethod
    def now() -> ThaiBuddhistDate: ...
    @typing.overload
    @staticmethod
    def now(clock: java.time.Clock, /) -> ThaiBuddhistDate: ...
    @typing.overload
    @staticmethod
    def now(zone: java.time.ZoneId, /) -> ThaiBuddhistDate: ...
    @staticmethod
    def of(prolepticYear: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> ThaiBuddhistDate: ...
    @typing.overload
    def plus(self, amount: java.time.temporal.TemporalAmount, /) -> ThaiBuddhistDate: ...
    @typing.overload
    def plus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> ThaiBuddhistDate: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    def toEpochDay(self) -> int: ...
    def toString(self) -> str: ...
    @typing.overload
    def until(self, endDate: ChronoLocalDate, /) -> ChronoPeriod: ...
    @typing.overload
    def until(self, endExclusive: java.time.temporal.Temporal, unit: java.time.temporal.TemporalUnit, /) -> int: ...
    @typing.overload
    def with_(self, adjuster: java.time.temporal.TemporalAdjuster, /) -> ThaiBuddhistDate: ...
    @typing.overload
    def with_(self, field: java.time.temporal.TemporalField, newValue: int | java.jlong | java.lang.Long, /) -> ThaiBuddhistDate: ...

class ThaiBuddhistEra(java.lang.Enum[ThaiBuddhistEra], Era):
    BE: typing.ClassVar[ThaiBuddhistEra] = ...
    BEFORE_BE: typing.ClassVar[ThaiBuddhistEra] = ...
    def getDisplayName(self, style: java.time.format.TextStyle, locale: java.util.Locale, /) -> str: ...
    def getValue(self) -> int: ...
    @staticmethod
    def of(thaiBuddhistEra: int | java.jint | java.lang.Integer, /) -> ThaiBuddhistEra: ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> ThaiBuddhistEra: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[ThaiBuddhistEra]: ...
