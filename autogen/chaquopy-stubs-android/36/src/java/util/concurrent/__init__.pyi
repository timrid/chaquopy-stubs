import java
import java.chaquopy
import java.io
import java.lang
import java.security
import java.time
import java.time.temporal
import java.util
import java.util.function
import java.util.stream
import typing



class AbstractExecutorService(ExecutorService):
    def __init__(self) -> None: ...
    _invokeAll_0__T = typing.TypeVar('_invokeAll_0__T')  # <T>
    _invokeAll_1__T = typing.TypeVar('_invokeAll_1__T')  # <T>
    @typing.overload
    def invokeAll(self, tasks: java.util.Collection[Callable[_invokeAll_0__T]], /) -> java.util.List[Future[_invokeAll_0__T]]: ...
    @typing.overload
    def invokeAll(self, tasks: java.util.Collection[Callable[_invokeAll_1__T]], timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> java.util.List[Future[_invokeAll_1__T]]: ...
    _invokeAny_0__T = typing.TypeVar('_invokeAny_0__T')  # <T>
    _invokeAny_1__T = typing.TypeVar('_invokeAny_1__T')  # <T>
    @typing.overload
    def invokeAny(self, tasks: java.util.Collection[Callable[_invokeAny_0__T]], /) -> _invokeAny_0__T: ...
    @typing.overload
    def invokeAny(self, tasks: java.util.Collection[Callable[_invokeAny_1__T]], timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> _invokeAny_1__T: ...
    _newTaskFor_0__T = typing.TypeVar('_newTaskFor_0__T')  # <T>
    _newTaskFor_1__T = typing.TypeVar('_newTaskFor_1__T')  # <T>
    @typing.overload
    def newTaskFor(self, callable: Callable[_newTaskFor_0__T], /) -> RunnableFuture[_newTaskFor_0__T]: ...
    @typing.overload
    def newTaskFor(self, runnable: java.lang.Runnable, value: _newTaskFor_1__T, /) -> RunnableFuture[_newTaskFor_1__T]: ...
    _submit_1__T = typing.TypeVar('_submit_1__T')  # <T>
    _submit_2__T = typing.TypeVar('_submit_2__T')  # <T>
    @typing.overload
    def submit(self, task: java.lang.Runnable, /) -> Future[java.lang.Object]: ...
    @typing.overload
    def submit(self, task: Callable[_submit_1__T], /) -> Future[_submit_1__T]: ...
    @typing.overload
    def submit(self, task: java.lang.Runnable, result: _submit_2__T, /) -> Future[_submit_2__T]: ...

_ArrayBlockingQueue__E = typing.TypeVar('_ArrayBlockingQueue__E')  # <E>
class ArrayBlockingQueue(java.util.AbstractQueue[_ArrayBlockingQueue__E], BlockingQueue[_ArrayBlockingQueue__E], java.io.Serializable, typing.Generic[_ArrayBlockingQueue__E]):
    @typing.overload
    def __init__(self, capacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, capacity: int | java.jint | java.lang.Integer, fair: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def __init__(self, capacity: int | java.jint | java.lang.Integer, fair: bool | java.jboolean | java.lang.Boolean, c: java.util.Collection[_ArrayBlockingQueue__E], /) -> None: ...
    def add(self, e: _ArrayBlockingQueue__E, /) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def drainTo(self, c: java.util.Collection[_ArrayBlockingQueue__E], /) -> int: ...
    @typing.overload
    def drainTo(self, c: java.util.Collection[_ArrayBlockingQueue__E], maxElements: int | java.jint | java.lang.Integer, /) -> int: ...
    def forEach(self, action: java.util.function.Consumer[_ArrayBlockingQueue__E], /) -> None: ...
    def iterator(self) -> java.util.Iterator[_ArrayBlockingQueue__E]: ...
    @typing.overload
    def offer(self, e: _ArrayBlockingQueue__E, /) -> bool: ...
    @typing.overload
    def offer(self, e: _ArrayBlockingQueue__E, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...
    def peek(self) -> _ArrayBlockingQueue__E | None: ...
    @typing.overload
    def poll(self) -> _ArrayBlockingQueue__E | None: ...
    @typing.overload
    def poll(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> _ArrayBlockingQueue__E | None: ...
    def put(self, e: _ArrayBlockingQueue__E, /) -> None: ...
    def remainingCapacity(self) -> int: ...
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def removeIf(self, filter: java.util.function.Predicate[_ArrayBlockingQueue__E], /) -> bool: ...
    def retainAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_ArrayBlockingQueue__E]: ...
    def take(self) -> _ArrayBlockingQueue__E: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...
    def toString(self) -> str: ...

_BlockingDeque__E = typing.TypeVar('_BlockingDeque__E')  # <E>
class BlockingDeque(BlockingQueue[_BlockingDeque__E], java.util.Deque[_BlockingDeque__E], typing.Generic[_BlockingDeque__E]):
    def add(self, arg1: _BlockingDeque__E, /) -> bool: ...
    def addFirst(self, arg1: _BlockingDeque__E, /) -> None: ...
    def addLast(self, arg1: _BlockingDeque__E, /) -> None: ...
    def contains(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def element(self) -> _BlockingDeque__E: ...
    def iterator(self) -> java.util.Iterator[_BlockingDeque__E]: ...
    @typing.overload
    def offer(self, arg1: _BlockingDeque__E, /) -> bool: ...
    @typing.overload
    def offer(self, arg1: _BlockingDeque__E, arg2: int | java.jlong | java.lang.Long, arg3: TimeUnit, /) -> bool: ...
    @typing.overload
    def offerFirst(self, arg1: _BlockingDeque__E, /) -> bool: ...
    @typing.overload
    def offerFirst(self, arg1: _BlockingDeque__E, arg2: int | java.jlong | java.lang.Long, arg3: TimeUnit, /) -> bool: ...
    @typing.overload
    def offerLast(self, arg1: _BlockingDeque__E, /) -> bool: ...
    @typing.overload
    def offerLast(self, arg1: _BlockingDeque__E, arg2: int | java.jlong | java.lang.Long, arg3: TimeUnit, /) -> bool: ...
    def peek(self) -> _BlockingDeque__E: ...
    @typing.overload
    def poll(self) -> _BlockingDeque__E: ...
    @typing.overload
    def poll(self, arg1: int | java.jlong | java.lang.Long, arg2: TimeUnit, /) -> _BlockingDeque__E: ...
    def pollFirst(self, arg1: int | java.jlong | java.lang.Long, arg2: TimeUnit, /) -> _BlockingDeque__E | None: ...
    def pollLast(self, arg1: int | java.jlong | java.lang.Long, arg2: TimeUnit, /) -> _BlockingDeque__E | None: ...
    def push(self, arg1: _BlockingDeque__E, /) -> None: ...
    def put(self, arg1: _BlockingDeque__E, /) -> None: ...
    def putFirst(self, arg1: _BlockingDeque__E, /) -> None: ...
    def putLast(self, arg1: _BlockingDeque__E, /) -> None: ...
    @typing.overload
    def remove(self) -> _BlockingDeque__E: ...
    @typing.overload
    def remove(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeFirstOccurrence(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeLastOccurrence(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def size(self) -> int: ...
    def take(self) -> _BlockingDeque__E: ...
    def takeFirst(self) -> _BlockingDeque__E: ...
    def takeLast(self) -> _BlockingDeque__E: ...

_BlockingQueue__E = typing.TypeVar('_BlockingQueue__E')  # <E>
class BlockingQueue(java.util.Queue[_BlockingQueue__E], typing.Generic[_BlockingQueue__E]):
    def add(self, arg1: _BlockingQueue__E, /) -> bool: ...
    def contains(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def drainTo(self, arg1: java.util.Collection[_BlockingQueue__E], /) -> int: ...
    @typing.overload
    def drainTo(self, arg1: java.util.Collection[_BlockingQueue__E], arg2: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def offer(self, arg1: _BlockingQueue__E, /) -> bool: ...
    @typing.overload
    def offer(self, arg1: _BlockingQueue__E, arg2: int | java.jlong | java.lang.Long, arg3: TimeUnit, /) -> bool: ...
    def poll(self, arg1: int | java.jlong | java.lang.Long, arg2: TimeUnit, /) -> _BlockingQueue__E | None: ...
    def put(self, arg1: _BlockingQueue__E, /) -> None: ...
    def remainingCapacity(self) -> int: ...
    def remove(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def take(self) -> _BlockingQueue__E: ...

class BrokenBarrierException(java.lang.Exception):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...

_Callable__V = typing.TypeVar('_Callable__V')  # <V>
class Callable(java.lang.Object, typing.Generic[_Callable__V]):
    def call(self) -> _Callable__V: ...

class CancellationException(java.lang.IllegalStateException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...

_CompletableFuture__T = typing.TypeVar('_CompletableFuture__T')  # <T>
class CompletableFuture(CompletionStage[_CompletableFuture__T], Future[_CompletableFuture__T], typing.Generic[_CompletableFuture__T]):
    def __init__(self) -> None: ...
    def acceptEither(self, other: CompletionStage[_CompletableFuture__T], action: java.util.function.Consumer[_CompletableFuture__T], /) -> CompletableFuture[java.lang.Void]: ...
    @typing.overload
    def acceptEitherAsync(self, other: CompletionStage[_CompletableFuture__T], action: java.util.function.Consumer[_CompletableFuture__T], /) -> CompletableFuture[java.lang.Void]: ...
    @typing.overload
    def acceptEitherAsync(self, other: CompletionStage[_CompletableFuture__T], action: java.util.function.Consumer[_CompletableFuture__T], executor: Executor, /) -> CompletableFuture[java.lang.Void]: ...
    @staticmethod
    def allOf(*cfs: CompletableFuture[java.lang.Object]) -> CompletableFuture[java.lang.Void]: ...
    @staticmethod
    def anyOf(*cfs: CompletableFuture[java.lang.Object]) -> CompletableFuture[java.lang.Object]: ...
    _applyToEither__U = typing.TypeVar('_applyToEither__U')  # <U>
    def applyToEither(self, other: CompletionStage[_CompletableFuture__T], fn: java.util.function.Function[_CompletableFuture__T, _applyToEither__U], /) -> CompletableFuture[_applyToEither__U]: ...
    _applyToEitherAsync_0__U = typing.TypeVar('_applyToEitherAsync_0__U')  # <U>
    _applyToEitherAsync_1__U = typing.TypeVar('_applyToEitherAsync_1__U')  # <U>
    @typing.overload
    def applyToEitherAsync(self, other: CompletionStage[_CompletableFuture__T], fn: java.util.function.Function[_CompletableFuture__T, _applyToEitherAsync_0__U], /) -> CompletableFuture[_applyToEitherAsync_0__U]: ...
    @typing.overload
    def applyToEitherAsync(self, other: CompletionStage[_CompletableFuture__T], fn: java.util.function.Function[_CompletableFuture__T, _applyToEitherAsync_1__U], executor: Executor, /) -> CompletableFuture[_applyToEitherAsync_1__U]: ...
    def cancel(self, mayInterruptIfRunning: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def complete(self, value: _CompletableFuture__T, /) -> bool: ...
    @typing.overload
    def completeAsync(self, supplier: java.util.function.Supplier[_CompletableFuture__T], /) -> CompletableFuture[_CompletableFuture__T]: ...
    @typing.overload
    def completeAsync(self, supplier: java.util.function.Supplier[_CompletableFuture__T], executor: Executor, /) -> CompletableFuture[_CompletableFuture__T]: ...
    def completeExceptionally(self, ex: java.lang.Throwable, /) -> bool: ...
    def completeOnTimeout(self, value: _CompletableFuture__T, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> CompletableFuture[_CompletableFuture__T]: ...
    _completedFuture__U = typing.TypeVar('_completedFuture__U')  # <U>
    @staticmethod
    def completedFuture(value: _completedFuture__U, /) -> CompletableFuture[_completedFuture__U]: ...
    _completedStage__U = typing.TypeVar('_completedStage__U')  # <U>
    @staticmethod
    def completedStage(value: _completedStage__U, /) -> CompletionStage[_completedStage__U]: ...
    def copy(self) -> CompletableFuture[_CompletableFuture__T]: ...
    def defaultExecutor(self) -> Executor: ...
    @typing.overload
    @staticmethod
    def delayedExecutor(delay: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> Executor: ...
    @typing.overload
    @staticmethod
    def delayedExecutor(delay: int | java.jlong | java.lang.Long, unit: TimeUnit, executor: Executor, /) -> Executor: ...
    def exceptionNow(self) -> java.lang.Throwable: ...
    def exceptionally(self, fn: java.util.function.Function[java.lang.Throwable, _CompletableFuture__T], /) -> CompletableFuture[_CompletableFuture__T]: ...
    @typing.overload
    def exceptionallyAsync(self, fn: java.util.function.Function[java.lang.Throwable, _CompletableFuture__T], /) -> CompletableFuture[_CompletableFuture__T]: ...
    @typing.overload
    def exceptionallyAsync(self, fn: java.util.function.Function[java.lang.Throwable, _CompletableFuture__T], executor: Executor, /) -> CompletableFuture[_CompletableFuture__T]: ...
    def exceptionallyCompose(self, fn: java.util.function.Function[java.lang.Throwable, CompletionStage[_CompletableFuture__T]], /) -> CompletableFuture[_CompletableFuture__T]: ...
    @typing.overload
    def exceptionallyComposeAsync(self, fn: java.util.function.Function[java.lang.Throwable, CompletionStage[_CompletableFuture__T]], /) -> CompletableFuture[_CompletableFuture__T]: ...
    @typing.overload
    def exceptionallyComposeAsync(self, fn: java.util.function.Function[java.lang.Throwable, CompletionStage[_CompletableFuture__T]], executor: Executor, /) -> CompletableFuture[_CompletableFuture__T]: ...
    @staticmethod
    def failedFuture(ex: java.lang.Throwable, /) -> CompletableFuture[java.lang.Object]: ...
    @staticmethod
    def failedStage(ex: java.lang.Throwable, /) -> CompletionStage[java.lang.Object]: ...
    @typing.overload
    def get(self) -> _CompletableFuture__T: ...
    @typing.overload
    def get(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> _CompletableFuture__T: ...
    def getNow(self, valueIfAbsent: _CompletableFuture__T, /) -> _CompletableFuture__T: ...
    def getNumberOfDependents(self) -> int: ...
    _handle__U = typing.TypeVar('_handle__U')  # <U>
    def handle(self, fn: java.util.function.BiFunction[_CompletableFuture__T, java.lang.Throwable, _handle__U], /) -> CompletableFuture[_handle__U]: ...
    _handleAsync_0__U = typing.TypeVar('_handleAsync_0__U')  # <U>
    _handleAsync_1__U = typing.TypeVar('_handleAsync_1__U')  # <U>
    @typing.overload
    def handleAsync(self, fn: java.util.function.BiFunction[_CompletableFuture__T, java.lang.Throwable, _handleAsync_0__U], /) -> CompletableFuture[_handleAsync_0__U]: ...
    @typing.overload
    def handleAsync(self, fn: java.util.function.BiFunction[_CompletableFuture__T, java.lang.Throwable, _handleAsync_1__U], executor: Executor, /) -> CompletableFuture[_handleAsync_1__U]: ...
    def isCancelled(self) -> bool: ...
    def isCompletedExceptionally(self) -> bool: ...
    def isDone(self) -> bool: ...
    def join(self) -> _CompletableFuture__T: ...
    def minimalCompletionStage(self) -> CompletionStage[_CompletableFuture__T]: ...
    def newIncompleteFuture(self) -> CompletableFuture[java.lang.Object]: ...
    def obtrudeException(self, ex: java.lang.Throwable, /) -> None: ...
    def obtrudeValue(self, value: _CompletableFuture__T, /) -> None: ...
    def orTimeout(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> CompletableFuture[_CompletableFuture__T]: ...
    def resultNow(self) -> _CompletableFuture__T: ...
    def runAfterBoth(self, other: CompletionStage[java.lang.Object], action: java.lang.Runnable, /) -> CompletableFuture[java.lang.Void]: ...
    @typing.overload
    def runAfterBothAsync(self, other: CompletionStage[java.lang.Object], action: java.lang.Runnable, /) -> CompletableFuture[java.lang.Void]: ...
    @typing.overload
    def runAfterBothAsync(self, other: CompletionStage[java.lang.Object], action: java.lang.Runnable, executor: Executor, /) -> CompletableFuture[java.lang.Void]: ...
    def runAfterEither(self, other: CompletionStage[java.lang.Object], action: java.lang.Runnable, /) -> CompletableFuture[java.lang.Void]: ...
    @typing.overload
    def runAfterEitherAsync(self, other: CompletionStage[java.lang.Object], action: java.lang.Runnable, /) -> CompletableFuture[java.lang.Void]: ...
    @typing.overload
    def runAfterEitherAsync(self, other: CompletionStage[java.lang.Object], action: java.lang.Runnable, executor: Executor, /) -> CompletableFuture[java.lang.Void]: ...
    @typing.overload
    @staticmethod
    def runAsync(runnable: java.lang.Runnable, /) -> CompletableFuture[java.lang.Void]: ...
    @typing.overload
    @staticmethod
    def runAsync(runnable: java.lang.Runnable, executor: Executor, /) -> CompletableFuture[java.lang.Void]: ...
    def state(self) -> Future.State: ...
    _supplyAsync_0__U = typing.TypeVar('_supplyAsync_0__U')  # <U>
    _supplyAsync_1__U = typing.TypeVar('_supplyAsync_1__U')  # <U>
    @typing.overload
    @staticmethod
    def supplyAsync(supplier: java.util.function.Supplier[_supplyAsync_0__U], /) -> CompletableFuture[_supplyAsync_0__U]: ...
    @typing.overload
    @staticmethod
    def supplyAsync(supplier: java.util.function.Supplier[_supplyAsync_1__U], executor: Executor, /) -> CompletableFuture[_supplyAsync_1__U]: ...
    def thenAccept(self, action: java.util.function.Consumer[_CompletableFuture__T], /) -> CompletableFuture[java.lang.Void]: ...
    @typing.overload
    def thenAcceptAsync(self, action: java.util.function.Consumer[_CompletableFuture__T], /) -> CompletableFuture[java.lang.Void]: ...
    @typing.overload
    def thenAcceptAsync(self, action: java.util.function.Consumer[_CompletableFuture__T], executor: Executor, /) -> CompletableFuture[java.lang.Void]: ...
    _thenAcceptBoth__U = typing.TypeVar('_thenAcceptBoth__U')  # <U>
    def thenAcceptBoth(self, other: CompletionStage[_thenAcceptBoth__U], action: java.util.function.BiConsumer[_CompletableFuture__T, _thenAcceptBoth__U], /) -> CompletableFuture[java.lang.Void]: ...
    _thenAcceptBothAsync_0__U = typing.TypeVar('_thenAcceptBothAsync_0__U')  # <U>
    _thenAcceptBothAsync_1__U = typing.TypeVar('_thenAcceptBothAsync_1__U')  # <U>
    @typing.overload
    def thenAcceptBothAsync(self, other: CompletionStage[_thenAcceptBothAsync_0__U], action: java.util.function.BiConsumer[_CompletableFuture__T, _thenAcceptBothAsync_0__U], /) -> CompletableFuture[java.lang.Void]: ...
    @typing.overload
    def thenAcceptBothAsync(self, other: CompletionStage[_thenAcceptBothAsync_1__U], action: java.util.function.BiConsumer[_CompletableFuture__T, _thenAcceptBothAsync_1__U], executor: Executor, /) -> CompletableFuture[java.lang.Void]: ...
    _thenApply__U = typing.TypeVar('_thenApply__U')  # <U>
    def thenApply(self, fn: java.util.function.Function[_CompletableFuture__T, _thenApply__U], /) -> CompletableFuture[_thenApply__U]: ...
    _thenApplyAsync_0__U = typing.TypeVar('_thenApplyAsync_0__U')  # <U>
    _thenApplyAsync_1__U = typing.TypeVar('_thenApplyAsync_1__U')  # <U>
    @typing.overload
    def thenApplyAsync(self, fn: java.util.function.Function[_CompletableFuture__T, _thenApplyAsync_0__U], /) -> CompletableFuture[_thenApplyAsync_0__U]: ...
    @typing.overload
    def thenApplyAsync(self, fn: java.util.function.Function[_CompletableFuture__T, _thenApplyAsync_1__U], executor: Executor, /) -> CompletableFuture[_thenApplyAsync_1__U]: ...
    _thenCombine__U = typing.TypeVar('_thenCombine__U')  # <U>
    _thenCombine__V = typing.TypeVar('_thenCombine__V')  # <V>
    def thenCombine(self, other: CompletionStage[_thenCombine__U], fn: java.util.function.BiFunction[_CompletableFuture__T, _thenCombine__U, _thenCombine__V], /) -> CompletableFuture[_thenCombine__V]: ...
    _thenCombineAsync_0__U = typing.TypeVar('_thenCombineAsync_0__U')  # <U>
    _thenCombineAsync_0__V = typing.TypeVar('_thenCombineAsync_0__V')  # <V>
    _thenCombineAsync_1__U = typing.TypeVar('_thenCombineAsync_1__U')  # <U>
    _thenCombineAsync_1__V = typing.TypeVar('_thenCombineAsync_1__V')  # <V>
    @typing.overload
    def thenCombineAsync(self, other: CompletionStage[_thenCombineAsync_0__U], fn: java.util.function.BiFunction[_CompletableFuture__T, _thenCombineAsync_0__U, _thenCombineAsync_0__V], /) -> CompletableFuture[_thenCombineAsync_0__V]: ...
    @typing.overload
    def thenCombineAsync(self, other: CompletionStage[_thenCombineAsync_1__U], fn: java.util.function.BiFunction[_CompletableFuture__T, _thenCombineAsync_1__U, _thenCombineAsync_1__V], executor: Executor, /) -> CompletableFuture[_thenCombineAsync_1__V]: ...
    _thenCompose__U = typing.TypeVar('_thenCompose__U')  # <U>
    def thenCompose(self, fn: java.util.function.Function[_CompletableFuture__T, CompletionStage[_thenCompose__U]], /) -> CompletableFuture[_thenCompose__U]: ...
    _thenComposeAsync_0__U = typing.TypeVar('_thenComposeAsync_0__U')  # <U>
    _thenComposeAsync_1__U = typing.TypeVar('_thenComposeAsync_1__U')  # <U>
    @typing.overload
    def thenComposeAsync(self, fn: java.util.function.Function[_CompletableFuture__T, CompletionStage[_thenComposeAsync_0__U]], /) -> CompletableFuture[_thenComposeAsync_0__U]: ...
    @typing.overload
    def thenComposeAsync(self, fn: java.util.function.Function[_CompletableFuture__T, CompletionStage[_thenComposeAsync_1__U]], executor: Executor, /) -> CompletableFuture[_thenComposeAsync_1__U]: ...
    def thenRun(self, action: java.lang.Runnable, /) -> CompletableFuture[java.lang.Void]: ...
    @typing.overload
    def thenRunAsync(self, action: java.lang.Runnable, /) -> CompletableFuture[java.lang.Void]: ...
    @typing.overload
    def thenRunAsync(self, action: java.lang.Runnable, executor: Executor, /) -> CompletableFuture[java.lang.Void]: ...
    def toCompletableFuture(self) -> CompletableFuture[_CompletableFuture__T]: ...
    def toString(self) -> str: ...
    def whenComplete(self, action: java.util.function.BiConsumer[_CompletableFuture__T, java.lang.Throwable], /) -> CompletableFuture[_CompletableFuture__T]: ...
    @typing.overload
    def whenCompleteAsync(self, action: java.util.function.BiConsumer[_CompletableFuture__T, java.lang.Throwable], /) -> CompletableFuture[_CompletableFuture__T]: ...
    @typing.overload
    def whenCompleteAsync(self, action: java.util.function.BiConsumer[_CompletableFuture__T, java.lang.Throwable], executor: Executor, /) -> CompletableFuture[_CompletableFuture__T]: ...

    class AsynchronousCompletionTask(java.lang.Object): ...

class CompletionException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: java.lang.Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, cause: java.lang.Throwable, /) -> None: ...

_CompletionService__V = typing.TypeVar('_CompletionService__V')  # <V>
class CompletionService(java.lang.Object, typing.Generic[_CompletionService__V]):
    @typing.overload
    def poll(self) -> Future[_CompletionService__V]: ...
    @typing.overload
    def poll(self, arg1: int | java.jlong | java.lang.Long, arg2: TimeUnit, /) -> Future[_CompletionService__V]: ...
    @typing.overload
    def submit(self, arg1: Callable[_CompletionService__V], /) -> Future[_CompletionService__V]: ...
    @typing.overload
    def submit(self, arg1: java.lang.Runnable, arg2: _CompletionService__V, /) -> Future[_CompletionService__V]: ...
    def take(self) -> Future[_CompletionService__V]: ...

_CompletionStage__T = typing.TypeVar('_CompletionStage__T')  # <T>
class CompletionStage(java.lang.Object, typing.Generic[_CompletionStage__T]):
    def acceptEither(self, arg1: CompletionStage[_CompletionStage__T], arg2: java.util.function.Consumer[_CompletionStage__T], /) -> CompletionStage[java.lang.Void]: ...
    @typing.overload
    def acceptEitherAsync(self, arg1: CompletionStage[_CompletionStage__T], arg2: java.util.function.Consumer[_CompletionStage__T], /) -> CompletionStage[java.lang.Void]: ...
    @typing.overload
    def acceptEitherAsync(self, arg1: CompletionStage[_CompletionStage__T], arg2: java.util.function.Consumer[_CompletionStage__T], arg3: Executor, /) -> CompletionStage[java.lang.Void]: ...
    _applyToEither__U = typing.TypeVar('_applyToEither__U')  # <U>
    def applyToEither(self, arg1: CompletionStage[_CompletionStage__T], arg2: java.util.function.Function[_CompletionStage__T, _applyToEither__U], /) -> CompletionStage[_applyToEither__U]: ...
    _applyToEitherAsync_0__U = typing.TypeVar('_applyToEitherAsync_0__U')  # <U>
    _applyToEitherAsync_1__U = typing.TypeVar('_applyToEitherAsync_1__U')  # <U>
    @typing.overload
    def applyToEitherAsync(self, arg1: CompletionStage[_CompletionStage__T], arg2: java.util.function.Function[_CompletionStage__T, _applyToEitherAsync_0__U], /) -> CompletionStage[_applyToEitherAsync_0__U]: ...
    @typing.overload
    def applyToEitherAsync(self, arg1: CompletionStage[_CompletionStage__T], arg2: java.util.function.Function[_CompletionStage__T, _applyToEitherAsync_1__U], arg3: Executor, /) -> CompletionStage[_applyToEitherAsync_1__U]: ...
    def exceptionally(self, arg1: java.util.function.Function[java.lang.Throwable, _CompletionStage__T], /) -> CompletionStage[_CompletionStage__T]: ...
    @typing.overload
    def exceptionallyAsync(self, fn: java.util.function.Function[java.lang.Throwable, _CompletionStage__T], /) -> CompletionStage[_CompletionStage__T]: ...
    @typing.overload
    def exceptionallyAsync(self, fn: java.util.function.Function[java.lang.Throwable, _CompletionStage__T], executor: Executor, /) -> CompletionStage[_CompletionStage__T]: ...
    def exceptionallyCompose(self, fn: java.util.function.Function[java.lang.Throwable, CompletionStage[_CompletionStage__T]], /) -> CompletionStage[_CompletionStage__T]: ...
    @typing.overload
    def exceptionallyComposeAsync(self, fn: java.util.function.Function[java.lang.Throwable, CompletionStage[_CompletionStage__T]], /) -> CompletionStage[_CompletionStage__T]: ...
    @typing.overload
    def exceptionallyComposeAsync(self, fn: java.util.function.Function[java.lang.Throwable, CompletionStage[_CompletionStage__T]], executor: Executor, /) -> CompletionStage[_CompletionStage__T]: ...
    _handle__U = typing.TypeVar('_handle__U')  # <U>
    def handle(self, arg1: java.util.function.BiFunction[_CompletionStage__T, java.lang.Throwable, _handle__U], /) -> CompletionStage[_handle__U]: ...
    _handleAsync_0__U = typing.TypeVar('_handleAsync_0__U')  # <U>
    _handleAsync_1__U = typing.TypeVar('_handleAsync_1__U')  # <U>
    @typing.overload
    def handleAsync(self, arg1: java.util.function.BiFunction[_CompletionStage__T, java.lang.Throwable, _handleAsync_0__U], /) -> CompletionStage[_handleAsync_0__U]: ...
    @typing.overload
    def handleAsync(self, arg1: java.util.function.BiFunction[_CompletionStage__T, java.lang.Throwable, _handleAsync_1__U], arg2: Executor, /) -> CompletionStage[_handleAsync_1__U]: ...
    def runAfterBoth(self, arg1: CompletionStage[java.lang.Object], arg2: java.lang.Runnable, /) -> CompletionStage[java.lang.Void]: ...
    @typing.overload
    def runAfterBothAsync(self, arg1: CompletionStage[java.lang.Object], arg2: java.lang.Runnable, /) -> CompletionStage[java.lang.Void]: ...
    @typing.overload
    def runAfterBothAsync(self, arg1: CompletionStage[java.lang.Object], arg2: java.lang.Runnable, arg3: Executor, /) -> CompletionStage[java.lang.Void]: ...
    def runAfterEither(self, arg1: CompletionStage[java.lang.Object], arg2: java.lang.Runnable, /) -> CompletionStage[java.lang.Void]: ...
    @typing.overload
    def runAfterEitherAsync(self, arg1: CompletionStage[java.lang.Object], arg2: java.lang.Runnable, /) -> CompletionStage[java.lang.Void]: ...
    @typing.overload
    def runAfterEitherAsync(self, arg1: CompletionStage[java.lang.Object], arg2: java.lang.Runnable, arg3: Executor, /) -> CompletionStage[java.lang.Void]: ...
    def thenAccept(self, arg1: java.util.function.Consumer[_CompletionStage__T], /) -> CompletionStage[java.lang.Void]: ...
    @typing.overload
    def thenAcceptAsync(self, arg1: java.util.function.Consumer[_CompletionStage__T], /) -> CompletionStage[java.lang.Void]: ...
    @typing.overload
    def thenAcceptAsync(self, arg1: java.util.function.Consumer[_CompletionStage__T], arg2: Executor, /) -> CompletionStage[java.lang.Void]: ...
    _thenAcceptBoth__U = typing.TypeVar('_thenAcceptBoth__U')  # <U>
    def thenAcceptBoth(self, arg1: CompletionStage[_thenAcceptBoth__U], arg2: java.util.function.BiConsumer[_CompletionStage__T, _thenAcceptBoth__U], /) -> CompletionStage[java.lang.Void]: ...
    _thenAcceptBothAsync_0__U = typing.TypeVar('_thenAcceptBothAsync_0__U')  # <U>
    _thenAcceptBothAsync_1__U = typing.TypeVar('_thenAcceptBothAsync_1__U')  # <U>
    @typing.overload
    def thenAcceptBothAsync(self, arg1: CompletionStage[_thenAcceptBothAsync_0__U], arg2: java.util.function.BiConsumer[_CompletionStage__T, _thenAcceptBothAsync_0__U], /) -> CompletionStage[java.lang.Void]: ...
    @typing.overload
    def thenAcceptBothAsync(self, arg1: CompletionStage[_thenAcceptBothAsync_1__U], arg2: java.util.function.BiConsumer[_CompletionStage__T, _thenAcceptBothAsync_1__U], arg3: Executor, /) -> CompletionStage[java.lang.Void]: ...
    _thenApply__U = typing.TypeVar('_thenApply__U')  # <U>
    def thenApply(self, arg1: java.util.function.Function[_CompletionStage__T, _thenApply__U], /) -> CompletionStage[_thenApply__U]: ...
    _thenApplyAsync_0__U = typing.TypeVar('_thenApplyAsync_0__U')  # <U>
    _thenApplyAsync_1__U = typing.TypeVar('_thenApplyAsync_1__U')  # <U>
    @typing.overload
    def thenApplyAsync(self, arg1: java.util.function.Function[_CompletionStage__T, _thenApplyAsync_0__U], /) -> CompletionStage[_thenApplyAsync_0__U]: ...
    @typing.overload
    def thenApplyAsync(self, arg1: java.util.function.Function[_CompletionStage__T, _thenApplyAsync_1__U], arg2: Executor, /) -> CompletionStage[_thenApplyAsync_1__U]: ...
    _thenCombine__U = typing.TypeVar('_thenCombine__U')  # <U>
    _thenCombine__V = typing.TypeVar('_thenCombine__V')  # <V>
    def thenCombine(self, arg1: CompletionStage[_thenCombine__U], arg2: java.util.function.BiFunction[_CompletionStage__T, _thenCombine__U, _thenCombine__V], /) -> CompletionStage[_thenCombine__V]: ...
    _thenCombineAsync_0__U = typing.TypeVar('_thenCombineAsync_0__U')  # <U>
    _thenCombineAsync_0__V = typing.TypeVar('_thenCombineAsync_0__V')  # <V>
    _thenCombineAsync_1__U = typing.TypeVar('_thenCombineAsync_1__U')  # <U>
    _thenCombineAsync_1__V = typing.TypeVar('_thenCombineAsync_1__V')  # <V>
    @typing.overload
    def thenCombineAsync(self, arg1: CompletionStage[_thenCombineAsync_0__U], arg2: java.util.function.BiFunction[_CompletionStage__T, _thenCombineAsync_0__U, _thenCombineAsync_0__V], /) -> CompletionStage[_thenCombineAsync_0__V]: ...
    @typing.overload
    def thenCombineAsync(self, arg1: CompletionStage[_thenCombineAsync_1__U], arg2: java.util.function.BiFunction[_CompletionStage__T, _thenCombineAsync_1__U, _thenCombineAsync_1__V], arg3: Executor, /) -> CompletionStage[_thenCombineAsync_1__V]: ...
    _thenCompose__U = typing.TypeVar('_thenCompose__U')  # <U>
    def thenCompose(self, arg1: java.util.function.Function[_CompletionStage__T, CompletionStage[_thenCompose__U]], /) -> CompletionStage[_thenCompose__U]: ...
    _thenComposeAsync_0__U = typing.TypeVar('_thenComposeAsync_0__U')  # <U>
    _thenComposeAsync_1__U = typing.TypeVar('_thenComposeAsync_1__U')  # <U>
    @typing.overload
    def thenComposeAsync(self, arg1: java.util.function.Function[_CompletionStage__T, CompletionStage[_thenComposeAsync_0__U]], /) -> CompletionStage[_thenComposeAsync_0__U]: ...
    @typing.overload
    def thenComposeAsync(self, arg1: java.util.function.Function[_CompletionStage__T, CompletionStage[_thenComposeAsync_1__U]], arg2: Executor, /) -> CompletionStage[_thenComposeAsync_1__U]: ...
    def thenRun(self, arg1: java.lang.Runnable, /) -> CompletionStage[java.lang.Void]: ...
    @typing.overload
    def thenRunAsync(self, arg1: java.lang.Runnable, /) -> CompletionStage[java.lang.Void]: ...
    @typing.overload
    def thenRunAsync(self, arg1: java.lang.Runnable, arg2: Executor, /) -> CompletionStage[java.lang.Void]: ...
    def toCompletableFuture(self) -> CompletableFuture[_CompletionStage__T]: ...
    def whenComplete(self, arg1: java.util.function.BiConsumer[_CompletionStage__T, java.lang.Throwable], /) -> CompletionStage[_CompletionStage__T]: ...
    @typing.overload
    def whenCompleteAsync(self, arg1: java.util.function.BiConsumer[_CompletionStage__T, java.lang.Throwable], /) -> CompletionStage[_CompletionStage__T]: ...
    @typing.overload
    def whenCompleteAsync(self, arg1: java.util.function.BiConsumer[_CompletionStage__T, java.lang.Throwable], arg2: Executor, /) -> CompletionStage[_CompletionStage__T]: ...

_ConcurrentHashMap__K = typing.TypeVar('_ConcurrentHashMap__K')  # <K>
_ConcurrentHashMap__V = typing.TypeVar('_ConcurrentHashMap__V')  # <V>

_ConcurrentHashMap__KeySetView__K = typing.TypeVar('_ConcurrentHashMap__KeySetView__K')  # <K>
_ConcurrentHashMap__KeySetView__V = typing.TypeVar('_ConcurrentHashMap__KeySetView__V')  # <V>
class ConcurrentHashMap(java.util.AbstractMap[_ConcurrentHashMap__K, _ConcurrentHashMap__V], ConcurrentMap[_ConcurrentHashMap__K, _ConcurrentHashMap__V], java.io.Serializable, typing.Generic[_ConcurrentHashMap__K, _ConcurrentHashMap__V]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, m: java.util.Map[_ConcurrentHashMap__K, _ConcurrentHashMap__V], /) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, loadFactor: float | java.jfloat | java.lang.Float, /) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, loadFactor: float | java.jfloat | java.lang.Float, concurrencyLevel: int | java.jint | java.lang.Integer, /) -> None: ...
    def clear(self) -> None: ...
    def compute(self, key: _ConcurrentHashMap__K, remappingFunction: java.util.function.BiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V, _ConcurrentHashMap__V], /) -> _ConcurrentHashMap__V | None: ...
    def computeIfAbsent(self, key: _ConcurrentHashMap__K, mappingFunction: java.util.function.Function[_ConcurrentHashMap__K, _ConcurrentHashMap__V], /) -> _ConcurrentHashMap__V | None: ...
    def computeIfPresent(self, key: _ConcurrentHashMap__K, remappingFunction: java.util.function.BiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V, _ConcurrentHashMap__V], /) -> _ConcurrentHashMap__V | None: ...
    def contains(self, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsKey(self, key: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsValue(self, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def elements(self) -> java.util.Enumeration[_ConcurrentHashMap__V]: ...
    def entrySet(self) -> java.util.Set[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]]: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    _forEach_2__U = typing.TypeVar('_forEach_2__U')  # <U>
    @typing.overload
    def forEach(self, action: java.util.function.BiConsumer[_ConcurrentHashMap__K, _ConcurrentHashMap__V], /) -> None: ...
    @typing.overload
    def forEach(self, parallelismThreshold: int | java.jlong | java.lang.Long, action: java.util.function.BiConsumer[_ConcurrentHashMap__K, _ConcurrentHashMap__V], /) -> None: ...
    @typing.overload
    def forEach(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.BiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V, _forEach_2__U], action: java.util.function.Consumer[_forEach_2__U], /) -> None: ...
    _forEachEntry_1__U = typing.TypeVar('_forEachEntry_1__U')  # <U>
    @typing.overload
    def forEachEntry(self, parallelismThreshold: int | java.jlong | java.lang.Long, action: java.util.function.Consumer[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]], /) -> None: ...
    @typing.overload
    def forEachEntry(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.Function[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V], _forEachEntry_1__U], action: java.util.function.Consumer[_forEachEntry_1__U], /) -> None: ...
    _forEachKey_1__U = typing.TypeVar('_forEachKey_1__U')  # <U>
    @typing.overload
    def forEachKey(self, parallelismThreshold: int | java.jlong | java.lang.Long, action: java.util.function.Consumer[_ConcurrentHashMap__K], /) -> None: ...
    @typing.overload
    def forEachKey(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.Function[_ConcurrentHashMap__K, _forEachKey_1__U], action: java.util.function.Consumer[_forEachKey_1__U], /) -> None: ...
    _forEachValue_1__U = typing.TypeVar('_forEachValue_1__U')  # <U>
    @typing.overload
    def forEachValue(self, parallelismThreshold: int | java.jlong | java.lang.Long, action: java.util.function.Consumer[_ConcurrentHashMap__V], /) -> None: ...
    @typing.overload
    def forEachValue(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.Function[_ConcurrentHashMap__V, _forEachValue_1__U], action: java.util.function.Consumer[_forEachValue_1__U], /) -> None: ...
    def get(self, key: java.lang.Object | int | bool | float | str, /) -> _ConcurrentHashMap__V | None: ...
    def getOrDefault(self, key: java.lang.Object | int | bool | float | str, defaultValue: _ConcurrentHashMap__V, /) -> _ConcurrentHashMap__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    @typing.overload
    def keySet(self) -> java.util.Set[_ConcurrentHashMap__K]: ...
    @typing.overload
    def keySet(self, mappedValue: _ConcurrentHashMap__V, /) -> ConcurrentHashMap.KeySetView[_ConcurrentHashMap__K, _ConcurrentHashMap__V]: ...
    def keys(self) -> java.util.Enumeration[_ConcurrentHashMap__K]: ...
    def mappingCount(self) -> int: ...
    def merge(self, key: _ConcurrentHashMap__K, value: _ConcurrentHashMap__V, remappingFunction: java.util.function.BiFunction[_ConcurrentHashMap__V, _ConcurrentHashMap__V, _ConcurrentHashMap__V], /) -> _ConcurrentHashMap__V | None: ...
    @typing.overload
    @staticmethod
    def newKeySet() -> ConcurrentHashMap.KeySetView[java.lang.Object, java.lang.Boolean]: ...
    @typing.overload
    @staticmethod
    def newKeySet(initialCapacity: int | java.jint | java.lang.Integer, /) -> ConcurrentHashMap.KeySetView[java.lang.Object, java.lang.Boolean]: ...
    def put(self, key: _ConcurrentHashMap__K, value: _ConcurrentHashMap__V, /) -> _ConcurrentHashMap__V | None: ...
    def putAll(self, m: java.util.Map[_ConcurrentHashMap__K, _ConcurrentHashMap__V], /) -> None: ...
    def putIfAbsent(self, key: _ConcurrentHashMap__K, value: _ConcurrentHashMap__V, /) -> _ConcurrentHashMap__V | None: ...
    _reduce__U = typing.TypeVar('_reduce__U')  # <U>
    def reduce(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.BiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V, _reduce__U], reducer: java.util.function.BiFunction[_reduce__U, _reduce__U, _reduce__U], /) -> _reduce__U: ...
    _reduceEntries_1__U = typing.TypeVar('_reduceEntries_1__U')  # <U>
    @typing.overload
    def reduceEntries(self, parallelismThreshold: int | java.jlong | java.lang.Long, reducer: java.util.function.BiFunction[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V], java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V], java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]], /) -> java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]: ...
    @typing.overload
    def reduceEntries(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.Function[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V], _reduceEntries_1__U], reducer: java.util.function.BiFunction[_reduceEntries_1__U, _reduceEntries_1__U, _reduceEntries_1__U], /) -> _reduceEntries_1__U: ...
    def reduceEntriesToDouble(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.ToDoubleFunction[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]], basis: float | java.jdouble | java.lang.Double, reducer: java.util.function.DoubleBinaryOperator, /) -> float: ...
    def reduceEntriesToInt(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.ToIntFunction[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]], basis: int | java.jint | java.lang.Integer, reducer: java.util.function.IntBinaryOperator, /) -> int: ...
    def reduceEntriesToLong(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.ToLongFunction[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V]], basis: int | java.jlong | java.lang.Long, reducer: java.util.function.LongBinaryOperator, /) -> int: ...
    _reduceKeys_1__U = typing.TypeVar('_reduceKeys_1__U')  # <U>
    @typing.overload
    def reduceKeys(self, parallelismThreshold: int | java.jlong | java.lang.Long, reducer: java.util.function.BiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__K, _ConcurrentHashMap__K], /) -> _ConcurrentHashMap__K: ...
    @typing.overload
    def reduceKeys(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.Function[_ConcurrentHashMap__K, _reduceKeys_1__U], reducer: java.util.function.BiFunction[_reduceKeys_1__U, _reduceKeys_1__U, _reduceKeys_1__U], /) -> _reduceKeys_1__U: ...
    def reduceKeysToDouble(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.ToDoubleFunction[_ConcurrentHashMap__K], basis: float | java.jdouble | java.lang.Double, reducer: java.util.function.DoubleBinaryOperator, /) -> float: ...
    def reduceKeysToInt(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.ToIntFunction[_ConcurrentHashMap__K], basis: int | java.jint | java.lang.Integer, reducer: java.util.function.IntBinaryOperator, /) -> int: ...
    def reduceKeysToLong(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.ToLongFunction[_ConcurrentHashMap__K], basis: int | java.jlong | java.lang.Long, reducer: java.util.function.LongBinaryOperator, /) -> int: ...
    def reduceToDouble(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.ToDoubleBiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V], basis: float | java.jdouble | java.lang.Double, reducer: java.util.function.DoubleBinaryOperator, /) -> float: ...
    def reduceToInt(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.ToIntBiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V], basis: int | java.jint | java.lang.Integer, reducer: java.util.function.IntBinaryOperator, /) -> int: ...
    def reduceToLong(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.ToLongBiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V], basis: int | java.jlong | java.lang.Long, reducer: java.util.function.LongBinaryOperator, /) -> int: ...
    _reduceValues_1__U = typing.TypeVar('_reduceValues_1__U')  # <U>
    @typing.overload
    def reduceValues(self, parallelismThreshold: int | java.jlong | java.lang.Long, reducer: java.util.function.BiFunction[_ConcurrentHashMap__V, _ConcurrentHashMap__V, _ConcurrentHashMap__V], /) -> _ConcurrentHashMap__V: ...
    @typing.overload
    def reduceValues(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.Function[_ConcurrentHashMap__V, _reduceValues_1__U], reducer: java.util.function.BiFunction[_reduceValues_1__U, _reduceValues_1__U, _reduceValues_1__U], /) -> _reduceValues_1__U: ...
    def reduceValuesToDouble(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.ToDoubleFunction[_ConcurrentHashMap__V], basis: float | java.jdouble | java.lang.Double, reducer: java.util.function.DoubleBinaryOperator, /) -> float: ...
    def reduceValuesToInt(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.ToIntFunction[_ConcurrentHashMap__V], basis: int | java.jint | java.lang.Integer, reducer: java.util.function.IntBinaryOperator, /) -> int: ...
    def reduceValuesToLong(self, parallelismThreshold: int | java.jlong | java.lang.Long, transformer: java.util.function.ToLongFunction[_ConcurrentHashMap__V], basis: int | java.jlong | java.lang.Long, reducer: java.util.function.LongBinaryOperator, /) -> int: ...
    @typing.overload
    def remove(self, key: java.lang.Object | int | bool | float | str, /) -> _ConcurrentHashMap__V | None: ...
    @typing.overload
    def remove(self, key: java.lang.Object | int | bool | float | str, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def replace(self, key: _ConcurrentHashMap__K, value: _ConcurrentHashMap__V, /) -> _ConcurrentHashMap__V | None: ...
    @typing.overload
    def replace(self, key: _ConcurrentHashMap__K, oldValue: _ConcurrentHashMap__V, newValue: _ConcurrentHashMap__V, /) -> bool: ...
    def replaceAll(self, function: java.util.function.BiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V, _ConcurrentHashMap__V], /) -> None: ...
    _search__U = typing.TypeVar('_search__U')  # <U>
    def search(self, parallelismThreshold: int | java.jlong | java.lang.Long, searchFunction: java.util.function.BiFunction[_ConcurrentHashMap__K, _ConcurrentHashMap__V, _search__U], /) -> _search__U: ...
    _searchEntries__U = typing.TypeVar('_searchEntries__U')  # <U>
    def searchEntries(self, parallelismThreshold: int | java.jlong | java.lang.Long, searchFunction: java.util.function.Function[java.util.Map.Entry[_ConcurrentHashMap__K, _ConcurrentHashMap__V], _searchEntries__U], /) -> _searchEntries__U: ...
    _searchKeys__U = typing.TypeVar('_searchKeys__U')  # <U>
    def searchKeys(self, parallelismThreshold: int | java.jlong | java.lang.Long, searchFunction: java.util.function.Function[_ConcurrentHashMap__K, _searchKeys__U], /) -> _searchKeys__U: ...
    _searchValues__U = typing.TypeVar('_searchValues__U')  # <U>
    def searchValues(self, parallelismThreshold: int | java.jlong | java.lang.Long, searchFunction: java.util.function.Function[_ConcurrentHashMap__V, _searchValues__U], /) -> _searchValues__U: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def values(self) -> java.util.Collection[_ConcurrentHashMap__V]: ...
    class KeySetView(java.util.Collection[_ConcurrentHashMap__KeySetView__K], java.io.Serializable, java.util.Set[_ConcurrentHashMap__KeySetView__K], typing.Generic[_ConcurrentHashMap__KeySetView__K, _ConcurrentHashMap__KeySetView__V]):
        def add(self, e: _ConcurrentHashMap__KeySetView__K, /) -> bool: ...
        def addAll(self, c: java.util.Collection[_ConcurrentHashMap__KeySetView__K], /) -> bool: ...
        def clear(self) -> None: ...
        def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
        def containsAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
        def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
        def forEach(self, action: java.util.function.Consumer[_ConcurrentHashMap__KeySetView__K], /) -> None: ...
        def getMap(self) -> ConcurrentHashMap[_ConcurrentHashMap__KeySetView__K, _ConcurrentHashMap__KeySetView__V]: ...
        def getMappedValue(self) -> _ConcurrentHashMap__KeySetView__V: ...
        def hashCode(self) -> int: ...
        def isEmpty(self) -> bool: ...
        def iterator(self) -> java.util.Iterator[_ConcurrentHashMap__KeySetView__K]: ...
        def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
        def removeAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
        def retainAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
        def size(self) -> int: ...
        def spliterator(self) -> java.util.Spliterator[_ConcurrentHashMap__KeySetView__K]: ...
        _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
        @typing.overload
        def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
        @typing.overload
        def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...
        def toString(self) -> str: ...

_ConcurrentLinkedDeque__E = typing.TypeVar('_ConcurrentLinkedDeque__E')  # <E>
class ConcurrentLinkedDeque(java.util.AbstractCollection[_ConcurrentLinkedDeque__E], java.util.Deque[_ConcurrentLinkedDeque__E], java.io.Serializable, typing.Generic[_ConcurrentLinkedDeque__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, c: java.util.Collection[_ConcurrentLinkedDeque__E], /) -> None: ...
    def add(self, e: _ConcurrentLinkedDeque__E, /) -> bool: ...
    def addAll(self, c: java.util.Collection[_ConcurrentLinkedDeque__E], /) -> bool: ...
    def addFirst(self, e: _ConcurrentLinkedDeque__E, /) -> None: ...
    def addLast(self, e: _ConcurrentLinkedDeque__E, /) -> None: ...
    def clear(self) -> None: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def descendingIterator(self) -> java.util.Iterator[_ConcurrentLinkedDeque__E]: ...
    def element(self) -> _ConcurrentLinkedDeque__E: ...
    def forEach(self, action: java.util.function.Consumer[_ConcurrentLinkedDeque__E], /) -> None: ...
    def getFirst(self) -> _ConcurrentLinkedDeque__E: ...
    def getLast(self) -> _ConcurrentLinkedDeque__E: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_ConcurrentLinkedDeque__E]: ...
    def offer(self, e: _ConcurrentLinkedDeque__E, /) -> bool: ...
    def offerFirst(self, e: _ConcurrentLinkedDeque__E, /) -> bool: ...
    def offerLast(self, e: _ConcurrentLinkedDeque__E, /) -> bool: ...
    def peek(self) -> _ConcurrentLinkedDeque__E | None: ...
    def peekFirst(self) -> _ConcurrentLinkedDeque__E | None: ...
    def peekLast(self) -> _ConcurrentLinkedDeque__E | None: ...
    def poll(self) -> _ConcurrentLinkedDeque__E | None: ...
    def pollFirst(self) -> _ConcurrentLinkedDeque__E | None: ...
    def pollLast(self) -> _ConcurrentLinkedDeque__E | None: ...
    def pop(self) -> _ConcurrentLinkedDeque__E: ...
    def push(self, e: _ConcurrentLinkedDeque__E, /) -> None: ...
    @typing.overload
    def remove(self) -> _ConcurrentLinkedDeque__E: ...
    @typing.overload
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def removeFirst(self) -> _ConcurrentLinkedDeque__E: ...
    def removeFirstOccurrence(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeIf(self, filter: java.util.function.Predicate[_ConcurrentLinkedDeque__E], /) -> bool: ...
    def removeLast(self) -> _ConcurrentLinkedDeque__E: ...
    def removeLastOccurrence(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def retainAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_ConcurrentLinkedDeque__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...
    def toString(self) -> str: ...

_ConcurrentLinkedQueue__E = typing.TypeVar('_ConcurrentLinkedQueue__E')  # <E>
class ConcurrentLinkedQueue(java.util.AbstractQueue[_ConcurrentLinkedQueue__E], java.util.Queue[_ConcurrentLinkedQueue__E], java.io.Serializable, typing.Generic[_ConcurrentLinkedQueue__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, c: java.util.Collection[_ConcurrentLinkedQueue__E], /) -> None: ...
    def add(self, e: _ConcurrentLinkedQueue__E, /) -> bool: ...
    def addAll(self, c: java.util.Collection[_ConcurrentLinkedQueue__E], /) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def forEach(self, action: java.util.function.Consumer[_ConcurrentLinkedQueue__E], /) -> None: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_ConcurrentLinkedQueue__E]: ...
    def offer(self, e: _ConcurrentLinkedQueue__E, /) -> bool: ...
    def peek(self) -> _ConcurrentLinkedQueue__E | None: ...
    def poll(self) -> _ConcurrentLinkedQueue__E | None: ...
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def removeIf(self, filter: java.util.function.Predicate[_ConcurrentLinkedQueue__E], /) -> bool: ...
    def retainAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_ConcurrentLinkedQueue__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...
    def toString(self) -> str: ...

_ConcurrentMap__K = typing.TypeVar('_ConcurrentMap__K')  # <K>
_ConcurrentMap__V = typing.TypeVar('_ConcurrentMap__V')  # <V>
class ConcurrentMap(java.util.Map[_ConcurrentMap__K, _ConcurrentMap__V], typing.Generic[_ConcurrentMap__K, _ConcurrentMap__V]):
    def compute(self, key: _ConcurrentMap__K, remappingFunction: java.util.function.BiFunction[_ConcurrentMap__K, _ConcurrentMap__V, _ConcurrentMap__V], /) -> _ConcurrentMap__V | None: ...
    def computeIfAbsent(self, key: _ConcurrentMap__K, mappingFunction: java.util.function.Function[_ConcurrentMap__K, _ConcurrentMap__V], /) -> _ConcurrentMap__V | None: ...
    def computeIfPresent(self, key: _ConcurrentMap__K, remappingFunction: java.util.function.BiFunction[_ConcurrentMap__K, _ConcurrentMap__V, _ConcurrentMap__V], /) -> _ConcurrentMap__V | None: ...
    def forEach(self, action: java.util.function.BiConsumer[_ConcurrentMap__K, _ConcurrentMap__V], /) -> None: ...
    def getOrDefault(self, key: java.lang.Object | int | bool | float | str, defaultValue: _ConcurrentMap__V, /) -> _ConcurrentMap__V: ...
    def merge(self, key: _ConcurrentMap__K, value: _ConcurrentMap__V, remappingFunction: java.util.function.BiFunction[_ConcurrentMap__V, _ConcurrentMap__V, _ConcurrentMap__V], /) -> _ConcurrentMap__V | None: ...
    def putIfAbsent(self, arg1: _ConcurrentMap__K, arg2: _ConcurrentMap__V, /) -> _ConcurrentMap__V | None: ...
    def remove(self, arg1: java.lang.Object | int | bool | float | str, arg2: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def replace(self, arg1: _ConcurrentMap__K, arg2: _ConcurrentMap__V, /) -> _ConcurrentMap__V | None: ...
    @typing.overload
    def replace(self, arg1: _ConcurrentMap__K, arg2: _ConcurrentMap__V, arg3: _ConcurrentMap__V, /) -> bool: ...
    def replaceAll(self, function: java.util.function.BiFunction[_ConcurrentMap__K, _ConcurrentMap__V, _ConcurrentMap__V], /) -> None: ...

_ConcurrentNavigableMap__K = typing.TypeVar('_ConcurrentNavigableMap__K')  # <K>
_ConcurrentNavigableMap__V = typing.TypeVar('_ConcurrentNavigableMap__V')  # <V>
class ConcurrentNavigableMap(ConcurrentMap[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V], java.util.NavigableMap[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V], typing.Generic[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V]):
    def descendingKeySet(self) -> java.util.NavigableSet[_ConcurrentNavigableMap__K]: ...
    def descendingMap(self) -> ConcurrentNavigableMap[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V]: ...
    @typing.overload
    def headMap(self, arg1: _ConcurrentNavigableMap__K, /) -> ConcurrentNavigableMap[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V]: ...
    @typing.overload
    def headMap(self, arg1: _ConcurrentNavigableMap__K, arg2: bool | java.jboolean | java.lang.Boolean, /) -> ConcurrentNavigableMap[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V]: ...
    def keySet(self) -> java.util.NavigableSet[_ConcurrentNavigableMap__K]: ...
    def navigableKeySet(self) -> java.util.NavigableSet[_ConcurrentNavigableMap__K]: ...
    @typing.overload
    def subMap(self, arg1: _ConcurrentNavigableMap__K, arg2: _ConcurrentNavigableMap__K, /) -> ConcurrentNavigableMap[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V]: ...
    @typing.overload
    def subMap(self, arg1: _ConcurrentNavigableMap__K, arg2: bool | java.jboolean | java.lang.Boolean, arg3: _ConcurrentNavigableMap__K, arg4: bool | java.jboolean | java.lang.Boolean, /) -> ConcurrentNavigableMap[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V]: ...
    @typing.overload
    def tailMap(self, arg1: _ConcurrentNavigableMap__K, /) -> ConcurrentNavigableMap[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V]: ...
    @typing.overload
    def tailMap(self, arg1: _ConcurrentNavigableMap__K, arg2: bool | java.jboolean | java.lang.Boolean, /) -> ConcurrentNavigableMap[_ConcurrentNavigableMap__K, _ConcurrentNavigableMap__V]: ...

_ConcurrentSkipListMap__K = typing.TypeVar('_ConcurrentSkipListMap__K')  # <K>
_ConcurrentSkipListMap__V = typing.TypeVar('_ConcurrentSkipListMap__V')  # <V>
class ConcurrentSkipListMap(java.util.AbstractMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V], java.lang.Cloneable, ConcurrentNavigableMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V], java.io.Serializable, typing.Generic[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, comparator: java.util.Comparator[_ConcurrentSkipListMap__K], /) -> None: ...
    @typing.overload
    def __init__(self, m: java.util.Map[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V], /) -> None: ...
    @typing.overload
    def __init__(self, m: java.util.SortedMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V], /) -> None: ...
    def ceilingEntry(self, key: _ConcurrentSkipListMap__K, /) -> java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V] | None: ...
    def ceilingKey(self, key: _ConcurrentSkipListMap__K, /) -> _ConcurrentSkipListMap__K | None: ...
    def clear(self) -> None: ...
    def clone(self) -> ConcurrentSkipListMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    def comparator(self) -> java.util.Comparator[_ConcurrentSkipListMap__K]: ...
    def compute(self, key: _ConcurrentSkipListMap__K, remappingFunction: java.util.function.BiFunction[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V, _ConcurrentSkipListMap__V], /) -> _ConcurrentSkipListMap__V | None: ...
    def computeIfAbsent(self, key: _ConcurrentSkipListMap__K, mappingFunction: java.util.function.Function[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V], /) -> _ConcurrentSkipListMap__V | None: ...
    def computeIfPresent(self, key: _ConcurrentSkipListMap__K, remappingFunction: java.util.function.BiFunction[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V, _ConcurrentSkipListMap__V], /) -> _ConcurrentSkipListMap__V | None: ...
    def containsKey(self, key: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsValue(self, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def descendingKeySet(self) -> java.util.NavigableSet[_ConcurrentSkipListMap__K]: ...
    def descendingMap(self) -> ConcurrentNavigableMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    def entrySet(self) -> java.util.Set[java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]]: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def firstEntry(self) -> java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V] | None: ...
    def firstKey(self) -> _ConcurrentSkipListMap__K: ...
    def floorEntry(self, key: _ConcurrentSkipListMap__K, /) -> java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V] | None: ...
    def floorKey(self, key: _ConcurrentSkipListMap__K, /) -> _ConcurrentSkipListMap__K | None: ...
    def forEach(self, action: java.util.function.BiConsumer[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V], /) -> None: ...
    def get(self, key: java.lang.Object | int | bool | float | str, /) -> _ConcurrentSkipListMap__V | None: ...
    def getOrDefault(self, key: java.lang.Object | int | bool | float | str, defaultValue: _ConcurrentSkipListMap__V, /) -> _ConcurrentSkipListMap__V: ...
    @typing.overload
    def headMap(self, toKey: _ConcurrentSkipListMap__K, /) -> ConcurrentNavigableMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    @typing.overload
    def headMap(self, toKey: _ConcurrentSkipListMap__K, inclusive: bool | java.jboolean | java.lang.Boolean, /) -> ConcurrentNavigableMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    def higherEntry(self, key: _ConcurrentSkipListMap__K, /) -> java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V] | None: ...
    def higherKey(self, key: _ConcurrentSkipListMap__K, /) -> _ConcurrentSkipListMap__K | None: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> java.util.NavigableSet[_ConcurrentSkipListMap__K]: ...
    def lastEntry(self) -> java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V] | None: ...
    def lastKey(self) -> _ConcurrentSkipListMap__K: ...
    def lowerEntry(self, key: _ConcurrentSkipListMap__K, /) -> java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V] | None: ...
    def lowerKey(self, key: _ConcurrentSkipListMap__K, /) -> _ConcurrentSkipListMap__K | None: ...
    def merge(self, key: _ConcurrentSkipListMap__K, value: _ConcurrentSkipListMap__V, remappingFunction: java.util.function.BiFunction[_ConcurrentSkipListMap__V, _ConcurrentSkipListMap__V, _ConcurrentSkipListMap__V], /) -> _ConcurrentSkipListMap__V | None: ...
    def navigableKeySet(self) -> java.util.NavigableSet[_ConcurrentSkipListMap__K]: ...
    def pollFirstEntry(self) -> java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V] | None: ...
    def pollLastEntry(self) -> java.util.Map.Entry[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V] | None: ...
    def put(self, key: _ConcurrentSkipListMap__K, value: _ConcurrentSkipListMap__V, /) -> _ConcurrentSkipListMap__V | None: ...
    def putFirst(self, k: _ConcurrentSkipListMap__K, v: _ConcurrentSkipListMap__V, /) -> _ConcurrentSkipListMap__V: ...
    def putIfAbsent(self, key: _ConcurrentSkipListMap__K, value: _ConcurrentSkipListMap__V, /) -> _ConcurrentSkipListMap__V | None: ...
    def putLast(self, k: _ConcurrentSkipListMap__K, v: _ConcurrentSkipListMap__V, /) -> _ConcurrentSkipListMap__V: ...
    @typing.overload
    def remove(self, key: java.lang.Object | int | bool | float | str, /) -> _ConcurrentSkipListMap__V | None: ...
    @typing.overload
    def remove(self, key: java.lang.Object | int | bool | float | str, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def replace(self, key: _ConcurrentSkipListMap__K, value: _ConcurrentSkipListMap__V, /) -> _ConcurrentSkipListMap__V | None: ...
    @typing.overload
    def replace(self, key: _ConcurrentSkipListMap__K, oldValue: _ConcurrentSkipListMap__V, newValue: _ConcurrentSkipListMap__V, /) -> bool: ...
    def replaceAll(self, function: java.util.function.BiFunction[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V, _ConcurrentSkipListMap__V], /) -> None: ...
    def size(self) -> int: ...
    @typing.overload
    def subMap(self, fromKey: _ConcurrentSkipListMap__K, toKey: _ConcurrentSkipListMap__K, /) -> ConcurrentNavigableMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    @typing.overload
    def subMap(self, fromKey: _ConcurrentSkipListMap__K, fromInclusive: bool | java.jboolean | java.lang.Boolean, toKey: _ConcurrentSkipListMap__K, toInclusive: bool | java.jboolean | java.lang.Boolean, /) -> ConcurrentNavigableMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    @typing.overload
    def tailMap(self, fromKey: _ConcurrentSkipListMap__K, /) -> ConcurrentNavigableMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    @typing.overload
    def tailMap(self, fromKey: _ConcurrentSkipListMap__K, inclusive: bool | java.jboolean | java.lang.Boolean, /) -> ConcurrentNavigableMap[_ConcurrentSkipListMap__K, _ConcurrentSkipListMap__V]: ...
    def values(self) -> java.util.Collection[_ConcurrentSkipListMap__V]: ...

_ConcurrentSkipListSet__E = typing.TypeVar('_ConcurrentSkipListSet__E')  # <E>
class ConcurrentSkipListSet(java.util.AbstractSet[_ConcurrentSkipListSet__E], java.lang.Cloneable, java.util.NavigableSet[_ConcurrentSkipListSet__E], java.io.Serializable, typing.Generic[_ConcurrentSkipListSet__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, c: java.util.Collection[_ConcurrentSkipListSet__E], /) -> None: ...
    @typing.overload
    def __init__(self, comparator: java.util.Comparator[_ConcurrentSkipListSet__E], /) -> None: ...
    @typing.overload
    def __init__(self, s: java.util.SortedSet[_ConcurrentSkipListSet__E], /) -> None: ...
    def add(self, e: _ConcurrentSkipListSet__E, /) -> bool: ...
    def addFirst(self, e: _ConcurrentSkipListSet__E, /) -> None: ...
    def addLast(self, e: _ConcurrentSkipListSet__E, /) -> None: ...
    def ceiling(self, e: _ConcurrentSkipListSet__E, /) -> _ConcurrentSkipListSet__E | None: ...
    def clear(self) -> None: ...
    def clone(self) -> ConcurrentSkipListSet[_ConcurrentSkipListSet__E]: ...
    def comparator(self) -> java.util.Comparator[_ConcurrentSkipListSet__E]: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def descendingIterator(self) -> java.util.Iterator[_ConcurrentSkipListSet__E]: ...
    def descendingSet(self) -> java.util.NavigableSet[_ConcurrentSkipListSet__E]: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def first(self) -> _ConcurrentSkipListSet__E: ...
    def floor(self, e: _ConcurrentSkipListSet__E, /) -> _ConcurrentSkipListSet__E | None: ...
    @typing.overload
    def headSet(self, toElement: _ConcurrentSkipListSet__E, /) -> java.util.NavigableSet[_ConcurrentSkipListSet__E]: ...
    @typing.overload
    def headSet(self, toElement: _ConcurrentSkipListSet__E, inclusive: bool | java.jboolean | java.lang.Boolean, /) -> java.util.NavigableSet[_ConcurrentSkipListSet__E]: ...
    def higher(self, e: _ConcurrentSkipListSet__E, /) -> _ConcurrentSkipListSet__E | None: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_ConcurrentSkipListSet__E]: ...
    def last(self) -> _ConcurrentSkipListSet__E: ...
    def lower(self, e: _ConcurrentSkipListSet__E, /) -> _ConcurrentSkipListSet__E | None: ...
    def pollFirst(self) -> _ConcurrentSkipListSet__E | None: ...
    def pollLast(self) -> _ConcurrentSkipListSet__E | None: ...
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_ConcurrentSkipListSet__E]: ...
    @typing.overload
    def subSet(self, fromElement: _ConcurrentSkipListSet__E, toElement: _ConcurrentSkipListSet__E, /) -> java.util.NavigableSet[_ConcurrentSkipListSet__E]: ...
    @typing.overload
    def subSet(self, fromElement: _ConcurrentSkipListSet__E, fromInclusive: bool | java.jboolean | java.lang.Boolean, toElement: _ConcurrentSkipListSet__E, toInclusive: bool | java.jboolean | java.lang.Boolean, /) -> java.util.NavigableSet[_ConcurrentSkipListSet__E]: ...
    @typing.overload
    def tailSet(self, fromElement: _ConcurrentSkipListSet__E, /) -> java.util.NavigableSet[_ConcurrentSkipListSet__E]: ...
    @typing.overload
    def tailSet(self, fromElement: _ConcurrentSkipListSet__E, inclusive: bool | java.jboolean | java.lang.Boolean, /) -> java.util.NavigableSet[_ConcurrentSkipListSet__E]: ...

_CopyOnWriteArrayList__E = typing.TypeVar('_CopyOnWriteArrayList__E')  # <E>
class CopyOnWriteArrayList(java.lang.Cloneable, java.util.List[_CopyOnWriteArrayList__E], java.util.RandomAccess, java.io.Serializable, typing.Generic[_CopyOnWriteArrayList__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, c: java.util.Collection[_CopyOnWriteArrayList__E], /) -> None: ...
    @typing.overload
    def __init__(self, toCopyIn: java.chaquopy.JavaArray[_CopyOnWriteArrayList__E], /) -> None: ...
    @typing.overload
    def add(self, e: _CopyOnWriteArrayList__E, /) -> bool: ...
    @typing.overload
    def add(self, index: int | java.jint | java.lang.Integer, element: _CopyOnWriteArrayList__E, /) -> None: ...
    @typing.overload
    def addAll(self, c: java.util.Collection[_CopyOnWriteArrayList__E], /) -> bool: ...
    @typing.overload
    def addAll(self, index: int | java.jint | java.lang.Integer, c: java.util.Collection[_CopyOnWriteArrayList__E], /) -> bool: ...
    def addAllAbsent(self, c: java.util.Collection[_CopyOnWriteArrayList__E], /) -> int: ...
    def addFirst(self, e: _CopyOnWriteArrayList__E, /) -> None: ...
    def addIfAbsent(self, e: _CopyOnWriteArrayList__E, /) -> bool: ...
    def addLast(self, e: _CopyOnWriteArrayList__E, /) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def forEach(self, action: java.util.function.Consumer[_CopyOnWriteArrayList__E], /) -> None: ...
    def get(self, index: int | java.jint | java.lang.Integer, /) -> _CopyOnWriteArrayList__E: ...
    def getFirst(self) -> _CopyOnWriteArrayList__E: ...
    def getLast(self) -> _CopyOnWriteArrayList__E: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def indexOf(self, o: java.lang.Object | int | bool | float | str, /) -> int: ...
    @typing.overload
    def indexOf(self, e: _CopyOnWriteArrayList__E, index: int | java.jint | java.lang.Integer, /) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_CopyOnWriteArrayList__E]: ...
    @typing.overload
    def lastIndexOf(self, o: java.lang.Object | int | bool | float | str, /) -> int: ...
    @typing.overload
    def lastIndexOf(self, e: _CopyOnWriteArrayList__E, index: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def listIterator(self) -> java.util.ListIterator[_CopyOnWriteArrayList__E]: ...
    @typing.overload
    def listIterator(self, index: int | java.jint | java.lang.Integer, /) -> java.util.ListIterator[_CopyOnWriteArrayList__E]: ...
    @typing.overload
    def remove(self, index: int | java.jint | java.lang.Integer, /) -> _CopyOnWriteArrayList__E: ...
    @typing.overload
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def removeFirst(self) -> _CopyOnWriteArrayList__E: ...
    def removeIf(self, filter: java.util.function.Predicate[_CopyOnWriteArrayList__E], /) -> bool: ...
    def removeLast(self) -> _CopyOnWriteArrayList__E: ...
    def replaceAll(self, operator: java.util.function.UnaryOperator[_CopyOnWriteArrayList__E], /) -> None: ...
    def retainAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def reversed(self) -> java.util.List[_CopyOnWriteArrayList__E]: ...
    def set(self, index: int | java.jint | java.lang.Integer, element: _CopyOnWriteArrayList__E, /) -> _CopyOnWriteArrayList__E: ...
    def size(self) -> int: ...
    def sort(self, c: java.util.Comparator[_CopyOnWriteArrayList__E], /) -> None: ...
    def spliterator(self) -> java.util.Spliterator[_CopyOnWriteArrayList__E]: ...
    def subList(self, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> java.util.List[_CopyOnWriteArrayList__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...
    def toString(self) -> str: ...

_CopyOnWriteArraySet__E = typing.TypeVar('_CopyOnWriteArraySet__E')  # <E>
class CopyOnWriteArraySet(java.util.AbstractSet[_CopyOnWriteArraySet__E], java.io.Serializable, typing.Generic[_CopyOnWriteArraySet__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, c: java.util.Collection[_CopyOnWriteArraySet__E], /) -> None: ...
    def add(self, e: _CopyOnWriteArraySet__E, /) -> bool: ...
    def addAll(self, c: java.util.Collection[_CopyOnWriteArraySet__E], /) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def forEach(self, action: java.util.function.Consumer[_CopyOnWriteArraySet__E], /) -> None: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_CopyOnWriteArraySet__E]: ...
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def removeIf(self, filter: java.util.function.Predicate[_CopyOnWriteArraySet__E], /) -> bool: ...
    def retainAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_CopyOnWriteArraySet__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...

class CountDownLatch(java.lang.Object):
    def __init__(self, count: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def await_(self) -> None: ...
    @typing.overload
    def await_(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...
    def countDown(self) -> None: ...
    def getCount(self) -> int: ...
    def toString(self) -> str: ...

_CountedCompleter__T = typing.TypeVar('_CountedCompleter__T')  # <T>
class CountedCompleter(ForkJoinTask[_CountedCompleter__T], typing.Generic[_CountedCompleter__T]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, completer: CountedCompleter[java.lang.Object], /) -> None: ...
    @typing.overload
    def __init__(self, completer: CountedCompleter[java.lang.Object], initialPendingCount: int | java.jint | java.lang.Integer, /) -> None: ...
    def addToPendingCount(self, delta: int | java.jint | java.lang.Integer, /) -> None: ...
    def compareAndSetPendingCount(self, expected: int | java.jint | java.lang.Integer, count: int | java.jint | java.lang.Integer, /) -> bool: ...
    def complete(self, rawResult: _CountedCompleter__T, /) -> None: ...
    def compute(self) -> None: ...
    def decrementPendingCountUnlessZero(self) -> int: ...
    def exec_(self) -> bool: ...
    def firstComplete(self) -> CountedCompleter[java.lang.Object]: ...
    def getCompleter(self) -> CountedCompleter[java.lang.Object]: ...
    def getPendingCount(self) -> int: ...
    def getRawResult(self) -> _CountedCompleter__T: ...
    def getRoot(self) -> CountedCompleter[java.lang.Object]: ...
    def helpComplete(self, maxTasks: int | java.jint | java.lang.Integer, /) -> None: ...
    def nextComplete(self) -> CountedCompleter[java.lang.Object]: ...
    def onCompletion(self, caller: CountedCompleter[java.lang.Object], /) -> None: ...
    def onExceptionalCompletion(self, ex: java.lang.Throwable, caller: CountedCompleter[java.lang.Object], /) -> bool: ...
    def propagateCompletion(self) -> None: ...
    def quietlyCompleteRoot(self) -> None: ...
    def setPendingCount(self, count: int | java.jint | java.lang.Integer, /) -> None: ...
    def setRawResult(self, t: _CountedCompleter__T, /) -> None: ...
    def tryComplete(self) -> None: ...

class CyclicBarrier(java.lang.Object):
    @typing.overload
    def __init__(self, parties: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, parties: int | java.jint | java.lang.Integer, barrierAction: java.lang.Runnable, /) -> None: ...
    @typing.overload
    def await_(self) -> int: ...
    @typing.overload
    def await_(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> int: ...
    def getNumberWaiting(self) -> int: ...
    def getParties(self) -> int: ...
    def isBroken(self) -> bool: ...
    def reset(self) -> None: ...

_DelayQueue__E = typing.TypeVar('_DelayQueue__E')  # <E>
class DelayQueue(java.util.AbstractQueue[_DelayQueue__E], BlockingQueue[_DelayQueue__E], typing.Generic[_DelayQueue__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, c: java.util.Collection[_DelayQueue__E], /) -> None: ...
    def add(self, e: _DelayQueue__E, /) -> bool: ...
    def clear(self) -> None: ...
    @typing.overload
    def drainTo(self, c: java.util.Collection[_DelayQueue__E], /) -> int: ...
    @typing.overload
    def drainTo(self, c: java.util.Collection[_DelayQueue__E], maxElements: int | java.jint | java.lang.Integer, /) -> int: ...
    def iterator(self) -> java.util.Iterator[_DelayQueue__E]: ...
    @typing.overload
    def offer(self, e: _DelayQueue__E, /) -> bool: ...
    @typing.overload
    def offer(self, e: _DelayQueue__E, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...
    def peek(self) -> _DelayQueue__E: ...
    @typing.overload
    def poll(self) -> _DelayQueue__E: ...
    @typing.overload
    def poll(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> _DelayQueue__E: ...
    def put(self, e: _DelayQueue__E, /) -> None: ...
    def remainingCapacity(self) -> int: ...
    @typing.overload
    def remove(self) -> _DelayQueue__E: ...
    @typing.overload
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def size(self) -> int: ...
    def take(self) -> _DelayQueue__E: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...

class Delayed(java.lang.Comparable[Delayed]):
    def getDelay(self, arg1: TimeUnit, /) -> int: ...

_Exchanger__V = typing.TypeVar('_Exchanger__V')  # <V>
class Exchanger(java.lang.Object, typing.Generic[_Exchanger__V]):
    def __init__(self) -> None: ...
    @typing.overload
    def exchange(self, x: _Exchanger__V, /) -> _Exchanger__V: ...
    @typing.overload
    def exchange(self, x: _Exchanger__V, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> _Exchanger__V: ...

class ExecutionException(java.lang.Exception):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: java.lang.Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, cause: java.lang.Throwable, /) -> None: ...

class Executor(java.lang.Object):
    def execute(self, arg1: java.lang.Runnable, /) -> None: ...

_ExecutorCompletionService__V = typing.TypeVar('_ExecutorCompletionService__V')  # <V>
class ExecutorCompletionService(CompletionService[_ExecutorCompletionService__V], typing.Generic[_ExecutorCompletionService__V]):
    @typing.overload
    def __init__(self, executor: Executor, /) -> None: ...
    @typing.overload
    def __init__(self, executor: Executor, completionQueue: BlockingQueue[Future[_ExecutorCompletionService__V]], /) -> None: ...
    @typing.overload
    def poll(self) -> Future[_ExecutorCompletionService__V]: ...
    @typing.overload
    def poll(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> Future[_ExecutorCompletionService__V]: ...
    @typing.overload
    def submit(self, task: Callable[_ExecutorCompletionService__V], /) -> Future[_ExecutorCompletionService__V]: ...
    @typing.overload
    def submit(self, task: java.lang.Runnable, result: _ExecutorCompletionService__V, /) -> Future[_ExecutorCompletionService__V]: ...
    def take(self) -> Future[_ExecutorCompletionService__V]: ...

class ExecutorService(java.lang.AutoCloseable, Executor):
    def awaitTermination(self, arg1: int | java.jlong | java.lang.Long, arg2: TimeUnit, /) -> bool: ...
    def close(self) -> None: ...
    _invokeAll_0__T = typing.TypeVar('_invokeAll_0__T')  # <T>
    _invokeAll_1__T = typing.TypeVar('_invokeAll_1__T')  # <T>
    @typing.overload
    def invokeAll(self, arg1: java.util.Collection[Callable[_invokeAll_0__T]], /) -> java.util.List[Future[_invokeAll_0__T]]: ...
    @typing.overload
    def invokeAll(self, arg1: java.util.Collection[Callable[_invokeAll_1__T]], arg2: int | java.jlong | java.lang.Long, arg3: TimeUnit, /) -> java.util.List[Future[_invokeAll_1__T]]: ...
    _invokeAny_0__T = typing.TypeVar('_invokeAny_0__T')  # <T>
    _invokeAny_1__T = typing.TypeVar('_invokeAny_1__T')  # <T>
    @typing.overload
    def invokeAny(self, arg1: java.util.Collection[Callable[_invokeAny_0__T]], /) -> _invokeAny_0__T: ...
    @typing.overload
    def invokeAny(self, arg1: java.util.Collection[Callable[_invokeAny_1__T]], arg2: int | java.jlong | java.lang.Long, arg3: TimeUnit, /) -> _invokeAny_1__T: ...
    def isShutdown(self) -> bool: ...
    def isTerminated(self) -> bool: ...
    def shutdown(self) -> None: ...
    def shutdownNow(self) -> java.util.List[java.lang.Runnable]: ...
    _submit_1__T = typing.TypeVar('_submit_1__T')  # <T>
    _submit_2__T = typing.TypeVar('_submit_2__T')  # <T>
    @typing.overload
    def submit(self, arg1: java.lang.Runnable, /) -> Future[java.lang.Object]: ...
    @typing.overload
    def submit(self, arg1: Callable[_submit_1__T], /) -> Future[_submit_1__T]: ...
    @typing.overload
    def submit(self, arg1: java.lang.Runnable, arg2: _submit_2__T, /) -> Future[_submit_2__T]: ...

class Executors(java.lang.Object):
    _callable_3__T = typing.TypeVar('_callable_3__T')  # <T>
    @typing.overload
    @staticmethod
    def callable(task: java.lang.Runnable, /) -> Callable[java.lang.Object]: ...
    @typing.overload
    @staticmethod
    def callable(action: java.security.PrivilegedAction[java.lang.Object], /) -> Callable[java.lang.Object]: ...
    @typing.overload
    @staticmethod
    def callable(action: java.security.PrivilegedExceptionAction[java.lang.Object], /) -> Callable[java.lang.Object]: ...
    @typing.overload
    @staticmethod
    def callable(task: java.lang.Runnable, result: _callable_3__T, /) -> Callable[_callable_3__T]: ...
    @staticmethod
    def defaultThreadFactory() -> ThreadFactory: ...
    @typing.overload
    @staticmethod
    def newCachedThreadPool() -> ExecutorService: ...
    @typing.overload
    @staticmethod
    def newCachedThreadPool(threadFactory: ThreadFactory, /) -> ExecutorService: ...
    @typing.overload
    @staticmethod
    def newFixedThreadPool(nThreads: int | java.jint | java.lang.Integer, /) -> ExecutorService: ...
    @typing.overload
    @staticmethod
    def newFixedThreadPool(nThreads: int | java.jint | java.lang.Integer, threadFactory: ThreadFactory, /) -> ExecutorService: ...
    @typing.overload
    @staticmethod
    def newScheduledThreadPool(corePoolSize: int | java.jint | java.lang.Integer, /) -> ScheduledExecutorService: ...
    @typing.overload
    @staticmethod
    def newScheduledThreadPool(corePoolSize: int | java.jint | java.lang.Integer, threadFactory: ThreadFactory, /) -> ScheduledExecutorService: ...
    @typing.overload
    @staticmethod
    def newSingleThreadExecutor() -> ExecutorService: ...
    @typing.overload
    @staticmethod
    def newSingleThreadExecutor(threadFactory: ThreadFactory, /) -> ExecutorService: ...
    @typing.overload
    @staticmethod
    def newSingleThreadScheduledExecutor() -> ScheduledExecutorService: ...
    @typing.overload
    @staticmethod
    def newSingleThreadScheduledExecutor(threadFactory: ThreadFactory, /) -> ScheduledExecutorService: ...
    @typing.overload
    @staticmethod
    def newWorkStealingPool() -> ExecutorService: ...
    @typing.overload
    @staticmethod
    def newWorkStealingPool(parallelism: int | java.jint | java.lang.Integer, /) -> ExecutorService: ...
    _privilegedCallable__T = typing.TypeVar('_privilegedCallable__T')  # <T>
    @staticmethod
    def privilegedCallable(callable: Callable[_privilegedCallable__T], /) -> Callable[_privilegedCallable__T]: ...
    _privilegedCallableUsingCurrentClassLoader__T = typing.TypeVar('_privilegedCallableUsingCurrentClassLoader__T')  # <T>
    @staticmethod
    def privilegedCallableUsingCurrentClassLoader(callable: Callable[_privilegedCallableUsingCurrentClassLoader__T], /) -> Callable[_privilegedCallableUsingCurrentClassLoader__T]: ...
    @staticmethod
    def privilegedThreadFactory() -> ThreadFactory: ...
    @staticmethod
    def unconfigurableExecutorService(executor: ExecutorService, /) -> ExecutorService: ...
    @staticmethod
    def unconfigurableScheduledExecutorService(executor: ScheduledExecutorService, /) -> ScheduledExecutorService: ...


_Flow__Subscriber__T = typing.TypeVar('_Flow__Subscriber__T')  # <T>

_Flow__Publisher__T = typing.TypeVar('_Flow__Publisher__T')  # <T>

_Flow__Processor__T = typing.TypeVar('_Flow__Processor__T')  # <T>
_Flow__Processor__R = typing.TypeVar('_Flow__Processor__R')  # <R>
class Flow(java.lang.Object):
    @staticmethod
    def defaultBufferSize() -> int: ...

    class Subscription(java.lang.Object):
        def cancel(self) -> None: ...
        def request(self, arg1: int | java.jlong | java.lang.Long, /) -> None: ...
    class Subscriber(java.lang.Object, typing.Generic[_Flow__Subscriber__T]):
        def onComplete(self) -> None: ...
        def onError(self, arg1: java.lang.Throwable, /) -> None: ...
        def onNext(self, arg1: _Flow__Subscriber__T, /) -> None: ...
        def onSubscribe(self, arg1: Flow.Subscription, /) -> None: ...
    class Publisher(java.lang.Object, typing.Generic[_Flow__Publisher__T]):
        def subscribe(self, arg1: Flow.Subscriber[_Flow__Publisher__T], /) -> None: ...
    class Processor(java.util.concurrent.Flow.Publisher[_Flow__Processor__R], java.util.concurrent.Flow.Subscriber[_Flow__Processor__T], typing.Generic[_Flow__Processor__T, _Flow__Processor__R]): ...

class ForkJoinPool(AbstractExecutorService):
    defaultForkJoinWorkerThreadFactory: typing.ClassVar[ForkJoinPool.ForkJoinWorkerThreadFactory] = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, parallelism: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, parallelism: int | java.jint | java.lang.Integer, factory: ForkJoinPool.ForkJoinWorkerThreadFactory, handler: java.lang.Thread.UncaughtExceptionHandler, asyncMode: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def __init__(self, parallelism: int | java.jint | java.lang.Integer, factory: ForkJoinPool.ForkJoinWorkerThreadFactory, handler: java.lang.Thread.UncaughtExceptionHandler, asyncMode: bool | java.jboolean | java.lang.Boolean, corePoolSize: int | java.jint | java.lang.Integer, maximumPoolSize: int | java.jint | java.lang.Integer, minimumRunnable: int | java.jint | java.lang.Integer, saturate: java.util.function.Predicate[ForkJoinPool], keepAliveTime: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> None: ...
    def awaitQuiescence(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...
    def awaitTermination(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...
    def close(self) -> None: ...
    @staticmethod
    def commonPool() -> ForkJoinPool: ...
    def drainTasksTo(self, c: java.util.Collection[ForkJoinTask[java.lang.Object]], /) -> int: ...
    @typing.overload
    def execute(self, task: java.lang.Runnable, /) -> None: ...
    @typing.overload
    def execute(self, task: ForkJoinTask[java.lang.Object], /) -> None: ...
    _externalSubmit__T = typing.TypeVar('_externalSubmit__T')  # <T>
    def externalSubmit(self, task: ForkJoinTask[_externalSubmit__T], /) -> ForkJoinTask[_externalSubmit__T]: ...
    def getActiveThreadCount(self) -> int: ...
    def getAsyncMode(self) -> bool: ...
    @staticmethod
    def getCommonPoolParallelism() -> int: ...
    def getFactory(self) -> ForkJoinPool.ForkJoinWorkerThreadFactory: ...
    def getParallelism(self) -> int: ...
    def getPoolSize(self) -> int: ...
    def getQueuedSubmissionCount(self) -> int: ...
    def getQueuedTaskCount(self) -> int: ...
    def getRunningThreadCount(self) -> int: ...
    def getStealCount(self) -> int: ...
    def getUncaughtExceptionHandler(self) -> java.lang.Thread.UncaughtExceptionHandler: ...
    def hasQueuedSubmissions(self) -> bool: ...
    _invoke__T = typing.TypeVar('_invoke__T')  # <T>
    def invoke(self, task: ForkJoinTask[_invoke__T], /) -> _invoke__T: ...
    _invokeAll_0__T = typing.TypeVar('_invokeAll_0__T')  # <T>
    _invokeAll_1__T = typing.TypeVar('_invokeAll_1__T')  # <T>
    @typing.overload
    def invokeAll(self, tasks: java.util.Collection[Callable[_invokeAll_0__T]], /) -> java.util.List[Future[_invokeAll_0__T]]: ...
    @typing.overload
    def invokeAll(self, tasks: java.util.Collection[Callable[_invokeAll_1__T]], timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> java.util.List[Future[_invokeAll_1__T]]: ...
    _invokeAny_0__T = typing.TypeVar('_invokeAny_0__T')  # <T>
    _invokeAny_1__T = typing.TypeVar('_invokeAny_1__T')  # <T>
    @typing.overload
    def invokeAny(self, tasks: java.util.Collection[Callable[_invokeAny_0__T]], /) -> _invokeAny_0__T: ...
    @typing.overload
    def invokeAny(self, tasks: java.util.Collection[Callable[_invokeAny_1__T]], timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> _invokeAny_1__T: ...
    def isQuiescent(self) -> bool: ...
    def isShutdown(self) -> bool: ...
    def isTerminated(self) -> bool: ...
    def isTerminating(self) -> bool: ...
    _lazySubmit__T = typing.TypeVar('_lazySubmit__T')  # <T>
    def lazySubmit(self, task: ForkJoinTask[_lazySubmit__T], /) -> ForkJoinTask[_lazySubmit__T]: ...
    @staticmethod
    def managedBlock(blocker: ForkJoinPool.ManagedBlocker, /) -> None: ...
    _newTaskFor_0__T = typing.TypeVar('_newTaskFor_0__T')  # <T>
    _newTaskFor_1__T = typing.TypeVar('_newTaskFor_1__T')  # <T>
    @typing.overload
    def newTaskFor(self, callable: Callable[_newTaskFor_0__T], /) -> RunnableFuture[_newTaskFor_0__T]: ...
    @typing.overload
    def newTaskFor(self, runnable: java.lang.Runnable, value: _newTaskFor_1__T, /) -> RunnableFuture[_newTaskFor_1__T]: ...
    def pollSubmission(self) -> ForkJoinTask[java.lang.Object]: ...
    def setParallelism(self, size: int | java.jint | java.lang.Integer, /) -> int: ...
    def shutdown(self) -> None: ...
    def shutdownNow(self) -> java.util.List[java.lang.Runnable]: ...
    _submit_1__T = typing.TypeVar('_submit_1__T')  # <T>
    _submit_2__T = typing.TypeVar('_submit_2__T')  # <T>
    _submit_3__T = typing.TypeVar('_submit_3__T')  # <T>
    @typing.overload
    def submit(self, task: java.lang.Runnable, /) -> ForkJoinTask[java.lang.Object]: ...
    @typing.overload
    def submit(self, task: Callable[_submit_1__T], /) -> ForkJoinTask[_submit_1__T]: ...
    @typing.overload
    def submit(self, task: ForkJoinTask[_submit_2__T], /) -> ForkJoinTask[_submit_2__T]: ...
    @typing.overload
    def submit(self, task: java.lang.Runnable, result: _submit_3__T, /) -> ForkJoinTask[_submit_3__T]: ...
    def toString(self) -> str: ...

    class ForkJoinWorkerThreadFactory(java.lang.Object):
        def newThread(self, arg1: ForkJoinPool, /) -> ForkJoinWorkerThread: ...

    class ManagedBlocker(java.lang.Object):
        def block(self) -> bool: ...
        def isReleasable(self) -> bool: ...

_ForkJoinTask__V = typing.TypeVar('_ForkJoinTask__V')  # <V>
class ForkJoinTask(Future[_ForkJoinTask__V], java.io.Serializable, typing.Generic[_ForkJoinTask__V]):
    def __init__(self) -> None: ...
    _adapt_1__T = typing.TypeVar('_adapt_1__T')  # <T>
    _adapt_2__T = typing.TypeVar('_adapt_2__T')  # <T>
    @typing.overload
    @staticmethod
    def adapt(runnable: java.lang.Runnable, /) -> ForkJoinTask[java.lang.Object]: ...
    @typing.overload
    @staticmethod
    def adapt(callable: Callable[_adapt_1__T], /) -> ForkJoinTask[_adapt_1__T]: ...
    @typing.overload
    @staticmethod
    def adapt(runnable: java.lang.Runnable, result: _adapt_2__T, /) -> ForkJoinTask[_adapt_2__T]: ...
    _adaptInterruptible__T = typing.TypeVar('_adaptInterruptible__T')  # <T>
    @staticmethod
    def adaptInterruptible(callable: Callable[_adaptInterruptible__T], /) -> ForkJoinTask[_adaptInterruptible__T]: ...
    def cancel(self, mayInterruptIfRunning: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def compareAndSetForkJoinTaskTag(self, expect: int | java.jshort | java.lang.Short, update: int | java.jshort | java.lang.Short, /) -> bool: ...
    def complete(self, value: _ForkJoinTask__V, /) -> None: ...
    def completeExceptionally(self, ex: java.lang.Throwable, /) -> None: ...
    def exceptionNow(self) -> java.lang.Throwable: ...
    def exec_(self) -> bool: ...
    def fork(self) -> ForkJoinTask[_ForkJoinTask__V]: ...
    @typing.overload
    def get(self) -> _ForkJoinTask__V: ...
    @typing.overload
    def get(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> _ForkJoinTask__V: ...
    def getException(self) -> java.lang.Throwable: ...
    def getForkJoinTaskTag(self) -> int: ...
    @staticmethod
    def getPool() -> ForkJoinPool: ...
    @staticmethod
    def getQueuedTaskCount() -> int: ...
    def getRawResult(self) -> _ForkJoinTask__V: ...
    @staticmethod
    def getSurplusQueuedTaskCount() -> int: ...
    @staticmethod
    def helpQuiesce() -> None: ...
    @staticmethod
    def inForkJoinPool() -> bool: ...
    def invoke(self) -> _ForkJoinTask__V: ...
    _invokeAll_0__T = typing.TypeVar('_invokeAll_0__T', bound=ForkJoinTask[java.lang.Object])  # <T>
    @typing.overload
    @staticmethod
    def invokeAll(tasks: java.util.Collection[_invokeAll_0__T], /) -> java.util.Collection[_invokeAll_0__T]: ...
    @typing.overload
    @staticmethod
    def invokeAll(*tasks: ForkJoinTask[java.lang.Object]) -> None: ...
    @typing.overload
    @staticmethod
    def invokeAll(t1: ForkJoinTask[java.lang.Object], t2: ForkJoinTask[java.lang.Object], /) -> None: ...
    def isCancelled(self) -> bool: ...
    def isCompletedAbnormally(self) -> bool: ...
    def isCompletedNormally(self) -> bool: ...
    def isDone(self) -> bool: ...
    def join(self) -> _ForkJoinTask__V: ...
    @staticmethod
    def peekNextLocalTask() -> ForkJoinTask[java.lang.Object]: ...
    @staticmethod
    def pollNextLocalTask() -> ForkJoinTask[java.lang.Object]: ...
    @staticmethod
    def pollTask() -> ForkJoinTask[java.lang.Object]: ...
    def quietlyComplete(self) -> None: ...
    def quietlyInvoke(self) -> None: ...
    @typing.overload
    def quietlyJoin(self) -> None: ...
    @typing.overload
    def quietlyJoin(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...
    def quietlyJoinUninterruptibly(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...
    def reinitialize(self) -> None: ...
    def resultNow(self) -> _ForkJoinTask__V: ...
    def setForkJoinTaskTag(self, newValue: int | java.jshort | java.lang.Short, /) -> int: ...
    def setRawResult(self, arg1: _ForkJoinTask__V, /) -> None: ...
    def state(self) -> Future.State: ...
    def tryUnfork(self) -> bool: ...

class ForkJoinWorkerThread(java.lang.Thread):
    @typing.overload
    def __init__(self, pool: ForkJoinPool, /) -> None: ...
    @typing.overload
    def __init__(self, group: java.lang.ThreadGroup, pool: ForkJoinPool, preserveThreadLocals: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def getPool(self) -> ForkJoinPool: ...
    def getPoolIndex(self) -> int: ...
    def getQueuedTaskCount(self) -> int: ...
    def onStart(self) -> None: ...
    def onTermination(self, exception: java.lang.Throwable, /) -> None: ...
    def run(self) -> None: ...

_Future__V = typing.TypeVar('_Future__V')  # <V>
class Future(java.lang.Object, typing.Generic[_Future__V]):
    def cancel(self, arg1: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def exceptionNow(self) -> java.lang.Throwable: ...
    @typing.overload
    def get(self) -> _Future__V | None: ...
    @typing.overload
    def get(self, arg1: int | java.jlong | java.lang.Long, arg2: TimeUnit, /) -> _Future__V | None: ...
    def isCancelled(self) -> bool: ...
    def isDone(self) -> bool: ...
    def resultNow(self) -> _Future__V: ...
    def state(self) -> Future.State: ...

    class State(java.lang.Enum[Future.State]):
        CANCELLED: typing.ClassVar[Future.State] = ...
        FAILED: typing.ClassVar[Future.State] = ...
        RUNNING: typing.ClassVar[Future.State] = ...
        SUCCESS: typing.ClassVar[Future.State] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> Future.State: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[Future.State]: ...

_FutureTask__V = typing.TypeVar('_FutureTask__V')  # <V>
class FutureTask(RunnableFuture[_FutureTask__V], typing.Generic[_FutureTask__V]):
    @typing.overload
    def __init__(self, callable: Callable[_FutureTask__V], /) -> None: ...
    @typing.overload
    def __init__(self, runnable: java.lang.Runnable, result: _FutureTask__V, /) -> None: ...
    def cancel(self, mayInterruptIfRunning: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def done(self) -> None: ...
    def exceptionNow(self) -> java.lang.Throwable: ...
    @typing.overload
    def get(self) -> _FutureTask__V | None: ...
    @typing.overload
    def get(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> _FutureTask__V | None: ...
    def isCancelled(self) -> bool: ...
    def isDone(self) -> bool: ...
    def resultNow(self) -> _FutureTask__V: ...
    def run(self) -> None: ...
    def runAndReset(self) -> bool: ...
    def set(self, v: _FutureTask__V, /) -> None: ...
    def setException(self, t: java.lang.Throwable, /) -> None: ...
    def state(self) -> Future.State: ...
    def toString(self) -> str: ...

_LinkedBlockingDeque__E = typing.TypeVar('_LinkedBlockingDeque__E')  # <E>
class LinkedBlockingDeque(java.util.AbstractQueue[_LinkedBlockingDeque__E], BlockingDeque[_LinkedBlockingDeque__E], java.io.Serializable, typing.Generic[_LinkedBlockingDeque__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, capacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, c: java.util.Collection[_LinkedBlockingDeque__E], /) -> None: ...
    def add(self, e: _LinkedBlockingDeque__E, /) -> bool: ...
    def addAll(self, c: java.util.Collection[_LinkedBlockingDeque__E], /) -> bool: ...
    def addFirst(self, e: _LinkedBlockingDeque__E, /) -> None: ...
    def addLast(self, e: _LinkedBlockingDeque__E, /) -> None: ...
    def clear(self) -> None: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def descendingIterator(self) -> java.util.Iterator[_LinkedBlockingDeque__E]: ...
    @typing.overload
    def drainTo(self, c: java.util.Collection[_LinkedBlockingDeque__E], /) -> int: ...
    @typing.overload
    def drainTo(self, c: java.util.Collection[_LinkedBlockingDeque__E], maxElements: int | java.jint | java.lang.Integer, /) -> int: ...
    def element(self) -> _LinkedBlockingDeque__E: ...
    def forEach(self, action: java.util.function.Consumer[_LinkedBlockingDeque__E], /) -> None: ...
    def getFirst(self) -> _LinkedBlockingDeque__E: ...
    def getLast(self) -> _LinkedBlockingDeque__E: ...
    def iterator(self) -> java.util.Iterator[_LinkedBlockingDeque__E]: ...
    @typing.overload
    def offer(self, e: _LinkedBlockingDeque__E, /) -> bool: ...
    @typing.overload
    def offer(self, e: _LinkedBlockingDeque__E, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...
    @typing.overload
    def offerFirst(self, e: _LinkedBlockingDeque__E, /) -> bool: ...
    @typing.overload
    def offerFirst(self, e: _LinkedBlockingDeque__E, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...
    @typing.overload
    def offerLast(self, e: _LinkedBlockingDeque__E, /) -> bool: ...
    @typing.overload
    def offerLast(self, e: _LinkedBlockingDeque__E, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...
    def peek(self) -> _LinkedBlockingDeque__E | None: ...
    def peekFirst(self) -> _LinkedBlockingDeque__E | None: ...
    def peekLast(self) -> _LinkedBlockingDeque__E | None: ...
    @typing.overload
    def poll(self) -> _LinkedBlockingDeque__E | None: ...
    @typing.overload
    def poll(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> _LinkedBlockingDeque__E | None: ...
    @typing.overload
    def pollFirst(self) -> _LinkedBlockingDeque__E | None: ...
    @typing.overload
    def pollFirst(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> _LinkedBlockingDeque__E | None: ...
    @typing.overload
    def pollLast(self) -> _LinkedBlockingDeque__E | None: ...
    @typing.overload
    def pollLast(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> _LinkedBlockingDeque__E | None: ...
    def pop(self) -> _LinkedBlockingDeque__E: ...
    def push(self, e: _LinkedBlockingDeque__E, /) -> None: ...
    def put(self, e: _LinkedBlockingDeque__E, /) -> None: ...
    def putFirst(self, e: _LinkedBlockingDeque__E, /) -> None: ...
    def putLast(self, e: _LinkedBlockingDeque__E, /) -> None: ...
    def remainingCapacity(self) -> int: ...
    @typing.overload
    def remove(self) -> _LinkedBlockingDeque__E: ...
    @typing.overload
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def removeFirst(self) -> _LinkedBlockingDeque__E: ...
    def removeFirstOccurrence(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeIf(self, filter: java.util.function.Predicate[_LinkedBlockingDeque__E], /) -> bool: ...
    def removeLast(self) -> _LinkedBlockingDeque__E: ...
    def removeLastOccurrence(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def retainAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_LinkedBlockingDeque__E]: ...
    def take(self) -> _LinkedBlockingDeque__E: ...
    def takeFirst(self) -> _LinkedBlockingDeque__E: ...
    def takeLast(self) -> _LinkedBlockingDeque__E: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...
    def toString(self) -> str: ...

_LinkedBlockingQueue__E = typing.TypeVar('_LinkedBlockingQueue__E')  # <E>
class LinkedBlockingQueue(java.util.AbstractQueue[_LinkedBlockingQueue__E], BlockingQueue[_LinkedBlockingQueue__E], java.io.Serializable, typing.Generic[_LinkedBlockingQueue__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, capacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, c: java.util.Collection[_LinkedBlockingQueue__E], /) -> None: ...
    def clear(self) -> None: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def drainTo(self, c: java.util.Collection[_LinkedBlockingQueue__E], /) -> int: ...
    @typing.overload
    def drainTo(self, c: java.util.Collection[_LinkedBlockingQueue__E], maxElements: int | java.jint | java.lang.Integer, /) -> int: ...
    def forEach(self, action: java.util.function.Consumer[_LinkedBlockingQueue__E], /) -> None: ...
    def iterator(self) -> java.util.Iterator[_LinkedBlockingQueue__E]: ...
    @typing.overload
    def offer(self, e: _LinkedBlockingQueue__E, /) -> bool: ...
    @typing.overload
    def offer(self, e: _LinkedBlockingQueue__E, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...
    def peek(self) -> _LinkedBlockingQueue__E | None: ...
    @typing.overload
    def poll(self) -> _LinkedBlockingQueue__E | None: ...
    @typing.overload
    def poll(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> _LinkedBlockingQueue__E | None: ...
    def put(self, e: _LinkedBlockingQueue__E, /) -> None: ...
    def remainingCapacity(self) -> int: ...
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def removeIf(self, filter: java.util.function.Predicate[_LinkedBlockingQueue__E], /) -> bool: ...
    def retainAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_LinkedBlockingQueue__E]: ...
    def take(self) -> _LinkedBlockingQueue__E: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...
    def toString(self) -> str: ...

_LinkedTransferQueue__E = typing.TypeVar('_LinkedTransferQueue__E')  # <E>
class LinkedTransferQueue(java.util.AbstractQueue[_LinkedTransferQueue__E], java.io.Serializable, TransferQueue[_LinkedTransferQueue__E], typing.Generic[_LinkedTransferQueue__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, c: java.util.Collection[_LinkedTransferQueue__E], /) -> None: ...
    def add(self, e: _LinkedTransferQueue__E, /) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def drainTo(self, c: java.util.Collection[_LinkedTransferQueue__E], /) -> int: ...
    @typing.overload
    def drainTo(self, c: java.util.Collection[_LinkedTransferQueue__E], maxElements: int | java.jint | java.lang.Integer, /) -> int: ...
    def forEach(self, action: java.util.function.Consumer[_LinkedTransferQueue__E], /) -> None: ...
    def getWaitingConsumerCount(self) -> int: ...
    def hasWaitingConsumer(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_LinkedTransferQueue__E]: ...
    @typing.overload
    def offer(self, e: _LinkedTransferQueue__E, /) -> bool: ...
    @typing.overload
    def offer(self, e: _LinkedTransferQueue__E, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...
    def peek(self) -> _LinkedTransferQueue__E: ...
    @typing.overload
    def poll(self) -> _LinkedTransferQueue__E: ...
    @typing.overload
    def poll(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> _LinkedTransferQueue__E: ...
    def put(self, e: _LinkedTransferQueue__E, /) -> None: ...
    def remainingCapacity(self) -> int: ...
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def removeIf(self, filter: java.util.function.Predicate[_LinkedTransferQueue__E], /) -> bool: ...
    def retainAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_LinkedTransferQueue__E]: ...
    def take(self) -> _LinkedTransferQueue__E: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...
    def toString(self) -> str: ...
    def transfer(self, e: _LinkedTransferQueue__E, /) -> None: ...
    @typing.overload
    def tryTransfer(self, e: _LinkedTransferQueue__E, /) -> bool: ...
    @typing.overload
    def tryTransfer(self, e: _LinkedTransferQueue__E, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...

class Phaser(java.lang.Object):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, parties: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, parent: Phaser, /) -> None: ...
    @typing.overload
    def __init__(self, parent: Phaser, parties: int | java.jint | java.lang.Integer, /) -> None: ...
    def arrive(self) -> int: ...
    def arriveAndAwaitAdvance(self) -> int: ...
    def arriveAndDeregister(self) -> int: ...
    def awaitAdvance(self, phase: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def awaitAdvanceInterruptibly(self, phase: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def awaitAdvanceInterruptibly(self, phase: int | java.jint | java.lang.Integer, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> int: ...
    def bulkRegister(self, parties: int | java.jint | java.lang.Integer, /) -> int: ...
    def forceTermination(self) -> None: ...
    def getArrivedParties(self) -> int: ...
    def getParent(self) -> Phaser: ...
    def getPhase(self) -> int: ...
    def getRegisteredParties(self) -> int: ...
    def getRoot(self) -> Phaser: ...
    def getUnarrivedParties(self) -> int: ...
    def isTerminated(self) -> bool: ...
    def onAdvance(self, phase: int | java.jint | java.lang.Integer, registeredParties: int | java.jint | java.lang.Integer, /) -> bool: ...
    def register(self) -> int: ...
    def toString(self) -> str: ...

_PriorityBlockingQueue__E = typing.TypeVar('_PriorityBlockingQueue__E')  # <E>
class PriorityBlockingQueue(java.util.AbstractQueue[_PriorityBlockingQueue__E], BlockingQueue[_PriorityBlockingQueue__E], java.io.Serializable, typing.Generic[_PriorityBlockingQueue__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, c: java.util.Collection[_PriorityBlockingQueue__E], /) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, comparator: java.util.Comparator[_PriorityBlockingQueue__E], /) -> None: ...
    def add(self, e: _PriorityBlockingQueue__E, /) -> bool: ...
    def clear(self) -> None: ...
    def comparator(self) -> java.util.Comparator[_PriorityBlockingQueue__E]: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def drainTo(self, c: java.util.Collection[_PriorityBlockingQueue__E], /) -> int: ...
    @typing.overload
    def drainTo(self, c: java.util.Collection[_PriorityBlockingQueue__E], maxElements: int | java.jint | java.lang.Integer, /) -> int: ...
    def forEach(self, action: java.util.function.Consumer[_PriorityBlockingQueue__E], /) -> None: ...
    def iterator(self) -> java.util.Iterator[_PriorityBlockingQueue__E]: ...
    @typing.overload
    def offer(self, e: _PriorityBlockingQueue__E, /) -> bool: ...
    @typing.overload
    def offer(self, e: _PriorityBlockingQueue__E, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...
    def peek(self) -> _PriorityBlockingQueue__E | None: ...
    @typing.overload
    def poll(self) -> _PriorityBlockingQueue__E | None: ...
    @typing.overload
    def poll(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> _PriorityBlockingQueue__E | None: ...
    def put(self, e: _PriorityBlockingQueue__E, /) -> None: ...
    def remainingCapacity(self) -> int: ...
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def removeIf(self, filter: java.util.function.Predicate[_PriorityBlockingQueue__E], /) -> bool: ...
    def retainAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_PriorityBlockingQueue__E]: ...
    def take(self) -> _PriorityBlockingQueue__E: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...
    def toString(self) -> str: ...

class RecursiveAction(ForkJoinTask[java.lang.Void]):
    def __init__(self) -> None: ...
    def compute(self) -> None: ...
    def exec_(self) -> bool: ...
    def getRawResult(self) -> None: ...
    def setRawResult(self, mustBeNull: None | java.jvoid | java.lang.Void, /) -> None: ...

_RecursiveTask__V = typing.TypeVar('_RecursiveTask__V')  # <V>
class RecursiveTask(ForkJoinTask[_RecursiveTask__V], typing.Generic[_RecursiveTask__V]):
    def __init__(self) -> None: ...
    def compute(self) -> _RecursiveTask__V: ...
    def exec_(self) -> bool: ...
    def getRawResult(self) -> _RecursiveTask__V: ...
    def setRawResult(self, value: _RecursiveTask__V, /) -> None: ...

class RejectedExecutionException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: java.lang.Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, cause: java.lang.Throwable, /) -> None: ...

class RejectedExecutionHandler(java.lang.Object):
    def rejectedExecution(self, arg1: java.lang.Runnable, arg2: ThreadPoolExecutor, /) -> None: ...

_RunnableFuture__V = typing.TypeVar('_RunnableFuture__V')  # <V>
class RunnableFuture(Future[_RunnableFuture__V], java.lang.Runnable, typing.Generic[_RunnableFuture__V]):
    def run(self) -> None: ...

_RunnableScheduledFuture__V = typing.TypeVar('_RunnableScheduledFuture__V')  # <V>
class RunnableScheduledFuture(RunnableFuture[_RunnableScheduledFuture__V], ScheduledFuture[_RunnableScheduledFuture__V], typing.Generic[_RunnableScheduledFuture__V]):
    def isPeriodic(self) -> bool: ...

class ScheduledExecutorService(ExecutorService):
    _schedule_1__V = typing.TypeVar('_schedule_1__V')  # <V>
    @typing.overload
    def schedule(self, arg1: java.lang.Runnable, arg2: int | java.jlong | java.lang.Long, arg3: TimeUnit, /) -> ScheduledFuture[java.lang.Object]: ...
    @typing.overload
    def schedule(self, arg1: Callable[_schedule_1__V], arg2: int | java.jlong | java.lang.Long, arg3: TimeUnit, /) -> ScheduledFuture[_schedule_1__V]: ...
    def scheduleAtFixedRate(self, arg1: java.lang.Runnable, arg2: int | java.jlong | java.lang.Long, arg3: int | java.jlong | java.lang.Long, arg4: TimeUnit, /) -> ScheduledFuture[java.lang.Object]: ...
    def scheduleWithFixedDelay(self, arg1: java.lang.Runnable, arg2: int | java.jlong | java.lang.Long, arg3: int | java.jlong | java.lang.Long, arg4: TimeUnit, /) -> ScheduledFuture[java.lang.Object]: ...

_ScheduledFuture__V = typing.TypeVar('_ScheduledFuture__V')  # <V>
class ScheduledFuture(Delayed, Future[_ScheduledFuture__V], typing.Generic[_ScheduledFuture__V]): ...

class ScheduledThreadPoolExecutor(ThreadPoolExecutor, ScheduledExecutorService):
    @typing.overload
    def __init__(self, corePoolSize: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, corePoolSize: int | java.jint | java.lang.Integer, handler: RejectedExecutionHandler, /) -> None: ...
    @typing.overload
    def __init__(self, corePoolSize: int | java.jint | java.lang.Integer, threadFactory: ThreadFactory, /) -> None: ...
    @typing.overload
    def __init__(self, corePoolSize: int | java.jint | java.lang.Integer, threadFactory: ThreadFactory, handler: RejectedExecutionHandler, /) -> None: ...
    _decorateTask_0__V = typing.TypeVar('_decorateTask_0__V')  # <V>
    _decorateTask_1__V = typing.TypeVar('_decorateTask_1__V')  # <V>
    @typing.overload
    def decorateTask(self, runnable: java.lang.Runnable, task: RunnableScheduledFuture[_decorateTask_0__V], /) -> RunnableScheduledFuture[_decorateTask_0__V]: ...
    @typing.overload
    def decorateTask(self, callable: Callable[_decorateTask_1__V], task: RunnableScheduledFuture[_decorateTask_1__V], /) -> RunnableScheduledFuture[_decorateTask_1__V]: ...
    def execute(self, command: java.lang.Runnable, /) -> None: ...
    def getContinueExistingPeriodicTasksAfterShutdownPolicy(self) -> bool: ...
    def getExecuteExistingDelayedTasksAfterShutdownPolicy(self) -> bool: ...
    def getQueue(self) -> BlockingQueue[java.lang.Runnable]: ...
    def getRemoveOnCancelPolicy(self) -> bool: ...
    _schedule_1__V = typing.TypeVar('_schedule_1__V')  # <V>
    @typing.overload
    def schedule(self, command: java.lang.Runnable, delay: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> ScheduledFuture[java.lang.Object]: ...
    @typing.overload
    def schedule(self, callable: Callable[_schedule_1__V], delay: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> ScheduledFuture[_schedule_1__V]: ...
    def scheduleAtFixedRate(self, command: java.lang.Runnable, initialDelay: int | java.jlong | java.lang.Long, period: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> ScheduledFuture[java.lang.Object]: ...
    def scheduleWithFixedDelay(self, command: java.lang.Runnable, initialDelay: int | java.jlong | java.lang.Long, delay: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> ScheduledFuture[java.lang.Object]: ...
    def setContinueExistingPeriodicTasksAfterShutdownPolicy(self, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setExecuteExistingDelayedTasksAfterShutdownPolicy(self, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setRemoveOnCancelPolicy(self, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def shutdown(self) -> None: ...
    def shutdownNow(self) -> java.util.List[java.lang.Runnable]: ...
    _submit_1__T = typing.TypeVar('_submit_1__T')  # <T>
    _submit_2__T = typing.TypeVar('_submit_2__T')  # <T>
    @typing.overload
    def submit(self, task: java.lang.Runnable, /) -> Future[java.lang.Object]: ...
    @typing.overload
    def submit(self, task: Callable[_submit_1__T], /) -> Future[_submit_1__T]: ...
    @typing.overload
    def submit(self, task: java.lang.Runnable, result: _submit_2__T, /) -> Future[_submit_2__T]: ...

class Semaphore(java.io.Serializable):
    @typing.overload
    def __init__(self, permits: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, permits: int | java.jint | java.lang.Integer, fair: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def acquire(self) -> None: ...
    @typing.overload
    def acquire(self, permits: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def acquireUninterruptibly(self) -> None: ...
    @typing.overload
    def acquireUninterruptibly(self, permits: int | java.jint | java.lang.Integer, /) -> None: ...
    def availablePermits(self) -> int: ...
    def drainPermits(self) -> int: ...
    def getQueueLength(self) -> int: ...
    def getQueuedThreads(self) -> java.util.Collection[java.lang.Thread]: ...
    def hasQueuedThreads(self) -> bool: ...
    def isFair(self) -> bool: ...
    def reducePermits(self, reduction: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def release(self) -> None: ...
    @typing.overload
    def release(self, permits: int | java.jint | java.lang.Integer, /) -> None: ...
    def toString(self) -> str: ...
    @typing.overload
    def tryAcquire(self) -> bool: ...
    @typing.overload
    def tryAcquire(self, permits: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    def tryAcquire(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...
    @typing.overload
    def tryAcquire(self, permits: int | java.jint | java.lang.Integer, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...

_SubmissionPublisher__T = typing.TypeVar('_SubmissionPublisher__T')  # <T>
class SubmissionPublisher(java.lang.AutoCloseable, java.util.concurrent.Flow.Publisher[_SubmissionPublisher__T], typing.Generic[_SubmissionPublisher__T]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, executor: Executor, maxBufferCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, executor: Executor, maxBufferCapacity: int | java.jint | java.lang.Integer, handler: java.util.function.BiConsumer[Flow.Subscriber[_SubmissionPublisher__T], java.lang.Throwable], /) -> None: ...
    def close(self) -> None: ...
    def closeExceptionally(self, error: java.lang.Throwable, /) -> None: ...
    def consume(self, consumer: java.util.function.Consumer[_SubmissionPublisher__T], /) -> CompletableFuture[java.lang.Void]: ...
    def estimateMaximumLag(self) -> int: ...
    def estimateMinimumDemand(self) -> int: ...
    def getClosedException(self) -> java.lang.Throwable: ...
    def getExecutor(self) -> Executor: ...
    def getMaxBufferCapacity(self) -> int: ...
    def getNumberOfSubscribers(self) -> int: ...
    def getSubscribers(self) -> java.util.List[Flow.Subscriber[_SubmissionPublisher__T]]: ...
    def hasSubscribers(self) -> bool: ...
    def isClosed(self) -> bool: ...
    def isSubscribed(self, subscriber: Flow.Subscriber[_SubmissionPublisher__T], /) -> bool: ...
    @typing.overload
    def offer(self, item: _SubmissionPublisher__T, onDrop: java.util.function.BiPredicate[Flow.Subscriber[_SubmissionPublisher__T], _SubmissionPublisher__T], /) -> int: ...
    @typing.overload
    def offer(self, item: _SubmissionPublisher__T, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, onDrop: java.util.function.BiPredicate[Flow.Subscriber[_SubmissionPublisher__T], _SubmissionPublisher__T], /) -> int: ...
    def submit(self, item: _SubmissionPublisher__T, /) -> int: ...
    def subscribe(self, subscriber: Flow.Subscriber[_SubmissionPublisher__T], /) -> None: ...

_SynchronousQueue__E = typing.TypeVar('_SynchronousQueue__E')  # <E>
class SynchronousQueue(java.util.AbstractQueue[_SynchronousQueue__E], BlockingQueue[_SynchronousQueue__E], java.io.Serializable, typing.Generic[_SynchronousQueue__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, fair: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def clear(self) -> None: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    @typing.overload
    def drainTo(self, c: java.util.Collection[_SynchronousQueue__E], /) -> int: ...
    @typing.overload
    def drainTo(self, c: java.util.Collection[_SynchronousQueue__E], maxElements: int | java.jint | java.lang.Integer, /) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_SynchronousQueue__E]: ...
    @typing.overload
    def offer(self, e: _SynchronousQueue__E, /) -> bool: ...
    @typing.overload
    def offer(self, e: _SynchronousQueue__E, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...
    def peek(self) -> _SynchronousQueue__E: ...
    @typing.overload
    def poll(self) -> _SynchronousQueue__E: ...
    @typing.overload
    def poll(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> _SynchronousQueue__E: ...
    def put(self, e: _SynchronousQueue__E, /) -> None: ...
    def remainingCapacity(self) -> int: ...
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def retainAll(self, c: java.util.Collection[java.lang.Object], /) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> java.util.Spliterator[_SynchronousQueue__E]: ...
    def take(self) -> _SynchronousQueue__E: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...
    def toString(self) -> str: ...

class ThreadFactory(java.lang.Object):
    def newThread(self, arg1: java.lang.Runnable, /) -> java.lang.Thread: ...

class ThreadLocalRandom(java.util.Random):
    @staticmethod
    def current() -> ThreadLocalRandom: ...
    @typing.overload
    def doubles(self) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, streamSize: int | java.jlong | java.lang.Long, /) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, randomNumberOrigin: float | java.jdouble | java.lang.Double, randomNumberBound: float | java.jdouble | java.lang.Double, /) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, streamSize: int | java.jlong | java.lang.Long, randomNumberOrigin: float | java.jdouble | java.lang.Double, randomNumberBound: float | java.jdouble | java.lang.Double, /) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def ints(self) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, streamSize: int | java.jlong | java.lang.Long, /) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, randomNumberOrigin: int | java.jint | java.lang.Integer, randomNumberBound: int | java.jint | java.lang.Integer, /) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, streamSize: int | java.jlong | java.lang.Long, randomNumberOrigin: int | java.jint | java.lang.Integer, randomNumberBound: int | java.jint | java.lang.Integer, /) -> java.util.stream.IntStream: ...
    @typing.overload
    def longs(self) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, streamSize: int | java.jlong | java.lang.Long, /) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, randomNumberOrigin: int | java.jlong | java.lang.Long, randomNumberBound: int | java.jlong | java.lang.Long, /) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, streamSize: int | java.jlong | java.lang.Long, randomNumberOrigin: int | java.jlong | java.lang.Long, randomNumberBound: int | java.jlong | java.lang.Long, /) -> java.util.stream.LongStream: ...
    def next(self, bits: int | java.jint | java.lang.Integer, /) -> int: ...
    def nextBoolean(self) -> bool: ...
    @typing.overload
    def nextDouble(self) -> float: ...
    @typing.overload
    def nextDouble(self, bound: float | java.jdouble | java.lang.Double, /) -> float: ...
    @typing.overload
    def nextDouble(self, origin: float | java.jdouble | java.lang.Double, bound: float | java.jdouble | java.lang.Double, /) -> float: ...
    @typing.overload
    def nextFloat(self) -> float: ...
    @typing.overload
    def nextFloat(self, bound: float | java.jfloat | java.lang.Float, /) -> float: ...
    @typing.overload
    def nextFloat(self, origin: float | java.jfloat | java.lang.Float, bound: float | java.jfloat | java.lang.Float, /) -> float: ...
    @typing.overload
    def nextInt(self) -> int: ...
    @typing.overload
    def nextInt(self, bound: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def nextInt(self, origin: int | java.jint | java.lang.Integer, bound: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def nextLong(self) -> int: ...
    @typing.overload
    def nextLong(self, bound: int | java.jlong | java.lang.Long, /) -> int: ...
    @typing.overload
    def nextLong(self, origin: int | java.jlong | java.lang.Long, bound: int | java.jlong | java.lang.Long, /) -> int: ...
    def setSeed(self, seed: int | java.jlong | java.lang.Long, /) -> None: ...

class ThreadPoolExecutor(AbstractExecutorService):
    @typing.overload
    def __init__(self, corePoolSize: int | java.jint | java.lang.Integer, maximumPoolSize: int | java.jint | java.lang.Integer, keepAliveTime: int | java.jlong | java.lang.Long, unit: TimeUnit, workQueue: BlockingQueue[java.lang.Runnable], /) -> None: ...
    @typing.overload
    def __init__(self, corePoolSize: int | java.jint | java.lang.Integer, maximumPoolSize: int | java.jint | java.lang.Integer, keepAliveTime: int | java.jlong | java.lang.Long, unit: TimeUnit, workQueue: BlockingQueue[java.lang.Runnable], handler: RejectedExecutionHandler, /) -> None: ...
    @typing.overload
    def __init__(self, corePoolSize: int | java.jint | java.lang.Integer, maximumPoolSize: int | java.jint | java.lang.Integer, keepAliveTime: int | java.jlong | java.lang.Long, unit: TimeUnit, workQueue: BlockingQueue[java.lang.Runnable], threadFactory: ThreadFactory, /) -> None: ...
    @typing.overload
    def __init__(self, corePoolSize: int | java.jint | java.lang.Integer, maximumPoolSize: int | java.jint | java.lang.Integer, keepAliveTime: int | java.jlong | java.lang.Long, unit: TimeUnit, workQueue: BlockingQueue[java.lang.Runnable], threadFactory: ThreadFactory, handler: RejectedExecutionHandler, /) -> None: ...
    def afterExecute(self, r: java.lang.Runnable, t: java.lang.Throwable, /) -> None: ...
    def allowCoreThreadTimeOut(self, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def allowsCoreThreadTimeOut(self) -> bool: ...
    def awaitTermination(self, timeout: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> bool: ...
    def beforeExecute(self, t: java.lang.Thread, r: java.lang.Runnable, /) -> None: ...
    def execute(self, command: java.lang.Runnable, /) -> None: ...
    def finalize(self) -> None: ...
    def getActiveCount(self) -> int: ...
    def getCompletedTaskCount(self) -> int: ...
    def getCorePoolSize(self) -> int: ...
    def getKeepAliveTime(self, unit: TimeUnit, /) -> int: ...
    def getLargestPoolSize(self) -> int: ...
    def getMaximumPoolSize(self) -> int: ...
    def getPoolSize(self) -> int: ...
    def getQueue(self) -> BlockingQueue[java.lang.Runnable]: ...
    def getRejectedExecutionHandler(self) -> RejectedExecutionHandler: ...
    def getTaskCount(self) -> int: ...
    def getThreadFactory(self) -> ThreadFactory: ...
    def isShutdown(self) -> bool: ...
    def isTerminated(self) -> bool: ...
    def isTerminating(self) -> bool: ...
    def prestartAllCoreThreads(self) -> int: ...
    def prestartCoreThread(self) -> bool: ...
    def purge(self) -> None: ...
    def remove(self, task: java.lang.Runnable, /) -> bool: ...
    def setCorePoolSize(self, corePoolSize: int | java.jint | java.lang.Integer, /) -> None: ...
    def setKeepAliveTime(self, time: int | java.jlong | java.lang.Long, unit: TimeUnit, /) -> None: ...
    def setMaximumPoolSize(self, maximumPoolSize: int | java.jint | java.lang.Integer, /) -> None: ...
    def setRejectedExecutionHandler(self, handler: RejectedExecutionHandler, /) -> None: ...
    def setThreadFactory(self, threadFactory: ThreadFactory, /) -> None: ...
    def shutdown(self) -> None: ...
    def shutdownNow(self) -> java.util.List[java.lang.Runnable]: ...
    def terminated(self) -> None: ...
    def toString(self) -> str: ...

    class DiscardPolicy(RejectedExecutionHandler):
        def __init__(self) -> None: ...
        def rejectedExecution(self, r: java.lang.Runnable, e: ThreadPoolExecutor, /) -> None: ...

    class DiscardOldestPolicy(RejectedExecutionHandler):
        def __init__(self) -> None: ...
        def rejectedExecution(self, r: java.lang.Runnable, e: ThreadPoolExecutor, /) -> None: ...

    class CallerRunsPolicy(RejectedExecutionHandler):
        def __init__(self) -> None: ...
        def rejectedExecution(self, r: java.lang.Runnable, e: ThreadPoolExecutor, /) -> None: ...

    class AbortPolicy(RejectedExecutionHandler):
        def __init__(self) -> None: ...
        def rejectedExecution(self, r: java.lang.Runnable, e: ThreadPoolExecutor, /) -> None: ...

class TimeUnit(java.lang.Enum[TimeUnit]):
    DAYS: typing.ClassVar[TimeUnit] = ...
    HOURS: typing.ClassVar[TimeUnit] = ...
    MICROSECONDS: typing.ClassVar[TimeUnit] = ...
    MILLISECONDS: typing.ClassVar[TimeUnit] = ...
    MINUTES: typing.ClassVar[TimeUnit] = ...
    NANOSECONDS: typing.ClassVar[TimeUnit] = ...
    SECONDS: typing.ClassVar[TimeUnit] = ...
    @typing.overload
    def convert(self, duration: java.time.Duration, /) -> int: ...
    @typing.overload
    def convert(self, sourceDuration: int | java.jlong | java.lang.Long, sourceUnit: TimeUnit, /) -> int: ...
    @staticmethod
    def of(chronoUnit: java.time.temporal.ChronoUnit, /) -> TimeUnit: ...
    def sleep(self, timeout: int | java.jlong | java.lang.Long, /) -> None: ...
    def timedJoin(self, thread: java.lang.Thread, timeout: int | java.jlong | java.lang.Long, /) -> None: ...
    def timedWait(self, obj: java.lang.Object | int | bool | float | str, timeout: int | java.jlong | java.lang.Long, /) -> None: ...
    def toChronoUnit(self) -> java.time.temporal.ChronoUnit: ...
    def toDays(self, duration: int | java.jlong | java.lang.Long, /) -> int: ...
    def toHours(self, duration: int | java.jlong | java.lang.Long, /) -> int: ...
    def toMicros(self, duration: int | java.jlong | java.lang.Long, /) -> int: ...
    def toMillis(self, duration: int | java.jlong | java.lang.Long, /) -> int: ...
    def toMinutes(self, duration: int | java.jlong | java.lang.Long, /) -> int: ...
    def toNanos(self, duration: int | java.jlong | java.lang.Long, /) -> int: ...
    def toSeconds(self, duration: int | java.jlong | java.lang.Long, /) -> int: ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> TimeUnit: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[TimeUnit]: ...

class TimeoutException(java.lang.Exception):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...

_TransferQueue__E = typing.TypeVar('_TransferQueue__E')  # <E>
class TransferQueue(BlockingQueue[_TransferQueue__E], typing.Generic[_TransferQueue__E]):
    def getWaitingConsumerCount(self) -> int: ...
    def hasWaitingConsumer(self) -> bool: ...
    def transfer(self, arg1: _TransferQueue__E, /) -> None: ...
    @typing.overload
    def tryTransfer(self, arg1: _TransferQueue__E, /) -> bool: ...
    @typing.overload
    def tryTransfer(self, arg1: _TransferQueue__E, arg2: int | java.jlong | java.lang.Long, arg3: TimeUnit, /) -> bool: ...
