import java
import java.chaquopy
import java.io
import java.lang
import java.util.function
import typing



class AtomicBoolean(java.io.Serializable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialValue: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def compareAndExchange(self, expectedValue: bool | java.jboolean | java.lang.Boolean, newValue: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def compareAndExchangeAcquire(self, expectedValue: bool | java.jboolean | java.lang.Boolean, newValue: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def compareAndExchangeRelease(self, expectedValue: bool | java.jboolean | java.lang.Boolean, newValue: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def compareAndSet(self, expectedValue: bool | java.jboolean | java.lang.Boolean, newValue: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def get(self) -> bool: ...
    def getAcquire(self) -> bool: ...
    def getAndSet(self, newValue: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def getOpaque(self) -> bool: ...
    def getPlain(self) -> bool: ...
    def lazySet(self, newValue: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def set(self, newValue: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setOpaque(self, newValue: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setPlain(self, newValue: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setRelease(self, newValue: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def toString(self) -> str: ...
    def weakCompareAndSet(self, expectedValue: bool | java.jboolean | java.lang.Boolean, newValue: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def weakCompareAndSetAcquire(self, expectedValue: bool | java.jboolean | java.lang.Boolean, newValue: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def weakCompareAndSetPlain(self, expectedValue: bool | java.jboolean | java.lang.Boolean, newValue: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def weakCompareAndSetRelease(self, expectedValue: bool | java.jboolean | java.lang.Boolean, newValue: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def weakCompareAndSetVolatile(self, expectedValue: bool | java.jboolean | java.lang.Boolean, newValue: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...

class AtomicInteger(java.lang.Number, java.io.Serializable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def accumulateAndGet(self, x: int | java.jint | java.lang.Integer, accumulatorFunction: java.util.function.IntBinaryOperator, /) -> int: ...
    def addAndGet(self, delta: int | java.jint | java.lang.Integer, /) -> int: ...
    def compareAndExchange(self, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> int: ...
    def compareAndExchangeAcquire(self, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> int: ...
    def compareAndExchangeRelease(self, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> int: ...
    def compareAndSet(self, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> bool: ...
    def decrementAndGet(self) -> int: ...
    def doubleValue(self) -> float: ...
    def floatValue(self) -> float: ...
    def get(self) -> int: ...
    def getAcquire(self) -> int: ...
    def getAndAccumulate(self, x: int | java.jint | java.lang.Integer, accumulatorFunction: java.util.function.IntBinaryOperator, /) -> int: ...
    def getAndAdd(self, delta: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAndDecrement(self) -> int: ...
    def getAndIncrement(self) -> int: ...
    def getAndSet(self, newValue: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAndUpdate(self, updateFunction: java.util.function.IntUnaryOperator, /) -> int: ...
    def getOpaque(self) -> int: ...
    def getPlain(self) -> int: ...
    def incrementAndGet(self) -> int: ...
    def intValue(self) -> int: ...
    def lazySet(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def longValue(self) -> int: ...
    def set(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setOpaque(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setPlain(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setRelease(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def toString(self) -> str: ...
    def updateAndGet(self, updateFunction: java.util.function.IntUnaryOperator, /) -> int: ...
    def weakCompareAndSet(self, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> bool: ...
    def weakCompareAndSetAcquire(self, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> bool: ...
    def weakCompareAndSetPlain(self, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> bool: ...
    def weakCompareAndSetRelease(self, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> bool: ...
    def weakCompareAndSetVolatile(self, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> bool: ...

class AtomicIntegerArray(java.io.Serializable):
    @typing.overload
    def __init__(self, length: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, array: java.chaquopy.JavaArrayJInt, /) -> None: ...
    def accumulateAndGet(self, i: int | java.jint | java.lang.Integer, x: int | java.jint | java.lang.Integer, accumulatorFunction: java.util.function.IntBinaryOperator, /) -> int: ...
    def addAndGet(self, i: int | java.jint | java.lang.Integer, delta: int | java.jint | java.lang.Integer, /) -> int: ...
    def compareAndExchange(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> int: ...
    def compareAndExchangeAcquire(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> int: ...
    def compareAndExchangeRelease(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> int: ...
    def compareAndSet(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> bool: ...
    def decrementAndGet(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
    def get(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAcquire(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAndAccumulate(self, i: int | java.jint | java.lang.Integer, x: int | java.jint | java.lang.Integer, accumulatorFunction: java.util.function.IntBinaryOperator, /) -> int: ...
    def getAndAdd(self, i: int | java.jint | java.lang.Integer, delta: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAndDecrement(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAndIncrement(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAndSet(self, i: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAndUpdate(self, i: int | java.jint | java.lang.Integer, updateFunction: java.util.function.IntUnaryOperator, /) -> int: ...
    def getOpaque(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
    def getPlain(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
    def incrementAndGet(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
    def lazySet(self, i: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def length(self) -> int: ...
    def set(self, i: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setOpaque(self, i: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setPlain(self, i: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setRelease(self, i: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def toString(self) -> str: ...
    def updateAndGet(self, i: int | java.jint | java.lang.Integer, updateFunction: java.util.function.IntUnaryOperator, /) -> int: ...
    def weakCompareAndSet(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> bool: ...
    def weakCompareAndSetAcquire(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> bool: ...
    def weakCompareAndSetPlain(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> bool: ...
    def weakCompareAndSetRelease(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> bool: ...
    def weakCompareAndSetVolatile(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jint | java.lang.Integer, newValue: int | java.jint | java.lang.Integer, /) -> bool: ...

_AtomicIntegerFieldUpdater__T = typing.TypeVar('_AtomicIntegerFieldUpdater__T')  # <T>
class AtomicIntegerFieldUpdater(java.lang.Object, typing.Generic[_AtomicIntegerFieldUpdater__T]):
    def __init__(self) -> None: ...
    def accumulateAndGet(self, obj: _AtomicIntegerFieldUpdater__T, x: int | java.jint | java.lang.Integer, accumulatorFunction: java.util.function.IntBinaryOperator, /) -> int: ...
    def addAndGet(self, obj: _AtomicIntegerFieldUpdater__T, delta: int | java.jint | java.lang.Integer, /) -> int: ...
    def compareAndSet(self, arg1: _AtomicIntegerFieldUpdater__T, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> bool: ...
    def decrementAndGet(self, obj: _AtomicIntegerFieldUpdater__T, /) -> int: ...
    def get(self, arg1: _AtomicIntegerFieldUpdater__T, /) -> int: ...
    def getAndAccumulate(self, obj: _AtomicIntegerFieldUpdater__T, x: int | java.jint | java.lang.Integer, accumulatorFunction: java.util.function.IntBinaryOperator, /) -> int: ...
    def getAndAdd(self, obj: _AtomicIntegerFieldUpdater__T, delta: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAndDecrement(self, obj: _AtomicIntegerFieldUpdater__T, /) -> int: ...
    def getAndIncrement(self, obj: _AtomicIntegerFieldUpdater__T, /) -> int: ...
    def getAndSet(self, obj: _AtomicIntegerFieldUpdater__T, newValue: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAndUpdate(self, obj: _AtomicIntegerFieldUpdater__T, updateFunction: java.util.function.IntUnaryOperator, /) -> int: ...
    def incrementAndGet(self, obj: _AtomicIntegerFieldUpdater__T, /) -> int: ...
    def lazySet(self, arg1: _AtomicIntegerFieldUpdater__T, arg2: int | java.jint | java.lang.Integer, /) -> None: ...
    _newUpdater__U = typing.TypeVar('_newUpdater__U')  # <U>
    @staticmethod
    def newUpdater(tclass: typing.Type[_newUpdater__U], fieldName: str | java.lang.String, /) -> AtomicIntegerFieldUpdater[_newUpdater__U]: ...
    def set(self, arg1: _AtomicIntegerFieldUpdater__T, arg2: int | java.jint | java.lang.Integer, /) -> None: ...
    def updateAndGet(self, obj: _AtomicIntegerFieldUpdater__T, updateFunction: java.util.function.IntUnaryOperator, /) -> int: ...
    def weakCompareAndSet(self, arg1: _AtomicIntegerFieldUpdater__T, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> bool: ...

class AtomicLong(java.lang.Number, java.io.Serializable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialValue: int | java.jlong | java.lang.Long, /) -> None: ...
    def accumulateAndGet(self, x: int | java.jlong | java.lang.Long, accumulatorFunction: java.util.function.LongBinaryOperator, /) -> int: ...
    def addAndGet(self, delta: int | java.jlong | java.lang.Long, /) -> int: ...
    def compareAndExchange(self, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> int: ...
    def compareAndExchangeAcquire(self, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> int: ...
    def compareAndExchangeRelease(self, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> int: ...
    def compareAndSet(self, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> bool: ...
    def decrementAndGet(self) -> int: ...
    def doubleValue(self) -> float: ...
    def floatValue(self) -> float: ...
    def get(self) -> int: ...
    def getAcquire(self) -> int: ...
    def getAndAccumulate(self, x: int | java.jlong | java.lang.Long, accumulatorFunction: java.util.function.LongBinaryOperator, /) -> int: ...
    def getAndAdd(self, delta: int | java.jlong | java.lang.Long, /) -> int: ...
    def getAndDecrement(self) -> int: ...
    def getAndIncrement(self) -> int: ...
    def getAndSet(self, newValue: int | java.jlong | java.lang.Long, /) -> int: ...
    def getAndUpdate(self, updateFunction: java.util.function.LongUnaryOperator, /) -> int: ...
    def getOpaque(self) -> int: ...
    def getPlain(self) -> int: ...
    def incrementAndGet(self) -> int: ...
    def intValue(self) -> int: ...
    def lazySet(self, newValue: int | java.jlong | java.lang.Long, /) -> None: ...
    def longValue(self) -> int: ...
    def set(self, newValue: int | java.jlong | java.lang.Long, /) -> None: ...
    def setOpaque(self, newValue: int | java.jlong | java.lang.Long, /) -> None: ...
    def setPlain(self, newValue: int | java.jlong | java.lang.Long, /) -> None: ...
    def setRelease(self, newValue: int | java.jlong | java.lang.Long, /) -> None: ...
    def toString(self) -> str: ...
    def updateAndGet(self, updateFunction: java.util.function.LongUnaryOperator, /) -> int: ...
    def weakCompareAndSet(self, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> bool: ...
    def weakCompareAndSetAcquire(self, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> bool: ...
    def weakCompareAndSetPlain(self, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> bool: ...
    def weakCompareAndSetRelease(self, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> bool: ...
    def weakCompareAndSetVolatile(self, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> bool: ...

class AtomicLongArray(java.io.Serializable):
    @typing.overload
    def __init__(self, length: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, array: java.chaquopy.JavaArrayJLong, /) -> None: ...
    def accumulateAndGet(self, i: int | java.jint | java.lang.Integer, x: int | java.jlong | java.lang.Long, accumulatorFunction: java.util.function.LongBinaryOperator, /) -> int: ...
    def addAndGet(self, i: int | java.jint | java.lang.Integer, delta: int | java.jlong | java.lang.Long, /) -> int: ...
    def compareAndExchange(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> int: ...
    def compareAndExchangeAcquire(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> int: ...
    def compareAndExchangeRelease(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> int: ...
    def compareAndSet(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> bool: ...
    def decrementAndGet(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
    def get(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAcquire(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAndAccumulate(self, i: int | java.jint | java.lang.Integer, x: int | java.jlong | java.lang.Long, accumulatorFunction: java.util.function.LongBinaryOperator, /) -> int: ...
    def getAndAdd(self, i: int | java.jint | java.lang.Integer, delta: int | java.jlong | java.lang.Long, /) -> int: ...
    def getAndDecrement(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAndIncrement(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAndSet(self, i: int | java.jint | java.lang.Integer, newValue: int | java.jlong | java.lang.Long, /) -> int: ...
    def getAndUpdate(self, i: int | java.jint | java.lang.Integer, updateFunction: java.util.function.LongUnaryOperator, /) -> int: ...
    def getOpaque(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
    def getPlain(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
    def incrementAndGet(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
    def lazySet(self, i: int | java.jint | java.lang.Integer, newValue: int | java.jlong | java.lang.Long, /) -> None: ...
    def length(self) -> int: ...
    def set(self, i: int | java.jint | java.lang.Integer, newValue: int | java.jlong | java.lang.Long, /) -> None: ...
    def setOpaque(self, i: int | java.jint | java.lang.Integer, newValue: int | java.jlong | java.lang.Long, /) -> None: ...
    def setPlain(self, i: int | java.jint | java.lang.Integer, newValue: int | java.jlong | java.lang.Long, /) -> None: ...
    def setRelease(self, i: int | java.jint | java.lang.Integer, newValue: int | java.jlong | java.lang.Long, /) -> None: ...
    def toString(self) -> str: ...
    def updateAndGet(self, i: int | java.jint | java.lang.Integer, updateFunction: java.util.function.LongUnaryOperator, /) -> int: ...
    def weakCompareAndSet(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> bool: ...
    def weakCompareAndSetAcquire(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> bool: ...
    def weakCompareAndSetPlain(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> bool: ...
    def weakCompareAndSetRelease(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> bool: ...
    def weakCompareAndSetVolatile(self, i: int | java.jint | java.lang.Integer, expectedValue: int | java.jlong | java.lang.Long, newValue: int | java.jlong | java.lang.Long, /) -> bool: ...

_AtomicLongFieldUpdater__T = typing.TypeVar('_AtomicLongFieldUpdater__T')  # <T>
class AtomicLongFieldUpdater(java.lang.Object, typing.Generic[_AtomicLongFieldUpdater__T]):
    def __init__(self) -> None: ...
    def accumulateAndGet(self, obj: _AtomicLongFieldUpdater__T, x: int | java.jlong | java.lang.Long, accumulatorFunction: java.util.function.LongBinaryOperator, /) -> int: ...
    def addAndGet(self, obj: _AtomicLongFieldUpdater__T, delta: int | java.jlong | java.lang.Long, /) -> int: ...
    def compareAndSet(self, arg1: _AtomicLongFieldUpdater__T, arg2: int | java.jlong | java.lang.Long, arg3: int | java.jlong | java.lang.Long, /) -> bool: ...
    def decrementAndGet(self, obj: _AtomicLongFieldUpdater__T, /) -> int: ...
    def get(self, arg1: _AtomicLongFieldUpdater__T, /) -> int: ...
    def getAndAccumulate(self, obj: _AtomicLongFieldUpdater__T, x: int | java.jlong | java.lang.Long, accumulatorFunction: java.util.function.LongBinaryOperator, /) -> int: ...
    def getAndAdd(self, obj: _AtomicLongFieldUpdater__T, delta: int | java.jlong | java.lang.Long, /) -> int: ...
    def getAndDecrement(self, obj: _AtomicLongFieldUpdater__T, /) -> int: ...
    def getAndIncrement(self, obj: _AtomicLongFieldUpdater__T, /) -> int: ...
    def getAndSet(self, obj: _AtomicLongFieldUpdater__T, newValue: int | java.jlong | java.lang.Long, /) -> int: ...
    def getAndUpdate(self, obj: _AtomicLongFieldUpdater__T, updateFunction: java.util.function.LongUnaryOperator, /) -> int: ...
    def incrementAndGet(self, obj: _AtomicLongFieldUpdater__T, /) -> int: ...
    def lazySet(self, arg1: _AtomicLongFieldUpdater__T, arg2: int | java.jlong | java.lang.Long, /) -> None: ...
    _newUpdater__U = typing.TypeVar('_newUpdater__U')  # <U>
    @staticmethod
    def newUpdater(tclass: typing.Type[_newUpdater__U], fieldName: str | java.lang.String, /) -> AtomicLongFieldUpdater[_newUpdater__U]: ...
    def set(self, arg1: _AtomicLongFieldUpdater__T, arg2: int | java.jlong | java.lang.Long, /) -> None: ...
    def updateAndGet(self, obj: _AtomicLongFieldUpdater__T, updateFunction: java.util.function.LongUnaryOperator, /) -> int: ...
    def weakCompareAndSet(self, arg1: _AtomicLongFieldUpdater__T, arg2: int | java.jlong | java.lang.Long, arg3: int | java.jlong | java.lang.Long, /) -> bool: ...

_AtomicMarkableReference__V = typing.TypeVar('_AtomicMarkableReference__V')  # <V>
class AtomicMarkableReference(java.lang.Object, typing.Generic[_AtomicMarkableReference__V]):
    def __init__(self, initialRef: _AtomicMarkableReference__V, initialMark: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def attemptMark(self, expectedReference: _AtomicMarkableReference__V, newMark: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def compareAndSet(self, expectedReference: _AtomicMarkableReference__V, newReference: _AtomicMarkableReference__V, expectedMark: bool | java.jboolean | java.lang.Boolean, newMark: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def get(self, markHolder: java.chaquopy.JavaArrayJBoolean, /) -> _AtomicMarkableReference__V: ...
    def getReference(self) -> _AtomicMarkableReference__V: ...
    def isMarked(self) -> bool: ...
    def set(self, newReference: _AtomicMarkableReference__V, newMark: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def weakCompareAndSet(self, expectedReference: _AtomicMarkableReference__V, newReference: _AtomicMarkableReference__V, expectedMark: bool | java.jboolean | java.lang.Boolean, newMark: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...

_AtomicReference__V = typing.TypeVar('_AtomicReference__V')  # <V>
class AtomicReference(java.io.Serializable, typing.Generic[_AtomicReference__V]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialValue: _AtomicReference__V, /) -> None: ...
    def accumulateAndGet(self, x: _AtomicReference__V, accumulatorFunction: java.util.function.BinaryOperator[_AtomicReference__V], /) -> _AtomicReference__V: ...
    def compareAndExchange(self, expectedValue: _AtomicReference__V, newValue: _AtomicReference__V, /) -> _AtomicReference__V: ...
    def compareAndExchangeAcquire(self, expectedValue: _AtomicReference__V, newValue: _AtomicReference__V, /) -> _AtomicReference__V: ...
    def compareAndExchangeRelease(self, expectedValue: _AtomicReference__V, newValue: _AtomicReference__V, /) -> _AtomicReference__V: ...
    def compareAndSet(self, expectedValue: _AtomicReference__V, newValue: _AtomicReference__V, /) -> bool: ...
    def get(self) -> _AtomicReference__V: ...
    def getAcquire(self) -> _AtomicReference__V: ...
    def getAndAccumulate(self, x: _AtomicReference__V, accumulatorFunction: java.util.function.BinaryOperator[_AtomicReference__V], /) -> _AtomicReference__V: ...
    def getAndSet(self, newValue: _AtomicReference__V, /) -> _AtomicReference__V: ...
    def getAndUpdate(self, updateFunction: java.util.function.UnaryOperator[_AtomicReference__V], /) -> _AtomicReference__V: ...
    def getOpaque(self) -> _AtomicReference__V: ...
    def getPlain(self) -> _AtomicReference__V: ...
    def lazySet(self, newValue: _AtomicReference__V, /) -> None: ...
    def set(self, newValue: _AtomicReference__V, /) -> None: ...
    def setOpaque(self, newValue: _AtomicReference__V, /) -> None: ...
    def setPlain(self, newValue: _AtomicReference__V, /) -> None: ...
    def setRelease(self, newValue: _AtomicReference__V, /) -> None: ...
    def toString(self) -> str: ...
    def updateAndGet(self, updateFunction: java.util.function.UnaryOperator[_AtomicReference__V], /) -> _AtomicReference__V: ...
    def weakCompareAndSet(self, expectedValue: _AtomicReference__V, newValue: _AtomicReference__V, /) -> bool: ...
    def weakCompareAndSetAcquire(self, expectedValue: _AtomicReference__V, newValue: _AtomicReference__V, /) -> bool: ...
    def weakCompareAndSetPlain(self, expectedValue: _AtomicReference__V, newValue: _AtomicReference__V, /) -> bool: ...
    def weakCompareAndSetRelease(self, expectedValue: _AtomicReference__V, newValue: _AtomicReference__V, /) -> bool: ...
    def weakCompareAndSetVolatile(self, expectedValue: _AtomicReference__V, newValue: _AtomicReference__V, /) -> bool: ...

_AtomicReferenceArray__E = typing.TypeVar('_AtomicReferenceArray__E')  # <E>
class AtomicReferenceArray(java.io.Serializable, typing.Generic[_AtomicReferenceArray__E]):
    @typing.overload
    def __init__(self, length: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, array: java.chaquopy.JavaArray[_AtomicReferenceArray__E], /) -> None: ...
    def accumulateAndGet(self, i: int | java.jint | java.lang.Integer, x: _AtomicReferenceArray__E, accumulatorFunction: java.util.function.BinaryOperator[_AtomicReferenceArray__E], /) -> _AtomicReferenceArray__E: ...
    def compareAndExchange(self, i: int | java.jint | java.lang.Integer, expectedValue: _AtomicReferenceArray__E, newValue: _AtomicReferenceArray__E, /) -> _AtomicReferenceArray__E: ...
    def compareAndExchangeAcquire(self, i: int | java.jint | java.lang.Integer, expectedValue: _AtomicReferenceArray__E, newValue: _AtomicReferenceArray__E, /) -> _AtomicReferenceArray__E: ...
    def compareAndExchangeRelease(self, i: int | java.jint | java.lang.Integer, expectedValue: _AtomicReferenceArray__E, newValue: _AtomicReferenceArray__E, /) -> _AtomicReferenceArray__E: ...
    def compareAndSet(self, i: int | java.jint | java.lang.Integer, expectedValue: _AtomicReferenceArray__E, newValue: _AtomicReferenceArray__E, /) -> bool: ...
    def get(self, i: int | java.jint | java.lang.Integer, /) -> _AtomicReferenceArray__E: ...
    def getAcquire(self, i: int | java.jint | java.lang.Integer, /) -> _AtomicReferenceArray__E: ...
    def getAndAccumulate(self, i: int | java.jint | java.lang.Integer, x: _AtomicReferenceArray__E, accumulatorFunction: java.util.function.BinaryOperator[_AtomicReferenceArray__E], /) -> _AtomicReferenceArray__E: ...
    def getAndSet(self, i: int | java.jint | java.lang.Integer, newValue: _AtomicReferenceArray__E, /) -> _AtomicReferenceArray__E: ...
    def getAndUpdate(self, i: int | java.jint | java.lang.Integer, updateFunction: java.util.function.UnaryOperator[_AtomicReferenceArray__E], /) -> _AtomicReferenceArray__E: ...
    def getOpaque(self, i: int | java.jint | java.lang.Integer, /) -> _AtomicReferenceArray__E: ...
    def getPlain(self, i: int | java.jint | java.lang.Integer, /) -> _AtomicReferenceArray__E: ...
    def lazySet(self, i: int | java.jint | java.lang.Integer, newValue: _AtomicReferenceArray__E, /) -> None: ...
    def length(self) -> int: ...
    def set(self, i: int | java.jint | java.lang.Integer, newValue: _AtomicReferenceArray__E, /) -> None: ...
    def setOpaque(self, i: int | java.jint | java.lang.Integer, newValue: _AtomicReferenceArray__E, /) -> None: ...
    def setPlain(self, i: int | java.jint | java.lang.Integer, newValue: _AtomicReferenceArray__E, /) -> None: ...
    def setRelease(self, i: int | java.jint | java.lang.Integer, newValue: _AtomicReferenceArray__E, /) -> None: ...
    def toString(self) -> str: ...
    def updateAndGet(self, i: int | java.jint | java.lang.Integer, updateFunction: java.util.function.UnaryOperator[_AtomicReferenceArray__E], /) -> _AtomicReferenceArray__E: ...
    def weakCompareAndSet(self, i: int | java.jint | java.lang.Integer, expectedValue: _AtomicReferenceArray__E, newValue: _AtomicReferenceArray__E, /) -> bool: ...
    def weakCompareAndSetAcquire(self, i: int | java.jint | java.lang.Integer, expectedValue: _AtomicReferenceArray__E, newValue: _AtomicReferenceArray__E, /) -> bool: ...
    def weakCompareAndSetPlain(self, i: int | java.jint | java.lang.Integer, expectedValue: _AtomicReferenceArray__E, newValue: _AtomicReferenceArray__E, /) -> bool: ...
    def weakCompareAndSetRelease(self, i: int | java.jint | java.lang.Integer, expectedValue: _AtomicReferenceArray__E, newValue: _AtomicReferenceArray__E, /) -> bool: ...
    def weakCompareAndSetVolatile(self, i: int | java.jint | java.lang.Integer, expectedValue: _AtomicReferenceArray__E, newValue: _AtomicReferenceArray__E, /) -> bool: ...

_AtomicReferenceFieldUpdater__T = typing.TypeVar('_AtomicReferenceFieldUpdater__T')  # <T>
_AtomicReferenceFieldUpdater__V = typing.TypeVar('_AtomicReferenceFieldUpdater__V')  # <V>
class AtomicReferenceFieldUpdater(java.lang.Object, typing.Generic[_AtomicReferenceFieldUpdater__T, _AtomicReferenceFieldUpdater__V]):
    def __init__(self) -> None: ...
    def accumulateAndGet(self, obj: _AtomicReferenceFieldUpdater__T, x: _AtomicReferenceFieldUpdater__V, accumulatorFunction: java.util.function.BinaryOperator[_AtomicReferenceFieldUpdater__V], /) -> _AtomicReferenceFieldUpdater__V: ...
    def compareAndSet(self, arg1: _AtomicReferenceFieldUpdater__T, arg2: _AtomicReferenceFieldUpdater__V, arg3: _AtomicReferenceFieldUpdater__V, /) -> bool: ...
    def get(self, arg1: _AtomicReferenceFieldUpdater__T, /) -> _AtomicReferenceFieldUpdater__V: ...
    def getAndAccumulate(self, obj: _AtomicReferenceFieldUpdater__T, x: _AtomicReferenceFieldUpdater__V, accumulatorFunction: java.util.function.BinaryOperator[_AtomicReferenceFieldUpdater__V], /) -> _AtomicReferenceFieldUpdater__V: ...
    def getAndSet(self, obj: _AtomicReferenceFieldUpdater__T, newValue: _AtomicReferenceFieldUpdater__V, /) -> _AtomicReferenceFieldUpdater__V: ...
    def getAndUpdate(self, obj: _AtomicReferenceFieldUpdater__T, updateFunction: java.util.function.UnaryOperator[_AtomicReferenceFieldUpdater__V], /) -> _AtomicReferenceFieldUpdater__V: ...
    def lazySet(self, arg1: _AtomicReferenceFieldUpdater__T, arg2: _AtomicReferenceFieldUpdater__V, /) -> None: ...
    _newUpdater__U = typing.TypeVar('_newUpdater__U')  # <U>
    _newUpdater__W = typing.TypeVar('_newUpdater__W')  # <W>
    @staticmethod
    def newUpdater(tclass: typing.Type[_newUpdater__U], vclass: typing.Type[_newUpdater__W], fieldName: str | java.lang.String, /) -> AtomicReferenceFieldUpdater[_newUpdater__U, _newUpdater__W]: ...
    def set(self, arg1: _AtomicReferenceFieldUpdater__T, arg2: _AtomicReferenceFieldUpdater__V, /) -> None: ...
    def updateAndGet(self, obj: _AtomicReferenceFieldUpdater__T, updateFunction: java.util.function.UnaryOperator[_AtomicReferenceFieldUpdater__V], /) -> _AtomicReferenceFieldUpdater__V: ...
    def weakCompareAndSet(self, arg1: _AtomicReferenceFieldUpdater__T, arg2: _AtomicReferenceFieldUpdater__V, arg3: _AtomicReferenceFieldUpdater__V, /) -> bool: ...

_AtomicStampedReference__V = typing.TypeVar('_AtomicStampedReference__V')  # <V>
class AtomicStampedReference(java.lang.Object, typing.Generic[_AtomicStampedReference__V]):
    def __init__(self, initialRef: _AtomicStampedReference__V, initialStamp: int | java.jint | java.lang.Integer, /) -> None: ...
    def attemptStamp(self, expectedReference: _AtomicStampedReference__V, newStamp: int | java.jint | java.lang.Integer, /) -> bool: ...
    def compareAndSet(self, expectedReference: _AtomicStampedReference__V, newReference: _AtomicStampedReference__V, expectedStamp: int | java.jint | java.lang.Integer, newStamp: int | java.jint | java.lang.Integer, /) -> bool: ...
    def get(self, stampHolder: java.chaquopy.JavaArrayJInt, /) -> _AtomicStampedReference__V: ...
    def getReference(self) -> _AtomicStampedReference__V: ...
    def getStamp(self) -> int: ...
    def set(self, newReference: _AtomicStampedReference__V, newStamp: int | java.jint | java.lang.Integer, /) -> None: ...
    def weakCompareAndSet(self, expectedReference: _AtomicStampedReference__V, newReference: _AtomicStampedReference__V, expectedStamp: int | java.jint | java.lang.Integer, newStamp: int | java.jint | java.lang.Integer, /) -> bool: ...

class DoubleAccumulator(java.lang.Number, java.io.Serializable):
    def __init__(self, accumulatorFunction: java.util.function.DoubleBinaryOperator, identity: float | java.jdouble | java.lang.Double, /) -> None: ...
    def accumulate(self, x: float | java.jdouble | java.lang.Double, /) -> None: ...
    def doubleValue(self) -> float: ...
    def floatValue(self) -> float: ...
    def get(self) -> float: ...
    def getThenReset(self) -> float: ...
    def intValue(self) -> int: ...
    def longValue(self) -> int: ...
    def reset(self) -> None: ...
    def toString(self) -> str: ...

class DoubleAdder(java.lang.Number, java.io.Serializable):
    def __init__(self) -> None: ...
    def add(self, x: float | java.jdouble | java.lang.Double, /) -> None: ...
    def doubleValue(self) -> float: ...
    def floatValue(self) -> float: ...
    def intValue(self) -> int: ...
    def longValue(self) -> int: ...
    def reset(self) -> None: ...
    def sum(self) -> float: ...
    def sumThenReset(self) -> float: ...
    def toString(self) -> str: ...

class LongAccumulator(java.lang.Number, java.io.Serializable):
    def __init__(self, accumulatorFunction: java.util.function.LongBinaryOperator, identity: int | java.jlong | java.lang.Long, /) -> None: ...
    def accumulate(self, x: int | java.jlong | java.lang.Long, /) -> None: ...
    def doubleValue(self) -> float: ...
    def floatValue(self) -> float: ...
    def get(self) -> int: ...
    def getThenReset(self) -> int: ...
    def intValue(self) -> int: ...
    def longValue(self) -> int: ...
    def reset(self) -> None: ...
    def toString(self) -> str: ...

class LongAdder(java.lang.Number, java.io.Serializable):
    def __init__(self) -> None: ...
    def add(self, x: int | java.jlong | java.lang.Long, /) -> None: ...
    def decrement(self) -> None: ...
    def doubleValue(self) -> float: ...
    def floatValue(self) -> float: ...
    def increment(self) -> None: ...
    def intValue(self) -> int: ...
    def longValue(self) -> int: ...
    def reset(self) -> None: ...
    def sum(self) -> int: ...
    def sumThenReset(self) -> int: ...
    def toString(self) -> str: ...
