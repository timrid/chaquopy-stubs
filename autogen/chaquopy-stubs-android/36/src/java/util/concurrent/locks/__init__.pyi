import java
import java.io
import java.lang
import java.util
import java.util.concurrent
import typing



class AbstractOwnableSynchronizer(java.io.Serializable):
    def __init__(self) -> None: ...
    def getExclusiveOwnerThread(self) -> java.lang.Thread: ...
    def setExclusiveOwnerThread(self, thread: java.lang.Thread, /) -> None: ...

class AbstractQueuedLongSynchronizer(AbstractOwnableSynchronizer, java.io.Serializable):
    def __init__(self) -> None: ...
    def acquire(self, arg: int | java.jlong | java.lang.Long, /) -> None: ...
    def acquireInterruptibly(self, arg: int | java.jlong | java.lang.Long, /) -> None: ...
    def acquireShared(self, arg: int | java.jlong | java.lang.Long, /) -> None: ...
    def acquireSharedInterruptibly(self, arg: int | java.jlong | java.lang.Long, /) -> None: ...
    def compareAndSetState(self, expect: int | java.jlong | java.lang.Long, update: int | java.jlong | java.lang.Long, /) -> bool: ...
    def getExclusiveQueuedThreads(self) -> java.util.Collection[java.lang.Thread]: ...
    def getFirstQueuedThread(self) -> java.lang.Thread: ...
    def getQueueLength(self) -> int: ...
    def getQueuedThreads(self) -> java.util.Collection[java.lang.Thread]: ...
    def getSharedQueuedThreads(self) -> java.util.Collection[java.lang.Thread]: ...
    def getState(self) -> int: ...
    def getWaitQueueLength(self, condition: AbstractQueuedLongSynchronizer.ConditionObject, /) -> int: ...
    def getWaitingThreads(self, condition: AbstractQueuedLongSynchronizer.ConditionObject, /) -> java.util.Collection[java.lang.Thread]: ...
    def hasContended(self) -> bool: ...
    def hasQueuedPredecessors(self) -> bool: ...
    def hasQueuedThreads(self) -> bool: ...
    def hasWaiters(self, condition: AbstractQueuedLongSynchronizer.ConditionObject, /) -> bool: ...
    def isHeldExclusively(self) -> bool: ...
    def isQueued(self, thread: java.lang.Thread, /) -> bool: ...
    def owns(self, condition: AbstractQueuedLongSynchronizer.ConditionObject, /) -> bool: ...
    def release(self, arg: int | java.jlong | java.lang.Long, /) -> bool: ...
    def releaseShared(self, arg: int | java.jlong | java.lang.Long, /) -> bool: ...
    def setState(self, newState: int | java.jlong | java.lang.Long, /) -> None: ...
    def toString(self) -> str: ...
    def tryAcquire(self, arg: int | java.jlong | java.lang.Long, /) -> bool: ...
    def tryAcquireNanos(self, arg: int | java.jlong | java.lang.Long, nanosTimeout: int | java.jlong | java.lang.Long, /) -> bool: ...
    def tryAcquireShared(self, arg: int | java.jlong | java.lang.Long, /) -> int: ...
    def tryAcquireSharedNanos(self, arg: int | java.jlong | java.lang.Long, nanosTimeout: int | java.jlong | java.lang.Long, /) -> bool: ...
    def tryRelease(self, arg: int | java.jlong | java.lang.Long, /) -> bool: ...
    def tryReleaseShared(self, arg: int | java.jlong | java.lang.Long, /) -> bool: ...

    class ConditionObject(Condition, java.io.Serializable):
        def __init__(self, this_0: AbstractQueuedLongSynchronizer, /) -> None: ...
        def awaitNanos(self, nanosTimeout: int | java.jlong | java.lang.Long, /) -> int: ...
        def awaitUninterruptibly(self) -> None: ...
        def awaitUntil(self, deadline: java.util.Date, /) -> bool: ...
        @typing.overload
        def await_(self) -> None: ...
        @typing.overload
        def await_(self, time: int | java.jlong | java.lang.Long, unit: java.util.concurrent.TimeUnit, /) -> bool: ...
        def getWaitQueueLength(self) -> int: ...
        def getWaitingThreads(self) -> java.util.Collection[java.lang.Thread]: ...
        def hasWaiters(self) -> bool: ...
        def signal(self) -> None: ...
        def signalAll(self) -> None: ...

class AbstractQueuedSynchronizer(AbstractOwnableSynchronizer, java.io.Serializable):
    def __init__(self) -> None: ...
    def acquire(self, arg: int | java.jint | java.lang.Integer, /) -> None: ...
    def acquireInterruptibly(self, arg: int | java.jint | java.lang.Integer, /) -> None: ...
    def acquireShared(self, arg: int | java.jint | java.lang.Integer, /) -> None: ...
    def acquireSharedInterruptibly(self, arg: int | java.jint | java.lang.Integer, /) -> None: ...
    def compareAndSetState(self, expect: int | java.jint | java.lang.Integer, update: int | java.jint | java.lang.Integer, /) -> bool: ...
    def getExclusiveQueuedThreads(self) -> java.util.Collection[java.lang.Thread]: ...
    def getFirstQueuedThread(self) -> java.lang.Thread: ...
    def getQueueLength(self) -> int: ...
    def getQueuedThreads(self) -> java.util.Collection[java.lang.Thread]: ...
    def getSharedQueuedThreads(self) -> java.util.Collection[java.lang.Thread]: ...
    def getState(self) -> int: ...
    def getWaitQueueLength(self, condition: AbstractQueuedSynchronizer.ConditionObject, /) -> int: ...
    def getWaitingThreads(self, condition: AbstractQueuedSynchronizer.ConditionObject, /) -> java.util.Collection[java.lang.Thread]: ...
    def hasContended(self) -> bool: ...
    def hasQueuedPredecessors(self) -> bool: ...
    def hasQueuedThreads(self) -> bool: ...
    def hasWaiters(self, condition: AbstractQueuedSynchronizer.ConditionObject, /) -> bool: ...
    def isHeldExclusively(self) -> bool: ...
    def isQueued(self, thread: java.lang.Thread, /) -> bool: ...
    def owns(self, condition: AbstractQueuedSynchronizer.ConditionObject, /) -> bool: ...
    def release(self, arg: int | java.jint | java.lang.Integer, /) -> bool: ...
    def releaseShared(self, arg: int | java.jint | java.lang.Integer, /) -> bool: ...
    def setState(self, newState: int | java.jint | java.lang.Integer, /) -> None: ...
    def toString(self) -> str: ...
    def tryAcquire(self, arg: int | java.jint | java.lang.Integer, /) -> bool: ...
    def tryAcquireNanos(self, arg: int | java.jint | java.lang.Integer, nanosTimeout: int | java.jlong | java.lang.Long, /) -> bool: ...
    def tryAcquireShared(self, arg: int | java.jint | java.lang.Integer, /) -> int: ...
    def tryAcquireSharedNanos(self, arg: int | java.jint | java.lang.Integer, nanosTimeout: int | java.jlong | java.lang.Long, /) -> bool: ...
    def tryRelease(self, arg: int | java.jint | java.lang.Integer, /) -> bool: ...
    def tryReleaseShared(self, arg: int | java.jint | java.lang.Integer, /) -> bool: ...

    class ConditionObject(Condition, java.io.Serializable):
        def __init__(self, this_0: AbstractQueuedSynchronizer, /) -> None: ...
        def awaitNanos(self, nanosTimeout: int | java.jlong | java.lang.Long, /) -> int: ...
        def awaitUninterruptibly(self) -> None: ...
        def awaitUntil(self, deadline: java.util.Date, /) -> bool: ...
        @typing.overload
        def await_(self) -> None: ...
        @typing.overload
        def await_(self, time: int | java.jlong | java.lang.Long, unit: java.util.concurrent.TimeUnit, /) -> bool: ...
        def getWaitQueueLength(self) -> int: ...
        def getWaitingThreads(self) -> java.util.Collection[java.lang.Thread]: ...
        def hasWaiters(self) -> bool: ...
        def signal(self) -> None: ...
        def signalAll(self) -> None: ...

class Condition(java.lang.Object):
    def awaitNanos(self, arg1: int | java.jlong | java.lang.Long, /) -> int: ...
    def awaitUninterruptibly(self) -> None: ...
    def awaitUntil(self, arg1: java.util.Date, /) -> bool: ...
    @typing.overload
    def await_(self) -> None: ...
    @typing.overload
    def await_(self, arg1: int | java.jlong | java.lang.Long, arg2: java.util.concurrent.TimeUnit, /) -> bool: ...
    def signal(self) -> None: ...
    def signalAll(self) -> None: ...

class Lock(java.lang.Object):
    def lock(self) -> None: ...
    def lockInterruptibly(self) -> None: ...
    def newCondition(self) -> Condition: ...
    @typing.overload
    def tryLock(self) -> bool: ...
    @typing.overload
    def tryLock(self, arg1: int | java.jlong | java.lang.Long, arg2: java.util.concurrent.TimeUnit, /) -> bool: ...
    def unlock(self) -> None: ...

class LockSupport(java.lang.Object):
    @staticmethod
    def getBlocker(t: java.lang.Thread, /) -> java.lang.Object: ...
    @typing.overload
    @staticmethod
    def park() -> None: ...
    @typing.overload
    @staticmethod
    def park(blocker: java.lang.Object | int | bool | float | str, /) -> None: ...
    @typing.overload
    @staticmethod
    def parkNanos(nanos: int | java.jlong | java.lang.Long, /) -> None: ...
    @typing.overload
    @staticmethod
    def parkNanos(blocker: java.lang.Object | int | bool | float | str, nanos: int | java.jlong | java.lang.Long, /) -> None: ...
    @typing.overload
    @staticmethod
    def parkUntil(deadline: int | java.jlong | java.lang.Long, /) -> None: ...
    @typing.overload
    @staticmethod
    def parkUntil(blocker: java.lang.Object | int | bool | float | str, deadline: int | java.jlong | java.lang.Long, /) -> None: ...
    @staticmethod
    def setCurrentBlocker(blocker: java.lang.Object | int | bool | float | str, /) -> None: ...
    @staticmethod
    def unpark(thread: java.lang.Thread, /) -> None: ...

class ReadWriteLock(java.lang.Object):
    def readLock(self) -> Lock: ...
    def writeLock(self) -> Lock: ...

class ReentrantLock(Lock, java.io.Serializable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, fair: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def getHoldCount(self) -> int: ...
    def getOwner(self) -> java.lang.Thread: ...
    def getQueueLength(self) -> int: ...
    def getQueuedThreads(self) -> java.util.Collection[java.lang.Thread]: ...
    def getWaitQueueLength(self, condition: Condition, /) -> int: ...
    def getWaitingThreads(self, condition: Condition, /) -> java.util.Collection[java.lang.Thread]: ...
    def hasQueuedThread(self, thread: java.lang.Thread, /) -> bool: ...
    def hasQueuedThreads(self) -> bool: ...
    def hasWaiters(self, condition: Condition, /) -> bool: ...
    def isFair(self) -> bool: ...
    def isHeldByCurrentThread(self) -> bool: ...
    def isLocked(self) -> bool: ...
    def lock(self) -> None: ...
    def lockInterruptibly(self) -> None: ...
    def newCondition(self) -> Condition: ...
    def toString(self) -> str: ...
    @typing.overload
    def tryLock(self) -> bool: ...
    @typing.overload
    def tryLock(self, timeout: int | java.jlong | java.lang.Long, unit: java.util.concurrent.TimeUnit, /) -> bool: ...
    def unlock(self) -> None: ...

class ReentrantReadWriteLock(ReadWriteLock, java.io.Serializable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, fair: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def getOwner(self) -> java.lang.Thread: ...
    def getQueueLength(self) -> int: ...
    def getQueuedReaderThreads(self) -> java.util.Collection[java.lang.Thread]: ...
    def getQueuedThreads(self) -> java.util.Collection[java.lang.Thread]: ...
    def getQueuedWriterThreads(self) -> java.util.Collection[java.lang.Thread]: ...
    def getReadHoldCount(self) -> int: ...
    def getReadLockCount(self) -> int: ...
    def getWaitQueueLength(self, condition: Condition, /) -> int: ...
    def getWaitingThreads(self, condition: Condition, /) -> java.util.Collection[java.lang.Thread]: ...
    def getWriteHoldCount(self) -> int: ...
    def hasQueuedThread(self, thread: java.lang.Thread, /) -> bool: ...
    def hasQueuedThreads(self) -> bool: ...
    def hasWaiters(self, condition: Condition, /) -> bool: ...
    def isFair(self) -> bool: ...
    def isWriteLocked(self) -> bool: ...
    def isWriteLockedByCurrentThread(self) -> bool: ...
    def readLock(self) -> ReentrantReadWriteLock.ReadLock: ...
    def toString(self) -> str: ...
    def writeLock(self) -> ReentrantReadWriteLock.WriteLock: ...

    class WriteLock(Lock, java.io.Serializable):
        def __init__(self, lock: ReentrantReadWriteLock, /) -> None: ...
        def getHoldCount(self) -> int: ...
        def isHeldByCurrentThread(self) -> bool: ...
        def lock(self) -> None: ...
        def lockInterruptibly(self) -> None: ...
        def newCondition(self) -> Condition: ...
        def toString(self) -> str: ...
        @typing.overload
        def tryLock(self) -> bool: ...
        @typing.overload
        def tryLock(self, timeout: int | java.jlong | java.lang.Long, unit: java.util.concurrent.TimeUnit, /) -> bool: ...
        def unlock(self) -> None: ...

    class ReadLock(Lock, java.io.Serializable):
        def __init__(self, lock: ReentrantReadWriteLock, /) -> None: ...
        def lock(self) -> None: ...
        def lockInterruptibly(self) -> None: ...
        def newCondition(self) -> Condition: ...
        def toString(self) -> str: ...
        @typing.overload
        def tryLock(self) -> bool: ...
        @typing.overload
        def tryLock(self, timeout: int | java.jlong | java.lang.Long, unit: java.util.concurrent.TimeUnit, /) -> bool: ...
        def unlock(self) -> None: ...

class StampedLock(java.io.Serializable):
    def __init__(self) -> None: ...
    def asReadLock(self) -> Lock: ...
    def asReadWriteLock(self) -> ReadWriteLock: ...
    def asWriteLock(self) -> Lock: ...
    def getReadLockCount(self) -> int: ...
    @staticmethod
    def isLockStamp(stamp: int | java.jlong | java.lang.Long, /) -> bool: ...
    @staticmethod
    def isOptimisticReadStamp(stamp: int | java.jlong | java.lang.Long, /) -> bool: ...
    @staticmethod
    def isReadLockStamp(stamp: int | java.jlong | java.lang.Long, /) -> bool: ...
    def isReadLocked(self) -> bool: ...
    @staticmethod
    def isWriteLockStamp(stamp: int | java.jlong | java.lang.Long, /) -> bool: ...
    def isWriteLocked(self) -> bool: ...
    def readLock(self) -> int: ...
    def readLockInterruptibly(self) -> int: ...
    def toString(self) -> str: ...
    def tryConvertToOptimisticRead(self, stamp: int | java.jlong | java.lang.Long, /) -> int: ...
    def tryConvertToReadLock(self, stamp: int | java.jlong | java.lang.Long, /) -> int: ...
    def tryConvertToWriteLock(self, stamp: int | java.jlong | java.lang.Long, /) -> int: ...
    def tryOptimisticRead(self) -> int: ...
    @typing.overload
    def tryReadLock(self) -> int: ...
    @typing.overload
    def tryReadLock(self, time: int | java.jlong | java.lang.Long, unit: java.util.concurrent.TimeUnit, /) -> int: ...
    def tryUnlockRead(self) -> bool: ...
    def tryUnlockWrite(self) -> bool: ...
    @typing.overload
    def tryWriteLock(self) -> int: ...
    @typing.overload
    def tryWriteLock(self, time: int | java.jlong | java.lang.Long, unit: java.util.concurrent.TimeUnit, /) -> int: ...
    def unlock(self, stamp: int | java.jlong | java.lang.Long, /) -> None: ...
    def unlockRead(self, stamp: int | java.jlong | java.lang.Long, /) -> None: ...
    def unlockWrite(self, stamp: int | java.jlong | java.lang.Long, /) -> None: ...
    def validate(self, stamp: int | java.jlong | java.lang.Long, /) -> bool: ...
    def writeLock(self) -> int: ...
    def writeLockInterruptibly(self) -> int: ...
