import java
import java.chaquopy
import java.lang
import java.util
import java.util.concurrent
import java.util.function
import typing



_BaseStream__T = typing.TypeVar('_BaseStream__T')  # <T>
_BaseStream__S = typing.TypeVar('_BaseStream__S')  # <S>
class BaseStream(java.lang.AutoCloseable, typing.Generic[_BaseStream__T, _BaseStream__S]):
    def close(self) -> None: ...
    def isParallel(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_BaseStream__T]: ...
    def onClose(self, arg1: java.lang.Runnable, /) -> _BaseStream__S: ...
    def parallel(self) -> _BaseStream__S: ...
    def sequential(self) -> _BaseStream__S: ...
    def spliterator(self) -> java.util.Spliterator[_BaseStream__T]: ...
    def unordered(self) -> _BaseStream__S: ...

_Collector__T = typing.TypeVar('_Collector__T')  # <T>
_Collector__A = typing.TypeVar('_Collector__A')  # <A>
_Collector__R = typing.TypeVar('_Collector__R')  # <R>
class Collector(java.lang.Object, typing.Generic[_Collector__T, _Collector__A, _Collector__R]):
    def accumulator(self) -> java.util.function.BiConsumer[_Collector__A, _Collector__T]: ...
    def characteristics(self) -> java.util.Set[Collector.Characteristics]: ...
    def combiner(self) -> java.util.function.BinaryOperator[_Collector__A]: ...
    def finisher(self) -> java.util.function.Function[_Collector__A, _Collector__R]: ...
    _of_0__T = typing.TypeVar('_of_0__T')  # <T>
    _of_0__R = typing.TypeVar('_of_0__R')  # <R>
    _of_1__T = typing.TypeVar('_of_1__T')  # <T>
    _of_1__A = typing.TypeVar('_of_1__A')  # <A>
    _of_1__R = typing.TypeVar('_of_1__R')  # <R>
    @typing.overload
    @staticmethod
    def of(supplier: java.util.function.Supplier[_of_0__R], accumulator: java.util.function.BiConsumer[_of_0__R, _of_0__T], combiner: java.util.function.BinaryOperator[_of_0__R], /, *characteristics: Collector.Characteristics) -> Collector[_of_0__T, _of_0__R, _of_0__R]: ...
    @typing.overload
    @staticmethod
    def of(supplier: java.util.function.Supplier[_of_1__A], accumulator: java.util.function.BiConsumer[_of_1__A, _of_1__T], combiner: java.util.function.BinaryOperator[_of_1__A], finisher: java.util.function.Function[_of_1__A, _of_1__R], /, *characteristics: Collector.Characteristics) -> Collector[_of_1__T, _of_1__A, _of_1__R]: ...
    def supplier(self) -> java.util.function.Supplier[_Collector__A]: ...

    class Characteristics(java.lang.Enum[Collector.Characteristics]):
        CONCURRENT: typing.ClassVar[Collector.Characteristics] = ...
        IDENTITY_FINISH: typing.ClassVar[Collector.Characteristics] = ...
        UNORDERED: typing.ClassVar[Collector.Characteristics] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> Collector.Characteristics: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[Collector.Characteristics]: ...

class Collectors(java.lang.Object):
    _averagingDouble__T = typing.TypeVar('_averagingDouble__T')  # <T>
    @staticmethod
    def averagingDouble(mapper: java.util.function.ToDoubleFunction[_averagingDouble__T], /) -> Collector[_averagingDouble__T, java.lang.Object, java.lang.Double]: ...
    _averagingInt__T = typing.TypeVar('_averagingInt__T')  # <T>
    @staticmethod
    def averagingInt(mapper: java.util.function.ToIntFunction[_averagingInt__T], /) -> Collector[_averagingInt__T, java.lang.Object, java.lang.Double]: ...
    _averagingLong__T = typing.TypeVar('_averagingLong__T')  # <T>
    @staticmethod
    def averagingLong(mapper: java.util.function.ToLongFunction[_averagingLong__T], /) -> Collector[_averagingLong__T, java.lang.Object, java.lang.Double]: ...
    _collectingAndThen__T = typing.TypeVar('_collectingAndThen__T')  # <T>
    _collectingAndThen__A = typing.TypeVar('_collectingAndThen__A')  # <A>
    _collectingAndThen__R = typing.TypeVar('_collectingAndThen__R')  # <R>
    _collectingAndThen__RR = typing.TypeVar('_collectingAndThen__RR')  # <RR>
    @staticmethod
    def collectingAndThen(downstream: Collector[_collectingAndThen__T, _collectingAndThen__A, _collectingAndThen__R], finisher: java.util.function.Function[_collectingAndThen__R, _collectingAndThen__RR], /) -> Collector[_collectingAndThen__T, _collectingAndThen__A, _collectingAndThen__RR]: ...
    @staticmethod
    def counting() -> Collector[java.lang.Object, java.lang.Object, java.lang.Long]: ...
    _filtering__T = typing.TypeVar('_filtering__T')  # <T>
    _filtering__R = typing.TypeVar('_filtering__R')  # <R>
    @staticmethod
    def filtering(predicate: java.util.function.Predicate[_filtering__T], downstream: Collector[_filtering__T, java.lang.Object, _filtering__R], /) -> Collector[_filtering__T, java.lang.Object, _filtering__R]: ...
    _flatMapping__T = typing.TypeVar('_flatMapping__T')  # <T>
    _flatMapping__U = typing.TypeVar('_flatMapping__U')  # <U>
    _flatMapping__R = typing.TypeVar('_flatMapping__R')  # <R>
    @staticmethod
    def flatMapping(mapper: java.util.function.Function[_flatMapping__T, Stream[_flatMapping__U]], downstream: Collector[_flatMapping__U, java.lang.Object, _flatMapping__R], /) -> Collector[_flatMapping__T, java.lang.Object, _flatMapping__R]: ...
    _groupingBy_0__T = typing.TypeVar('_groupingBy_0__T')  # <T>
    _groupingBy_0__K = typing.TypeVar('_groupingBy_0__K')  # <K>
    _groupingBy_1__T = typing.TypeVar('_groupingBy_1__T')  # <T>
    _groupingBy_1__K = typing.TypeVar('_groupingBy_1__K')  # <K>
    _groupingBy_1__D = typing.TypeVar('_groupingBy_1__D')  # <D>
    _groupingBy_2__T = typing.TypeVar('_groupingBy_2__T')  # <T>
    _groupingBy_2__M = typing.TypeVar('_groupingBy_2__M')  # <M>
    @typing.overload
    @staticmethod
    def groupingBy(classifier: java.util.function.Function[_groupingBy_0__T, _groupingBy_0__K], /) -> Collector[_groupingBy_0__T, java.lang.Object, java.util.Map[_groupingBy_0__K, java.util.List[_groupingBy_0__T]]]: ...
    @typing.overload
    @staticmethod
    def groupingBy(classifier: java.util.function.Function[_groupingBy_1__T, _groupingBy_1__K], downstream: Collector[_groupingBy_1__T, java.lang.Object, _groupingBy_1__D], /) -> Collector[_groupingBy_1__T, java.lang.Object, java.util.Map[_groupingBy_1__K, _groupingBy_1__D]]: ...
    @typing.overload
    @staticmethod
    def groupingBy(classifier: java.util.function.Function[_groupingBy_2__T, java.lang.Object], mapFactory: java.util.function.Supplier[_groupingBy_2__M], downstream: Collector[_groupingBy_2__T, java.lang.Object, java.lang.Object], /) -> Collector[_groupingBy_2__T, java.lang.Object, _groupingBy_2__M]: ...
    _groupingByConcurrent_0__T = typing.TypeVar('_groupingByConcurrent_0__T')  # <T>
    _groupingByConcurrent_0__K = typing.TypeVar('_groupingByConcurrent_0__K')  # <K>
    _groupingByConcurrent_1__T = typing.TypeVar('_groupingByConcurrent_1__T')  # <T>
    _groupingByConcurrent_1__K = typing.TypeVar('_groupingByConcurrent_1__K')  # <K>
    _groupingByConcurrent_1__D = typing.TypeVar('_groupingByConcurrent_1__D')  # <D>
    _groupingByConcurrent_2__T = typing.TypeVar('_groupingByConcurrent_2__T')  # <T>
    _groupingByConcurrent_2__M = typing.TypeVar('_groupingByConcurrent_2__M')  # <M>
    @typing.overload
    @staticmethod
    def groupingByConcurrent(classifier: java.util.function.Function[_groupingByConcurrent_0__T, _groupingByConcurrent_0__K], /) -> Collector[_groupingByConcurrent_0__T, java.lang.Object, java.util.concurrent.ConcurrentMap[_groupingByConcurrent_0__K, java.util.List[_groupingByConcurrent_0__T]]]: ...
    @typing.overload
    @staticmethod
    def groupingByConcurrent(classifier: java.util.function.Function[_groupingByConcurrent_1__T, _groupingByConcurrent_1__K], downstream: Collector[_groupingByConcurrent_1__T, java.lang.Object, _groupingByConcurrent_1__D], /) -> Collector[_groupingByConcurrent_1__T, java.lang.Object, java.util.concurrent.ConcurrentMap[_groupingByConcurrent_1__K, _groupingByConcurrent_1__D]]: ...
    @typing.overload
    @staticmethod
    def groupingByConcurrent(classifier: java.util.function.Function[_groupingByConcurrent_2__T, java.lang.Object], mapFactory: java.util.function.Supplier[_groupingByConcurrent_2__M], downstream: Collector[_groupingByConcurrent_2__T, java.lang.Object, java.lang.Object], /) -> Collector[_groupingByConcurrent_2__T, java.lang.Object, _groupingByConcurrent_2__M]: ...
    @typing.overload
    @staticmethod
    def joining() -> Collector[java.lang.CharSequence, java.lang.Object, java.lang.String]: ...
    @typing.overload
    @staticmethod
    def joining(delimiter: java.lang.CharSequence, /) -> Collector[java.lang.CharSequence, java.lang.Object, java.lang.String]: ...
    @typing.overload
    @staticmethod
    def joining(delimiter: java.lang.CharSequence, prefix: java.lang.CharSequence, suffix: java.lang.CharSequence, /) -> Collector[java.lang.CharSequence, java.lang.Object, java.lang.String]: ...
    _mapping__T = typing.TypeVar('_mapping__T')  # <T>
    _mapping__U = typing.TypeVar('_mapping__U')  # <U>
    _mapping__R = typing.TypeVar('_mapping__R')  # <R>
    @staticmethod
    def mapping(mapper: java.util.function.Function[_mapping__T, _mapping__U], downstream: Collector[_mapping__U, java.lang.Object, _mapping__R], /) -> Collector[_mapping__T, java.lang.Object, _mapping__R]: ...
    _maxBy__T = typing.TypeVar('_maxBy__T')  # <T>
    @staticmethod
    def maxBy(comparator: java.util.Comparator[_maxBy__T], /) -> Collector[_maxBy__T, java.lang.Object, java.util.Optional[_maxBy__T]]: ...
    _minBy__T = typing.TypeVar('_minBy__T')  # <T>
    @staticmethod
    def minBy(comparator: java.util.Comparator[_minBy__T], /) -> Collector[_minBy__T, java.lang.Object, java.util.Optional[_minBy__T]]: ...
    _partitioningBy_0__T = typing.TypeVar('_partitioningBy_0__T')  # <T>
    _partitioningBy_1__T = typing.TypeVar('_partitioningBy_1__T')  # <T>
    _partitioningBy_1__D = typing.TypeVar('_partitioningBy_1__D')  # <D>
    @typing.overload
    @staticmethod
    def partitioningBy(predicate: java.util.function.Predicate[_partitioningBy_0__T], /) -> Collector[_partitioningBy_0__T, java.lang.Object, java.util.Map[java.lang.Boolean, java.util.List[_partitioningBy_0__T]]]: ...
    @typing.overload
    @staticmethod
    def partitioningBy(predicate: java.util.function.Predicate[_partitioningBy_1__T], downstream: Collector[_partitioningBy_1__T, java.lang.Object, _partitioningBy_1__D], /) -> Collector[_partitioningBy_1__T, java.lang.Object, java.util.Map[java.lang.Boolean, _partitioningBy_1__D]]: ...
    _reducing_0__T = typing.TypeVar('_reducing_0__T')  # <T>
    _reducing_1__T = typing.TypeVar('_reducing_1__T')  # <T>
    _reducing_2__T = typing.TypeVar('_reducing_2__T')  # <T>
    _reducing_2__U = typing.TypeVar('_reducing_2__U')  # <U>
    @typing.overload
    @staticmethod
    def reducing(op: java.util.function.BinaryOperator[_reducing_0__T], /) -> Collector[_reducing_0__T, java.lang.Object, java.util.Optional[_reducing_0__T]]: ...
    @typing.overload
    @staticmethod
    def reducing(identity: _reducing_1__T, op: java.util.function.BinaryOperator[_reducing_1__T], /) -> Collector[_reducing_1__T, java.lang.Object, _reducing_1__T]: ...
    @typing.overload
    @staticmethod
    def reducing(identity: _reducing_2__U, mapper: java.util.function.Function[_reducing_2__T, _reducing_2__U], op: java.util.function.BinaryOperator[_reducing_2__U], /) -> Collector[_reducing_2__T, java.lang.Object, _reducing_2__U]: ...
    _summarizingDouble__T = typing.TypeVar('_summarizingDouble__T')  # <T>
    @staticmethod
    def summarizingDouble(mapper: java.util.function.ToDoubleFunction[_summarizingDouble__T], /) -> Collector[_summarizingDouble__T, java.lang.Object, java.util.DoubleSummaryStatistics]: ...
    _summarizingInt__T = typing.TypeVar('_summarizingInt__T')  # <T>
    @staticmethod
    def summarizingInt(mapper: java.util.function.ToIntFunction[_summarizingInt__T], /) -> Collector[_summarizingInt__T, java.lang.Object, java.util.IntSummaryStatistics]: ...
    _summarizingLong__T = typing.TypeVar('_summarizingLong__T')  # <T>
    @staticmethod
    def summarizingLong(mapper: java.util.function.ToLongFunction[_summarizingLong__T], /) -> Collector[_summarizingLong__T, java.lang.Object, java.util.LongSummaryStatistics]: ...
    _summingDouble__T = typing.TypeVar('_summingDouble__T')  # <T>
    @staticmethod
    def summingDouble(mapper: java.util.function.ToDoubleFunction[_summingDouble__T], /) -> Collector[_summingDouble__T, java.lang.Object, java.lang.Double]: ...
    _summingInt__T = typing.TypeVar('_summingInt__T')  # <T>
    @staticmethod
    def summingInt(mapper: java.util.function.ToIntFunction[_summingInt__T], /) -> Collector[_summingInt__T, java.lang.Object, java.lang.Integer]: ...
    _summingLong__T = typing.TypeVar('_summingLong__T')  # <T>
    @staticmethod
    def summingLong(mapper: java.util.function.ToLongFunction[_summingLong__T], /) -> Collector[_summingLong__T, java.lang.Object, java.lang.Long]: ...
    _teeing__T = typing.TypeVar('_teeing__T')  # <T>
    _teeing__R1 = typing.TypeVar('_teeing__R1')  # <R1>
    _teeing__R2 = typing.TypeVar('_teeing__R2')  # <R2>
    _teeing__R = typing.TypeVar('_teeing__R')  # <R>
    @staticmethod
    def teeing(downstream1: Collector[_teeing__T, java.lang.Object, _teeing__R1], downstream2: Collector[_teeing__T, java.lang.Object, _teeing__R2], merger: java.util.function.BiFunction[_teeing__R1, _teeing__R2, _teeing__R], /) -> Collector[_teeing__T, java.lang.Object, _teeing__R]: ...
    _toCollection__C = typing.TypeVar('_toCollection__C')  # <C>
    @staticmethod
    def toCollection(collectionFactory: java.util.function.Supplier[_toCollection__C], /) -> Collector[java.lang.Object, java.lang.Object, _toCollection__C]: ...
    _toConcurrentMap_0__T = typing.TypeVar('_toConcurrentMap_0__T')  # <T>
    _toConcurrentMap_0__K = typing.TypeVar('_toConcurrentMap_0__K')  # <K>
    _toConcurrentMap_0__U = typing.TypeVar('_toConcurrentMap_0__U')  # <U>
    _toConcurrentMap_1__T = typing.TypeVar('_toConcurrentMap_1__T')  # <T>
    _toConcurrentMap_1__K = typing.TypeVar('_toConcurrentMap_1__K')  # <K>
    _toConcurrentMap_1__U = typing.TypeVar('_toConcurrentMap_1__U')  # <U>
    _toConcurrentMap_2__T = typing.TypeVar('_toConcurrentMap_2__T')  # <T>
    _toConcurrentMap_2__U = typing.TypeVar('_toConcurrentMap_2__U')  # <U>
    _toConcurrentMap_2__M = typing.TypeVar('_toConcurrentMap_2__M')  # <M>
    @typing.overload
    @staticmethod
    def toConcurrentMap(keyMapper: java.util.function.Function[_toConcurrentMap_0__T, _toConcurrentMap_0__K], valueMapper: java.util.function.Function[_toConcurrentMap_0__T, _toConcurrentMap_0__U], /) -> Collector[_toConcurrentMap_0__T, java.lang.Object, java.util.concurrent.ConcurrentMap[_toConcurrentMap_0__K, _toConcurrentMap_0__U]]: ...
    @typing.overload
    @staticmethod
    def toConcurrentMap(keyMapper: java.util.function.Function[_toConcurrentMap_1__T, _toConcurrentMap_1__K], valueMapper: java.util.function.Function[_toConcurrentMap_1__T, _toConcurrentMap_1__U], mergeFunction: java.util.function.BinaryOperator[_toConcurrentMap_1__U], /) -> Collector[_toConcurrentMap_1__T, java.lang.Object, java.util.concurrent.ConcurrentMap[_toConcurrentMap_1__K, _toConcurrentMap_1__U]]: ...
    @typing.overload
    @staticmethod
    def toConcurrentMap(keyMapper: java.util.function.Function[_toConcurrentMap_2__T, java.lang.Object], valueMapper: java.util.function.Function[_toConcurrentMap_2__T, _toConcurrentMap_2__U], mergeFunction: java.util.function.BinaryOperator[_toConcurrentMap_2__U], mapFactory: java.util.function.Supplier[_toConcurrentMap_2__M], /) -> Collector[_toConcurrentMap_2__T, java.lang.Object, _toConcurrentMap_2__M]: ...
    _toList__T = typing.TypeVar('_toList__T')  # <T>
    @staticmethod
    def toList() -> Collector[_toList__T, java.lang.Object, java.util.List[_toList__T]]: ...
    _toMap_0__T = typing.TypeVar('_toMap_0__T')  # <T>
    _toMap_0__K = typing.TypeVar('_toMap_0__K')  # <K>
    _toMap_0__U = typing.TypeVar('_toMap_0__U')  # <U>
    _toMap_1__T = typing.TypeVar('_toMap_1__T')  # <T>
    _toMap_1__K = typing.TypeVar('_toMap_1__K')  # <K>
    _toMap_1__U = typing.TypeVar('_toMap_1__U')  # <U>
    _toMap_2__T = typing.TypeVar('_toMap_2__T')  # <T>
    _toMap_2__U = typing.TypeVar('_toMap_2__U')  # <U>
    _toMap_2__M = typing.TypeVar('_toMap_2__M')  # <M>
    @typing.overload
    @staticmethod
    def toMap(keyMapper: java.util.function.Function[_toMap_0__T, _toMap_0__K], valueMapper: java.util.function.Function[_toMap_0__T, _toMap_0__U], /) -> Collector[_toMap_0__T, java.lang.Object, java.util.Map[_toMap_0__K, _toMap_0__U]]: ...
    @typing.overload
    @staticmethod
    def toMap(keyMapper: java.util.function.Function[_toMap_1__T, _toMap_1__K], valueMapper: java.util.function.Function[_toMap_1__T, _toMap_1__U], mergeFunction: java.util.function.BinaryOperator[_toMap_1__U], /) -> Collector[_toMap_1__T, java.lang.Object, java.util.Map[_toMap_1__K, _toMap_1__U]]: ...
    @typing.overload
    @staticmethod
    def toMap(keyMapper: java.util.function.Function[_toMap_2__T, java.lang.Object], valueMapper: java.util.function.Function[_toMap_2__T, _toMap_2__U], mergeFunction: java.util.function.BinaryOperator[_toMap_2__U], mapFactory: java.util.function.Supplier[_toMap_2__M], /) -> Collector[_toMap_2__T, java.lang.Object, _toMap_2__M]: ...
    _toSet__T = typing.TypeVar('_toSet__T')  # <T>
    @staticmethod
    def toSet() -> Collector[_toSet__T, java.lang.Object, java.util.Set[_toSet__T]]: ...
    _toUnmodifiableList__T = typing.TypeVar('_toUnmodifiableList__T')  # <T>
    @staticmethod
    def toUnmodifiableList() -> Collector[_toUnmodifiableList__T, java.lang.Object, java.util.List[_toUnmodifiableList__T]]: ...
    _toUnmodifiableMap_0__T = typing.TypeVar('_toUnmodifiableMap_0__T')  # <T>
    _toUnmodifiableMap_0__K = typing.TypeVar('_toUnmodifiableMap_0__K')  # <K>
    _toUnmodifiableMap_0__U = typing.TypeVar('_toUnmodifiableMap_0__U')  # <U>
    _toUnmodifiableMap_1__T = typing.TypeVar('_toUnmodifiableMap_1__T')  # <T>
    _toUnmodifiableMap_1__K = typing.TypeVar('_toUnmodifiableMap_1__K')  # <K>
    _toUnmodifiableMap_1__U = typing.TypeVar('_toUnmodifiableMap_1__U')  # <U>
    @typing.overload
    @staticmethod
    def toUnmodifiableMap(keyMapper: java.util.function.Function[_toUnmodifiableMap_0__T, _toUnmodifiableMap_0__K], valueMapper: java.util.function.Function[_toUnmodifiableMap_0__T, _toUnmodifiableMap_0__U], /) -> Collector[_toUnmodifiableMap_0__T, java.lang.Object, java.util.Map[_toUnmodifiableMap_0__K, _toUnmodifiableMap_0__U]]: ...
    @typing.overload
    @staticmethod
    def toUnmodifiableMap(keyMapper: java.util.function.Function[_toUnmodifiableMap_1__T, _toUnmodifiableMap_1__K], valueMapper: java.util.function.Function[_toUnmodifiableMap_1__T, _toUnmodifiableMap_1__U], mergeFunction: java.util.function.BinaryOperator[_toUnmodifiableMap_1__U], /) -> Collector[_toUnmodifiableMap_1__T, java.lang.Object, java.util.Map[_toUnmodifiableMap_1__K, _toUnmodifiableMap_1__U]]: ...
    _toUnmodifiableSet__T = typing.TypeVar('_toUnmodifiableSet__T')  # <T>
    @staticmethod
    def toUnmodifiableSet() -> Collector[_toUnmodifiableSet__T, java.lang.Object, java.util.Set[_toUnmodifiableSet__T]]: ...

class DoubleStream(BaseStream[java.lang.Double, DoubleStream]):
    def allMatch(self, arg1: java.util.function.DoublePredicate, /) -> bool: ...
    def anyMatch(self, arg1: java.util.function.DoublePredicate, /) -> bool: ...
    def average(self) -> java.util.OptionalDouble: ...
    def boxed(self) -> Stream[java.lang.Double]: ...
    @staticmethod
    def builder() -> DoubleStream.Builder: ...
    _collect__R = typing.TypeVar('_collect__R')  # <R>
    def collect(self, arg1: java.util.function.Supplier[_collect__R], arg2: java.util.function.ObjDoubleConsumer[_collect__R], arg3: java.util.function.BiConsumer[_collect__R, _collect__R], /) -> _collect__R: ...
    @staticmethod
    def concat(a: DoubleStream, b: DoubleStream, /) -> DoubleStream: ...
    def count(self) -> int: ...
    def distinct(self) -> DoubleStream: ...
    def dropWhile(self, predicate: java.util.function.DoublePredicate, /) -> DoubleStream: ...
    @staticmethod
    def empty() -> DoubleStream: ...
    def filter(self, arg1: java.util.function.DoublePredicate, /) -> DoubleStream: ...
    def findAny(self) -> java.util.OptionalDouble: ...
    def findFirst(self) -> java.util.OptionalDouble: ...
    def flatMap(self, arg1: java.util.function.DoubleFunction[DoubleStream], /) -> DoubleStream: ...
    def forEach(self, arg1: java.util.function.DoubleConsumer, /) -> None: ...
    def forEachOrdered(self, arg1: java.util.function.DoubleConsumer, /) -> None: ...
    @staticmethod
    def generate(s: java.util.function.DoubleSupplier, /) -> DoubleStream: ...
    @typing.overload
    @staticmethod
    def iterate(seed: float | java.jdouble | java.lang.Double, f: java.util.function.DoubleUnaryOperator, /) -> DoubleStream: ...
    @typing.overload
    @staticmethod
    def iterate(seed: float | java.jdouble | java.lang.Double, hasNext: java.util.function.DoublePredicate, next: java.util.function.DoubleUnaryOperator, /) -> DoubleStream: ...
    def iterator(self) -> java.util.PrimitiveIterator.OfDouble: ...
    def limit(self, arg1: int | java.jlong | java.lang.Long, /) -> DoubleStream: ...
    def map(self, arg1: java.util.function.DoubleUnaryOperator, /) -> DoubleStream: ...
    def mapMulti(self, mapper: DoubleStream.DoubleMapMultiConsumer, /) -> DoubleStream: ...
    def mapToInt(self, arg1: java.util.function.DoubleToIntFunction, /) -> IntStream: ...
    def mapToLong(self, arg1: java.util.function.DoubleToLongFunction, /) -> LongStream: ...
    _mapToObj__U = typing.TypeVar('_mapToObj__U')  # <U>
    def mapToObj(self, arg1: java.util.function.DoubleFunction[_mapToObj__U], /) -> Stream[_mapToObj__U]: ...
    def max(self) -> java.util.OptionalDouble: ...
    def min(self) -> java.util.OptionalDouble: ...
    def noneMatch(self, arg1: java.util.function.DoublePredicate, /) -> bool: ...
    @typing.overload
    @staticmethod
    def of(t: float | java.jdouble | java.lang.Double, /) -> DoubleStream: ...
    @typing.overload
    @staticmethod
    def of(*values: java.chaquopy.JavaArrayJDouble) -> DoubleStream: ...
    def parallel(self) -> DoubleStream: ...
    def peek(self, arg1: java.util.function.DoubleConsumer, /) -> DoubleStream: ...
    @typing.overload
    def reduce(self, arg1: java.util.function.DoubleBinaryOperator, /) -> java.util.OptionalDouble: ...
    @typing.overload
    def reduce(self, arg1: float | java.jdouble | java.lang.Double, arg2: java.util.function.DoubleBinaryOperator, /) -> float: ...
    def sequential(self) -> DoubleStream: ...
    def skip(self, arg1: int | java.jlong | java.lang.Long, /) -> DoubleStream: ...
    def sorted(self) -> DoubleStream: ...
    def spliterator(self) -> java.util.Spliterator.OfDouble: ...
    def sum(self) -> float: ...
    def summaryStatistics(self) -> java.util.DoubleSummaryStatistics: ...
    def takeWhile(self, predicate: java.util.function.DoublePredicate, /) -> DoubleStream: ...
    def toArray(self) -> java.chaquopy.JavaArrayJDouble: ...

    class DoubleMapMultiConsumer(java.lang.Object):
        def accept(self, arg1: float | java.jdouble | java.lang.Double, arg2: java.util.function.DoubleConsumer, /) -> None: ...

    class Builder(java.util.function.DoubleConsumer):
        def accept(self, arg1: float | java.jdouble | java.lang.Double, /) -> None: ...
        def add(self, t: float | java.jdouble | java.lang.Double, /) -> DoubleStream.Builder: ...
        def build(self) -> DoubleStream: ...

class IntStream(BaseStream[java.lang.Integer, IntStream]):
    def allMatch(self, arg1: java.util.function.IntPredicate, /) -> bool: ...
    def anyMatch(self, arg1: java.util.function.IntPredicate, /) -> bool: ...
    def asDoubleStream(self) -> DoubleStream: ...
    def asLongStream(self) -> LongStream: ...
    def average(self) -> java.util.OptionalDouble: ...
    def boxed(self) -> Stream[java.lang.Integer]: ...
    @staticmethod
    def builder() -> IntStream.Builder: ...
    _collect__R = typing.TypeVar('_collect__R')  # <R>
    def collect(self, arg1: java.util.function.Supplier[_collect__R], arg2: java.util.function.ObjIntConsumer[_collect__R], arg3: java.util.function.BiConsumer[_collect__R, _collect__R], /) -> _collect__R: ...
    @staticmethod
    def concat(a: IntStream, b: IntStream, /) -> IntStream: ...
    def count(self) -> int: ...
    def distinct(self) -> IntStream: ...
    def dropWhile(self, predicate: java.util.function.IntPredicate, /) -> IntStream: ...
    @staticmethod
    def empty() -> IntStream: ...
    def filter(self, arg1: java.util.function.IntPredicate, /) -> IntStream: ...
    def findAny(self) -> java.util.OptionalInt: ...
    def findFirst(self) -> java.util.OptionalInt: ...
    def flatMap(self, arg1: java.util.function.IntFunction[IntStream], /) -> IntStream: ...
    def forEach(self, arg1: java.util.function.IntConsumer, /) -> None: ...
    def forEachOrdered(self, arg1: java.util.function.IntConsumer, /) -> None: ...
    @staticmethod
    def generate(s: java.util.function.IntSupplier, /) -> IntStream: ...
    @typing.overload
    @staticmethod
    def iterate(seed: int | java.jint | java.lang.Integer, f: java.util.function.IntUnaryOperator, /) -> IntStream: ...
    @typing.overload
    @staticmethod
    def iterate(seed: int | java.jint | java.lang.Integer, hasNext: java.util.function.IntPredicate, next: java.util.function.IntUnaryOperator, /) -> IntStream: ...
    def iterator(self) -> java.util.PrimitiveIterator.OfInt: ...
    def limit(self, arg1: int | java.jlong | java.lang.Long, /) -> IntStream: ...
    def map(self, arg1: java.util.function.IntUnaryOperator, /) -> IntStream: ...
    def mapMulti(self, mapper: IntStream.IntMapMultiConsumer, /) -> IntStream: ...
    def mapToDouble(self, arg1: java.util.function.IntToDoubleFunction, /) -> DoubleStream: ...
    def mapToLong(self, arg1: java.util.function.IntToLongFunction, /) -> LongStream: ...
    _mapToObj__U = typing.TypeVar('_mapToObj__U')  # <U>
    def mapToObj(self, arg1: java.util.function.IntFunction[_mapToObj__U], /) -> Stream[_mapToObj__U]: ...
    def max(self) -> java.util.OptionalInt: ...
    def min(self) -> java.util.OptionalInt: ...
    def noneMatch(self, arg1: java.util.function.IntPredicate, /) -> bool: ...
    @typing.overload
    @staticmethod
    def of(t: int | java.jint | java.lang.Integer, /) -> IntStream: ...
    @typing.overload
    @staticmethod
    def of(*values: java.chaquopy.JavaArrayJInt) -> IntStream: ...
    def parallel(self) -> IntStream: ...
    def peek(self, arg1: java.util.function.IntConsumer, /) -> IntStream: ...
    @staticmethod
    def range(startInclusive: int | java.jint | java.lang.Integer, endExclusive: int | java.jint | java.lang.Integer, /) -> IntStream: ...
    @staticmethod
    def rangeClosed(startInclusive: int | java.jint | java.lang.Integer, endInclusive: int | java.jint | java.lang.Integer, /) -> IntStream: ...
    @typing.overload
    def reduce(self, arg1: java.util.function.IntBinaryOperator, /) -> java.util.OptionalInt: ...
    @typing.overload
    def reduce(self, arg1: int | java.jint | java.lang.Integer, arg2: java.util.function.IntBinaryOperator, /) -> int: ...
    def sequential(self) -> IntStream: ...
    def skip(self, arg1: int | java.jlong | java.lang.Long, /) -> IntStream: ...
    def sorted(self) -> IntStream: ...
    def spliterator(self) -> java.util.Spliterator.OfInt: ...
    def sum(self) -> int: ...
    def summaryStatistics(self) -> java.util.IntSummaryStatistics: ...
    def takeWhile(self, predicate: java.util.function.IntPredicate, /) -> IntStream: ...
    def toArray(self) -> java.chaquopy.JavaArrayJInt: ...

    class IntMapMultiConsumer(java.lang.Object):
        def accept(self, arg1: int | java.jint | java.lang.Integer, arg2: java.util.function.IntConsumer, /) -> None: ...

    class Builder(java.util.function.IntConsumer):
        def accept(self, arg1: int | java.jint | java.lang.Integer, /) -> None: ...
        def add(self, t: int | java.jint | java.lang.Integer, /) -> IntStream.Builder: ...
        def build(self) -> IntStream: ...

class LongStream(BaseStream[java.lang.Long, LongStream]):
    def allMatch(self, arg1: java.util.function.LongPredicate, /) -> bool: ...
    def anyMatch(self, arg1: java.util.function.LongPredicate, /) -> bool: ...
    def asDoubleStream(self) -> DoubleStream: ...
    def average(self) -> java.util.OptionalDouble: ...
    def boxed(self) -> Stream[java.lang.Long]: ...
    @staticmethod
    def builder() -> LongStream.Builder: ...
    _collect__R = typing.TypeVar('_collect__R')  # <R>
    def collect(self, arg1: java.util.function.Supplier[_collect__R], arg2: java.util.function.ObjLongConsumer[_collect__R], arg3: java.util.function.BiConsumer[_collect__R, _collect__R], /) -> _collect__R: ...
    @staticmethod
    def concat(a: LongStream, b: LongStream, /) -> LongStream: ...
    def count(self) -> int: ...
    def distinct(self) -> LongStream: ...
    def dropWhile(self, predicate: java.util.function.LongPredicate, /) -> LongStream: ...
    @staticmethod
    def empty() -> LongStream: ...
    def filter(self, arg1: java.util.function.LongPredicate, /) -> LongStream: ...
    def findAny(self) -> java.util.OptionalLong: ...
    def findFirst(self) -> java.util.OptionalLong: ...
    def flatMap(self, arg1: java.util.function.LongFunction[LongStream], /) -> LongStream: ...
    def forEach(self, arg1: java.util.function.LongConsumer, /) -> None: ...
    def forEachOrdered(self, arg1: java.util.function.LongConsumer, /) -> None: ...
    @staticmethod
    def generate(s: java.util.function.LongSupplier, /) -> LongStream: ...
    @typing.overload
    @staticmethod
    def iterate(seed: int | java.jlong | java.lang.Long, f: java.util.function.LongUnaryOperator, /) -> LongStream: ...
    @typing.overload
    @staticmethod
    def iterate(seed: int | java.jlong | java.lang.Long, hasNext: java.util.function.LongPredicate, next: java.util.function.LongUnaryOperator, /) -> LongStream: ...
    def iterator(self) -> java.util.PrimitiveIterator.OfLong: ...
    def limit(self, arg1: int | java.jlong | java.lang.Long, /) -> LongStream: ...
    def map(self, arg1: java.util.function.LongUnaryOperator, /) -> LongStream: ...
    def mapMulti(self, mapper: LongStream.LongMapMultiConsumer, /) -> LongStream: ...
    def mapToDouble(self, arg1: java.util.function.LongToDoubleFunction, /) -> DoubleStream: ...
    def mapToInt(self, arg1: java.util.function.LongToIntFunction, /) -> IntStream: ...
    _mapToObj__U = typing.TypeVar('_mapToObj__U')  # <U>
    def mapToObj(self, arg1: java.util.function.LongFunction[_mapToObj__U], /) -> Stream[_mapToObj__U]: ...
    def max(self) -> java.util.OptionalLong: ...
    def min(self) -> java.util.OptionalLong: ...
    def noneMatch(self, arg1: java.util.function.LongPredicate, /) -> bool: ...
    @typing.overload
    @staticmethod
    def of(t: int | java.jlong | java.lang.Long, /) -> LongStream: ...
    @typing.overload
    @staticmethod
    def of(*values: java.chaquopy.JavaArrayJLong) -> LongStream: ...
    def parallel(self) -> LongStream: ...
    def peek(self, arg1: java.util.function.LongConsumer, /) -> LongStream: ...
    @staticmethod
    def range(startInclusive: int | java.jlong | java.lang.Long, endExclusive: int | java.jlong | java.lang.Long, /) -> LongStream: ...
    @staticmethod
    def rangeClosed(startInclusive: int | java.jlong | java.lang.Long, endInclusive: int | java.jlong | java.lang.Long, /) -> LongStream: ...
    @typing.overload
    def reduce(self, arg1: java.util.function.LongBinaryOperator, /) -> java.util.OptionalLong: ...
    @typing.overload
    def reduce(self, arg1: int | java.jlong | java.lang.Long, arg2: java.util.function.LongBinaryOperator, /) -> int: ...
    def sequential(self) -> LongStream: ...
    def skip(self, arg1: int | java.jlong | java.lang.Long, /) -> LongStream: ...
    def sorted(self) -> LongStream: ...
    def spliterator(self) -> java.util.Spliterator.OfLong: ...
    def sum(self) -> int: ...
    def summaryStatistics(self) -> java.util.LongSummaryStatistics: ...
    def takeWhile(self, predicate: java.util.function.LongPredicate, /) -> LongStream: ...
    def toArray(self) -> java.chaquopy.JavaArrayJLong: ...

    class LongMapMultiConsumer(java.lang.Object):
        def accept(self, arg1: int | java.jlong | java.lang.Long, arg2: java.util.function.LongConsumer, /) -> None: ...

    class Builder(java.util.function.LongConsumer):
        def accept(self, arg1: int | java.jlong | java.lang.Long, /) -> None: ...
        def add(self, t: int | java.jlong | java.lang.Long, /) -> LongStream.Builder: ...
        def build(self) -> LongStream: ...

_Stream__T = typing.TypeVar('_Stream__T')  # <T>

_Stream__Builder__T = typing.TypeVar('_Stream__Builder__T')  # <T>
class Stream(BaseStream[_Stream__T, Stream[_Stream__T]], typing.Generic[_Stream__T]):
    def allMatch(self, arg1: java.util.function.Predicate[_Stream__T], /) -> bool: ...
    def anyMatch(self, arg1: java.util.function.Predicate[_Stream__T], /) -> bool: ...
    @staticmethod
    def builder() -> Stream.Builder[java.lang.Object]: ...
    _collect_0__R = typing.TypeVar('_collect_0__R')  # <R>
    _collect_1__R = typing.TypeVar('_collect_1__R')  # <R>
    @typing.overload
    def collect(self, arg1: Collector[_Stream__T, java.lang.Object, _collect_0__R], /) -> _collect_0__R: ...
    @typing.overload
    def collect(self, arg1: java.util.function.Supplier[_collect_1__R], arg2: java.util.function.BiConsumer[_collect_1__R, _Stream__T], arg3: java.util.function.BiConsumer[_collect_1__R, _collect_1__R], /) -> _collect_1__R: ...
    _concat__T = typing.TypeVar('_concat__T')  # <T>
    @staticmethod
    def concat(a: Stream[_concat__T], b: Stream[_concat__T], /) -> Stream[_concat__T]: ...
    def count(self) -> int: ...
    def distinct(self) -> Stream[_Stream__T]: ...
    def dropWhile(self, predicate: java.util.function.Predicate[_Stream__T], /) -> Stream[_Stream__T]: ...
    @staticmethod
    def empty() -> Stream[java.lang.Object]: ...
    def filter(self, arg1: java.util.function.Predicate[_Stream__T], /) -> Stream[_Stream__T]: ...
    def findAny(self) -> java.util.Optional[_Stream__T]: ...
    def findFirst(self) -> java.util.Optional[_Stream__T]: ...
    _flatMap__R = typing.TypeVar('_flatMap__R')  # <R>
    def flatMap(self, arg1: java.util.function.Function[_Stream__T, Stream[_flatMap__R]], /) -> Stream[_flatMap__R]: ...
    def flatMapToDouble(self, arg1: java.util.function.Function[_Stream__T, DoubleStream], /) -> DoubleStream: ...
    def flatMapToInt(self, arg1: java.util.function.Function[_Stream__T, IntStream], /) -> IntStream: ...
    def flatMapToLong(self, arg1: java.util.function.Function[_Stream__T, LongStream], /) -> LongStream: ...
    def forEach(self, arg1: java.util.function.Consumer[_Stream__T], /) -> None: ...
    def forEachOrdered(self, arg1: java.util.function.Consumer[_Stream__T], /) -> None: ...
    _generate__T = typing.TypeVar('_generate__T')  # <T>
    @staticmethod
    def generate(s: java.util.function.Supplier[_generate__T], /) -> Stream[_generate__T]: ...
    _iterate_0__T = typing.TypeVar('_iterate_0__T')  # <T>
    _iterate_1__T = typing.TypeVar('_iterate_1__T')  # <T>
    @typing.overload
    @staticmethod
    def iterate(seed: _iterate_0__T, f: java.util.function.UnaryOperator[_iterate_0__T], /) -> Stream[_iterate_0__T]: ...
    @typing.overload
    @staticmethod
    def iterate(seed: _iterate_1__T, hasNext: java.util.function.Predicate[_iterate_1__T], next: java.util.function.UnaryOperator[_iterate_1__T], /) -> Stream[_iterate_1__T]: ...
    def limit(self, arg1: int | java.jlong | java.lang.Long, /) -> Stream[_Stream__T]: ...
    _map__R = typing.TypeVar('_map__R')  # <R>
    def map(self, arg1: java.util.function.Function[_Stream__T, _map__R], /) -> Stream[_map__R]: ...
    _mapMulti__R = typing.TypeVar('_mapMulti__R')  # <R>
    def mapMulti(self, mapper: java.util.function.BiConsumer[_Stream__T, java.util.function.Consumer[_mapMulti__R]], /) -> Stream[_mapMulti__R]: ...
    def mapMultiToDouble(self, mapper: java.util.function.BiConsumer[_Stream__T, java.util.function.DoubleConsumer], /) -> DoubleStream: ...
    def mapMultiToInt(self, mapper: java.util.function.BiConsumer[_Stream__T, java.util.function.IntConsumer], /) -> IntStream: ...
    def mapMultiToLong(self, mapper: java.util.function.BiConsumer[_Stream__T, java.util.function.LongConsumer], /) -> LongStream: ...
    def mapToDouble(self, arg1: java.util.function.ToDoubleFunction[_Stream__T], /) -> DoubleStream: ...
    def mapToInt(self, arg1: java.util.function.ToIntFunction[_Stream__T], /) -> IntStream: ...
    def mapToLong(self, arg1: java.util.function.ToLongFunction[_Stream__T], /) -> LongStream: ...
    def max(self, arg1: java.util.Comparator[_Stream__T], /) -> java.util.Optional[_Stream__T]: ...
    def min(self, arg1: java.util.Comparator[_Stream__T], /) -> java.util.Optional[_Stream__T]: ...
    def noneMatch(self, arg1: java.util.function.Predicate[_Stream__T], /) -> bool: ...
    _of_0__T = typing.TypeVar('_of_0__T')  # <T>
    _of_1__T = typing.TypeVar('_of_1__T')  # <T>
    @typing.overload
    @staticmethod
    def of(t: _of_0__T, /) -> Stream[_of_0__T]: ...
    @typing.overload
    @staticmethod
    def of(*values: _of_1__T) -> Stream[_of_1__T]: ...
    _ofNullable__T = typing.TypeVar('_ofNullable__T')  # <T>
    @staticmethod
    def ofNullable(t: _ofNullable__T, /) -> Stream[_ofNullable__T]: ...
    def peek(self, arg1: java.util.function.Consumer[_Stream__T], /) -> Stream[_Stream__T]: ...
    _reduce_2__U = typing.TypeVar('_reduce_2__U')  # <U>
    @typing.overload
    def reduce(self, arg1: java.util.function.BinaryOperator[_Stream__T], /) -> java.util.Optional[_Stream__T]: ...
    @typing.overload
    def reduce(self, arg1: _Stream__T, arg2: java.util.function.BinaryOperator[_Stream__T], /) -> _Stream__T: ...
    @typing.overload
    def reduce(self, arg1: _reduce_2__U, arg2: java.util.function.BiFunction[_reduce_2__U, _Stream__T, _reduce_2__U], arg3: java.util.function.BinaryOperator[_reduce_2__U], /) -> _reduce_2__U: ...
    def skip(self, arg1: int | java.jlong | java.lang.Long, /) -> Stream[_Stream__T]: ...
    @typing.overload
    def sorted(self) -> Stream[_Stream__T]: ...
    @typing.overload
    def sorted(self, arg1: java.util.Comparator[_Stream__T], /) -> Stream[_Stream__T]: ...
    def takeWhile(self, predicate: java.util.function.Predicate[_Stream__T], /) -> Stream[_Stream__T]: ...
    _toArray_1__A = typing.TypeVar('_toArray_1__A')  # <A>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, arg1: java.util.function.IntFunction[java.chaquopy.JavaArray[_toArray_1__A]], /) -> java.chaquopy.JavaArray[_toArray_1__A]: ...
    def toList(self) -> java.util.List[_Stream__T]: ...
    class Builder(java.util.function.Consumer[_Stream__Builder__T], typing.Generic[_Stream__Builder__T]):
        def accept(self, arg1: _Stream__Builder__T, /) -> None: ...
        def add(self, t: _Stream__Builder__T, /) -> Stream.Builder[_Stream__Builder__T]: ...
        def build(self) -> Stream[_Stream__Builder__T]: ...

class StreamSupport(java.lang.Object):
    @typing.overload
    @staticmethod
    def doubleStream(spliterator: java.util.Spliterator.OfDouble, parallel: bool | java.jboolean | java.lang.Boolean, /) -> DoubleStream: ...
    @typing.overload
    @staticmethod
    def doubleStream(supplier: java.util.function.Supplier[java.util.Spliterator.OfDouble], characteristics: int | java.jint | java.lang.Integer, parallel: bool | java.jboolean | java.lang.Boolean, /) -> DoubleStream: ...
    @typing.overload
    @staticmethod
    def intStream(spliterator: java.util.Spliterator.OfInt, parallel: bool | java.jboolean | java.lang.Boolean, /) -> IntStream: ...
    @typing.overload
    @staticmethod
    def intStream(supplier: java.util.function.Supplier[java.util.Spliterator.OfInt], characteristics: int | java.jint | java.lang.Integer, parallel: bool | java.jboolean | java.lang.Boolean, /) -> IntStream: ...
    @typing.overload
    @staticmethod
    def longStream(spliterator: java.util.Spliterator.OfLong, parallel: bool | java.jboolean | java.lang.Boolean, /) -> LongStream: ...
    @typing.overload
    @staticmethod
    def longStream(supplier: java.util.function.Supplier[java.util.Spliterator.OfLong], characteristics: int | java.jint | java.lang.Integer, parallel: bool | java.jboolean | java.lang.Boolean, /) -> LongStream: ...
    _stream_0__T = typing.TypeVar('_stream_0__T')  # <T>
    _stream_1__T = typing.TypeVar('_stream_1__T')  # <T>
    @typing.overload
    @staticmethod
    def stream(spliterator: java.util.Spliterator[_stream_0__T], parallel: bool | java.jboolean | java.lang.Boolean, /) -> Stream[_stream_0__T]: ...
    @typing.overload
    @staticmethod
    def stream(supplier: java.util.function.Supplier[java.util.Spliterator[_stream_1__T]], characteristics: int | java.jint | java.lang.Integer, parallel: bool | java.jboolean | java.lang.Boolean, /) -> Stream[_stream_1__T]: ...
