import java
import java.chaquopy
import java.io
import java.lang
import java.util.function
import java.util.stream
import typing



class MatchResult(java.lang.Object):
    @typing.overload
    def end(self) -> int: ...
    @typing.overload
    def end(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def group(self) -> str: ...
    @typing.overload
    def group(self, arg1: int | java.jint | java.lang.Integer, /) -> str | None: ...
    def groupCount(self) -> int: ...
    @typing.overload
    def start(self) -> int: ...
    @typing.overload
    def start(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...

class Matcher(MatchResult):
    @typing.overload
    def appendReplacement(self, sb: java.lang.StringBuffer, replacement: str | java.lang.String, /) -> Matcher: ...
    @typing.overload
    def appendReplacement(self, sb: java.lang.StringBuilder, replacement: str | java.lang.String, /) -> Matcher: ...
    @typing.overload
    def appendTail(self, sb: java.lang.StringBuffer, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def appendTail(self, sb: java.lang.StringBuilder, /) -> java.lang.StringBuilder: ...
    @typing.overload
    def end(self) -> int: ...
    @typing.overload
    def end(self, group: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def end(self, name: str | java.lang.String, /) -> int: ...
    @typing.overload
    def find(self) -> bool: ...
    @typing.overload
    def find(self, start: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    def group(self) -> str | None: ...
    @typing.overload
    def group(self, group: int | java.jint | java.lang.Integer, /) -> str | None: ...
    @typing.overload
    def group(self, name: str | java.lang.String, /) -> str | None: ...
    def groupCount(self) -> int: ...
    def hasAnchoringBounds(self) -> bool: ...
    def hasTransparentBounds(self) -> bool: ...
    def hitEnd(self) -> bool: ...
    def lookingAt(self) -> bool: ...
    def matches(self) -> bool: ...
    def pattern(self) -> Pattern: ...
    @staticmethod
    def quoteReplacement(s: str | java.lang.String, /) -> str: ...
    def region(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> Matcher: ...
    def regionEnd(self) -> int: ...
    def regionStart(self) -> int: ...
    @typing.overload
    def replaceAll(self, replacement: str | java.lang.String, /) -> str: ...
    @typing.overload
    def replaceAll(self, replacer: java.util.function.Function[MatchResult, java.lang.String], /) -> str: ...
    @typing.overload
    def replaceFirst(self, replacement: str | java.lang.String, /) -> str: ...
    @typing.overload
    def replaceFirst(self, replacer: java.util.function.Function[MatchResult, java.lang.String], /) -> str: ...
    def requireEnd(self) -> bool: ...
    @typing.overload
    def reset(self) -> Matcher: ...
    @typing.overload
    def reset(self, input: java.lang.CharSequence, /) -> Matcher: ...
    def results(self) -> java.util.stream.Stream[MatchResult]: ...
    @typing.overload
    def start(self) -> int: ...
    @typing.overload
    def start(self, group: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def start(self, name: str | java.lang.String, /) -> int: ...
    def toMatchResult(self) -> MatchResult: ...
    def toString(self) -> str: ...
    def useAnchoringBounds(self, b: bool | java.jboolean | java.lang.Boolean, /) -> Matcher: ...
    def usePattern(self, newPattern: Pattern, /) -> Matcher: ...
    def useTransparentBounds(self, b: bool | java.jboolean | java.lang.Boolean, /) -> Matcher: ...

class Pattern(java.io.Serializable):
    CANON_EQ: typing.ClassVar[int] = ...
    CASE_INSENSITIVE: typing.ClassVar[int] = ...
    COMMENTS: typing.ClassVar[int] = ...
    DOTALL: typing.ClassVar[int] = ...
    LITERAL: typing.ClassVar[int] = ...
    MULTILINE: typing.ClassVar[int] = ...
    UNICODE_CASE: typing.ClassVar[int] = ...
    UNICODE_CHARACTER_CLASS: typing.ClassVar[int] = ...
    UNIX_LINES: typing.ClassVar[int] = ...
    def asMatchPredicate(self) -> java.util.function.Predicate[java.lang.String]: ...
    def asPredicate(self) -> java.util.function.Predicate[java.lang.String]: ...
    @typing.overload
    @staticmethod
    def compile(regex: str | java.lang.String, /) -> Pattern: ...
    @typing.overload
    @staticmethod
    def compile(regex: str | java.lang.String, flags: int | java.jint | java.lang.Integer, /) -> Pattern: ...
    def flags(self) -> int: ...
    def matcher(self, input: java.lang.CharSequence, /) -> Matcher: ...
    @staticmethod
    def matches(regex: str | java.lang.String, input: java.lang.CharSequence, /) -> bool: ...
    def pattern(self) -> str: ...
    @staticmethod
    def quote(s: str | java.lang.String, /) -> str: ...
    @typing.overload
    def split(self, input: java.lang.CharSequence, /) -> java.chaquopy.JavaArray[java.lang.String]: ...
    @typing.overload
    def split(self, input: java.lang.CharSequence, limit: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArray[java.lang.String]: ...
    def splitAsStream(self, input: java.lang.CharSequence, /) -> java.util.stream.Stream[java.lang.String]: ...
    def toString(self) -> str: ...

class PatternSyntaxException(java.lang.IllegalArgumentException):
    def __init__(self, desc: str | java.lang.String, regex: str | java.lang.String, index: int | java.jint | java.lang.Integer, /) -> None: ...
    def getDescription(self) -> str: ...
    def getIndex(self) -> int: ...
    def getMessage(self) -> str: ...
    def getPattern(self) -> str: ...
