import java
import java.chaquopy
import java.io
import java.lang
import java.math
import java.nio
import java.nio.channels
import java.nio.charset
import java.nio.file
import java.security
import java.time
import java.util.function
import java.util.random
import java.util.regex
import java.util.stream
import typing



_AbstractCollection__E = typing.TypeVar('_AbstractCollection__E')  # <E>
class AbstractCollection(Collection[_AbstractCollection__E], typing.Generic[_AbstractCollection__E]):
    def __init__(self) -> None: ...
    def add(self, e: _AbstractCollection__E, /) -> bool: ...
    def addAll(self, c: Collection[_AbstractCollection__E], /) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsAll(self, c: Collection[java.lang.Object], /) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_AbstractCollection__E]: ...
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, c: Collection[java.lang.Object], /) -> bool: ...
    def retainAll(self, c: Collection[java.lang.Object], /) -> bool: ...
    def size(self) -> int: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...
    def toString(self) -> str: ...

_AbstractList__E = typing.TypeVar('_AbstractList__E')  # <E>
class AbstractList(AbstractCollection[_AbstractList__E], List[_AbstractList__E], typing.Generic[_AbstractList__E]):
    modCount: int = ...
    def __init__(self) -> None: ...
    @typing.overload
    def add(self, e: _AbstractList__E, /) -> bool: ...
    @typing.overload
    def add(self, index: int | java.jint | java.lang.Integer, element: _AbstractList__E, /) -> None: ...
    def addAll(self, index: int | java.jint | java.lang.Integer, c: Collection[_AbstractList__E], /) -> bool: ...
    def clear(self) -> None: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def get(self, arg1: int | java.jint | java.lang.Integer, /) -> _AbstractList__E: ...
    def hashCode(self) -> int: ...
    def indexOf(self, o: java.lang.Object | int | bool | float | str, /) -> int: ...
    def iterator(self) -> Iterator[_AbstractList__E]: ...
    def lastIndexOf(self, o: java.lang.Object | int | bool | float | str, /) -> int: ...
    @typing.overload
    def listIterator(self) -> ListIterator[_AbstractList__E]: ...
    @typing.overload
    def listIterator(self, index: int | java.jint | java.lang.Integer, /) -> ListIterator[_AbstractList__E]: ...
    def remove(self, index: int | java.jint | java.lang.Integer, /) -> _AbstractList__E: ...
    def removeRange(self, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    def set(self, index: int | java.jint | java.lang.Integer, element: _AbstractList__E, /) -> _AbstractList__E: ...
    def subList(self, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> List[_AbstractList__E]: ...

_AbstractMap__K = typing.TypeVar('_AbstractMap__K')  # <K>
_AbstractMap__V = typing.TypeVar('_AbstractMap__V')  # <V>

_AbstractMap__SimpleImmutableEntry__K = typing.TypeVar('_AbstractMap__SimpleImmutableEntry__K')  # <K>
_AbstractMap__SimpleImmutableEntry__V = typing.TypeVar('_AbstractMap__SimpleImmutableEntry__V')  # <V>

_AbstractMap__SimpleEntry__K = typing.TypeVar('_AbstractMap__SimpleEntry__K')  # <K>
_AbstractMap__SimpleEntry__V = typing.TypeVar('_AbstractMap__SimpleEntry__V')  # <V>
class AbstractMap(Map[_AbstractMap__K, _AbstractMap__V], typing.Generic[_AbstractMap__K, _AbstractMap__V]):
    def __init__(self) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def containsKey(self, key: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsValue(self, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_AbstractMap__K, _AbstractMap__V]]: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def get(self, key: java.lang.Object | int | bool | float | str, /) -> _AbstractMap__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_AbstractMap__K]: ...
    def put(self, key: _AbstractMap__K, value: _AbstractMap__V, /) -> _AbstractMap__V: ...
    def putAll(self, m: Map[_AbstractMap__K, _AbstractMap__V], /) -> None: ...
    def remove(self, key: java.lang.Object | int | bool | float | str, /) -> _AbstractMap__V: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def values(self) -> Collection[_AbstractMap__V]: ...
    class SimpleImmutableEntry(java.util.Map.Entry[_AbstractMap__SimpleImmutableEntry__K, _AbstractMap__SimpleImmutableEntry__V], java.io.Serializable, typing.Generic[_AbstractMap__SimpleImmutableEntry__K, _AbstractMap__SimpleImmutableEntry__V]):
        @typing.overload
        def __init__(self, entry: Map.Entry[_AbstractMap__SimpleImmutableEntry__K, _AbstractMap__SimpleImmutableEntry__V], /) -> None: ...
        @typing.overload
        def __init__(self, key: _AbstractMap__SimpleImmutableEntry__K, value: _AbstractMap__SimpleImmutableEntry__V, /) -> None: ...
        def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
        def getKey(self) -> _AbstractMap__SimpleImmutableEntry__K: ...
        def getValue(self) -> _AbstractMap__SimpleImmutableEntry__V: ...
        def hashCode(self) -> int: ...
        def setValue(self, value: _AbstractMap__SimpleImmutableEntry__V, /) -> _AbstractMap__SimpleImmutableEntry__V: ...
        def toString(self) -> str: ...
    class SimpleEntry(java.util.Map.Entry[_AbstractMap__SimpleEntry__K, _AbstractMap__SimpleEntry__V], java.io.Serializable, typing.Generic[_AbstractMap__SimpleEntry__K, _AbstractMap__SimpleEntry__V]):
        @typing.overload
        def __init__(self, entry: Map.Entry[_AbstractMap__SimpleEntry__K, _AbstractMap__SimpleEntry__V], /) -> None: ...
        @typing.overload
        def __init__(self, key: _AbstractMap__SimpleEntry__K, value: _AbstractMap__SimpleEntry__V, /) -> None: ...
        def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
        def getKey(self) -> _AbstractMap__SimpleEntry__K: ...
        def getValue(self) -> _AbstractMap__SimpleEntry__V: ...
        def hashCode(self) -> int: ...
        def setValue(self, value: _AbstractMap__SimpleEntry__V, /) -> _AbstractMap__SimpleEntry__V: ...
        def toString(self) -> str: ...

_AbstractQueue__E = typing.TypeVar('_AbstractQueue__E')  # <E>
class AbstractQueue(AbstractCollection[_AbstractQueue__E], Queue[_AbstractQueue__E], typing.Generic[_AbstractQueue__E]):
    def __init__(self) -> None: ...
    def add(self, e: _AbstractQueue__E, /) -> bool: ...
    def addAll(self, c: Collection[_AbstractQueue__E], /) -> bool: ...
    def clear(self) -> None: ...
    def element(self) -> _AbstractQueue__E: ...
    def remove(self) -> _AbstractQueue__E: ...

_AbstractSequentialList__E = typing.TypeVar('_AbstractSequentialList__E')  # <E>
class AbstractSequentialList(AbstractList[_AbstractSequentialList__E], typing.Generic[_AbstractSequentialList__E]):
    def __init__(self) -> None: ...
    def add(self, index: int | java.jint | java.lang.Integer, element: _AbstractSequentialList__E, /) -> None: ...
    def addAll(self, index: int | java.jint | java.lang.Integer, c: Collection[_AbstractSequentialList__E], /) -> bool: ...
    def get(self, index: int | java.jint | java.lang.Integer, /) -> _AbstractSequentialList__E: ...
    def iterator(self) -> Iterator[_AbstractSequentialList__E]: ...
    def listIterator(self, arg1: int | java.jint | java.lang.Integer, /) -> ListIterator[_AbstractSequentialList__E]: ...
    def remove(self, index: int | java.jint | java.lang.Integer, /) -> _AbstractSequentialList__E: ...
    def set(self, index: int | java.jint | java.lang.Integer, element: _AbstractSequentialList__E, /) -> _AbstractSequentialList__E: ...

_AbstractSet__E = typing.TypeVar('_AbstractSet__E')  # <E>
class AbstractSet(AbstractCollection[_AbstractSet__E], Set[_AbstractSet__E], typing.Generic[_AbstractSet__E]):
    def __init__(self) -> None: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def hashCode(self) -> int: ...
    def removeAll(self, c: Collection[java.lang.Object], /) -> bool: ...

_ArrayDeque__E = typing.TypeVar('_ArrayDeque__E')  # <E>
class ArrayDeque(AbstractCollection[_ArrayDeque__E], java.lang.Cloneable, Deque[_ArrayDeque__E], java.io.Serializable, typing.Generic[_ArrayDeque__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, numElements: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, c: Collection[_ArrayDeque__E], /) -> None: ...
    def add(self, e: _ArrayDeque__E, /) -> bool: ...
    def addAll(self, c: Collection[_ArrayDeque__E], /) -> bool: ...
    def addFirst(self, e: _ArrayDeque__E, /) -> None: ...
    def addLast(self, e: _ArrayDeque__E, /) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> ArrayDeque[_ArrayDeque__E]: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def descendingIterator(self) -> Iterator[_ArrayDeque__E]: ...
    def element(self) -> _ArrayDeque__E: ...
    def forEach(self, action: java.util.function.Consumer[_ArrayDeque__E], /) -> None: ...
    def getFirst(self) -> _ArrayDeque__E: ...
    def getLast(self) -> _ArrayDeque__E: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_ArrayDeque__E]: ...
    def offer(self, e: _ArrayDeque__E, /) -> bool: ...
    def offerFirst(self, e: _ArrayDeque__E, /) -> bool: ...
    def offerLast(self, e: _ArrayDeque__E, /) -> bool: ...
    def peek(self) -> _ArrayDeque__E | None: ...
    def peekFirst(self) -> _ArrayDeque__E | None: ...
    def peekLast(self) -> _ArrayDeque__E | None: ...
    def poll(self) -> _ArrayDeque__E | None: ...
    def pollFirst(self) -> _ArrayDeque__E | None: ...
    def pollLast(self) -> _ArrayDeque__E | None: ...
    def pop(self) -> _ArrayDeque__E: ...
    def push(self, e: _ArrayDeque__E, /) -> None: ...
    @typing.overload
    def remove(self) -> _ArrayDeque__E: ...
    @typing.overload
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, c: Collection[java.lang.Object], /) -> bool: ...
    def removeFirst(self) -> _ArrayDeque__E: ...
    def removeFirstOccurrence(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeIf(self, filter: java.util.function.Predicate[_ArrayDeque__E], /) -> bool: ...
    def removeLast(self) -> _ArrayDeque__E: ...
    def removeLastOccurrence(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def retainAll(self, c: Collection[java.lang.Object], /) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> Spliterator[_ArrayDeque__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...

_ArrayList__E = typing.TypeVar('_ArrayList__E')  # <E>
class ArrayList(AbstractList[_ArrayList__E], java.lang.Cloneable, List[_ArrayList__E], RandomAccess, java.io.Serializable, typing.Generic[_ArrayList__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, c: Collection[_ArrayList__E], /) -> None: ...
    @typing.overload
    def add(self, e: _ArrayList__E, /) -> bool: ...
    @typing.overload
    def add(self, index: int | java.jint | java.lang.Integer, element: _ArrayList__E, /) -> None: ...
    @typing.overload
    def addAll(self, c: Collection[_ArrayList__E], /) -> bool: ...
    @typing.overload
    def addAll(self, index: int | java.jint | java.lang.Integer, c: Collection[_ArrayList__E], /) -> bool: ...
    def addFirst(self, element: _ArrayList__E, /) -> None: ...
    def addLast(self, element: _ArrayList__E, /) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def ensureCapacity(self, minCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def forEach(self, action: java.util.function.Consumer[_ArrayList__E], /) -> None: ...
    def get(self, index: int | java.jint | java.lang.Integer, /) -> _ArrayList__E: ...
    def getFirst(self) -> _ArrayList__E: ...
    def getLast(self) -> _ArrayList__E: ...
    def hashCode(self) -> int: ...
    def indexOf(self, o: java.lang.Object | int | bool | float | str, /) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_ArrayList__E]: ...
    def lastIndexOf(self, o: java.lang.Object | int | bool | float | str, /) -> int: ...
    @typing.overload
    def listIterator(self) -> ListIterator[_ArrayList__E]: ...
    @typing.overload
    def listIterator(self, index: int | java.jint | java.lang.Integer, /) -> ListIterator[_ArrayList__E]: ...
    @typing.overload
    def remove(self, index: int | java.jint | java.lang.Integer, /) -> _ArrayList__E: ...
    @typing.overload
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, c: Collection[java.lang.Object], /) -> bool: ...
    def removeFirst(self) -> _ArrayList__E: ...
    def removeIf(self, filter: java.util.function.Predicate[_ArrayList__E], /) -> bool: ...
    def removeLast(self) -> _ArrayList__E: ...
    def removeRange(self, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    def replaceAll(self, operator: java.util.function.UnaryOperator[_ArrayList__E], /) -> None: ...
    def retainAll(self, c: Collection[java.lang.Object], /) -> bool: ...
    def set(self, index: int | java.jint | java.lang.Integer, element: _ArrayList__E, /) -> _ArrayList__E: ...
    def size(self) -> int: ...
    def sort(self, c: Comparator[_ArrayList__E], /) -> None: ...
    def spliterator(self) -> Spliterator[_ArrayList__E]: ...
    def subList(self, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> List[_ArrayList__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...
    def trimToSize(self) -> None: ...

class Arrays(java.lang.Object):
    _asList__T = typing.TypeVar('_asList__T')  # <T>
    @staticmethod
    def asList(*a: _asList__T) -> List[_asList__T]: ...
    _binarySearch_8__T = typing.TypeVar('_binarySearch_8__T')  # <T>
    _binarySearch_17__T = typing.TypeVar('_binarySearch_17__T')  # <T>
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArrayJByte, key: int | java.jbyte | java.lang.Byte, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArrayJChar, key: str | java.jchar | java.lang.Character, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArrayJDouble, key: float | java.jdouble | java.lang.Double, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArrayJFloat, key: float | java.jfloat | java.lang.Float, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArrayJInt, key: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArrayJLong, key: int | java.jlong | java.lang.Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArray[java.lang.Object], key: java.lang.Object | int | bool | float | str, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArrayJShort, key: int | java.jshort | java.lang.Short, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArray[_binarySearch_8__T], key: _binarySearch_8__T, c: Comparator[_binarySearch_8__T], /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArrayJByte, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, key: int | java.jbyte | java.lang.Byte, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArrayJChar, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, key: str | java.jchar | java.lang.Character, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArrayJDouble, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, key: float | java.jdouble | java.lang.Double, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArrayJFloat, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, key: float | java.jfloat | java.lang.Float, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArrayJInt, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, key: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArrayJLong, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, key: int | java.jlong | java.lang.Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArray[java.lang.Object], fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, key: java.lang.Object | int | bool | float | str, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArrayJShort, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, key: int | java.jshort | java.lang.Short, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(a: java.chaquopy.JavaArray[_binarySearch_17__T], fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, key: _binarySearch_17__T, c: Comparator[_binarySearch_17__T], /) -> int: ...
    _compare_6__T = typing.TypeVar('_compare_6__T')  # <T>
    _compare_9__T = typing.TypeVar('_compare_9__T')  # <T>
    _compare_16__T = typing.TypeVar('_compare_16__T')  # <T>
    _compare_19__T = typing.TypeVar('_compare_19__T')  # <T>
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArrayJByte, b: java.chaquopy.JavaArrayJByte, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArrayJChar, b: java.chaquopy.JavaArrayJChar, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArrayJDouble, b: java.chaquopy.JavaArrayJDouble, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArrayJFloat, b: java.chaquopy.JavaArrayJFloat, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArrayJInt, b: java.chaquopy.JavaArrayJInt, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArrayJLong, b: java.chaquopy.JavaArrayJLong, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArray[_compare_6__T], b: java.chaquopy.JavaArray[_compare_6__T], /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArrayJShort, b: java.chaquopy.JavaArrayJShort, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArrayJBoolean, b: java.chaquopy.JavaArrayJBoolean, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArray[_compare_9__T], b: java.chaquopy.JavaArray[_compare_9__T], cmp: Comparator[_compare_9__T], /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArrayJByte, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJByte, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArrayJChar, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJChar, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArrayJDouble, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJDouble, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArrayJFloat, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJFloat, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArrayJInt, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJInt, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArrayJLong, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJLong, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArray[_compare_16__T], aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArray[_compare_16__T], bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArrayJShort, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJShort, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArrayJBoolean, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJBoolean, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(a: java.chaquopy.JavaArray[_compare_19__T], aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArray[_compare_19__T], bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, cmp: Comparator[_compare_19__T], /) -> int: ...
    @typing.overload
    @staticmethod
    def compareUnsigned(a: java.chaquopy.JavaArrayJByte, b: java.chaquopy.JavaArrayJByte, /) -> int: ...
    @typing.overload
    @staticmethod
    def compareUnsigned(a: java.chaquopy.JavaArrayJInt, b: java.chaquopy.JavaArrayJInt, /) -> int: ...
    @typing.overload
    @staticmethod
    def compareUnsigned(a: java.chaquopy.JavaArrayJLong, b: java.chaquopy.JavaArrayJLong, /) -> int: ...
    @typing.overload
    @staticmethod
    def compareUnsigned(a: java.chaquopy.JavaArrayJShort, b: java.chaquopy.JavaArrayJShort, /) -> int: ...
    @typing.overload
    @staticmethod
    def compareUnsigned(a: java.chaquopy.JavaArrayJByte, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJByte, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def compareUnsigned(a: java.chaquopy.JavaArrayJInt, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJInt, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def compareUnsigned(a: java.chaquopy.JavaArrayJLong, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJLong, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def compareUnsigned(a: java.chaquopy.JavaArrayJShort, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJShort, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    _copyOf_6__T = typing.TypeVar('_copyOf_6__T')  # <T>
    _copyOf_9__T = typing.TypeVar('_copyOf_9__T')  # <T>
    @typing.overload
    @staticmethod
    def copyOf(original: java.chaquopy.JavaArrayJByte, newLength: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    @staticmethod
    def copyOf(original: java.chaquopy.JavaArrayJChar, newLength: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJChar: ...
    @typing.overload
    @staticmethod
    def copyOf(original: java.chaquopy.JavaArrayJDouble, newLength: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJDouble: ...
    @typing.overload
    @staticmethod
    def copyOf(original: java.chaquopy.JavaArrayJFloat, newLength: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJFloat: ...
    @typing.overload
    @staticmethod
    def copyOf(original: java.chaquopy.JavaArrayJInt, newLength: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJInt: ...
    @typing.overload
    @staticmethod
    def copyOf(original: java.chaquopy.JavaArrayJLong, newLength: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJLong: ...
    @typing.overload
    @staticmethod
    def copyOf(original: java.chaquopy.JavaArray[_copyOf_6__T], newLength: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArray[_copyOf_6__T]: ...
    @typing.overload
    @staticmethod
    def copyOf(original: java.chaquopy.JavaArrayJShort, newLength: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJShort: ...
    @typing.overload
    @staticmethod
    def copyOf(original: java.chaquopy.JavaArrayJBoolean, newLength: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJBoolean: ...
    @typing.overload
    @staticmethod
    def copyOf(original: java.chaquopy.JavaArray[java.lang.Object], newLength: int | java.jint | java.lang.Integer, newType: typing.Type[java.chaquopy.JavaArray[_copyOf_9__T]], /) -> java.chaquopy.JavaArray[_copyOf_9__T]: ...
    _copyOfRange_6__T = typing.TypeVar('_copyOfRange_6__T')  # <T>
    _copyOfRange_9__T = typing.TypeVar('_copyOfRange_9__T')  # <T>
    @typing.overload
    @staticmethod
    def copyOfRange(original: java.chaquopy.JavaArrayJByte, from_: int | java.jint | java.lang.Integer, to: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    @staticmethod
    def copyOfRange(original: java.chaquopy.JavaArrayJChar, from_: int | java.jint | java.lang.Integer, to: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJChar: ...
    @typing.overload
    @staticmethod
    def copyOfRange(original: java.chaquopy.JavaArrayJDouble, from_: int | java.jint | java.lang.Integer, to: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJDouble: ...
    @typing.overload
    @staticmethod
    def copyOfRange(original: java.chaquopy.JavaArrayJFloat, from_: int | java.jint | java.lang.Integer, to: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJFloat: ...
    @typing.overload
    @staticmethod
    def copyOfRange(original: java.chaquopy.JavaArrayJInt, from_: int | java.jint | java.lang.Integer, to: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJInt: ...
    @typing.overload
    @staticmethod
    def copyOfRange(original: java.chaquopy.JavaArrayJLong, from_: int | java.jint | java.lang.Integer, to: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJLong: ...
    @typing.overload
    @staticmethod
    def copyOfRange(original: java.chaquopy.JavaArray[_copyOfRange_6__T], from_: int | java.jint | java.lang.Integer, to: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArray[_copyOfRange_6__T]: ...
    @typing.overload
    @staticmethod
    def copyOfRange(original: java.chaquopy.JavaArrayJShort, from_: int | java.jint | java.lang.Integer, to: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJShort: ...
    @typing.overload
    @staticmethod
    def copyOfRange(original: java.chaquopy.JavaArrayJBoolean, from_: int | java.jint | java.lang.Integer, to: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJBoolean: ...
    @typing.overload
    @staticmethod
    def copyOfRange(original: java.chaquopy.JavaArray[java.lang.Object], from_: int | java.jint | java.lang.Integer, to: int | java.jint | java.lang.Integer, newType: typing.Type[java.chaquopy.JavaArray[_copyOfRange_9__T]], /) -> java.chaquopy.JavaArray[_copyOfRange_9__T]: ...
    @staticmethod
    def deepEquals(a1: java.chaquopy.JavaArray[java.lang.Object], a2: java.chaquopy.JavaArray[java.lang.Object], /) -> bool: ...
    @staticmethod
    def deepHashCode(a: java.chaquopy.JavaArray[java.lang.Object], /) -> int: ...
    @staticmethod
    def deepToString(a: java.chaquopy.JavaArray[java.lang.Object], /) -> str: ...
    _equals_9__T = typing.TypeVar('_equals_9__T')  # <T>
    _equals_19__T = typing.TypeVar('_equals_19__T')  # <T>
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArrayJByte, a2: java.chaquopy.JavaArrayJByte, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArrayJChar, a2: java.chaquopy.JavaArrayJChar, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArrayJDouble, a2: java.chaquopy.JavaArrayJDouble, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArrayJFloat, a2: java.chaquopy.JavaArrayJFloat, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArrayJInt, a2: java.chaquopy.JavaArrayJInt, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArrayJLong, a2: java.chaquopy.JavaArrayJLong, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArray[java.lang.Object], a2: java.chaquopy.JavaArray[java.lang.Object], /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArrayJShort, a2: java.chaquopy.JavaArrayJShort, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArrayJBoolean, a2: java.chaquopy.JavaArrayJBoolean, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArray[_equals_9__T], a2: java.chaquopy.JavaArray[_equals_9__T], cmp: Comparator[_equals_9__T], /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArrayJByte, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJByte, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArrayJChar, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJChar, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArrayJDouble, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJDouble, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArrayJFloat, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJFloat, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArrayJInt, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJInt, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArrayJLong, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJLong, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArray[java.lang.Object], aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArray[java.lang.Object], bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArrayJShort, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJShort, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArrayJBoolean, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJBoolean, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(a: java.chaquopy.JavaArray[_equals_19__T], aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArray[_equals_19__T], bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, cmp: Comparator[_equals_19__T], /) -> bool: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArrayJByte, val: int | java.jbyte | java.lang.Byte, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArrayJChar, val: str | java.jchar | java.lang.Character, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArrayJDouble, val: float | java.jdouble | java.lang.Double, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArrayJFloat, val: float | java.jfloat | java.lang.Float, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArrayJInt, val: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArrayJLong, val: int | java.jlong | java.lang.Long, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArray[java.lang.Object], val: java.lang.Object | int | bool | float | str, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArrayJShort, val: int | java.jshort | java.lang.Short, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArrayJBoolean, val: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArrayJByte, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, val: int | java.jbyte | java.lang.Byte, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArrayJChar, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, val: str | java.jchar | java.lang.Character, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArrayJDouble, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, val: float | java.jdouble | java.lang.Double, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArrayJFloat, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, val: float | java.jfloat | java.lang.Float, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArrayJInt, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, val: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArrayJLong, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, val: int | java.jlong | java.lang.Long, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArray[java.lang.Object], fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, val: java.lang.Object | int | bool | float | str, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArrayJShort, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, val: int | java.jshort | java.lang.Short, /) -> None: ...
    @typing.overload
    @staticmethod
    def fill(a: java.chaquopy.JavaArrayJBoolean, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, val: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    @staticmethod
    def hashCode(a: java.chaquopy.JavaArrayJByte, /) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(a: java.chaquopy.JavaArrayJChar, /) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(a: java.chaquopy.JavaArrayJDouble, /) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(a: java.chaquopy.JavaArrayJFloat, /) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(a: java.chaquopy.JavaArrayJInt, /) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(a: java.chaquopy.JavaArrayJLong, /) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(a: java.chaquopy.JavaArray[java.lang.Object], /) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(a: java.chaquopy.JavaArrayJShort, /) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(a: java.chaquopy.JavaArrayJBoolean, /) -> int: ...
    _mismatch_9__T = typing.TypeVar('_mismatch_9__T')  # <T>
    _mismatch_19__T = typing.TypeVar('_mismatch_19__T')  # <T>
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArrayJByte, b: java.chaquopy.JavaArrayJByte, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArrayJChar, b: java.chaquopy.JavaArrayJChar, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArrayJDouble, b: java.chaquopy.JavaArrayJDouble, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArrayJFloat, b: java.chaquopy.JavaArrayJFloat, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArrayJInt, b: java.chaquopy.JavaArrayJInt, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArrayJLong, b: java.chaquopy.JavaArrayJLong, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArray[java.lang.Object], b: java.chaquopy.JavaArray[java.lang.Object], /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArrayJShort, b: java.chaquopy.JavaArrayJShort, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArrayJBoolean, b: java.chaquopy.JavaArrayJBoolean, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArray[_mismatch_9__T], b: java.chaquopy.JavaArray[_mismatch_9__T], cmp: Comparator[_mismatch_9__T], /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArrayJByte, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJByte, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArrayJChar, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJChar, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArrayJDouble, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJDouble, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArrayJFloat, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJFloat, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArrayJInt, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJInt, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArrayJLong, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJLong, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArray[java.lang.Object], aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArray[java.lang.Object], bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArrayJShort, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJShort, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArrayJBoolean, aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArrayJBoolean, bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def mismatch(a: java.chaquopy.JavaArray[_mismatch_19__T], aFromIndex: int | java.jint | java.lang.Integer, aToIndex: int | java.jint | java.lang.Integer, b: java.chaquopy.JavaArray[_mismatch_19__T], bFromIndex: int | java.jint | java.lang.Integer, bToIndex: int | java.jint | java.lang.Integer, cmp: Comparator[_mismatch_19__T], /) -> int: ...
    _parallelPrefix_3__T = typing.TypeVar('_parallelPrefix_3__T')  # <T>
    _parallelPrefix_7__T = typing.TypeVar('_parallelPrefix_7__T')  # <T>
    @typing.overload
    @staticmethod
    def parallelPrefix(array: java.chaquopy.JavaArrayJDouble, op: java.util.function.DoubleBinaryOperator, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelPrefix(array: java.chaquopy.JavaArrayJInt, op: java.util.function.IntBinaryOperator, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelPrefix(array: java.chaquopy.JavaArrayJLong, op: java.util.function.LongBinaryOperator, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelPrefix(array: java.chaquopy.JavaArray[_parallelPrefix_3__T], op: java.util.function.BinaryOperator[_parallelPrefix_3__T], /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelPrefix(array: java.chaquopy.JavaArrayJDouble, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, op: java.util.function.DoubleBinaryOperator, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelPrefix(array: java.chaquopy.JavaArrayJInt, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, op: java.util.function.IntBinaryOperator, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelPrefix(array: java.chaquopy.JavaArrayJLong, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, op: java.util.function.LongBinaryOperator, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelPrefix(array: java.chaquopy.JavaArray[_parallelPrefix_7__T], fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, op: java.util.function.BinaryOperator[_parallelPrefix_7__T], /) -> None: ...
    _parallelSetAll_3__T = typing.TypeVar('_parallelSetAll_3__T')  # <T>
    @typing.overload
    @staticmethod
    def parallelSetAll(array: java.chaquopy.JavaArrayJDouble, generator: java.util.function.IntToDoubleFunction, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSetAll(array: java.chaquopy.JavaArrayJInt, generator: java.util.function.IntUnaryOperator, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSetAll(array: java.chaquopy.JavaArrayJLong, generator: java.util.function.IntToLongFunction, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSetAll(array: java.chaquopy.JavaArray[_parallelSetAll_3__T], generator: java.util.function.IntFunction[_parallelSetAll_3__T], /) -> None: ...
    _parallelSort_8__T = typing.TypeVar('_parallelSort_8__T')  # <T>
    _parallelSort_17__T = typing.TypeVar('_parallelSort_17__T')  # <T>
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArrayJByte, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArrayJChar, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArrayJDouble, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArrayJFloat, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArrayJInt, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArrayJLong, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArray[java.lang.Object], /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArrayJShort, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArray[_parallelSort_8__T], cmp: Comparator[_parallelSort_8__T], /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArrayJByte, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArrayJChar, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArrayJDouble, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArrayJFloat, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArrayJInt, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArrayJLong, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArray[java.lang.Object], fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArrayJShort, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def parallelSort(a: java.chaquopy.JavaArray[_parallelSort_17__T], fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, cmp: Comparator[_parallelSort_17__T], /) -> None: ...
    _setAll_3__T = typing.TypeVar('_setAll_3__T')  # <T>
    @typing.overload
    @staticmethod
    def setAll(array: java.chaquopy.JavaArrayJDouble, generator: java.util.function.IntToDoubleFunction, /) -> None: ...
    @typing.overload
    @staticmethod
    def setAll(array: java.chaquopy.JavaArrayJInt, generator: java.util.function.IntUnaryOperator, /) -> None: ...
    @typing.overload
    @staticmethod
    def setAll(array: java.chaquopy.JavaArrayJLong, generator: java.util.function.IntToLongFunction, /) -> None: ...
    @typing.overload
    @staticmethod
    def setAll(array: java.chaquopy.JavaArray[_setAll_3__T], generator: java.util.function.IntFunction[_setAll_3__T], /) -> None: ...
    _sort_8__T = typing.TypeVar('_sort_8__T')  # <T>
    _sort_17__T = typing.TypeVar('_sort_17__T')  # <T>
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArrayJByte, /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArrayJChar, /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArrayJDouble, /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArrayJFloat, /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArrayJInt, /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArrayJLong, /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArray[java.lang.Object], /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArrayJShort, /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArray[_sort_8__T], c: Comparator[_sort_8__T], /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArrayJByte, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArrayJChar, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArrayJDouble, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArrayJFloat, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArrayJInt, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArrayJLong, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArray[java.lang.Object], fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArrayJShort, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(a: java.chaquopy.JavaArray[_sort_17__T], fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, c: Comparator[_sort_17__T], /) -> None: ...
    _spliterator_3__T = typing.TypeVar('_spliterator_3__T')  # <T>
    _spliterator_7__T = typing.TypeVar('_spliterator_7__T')  # <T>
    @typing.overload
    @staticmethod
    def spliterator(array: java.chaquopy.JavaArrayJDouble, /) -> Spliterator.OfDouble: ...
    @typing.overload
    @staticmethod
    def spliterator(array: java.chaquopy.JavaArrayJInt, /) -> Spliterator.OfInt: ...
    @typing.overload
    @staticmethod
    def spliterator(array: java.chaquopy.JavaArrayJLong, /) -> Spliterator.OfLong: ...
    @typing.overload
    @staticmethod
    def spliterator(array: java.chaquopy.JavaArray[_spliterator_3__T], /) -> Spliterator[_spliterator_3__T]: ...
    @typing.overload
    @staticmethod
    def spliterator(array: java.chaquopy.JavaArrayJDouble, startInclusive: int | java.jint | java.lang.Integer, endExclusive: int | java.jint | java.lang.Integer, /) -> Spliterator.OfDouble: ...
    @typing.overload
    @staticmethod
    def spliterator(array: java.chaquopy.JavaArrayJInt, startInclusive: int | java.jint | java.lang.Integer, endExclusive: int | java.jint | java.lang.Integer, /) -> Spliterator.OfInt: ...
    @typing.overload
    @staticmethod
    def spliterator(array: java.chaquopy.JavaArrayJLong, startInclusive: int | java.jint | java.lang.Integer, endExclusive: int | java.jint | java.lang.Integer, /) -> Spliterator.OfLong: ...
    @typing.overload
    @staticmethod
    def spliterator(array: java.chaquopy.JavaArray[_spliterator_7__T], startInclusive: int | java.jint | java.lang.Integer, endExclusive: int | java.jint | java.lang.Integer, /) -> Spliterator[_spliterator_7__T]: ...
    _stream_3__T = typing.TypeVar('_stream_3__T')  # <T>
    _stream_7__T = typing.TypeVar('_stream_7__T')  # <T>
    @typing.overload
    @staticmethod
    def stream(array: java.chaquopy.JavaArrayJDouble, /) -> java.util.stream.DoubleStream: ...
    @typing.overload
    @staticmethod
    def stream(array: java.chaquopy.JavaArrayJInt, /) -> java.util.stream.IntStream: ...
    @typing.overload
    @staticmethod
    def stream(array: java.chaquopy.JavaArrayJLong, /) -> java.util.stream.LongStream: ...
    @typing.overload
    @staticmethod
    def stream(array: java.chaquopy.JavaArray[_stream_3__T], /) -> java.util.stream.Stream[_stream_3__T]: ...
    @typing.overload
    @staticmethod
    def stream(array: java.chaquopy.JavaArrayJDouble, startInclusive: int | java.jint | java.lang.Integer, endExclusive: int | java.jint | java.lang.Integer, /) -> java.util.stream.DoubleStream: ...
    @typing.overload
    @staticmethod
    def stream(array: java.chaquopy.JavaArrayJInt, startInclusive: int | java.jint | java.lang.Integer, endExclusive: int | java.jint | java.lang.Integer, /) -> java.util.stream.IntStream: ...
    @typing.overload
    @staticmethod
    def stream(array: java.chaquopy.JavaArrayJLong, startInclusive: int | java.jint | java.lang.Integer, endExclusive: int | java.jint | java.lang.Integer, /) -> java.util.stream.LongStream: ...
    @typing.overload
    @staticmethod
    def stream(array: java.chaquopy.JavaArray[_stream_7__T], startInclusive: int | java.jint | java.lang.Integer, endExclusive: int | java.jint | java.lang.Integer, /) -> java.util.stream.Stream[_stream_7__T]: ...
    @typing.overload
    @staticmethod
    def toString(a: java.chaquopy.JavaArrayJByte, /) -> str: ...
    @typing.overload
    @staticmethod
    def toString(a: java.chaquopy.JavaArrayJChar, /) -> str: ...
    @typing.overload
    @staticmethod
    def toString(a: java.chaquopy.JavaArrayJDouble, /) -> str: ...
    @typing.overload
    @staticmethod
    def toString(a: java.chaquopy.JavaArrayJFloat, /) -> str: ...
    @typing.overload
    @staticmethod
    def toString(a: java.chaquopy.JavaArrayJInt, /) -> str: ...
    @typing.overload
    @staticmethod
    def toString(a: java.chaquopy.JavaArrayJLong, /) -> str: ...
    @typing.overload
    @staticmethod
    def toString(a: java.chaquopy.JavaArray[java.lang.Object], /) -> str: ...
    @typing.overload
    @staticmethod
    def toString(a: java.chaquopy.JavaArrayJShort, /) -> str: ...
    @typing.overload
    @staticmethod
    def toString(a: java.chaquopy.JavaArrayJBoolean, /) -> str: ...

class Base64(java.lang.Object):
    @staticmethod
    def getDecoder() -> Base64.Decoder: ...
    @staticmethod
    def getEncoder() -> Base64.Encoder: ...
    @staticmethod
    def getMimeDecoder() -> Base64.Decoder: ...
    @typing.overload
    @staticmethod
    def getMimeEncoder() -> Base64.Encoder: ...
    @typing.overload
    @staticmethod
    def getMimeEncoder(lineLength: int | java.jint | java.lang.Integer, lineSeparator: java.chaquopy.JavaArrayJByte, /) -> Base64.Encoder: ...
    @staticmethod
    def getUrlDecoder() -> Base64.Decoder: ...
    @staticmethod
    def getUrlEncoder() -> Base64.Encoder: ...

    class Encoder(java.lang.Object):
        @typing.overload
        def encode(self, buffer: java.nio.ByteBuffer, /) -> java.nio.ByteBuffer: ...
        @typing.overload
        def encode(self, src: java.chaquopy.JavaArrayJByte, /) -> java.chaquopy.JavaArrayJByte: ...
        @typing.overload
        def encode(self, src: java.chaquopy.JavaArrayJByte, dst: java.chaquopy.JavaArrayJByte, /) -> int: ...
        def encodeToString(self, src: java.chaquopy.JavaArrayJByte, /) -> str: ...
        def withoutPadding(self) -> Base64.Encoder: ...
        def wrap(self, os: java.io.OutputStream, /) -> java.io.OutputStream: ...

    class Decoder(java.lang.Object):
        @typing.overload
        def decode(self, src: str | java.lang.String, /) -> java.chaquopy.JavaArrayJByte: ...
        @typing.overload
        def decode(self, buffer: java.nio.ByteBuffer, /) -> java.nio.ByteBuffer: ...
        @typing.overload
        def decode(self, src: java.chaquopy.JavaArrayJByte, /) -> java.chaquopy.JavaArrayJByte: ...
        @typing.overload
        def decode(self, src: java.chaquopy.JavaArrayJByte, dst: java.chaquopy.JavaArrayJByte, /) -> int: ...
        def wrap(self, is_: java.io.InputStream, /) -> java.io.InputStream: ...

class BitSet(java.lang.Cloneable, java.io.Serializable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, nbits: int | java.jint | java.lang.Integer, /) -> None: ...
    def andNot(self, set: BitSet, /) -> None: ...
    def and_(self, set: BitSet, /) -> None: ...
    def cardinality(self) -> int: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def clear(self, bitIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def clear(self, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def flip(self, bitIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def flip(self, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def get(self, bitIndex: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    def get(self, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> BitSet: ...
    def hashCode(self) -> int: ...
    def intersects(self, set: BitSet, /) -> bool: ...
    def isEmpty(self) -> bool: ...
    def length(self) -> int: ...
    def nextClearBit(self, fromIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    def nextSetBit(self, fromIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    def or_(self, set: BitSet, /) -> None: ...
    def previousClearBit(self, fromIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    def previousSetBit(self, fromIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def set(self, bitIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def set(self, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def set(self, bitIndex: int | java.jint | java.lang.Integer, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def set(self, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def size(self) -> int: ...
    def stream(self) -> java.util.stream.IntStream: ...
    def toByteArray(self) -> java.chaquopy.JavaArrayJByte: ...
    def toLongArray(self) -> java.chaquopy.JavaArrayJLong: ...
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def valueOf(bb: java.nio.ByteBuffer, /) -> BitSet: ...
    @typing.overload
    @staticmethod
    def valueOf(lb: java.nio.LongBuffer, /) -> BitSet: ...
    @typing.overload
    @staticmethod
    def valueOf(bytes: java.chaquopy.JavaArrayJByte, /) -> BitSet: ...
    @typing.overload
    @staticmethod
    def valueOf(longs: java.chaquopy.JavaArrayJLong, /) -> BitSet: ...
    def xor(self, set: BitSet, /) -> None: ...

class Calendar(java.lang.Cloneable, java.lang.Comparable[Calendar], java.io.Serializable):
    ALL_STYLES: typing.ClassVar[int] = ...
    AM: typing.ClassVar[int] = ...
    AM_PM: typing.ClassVar[int] = ...
    APRIL: typing.ClassVar[int] = ...
    AUGUST: typing.ClassVar[int] = ...
    DATE: typing.ClassVar[int] = ...
    DAY_OF_MONTH: typing.ClassVar[int] = ...
    DAY_OF_WEEK: typing.ClassVar[int] = ...
    DAY_OF_WEEK_IN_MONTH: typing.ClassVar[int] = ...
    DAY_OF_YEAR: typing.ClassVar[int] = ...
    DECEMBER: typing.ClassVar[int] = ...
    DST_OFFSET: typing.ClassVar[int] = ...
    ERA: typing.ClassVar[int] = ...
    FEBRUARY: typing.ClassVar[int] = ...
    FIELD_COUNT: typing.ClassVar[int] = ...
    FRIDAY: typing.ClassVar[int] = ...
    HOUR: typing.ClassVar[int] = ...
    HOUR_OF_DAY: typing.ClassVar[int] = ...
    JANUARY: typing.ClassVar[int] = ...
    JULY: typing.ClassVar[int] = ...
    JUNE: typing.ClassVar[int] = ...
    LONG: typing.ClassVar[int] = ...
    LONG_FORMAT: typing.ClassVar[int] = ...
    LONG_STANDALONE: typing.ClassVar[int] = ...
    MARCH: typing.ClassVar[int] = ...
    MAY: typing.ClassVar[int] = ...
    MILLISECOND: typing.ClassVar[int] = ...
    MINUTE: typing.ClassVar[int] = ...
    MONDAY: typing.ClassVar[int] = ...
    MONTH: typing.ClassVar[int] = ...
    NARROW_FORMAT: typing.ClassVar[int] = ...
    NARROW_STANDALONE: typing.ClassVar[int] = ...
    NOVEMBER: typing.ClassVar[int] = ...
    OCTOBER: typing.ClassVar[int] = ...
    PM: typing.ClassVar[int] = ...
    SATURDAY: typing.ClassVar[int] = ...
    SECOND: typing.ClassVar[int] = ...
    SEPTEMBER: typing.ClassVar[int] = ...
    SHORT: typing.ClassVar[int] = ...
    SHORT_FORMAT: typing.ClassVar[int] = ...
    SHORT_STANDALONE: typing.ClassVar[int] = ...
    SUNDAY: typing.ClassVar[int] = ...
    THURSDAY: typing.ClassVar[int] = ...
    TUESDAY: typing.ClassVar[int] = ...
    UNDECIMBER: typing.ClassVar[int] = ...
    WEDNESDAY: typing.ClassVar[int] = ...
    WEEK_OF_MONTH: typing.ClassVar[int] = ...
    WEEK_OF_YEAR: typing.ClassVar[int] = ...
    YEAR: typing.ClassVar[int] = ...
    ZONE_OFFSET: typing.ClassVar[int] = ...
    areFieldsSet: bool = ...
    fields: java.chaquopy.JavaArrayJInt = ...
    isSet: java.chaquopy.JavaArrayJBoolean = ...
    isTimeSet: bool = ...
    time: int = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, zone: TimeZone, aLocale: Locale, /) -> None: ...
    def add(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, /) -> None: ...
    def after(self, when: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def before(self, when: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def clear(self) -> None: ...
    @typing.overload
    def clear(self, field: int | java.jint | java.lang.Integer, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def compareTo(self, anotherCalendar: Calendar, /) -> int: ...
    def complete(self) -> None: ...
    def computeFields(self) -> None: ...
    def computeTime(self) -> None: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def get(self, field: int | java.jint | java.lang.Integer, /) -> int: ...
    def getActualMaximum(self, field: int | java.jint | java.lang.Integer, /) -> int: ...
    def getActualMinimum(self, field: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def getAvailableCalendarTypes() -> Set[java.lang.String]: ...
    @staticmethod
    def getAvailableLocales() -> java.chaquopy.JavaArray[Locale]: ...
    def getCalendarType(self) -> str: ...
    def getDisplayName(self, field: int | java.jint | java.lang.Integer, style: int | java.jint | java.lang.Integer, locale: Locale, /) -> str: ...
    def getDisplayNames(self, field: int | java.jint | java.lang.Integer, style: int | java.jint | java.lang.Integer, locale: Locale, /) -> Map[java.lang.String, java.lang.Integer]: ...
    def getFirstDayOfWeek(self) -> int: ...
    def getGreatestMinimum(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def getInstance() -> Calendar: ...
    @typing.overload
    @staticmethod
    def getInstance(aLocale: Locale, /) -> Calendar: ...
    @typing.overload
    @staticmethod
    def getInstance(zone: TimeZone, /) -> Calendar: ...
    @typing.overload
    @staticmethod
    def getInstance(zone: TimeZone, aLocale: Locale, /) -> Calendar: ...
    def getLeastMaximum(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def getMaximum(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def getMinimalDaysInFirstWeek(self) -> int: ...
    def getMinimum(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def getTime(self) -> Date: ...
    def getTimeInMillis(self) -> int: ...
    def getTimeZone(self) -> TimeZone: ...
    def getWeekYear(self) -> int: ...
    def getWeeksInWeekYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def internalGet(self, field: int | java.jint | java.lang.Integer, /) -> int: ...
    def isLenient(self) -> bool: ...
    def isSet(self, field: int | java.jint | java.lang.Integer, /) -> bool: ...
    def isWeekDateSupported(self) -> bool: ...
    @typing.overload
    def roll(self, field: int | java.jint | java.lang.Integer, amount: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def roll(self, arg1: int | java.jint | java.lang.Integer, arg2: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def set(self, field: int | java.jint | java.lang.Integer, value: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def set(self, year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, date: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def set(self, year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, date: int | java.jint | java.lang.Integer, hourOfDay: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def set(self, year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, date: int | java.jint | java.lang.Integer, hourOfDay: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, /) -> None: ...
    def setFirstDayOfWeek(self, value: int | java.jint | java.lang.Integer, /) -> None: ...
    def setLenient(self, lenient: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setMinimalDaysInFirstWeek(self, value: int | java.jint | java.lang.Integer, /) -> None: ...
    def setTime(self, date: Date, /) -> None: ...
    def setTimeInMillis(self, millis: int | java.jlong | java.lang.Long, /) -> None: ...
    def setTimeZone(self, value: TimeZone, /) -> None: ...
    def setWeekDate(self, weekYear: int | java.jint | java.lang.Integer, weekOfYear: int | java.jint | java.lang.Integer, dayOfWeek: int | java.jint | java.lang.Integer, /) -> None: ...
    def toInstant(self) -> java.time.Instant: ...
    def toString(self) -> str: ...

    class Builder(java.lang.Object):
        def __init__(self) -> None: ...
        def build(self) -> Calendar: ...
        def set(self, field: int | java.jint | java.lang.Integer, value: int | java.jint | java.lang.Integer, /) -> Calendar.Builder: ...
        def setCalendarType(self, type: str | java.lang.String, /) -> Calendar.Builder: ...
        def setDate(self, year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> Calendar.Builder: ...
        def setFields(self, *fieldValuePairs: java.chaquopy.JavaArrayJInt) -> Calendar.Builder: ...
        @typing.overload
        def setInstant(self, instant: int | java.jlong | java.lang.Long, /) -> Calendar.Builder: ...
        @typing.overload
        def setInstant(self, instant: Date, /) -> Calendar.Builder: ...
        def setLenient(self, lenient: bool | java.jboolean | java.lang.Boolean, /) -> Calendar.Builder: ...
        def setLocale(self, locale: Locale, /) -> Calendar.Builder: ...
        @typing.overload
        def setTimeOfDay(self, hourOfDay: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, /) -> Calendar.Builder: ...
        @typing.overload
        def setTimeOfDay(self, hourOfDay: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, millis: int | java.jint | java.lang.Integer, /) -> Calendar.Builder: ...
        def setTimeZone(self, zone: TimeZone, /) -> Calendar.Builder: ...
        def setWeekDate(self, weekYear: int | java.jint | java.lang.Integer, weekOfYear: int | java.jint | java.lang.Integer, dayOfWeek: int | java.jint | java.lang.Integer, /) -> Calendar.Builder: ...
        def setWeekDefinition(self, firstDayOfWeek: int | java.jint | java.lang.Integer, minimalDaysInFirstWeek: int | java.jint | java.lang.Integer, /) -> Calendar.Builder: ...

_Collection__E = typing.TypeVar('_Collection__E')  # <E>
class Collection(java.lang.Iterable[_Collection__E], typing.Generic[_Collection__E]):
    def add(self, arg1: _Collection__E, /) -> bool: ...
    def addAll(self, arg1: Collection[_Collection__E], /) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsAll(self, arg1: Collection[java.lang.Object], /) -> bool: ...
    def equals(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_Collection__E]: ...
    def parallelStream(self) -> java.util.stream.Stream[_Collection__E]: ...
    def remove(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, arg1: Collection[java.lang.Object], /) -> bool: ...
    def removeIf(self, filter: java.util.function.Predicate[_Collection__E], /) -> bool: ...
    def retainAll(self, arg1: Collection[java.lang.Object], /) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> Spliterator[_Collection__E]: ...
    def stream(self) -> java.util.stream.Stream[_Collection__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    _toArray_2__T = typing.TypeVar('_toArray_2__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, generator: java.util.function.IntFunction[java.chaquopy.JavaArray[_toArray_1__T]], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...
    @typing.overload
    def toArray(self, arg1: java.chaquopy.JavaArray[_toArray_2__T], /) -> java.chaquopy.JavaArray[_toArray_2__T]: ...

class Collections(java.lang.Object):
    EMPTY_LIST: typing.ClassVar[List] = ...
    EMPTY_MAP: typing.ClassVar[Map] = ...
    EMPTY_SET: typing.ClassVar[Set] = ...
    _addAll__T = typing.TypeVar('_addAll__T')  # <T>
    @staticmethod
    def addAll(c: Collection[_addAll__T], /, *elements: _addAll__T) -> bool: ...
    _asLifoQueue__T = typing.TypeVar('_asLifoQueue__T')  # <T>
    @staticmethod
    def asLifoQueue(deque: Deque[_asLifoQueue__T], /) -> Queue[_asLifoQueue__T]: ...
    _binarySearch_0__T = typing.TypeVar('_binarySearch_0__T')  # <T>
    _binarySearch_1__T = typing.TypeVar('_binarySearch_1__T')  # <T>
    @typing.overload
    @staticmethod
    def binarySearch(list: List[java.lang.Comparable[_binarySearch_0__T]], key: _binarySearch_0__T, /) -> int: ...
    @typing.overload
    @staticmethod
    def binarySearch(list: List[_binarySearch_1__T], key: _binarySearch_1__T, c: Comparator[_binarySearch_1__T], /) -> int: ...
    _checkedCollection__E = typing.TypeVar('_checkedCollection__E')  # <E>
    @staticmethod
    def checkedCollection(c: Collection[_checkedCollection__E], type: typing.Type[_checkedCollection__E], /) -> Collection[_checkedCollection__E]: ...
    _checkedList__E = typing.TypeVar('_checkedList__E')  # <E>
    @staticmethod
    def checkedList(list: List[_checkedList__E], type: typing.Type[_checkedList__E], /) -> List[_checkedList__E]: ...
    _checkedMap__K = typing.TypeVar('_checkedMap__K')  # <K>
    _checkedMap__V = typing.TypeVar('_checkedMap__V')  # <V>
    @staticmethod
    def checkedMap(m: Map[_checkedMap__K, _checkedMap__V], keyType: typing.Type[_checkedMap__K], valueType: typing.Type[_checkedMap__V], /) -> Map[_checkedMap__K, _checkedMap__V]: ...
    _checkedNavigableMap__K = typing.TypeVar('_checkedNavigableMap__K')  # <K>
    _checkedNavigableMap__V = typing.TypeVar('_checkedNavigableMap__V')  # <V>
    @staticmethod
    def checkedNavigableMap(m: NavigableMap[_checkedNavigableMap__K, _checkedNavigableMap__V], keyType: typing.Type[_checkedNavigableMap__K], valueType: typing.Type[_checkedNavigableMap__V], /) -> NavigableMap[_checkedNavigableMap__K, _checkedNavigableMap__V]: ...
    _checkedNavigableSet__E = typing.TypeVar('_checkedNavigableSet__E')  # <E>
    @staticmethod
    def checkedNavigableSet(s: NavigableSet[_checkedNavigableSet__E], type: typing.Type[_checkedNavigableSet__E], /) -> NavigableSet[_checkedNavigableSet__E]: ...
    _checkedQueue__E = typing.TypeVar('_checkedQueue__E')  # <E>
    @staticmethod
    def checkedQueue(queue: Queue[_checkedQueue__E], type: typing.Type[_checkedQueue__E], /) -> Queue[_checkedQueue__E]: ...
    _checkedSet__E = typing.TypeVar('_checkedSet__E')  # <E>
    @staticmethod
    def checkedSet(s: Set[_checkedSet__E], type: typing.Type[_checkedSet__E], /) -> Set[_checkedSet__E]: ...
    _checkedSortedMap__K = typing.TypeVar('_checkedSortedMap__K')  # <K>
    _checkedSortedMap__V = typing.TypeVar('_checkedSortedMap__V')  # <V>
    @staticmethod
    def checkedSortedMap(m: SortedMap[_checkedSortedMap__K, _checkedSortedMap__V], keyType: typing.Type[_checkedSortedMap__K], valueType: typing.Type[_checkedSortedMap__V], /) -> SortedMap[_checkedSortedMap__K, _checkedSortedMap__V]: ...
    _checkedSortedSet__E = typing.TypeVar('_checkedSortedSet__E')  # <E>
    @staticmethod
    def checkedSortedSet(s: SortedSet[_checkedSortedSet__E], type: typing.Type[_checkedSortedSet__E], /) -> SortedSet[_checkedSortedSet__E]: ...
    _copy__T = typing.TypeVar('_copy__T')  # <T>
    @staticmethod
    def copy(dest: List[_copy__T], src: List[_copy__T], /) -> None: ...
    @staticmethod
    def disjoint(c1: Collection[java.lang.Object], c2: Collection[java.lang.Object], /) -> bool: ...
    @staticmethod
    def emptyEnumeration() -> Enumeration[java.lang.Object]: ...
    @staticmethod
    def emptyIterator() -> Iterator[java.lang.Object]: ...
    @staticmethod
    def emptyList() -> List[java.lang.Object]: ...
    @staticmethod
    def emptyListIterator() -> ListIterator[java.lang.Object]: ...
    @staticmethod
    def emptyMap() -> Map[java.lang.Object, java.lang.Object]: ...
    @staticmethod
    def emptyNavigableMap() -> NavigableMap[java.lang.Object, java.lang.Object]: ...
    @staticmethod
    def emptyNavigableSet() -> NavigableSet[java.lang.Object]: ...
    @staticmethod
    def emptySet() -> Set[java.lang.Object]: ...
    @staticmethod
    def emptySortedMap() -> SortedMap[java.lang.Object, java.lang.Object]: ...
    @staticmethod
    def emptySortedSet() -> SortedSet[java.lang.Object]: ...
    _enumeration__T = typing.TypeVar('_enumeration__T')  # <T>
    @staticmethod
    def enumeration(c: Collection[_enumeration__T], /) -> Enumeration[_enumeration__T]: ...
    _fill__T = typing.TypeVar('_fill__T')  # <T>
    @staticmethod
    def fill(list: List[_fill__T], obj: _fill__T, /) -> None: ...
    @staticmethod
    def frequency(c: Collection[java.lang.Object], o: java.lang.Object | int | bool | float | str, /) -> int: ...
    @staticmethod
    def indexOfSubList(source: List[java.lang.Object], target: List[java.lang.Object], /) -> int: ...
    @staticmethod
    def lastIndexOfSubList(source: List[java.lang.Object], target: List[java.lang.Object], /) -> int: ...
    _list__T = typing.TypeVar('_list__T')  # <T>
    @staticmethod
    def list(e: Enumeration[_list__T], /) -> ArrayList[_list__T]: ...
    _max_0__T = typing.TypeVar('_max_0__T')  # <T>
    _max_1__T = typing.TypeVar('_max_1__T')  # <T>
    @typing.overload
    @staticmethod
    def max(coll: Collection[_max_0__T], /) -> _max_0__T: ...
    @typing.overload
    @staticmethod
    def max(coll: Collection[_max_1__T], comp: Comparator[_max_1__T], /) -> _max_1__T: ...
    _min_0__T = typing.TypeVar('_min_0__T')  # <T>
    _min_1__T = typing.TypeVar('_min_1__T')  # <T>
    @typing.overload
    @staticmethod
    def min(coll: Collection[_min_0__T], /) -> _min_0__T: ...
    @typing.overload
    @staticmethod
    def min(coll: Collection[_min_1__T], comp: Comparator[_min_1__T], /) -> _min_1__T: ...
    _nCopies__T = typing.TypeVar('_nCopies__T')  # <T>
    @staticmethod
    def nCopies(n: int | java.jint | java.lang.Integer, o: _nCopies__T, /) -> List[_nCopies__T]: ...
    _newSequencedSetFromMap__E = typing.TypeVar('_newSequencedSetFromMap__E')  # <E>
    @staticmethod
    def newSequencedSetFromMap(map: SequencedMap[_newSequencedSetFromMap__E, java.lang.Boolean], /) -> SequencedSet[_newSequencedSetFromMap__E]: ...
    _newSetFromMap__E = typing.TypeVar('_newSetFromMap__E')  # <E>
    @staticmethod
    def newSetFromMap(map: Map[_newSetFromMap__E, java.lang.Boolean], /) -> Set[_newSetFromMap__E]: ...
    _replaceAll__T = typing.TypeVar('_replaceAll__T')  # <T>
    @staticmethod
    def replaceAll(list: List[_replaceAll__T], oldVal: _replaceAll__T, newVal: _replaceAll__T, /) -> bool: ...
    @staticmethod
    def reverse(list: List[java.lang.Object], /) -> None: ...
    _reverseOrder_1__T = typing.TypeVar('_reverseOrder_1__T')  # <T>
    @typing.overload
    @staticmethod
    def reverseOrder() -> Comparator[java.lang.Object]: ...
    @typing.overload
    @staticmethod
    def reverseOrder(cmp: Comparator[_reverseOrder_1__T], /) -> Comparator[_reverseOrder_1__T]: ...
    @staticmethod
    def rotate(list: List[java.lang.Object], distance: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def shuffle(list: List[java.lang.Object], /) -> None: ...
    @typing.overload
    @staticmethod
    def shuffle(list: List[java.lang.Object], rnd: Random, /) -> None: ...
    @typing.overload
    @staticmethod
    def shuffle(list: List[java.lang.Object], rnd: java.util.random.RandomGenerator, /) -> None: ...
    _singleton__T = typing.TypeVar('_singleton__T')  # <T>
    @staticmethod
    def singleton(o: _singleton__T, /) -> Set[_singleton__T]: ...
    _singletonList__T = typing.TypeVar('_singletonList__T')  # <T>
    @staticmethod
    def singletonList(o: _singletonList__T, /) -> List[_singletonList__T]: ...
    _singletonMap__K = typing.TypeVar('_singletonMap__K')  # <K>
    _singletonMap__V = typing.TypeVar('_singletonMap__V')  # <V>
    @staticmethod
    def singletonMap(key: _singletonMap__K, value: _singletonMap__V, /) -> Map[_singletonMap__K, _singletonMap__V]: ...
    _sort_1__T = typing.TypeVar('_sort_1__T')  # <T>
    @typing.overload
    @staticmethod
    def sort(list: List[java.lang.Object], /) -> None: ...
    @typing.overload
    @staticmethod
    def sort(list: List[_sort_1__T], c: Comparator[_sort_1__T], /) -> None: ...
    @staticmethod
    def swap(list: List[java.lang.Object], i: int | java.jint | java.lang.Integer, j: int | java.jint | java.lang.Integer, /) -> None: ...
    _synchronizedCollection__T = typing.TypeVar('_synchronizedCollection__T')  # <T>
    @staticmethod
    def synchronizedCollection(c: Collection[_synchronizedCollection__T], /) -> Collection[_synchronizedCollection__T]: ...
    _synchronizedList__T = typing.TypeVar('_synchronizedList__T')  # <T>
    @staticmethod
    def synchronizedList(list: List[_synchronizedList__T], /) -> List[_synchronizedList__T]: ...
    _synchronizedMap__K = typing.TypeVar('_synchronizedMap__K')  # <K>
    _synchronizedMap__V = typing.TypeVar('_synchronizedMap__V')  # <V>
    @staticmethod
    def synchronizedMap(m: Map[_synchronizedMap__K, _synchronizedMap__V], /) -> Map[_synchronizedMap__K, _synchronizedMap__V]: ...
    _synchronizedNavigableMap__K = typing.TypeVar('_synchronizedNavigableMap__K')  # <K>
    _synchronizedNavigableMap__V = typing.TypeVar('_synchronizedNavigableMap__V')  # <V>
    @staticmethod
    def synchronizedNavigableMap(m: NavigableMap[_synchronizedNavigableMap__K, _synchronizedNavigableMap__V], /) -> NavigableMap[_synchronizedNavigableMap__K, _synchronizedNavigableMap__V]: ...
    _synchronizedNavigableSet__T = typing.TypeVar('_synchronizedNavigableSet__T')  # <T>
    @staticmethod
    def synchronizedNavigableSet(s: NavigableSet[_synchronizedNavigableSet__T], /) -> NavigableSet[_synchronizedNavigableSet__T]: ...
    _synchronizedSet__T = typing.TypeVar('_synchronizedSet__T')  # <T>
    @staticmethod
    def synchronizedSet(s: Set[_synchronizedSet__T], /) -> Set[_synchronizedSet__T]: ...
    _synchronizedSortedMap__K = typing.TypeVar('_synchronizedSortedMap__K')  # <K>
    _synchronizedSortedMap__V = typing.TypeVar('_synchronizedSortedMap__V')  # <V>
    @staticmethod
    def synchronizedSortedMap(m: SortedMap[_synchronizedSortedMap__K, _synchronizedSortedMap__V], /) -> SortedMap[_synchronizedSortedMap__K, _synchronizedSortedMap__V]: ...
    _synchronizedSortedSet__T = typing.TypeVar('_synchronizedSortedSet__T')  # <T>
    @staticmethod
    def synchronizedSortedSet(s: SortedSet[_synchronizedSortedSet__T], /) -> SortedSet[_synchronizedSortedSet__T]: ...
    _unmodifiableCollection__T = typing.TypeVar('_unmodifiableCollection__T')  # <T>
    @staticmethod
    def unmodifiableCollection(c: Collection[_unmodifiableCollection__T], /) -> Collection[_unmodifiableCollection__T]: ...
    _unmodifiableList__T = typing.TypeVar('_unmodifiableList__T')  # <T>
    @staticmethod
    def unmodifiableList(list: List[_unmodifiableList__T], /) -> List[_unmodifiableList__T]: ...
    _unmodifiableMap__K = typing.TypeVar('_unmodifiableMap__K')  # <K>
    _unmodifiableMap__V = typing.TypeVar('_unmodifiableMap__V')  # <V>
    @staticmethod
    def unmodifiableMap(m: Map[_unmodifiableMap__K, _unmodifiableMap__V], /) -> Map[_unmodifiableMap__K, _unmodifiableMap__V]: ...
    _unmodifiableNavigableMap__K = typing.TypeVar('_unmodifiableNavigableMap__K')  # <K>
    _unmodifiableNavigableMap__V = typing.TypeVar('_unmodifiableNavigableMap__V')  # <V>
    @staticmethod
    def unmodifiableNavigableMap(m: NavigableMap[_unmodifiableNavigableMap__K, _unmodifiableNavigableMap__V], /) -> NavigableMap[_unmodifiableNavigableMap__K, _unmodifiableNavigableMap__V]: ...
    _unmodifiableNavigableSet__T = typing.TypeVar('_unmodifiableNavigableSet__T')  # <T>
    @staticmethod
    def unmodifiableNavigableSet(s: NavigableSet[_unmodifiableNavigableSet__T], /) -> NavigableSet[_unmodifiableNavigableSet__T]: ...
    _unmodifiableSequencedCollection__T = typing.TypeVar('_unmodifiableSequencedCollection__T')  # <T>
    @staticmethod
    def unmodifiableSequencedCollection(c: SequencedCollection[_unmodifiableSequencedCollection__T], /) -> SequencedCollection[_unmodifiableSequencedCollection__T]: ...
    _unmodifiableSequencedMap__K = typing.TypeVar('_unmodifiableSequencedMap__K')  # <K>
    _unmodifiableSequencedMap__V = typing.TypeVar('_unmodifiableSequencedMap__V')  # <V>
    @staticmethod
    def unmodifiableSequencedMap(m: SequencedMap[_unmodifiableSequencedMap__K, _unmodifiableSequencedMap__V], /) -> SequencedMap[_unmodifiableSequencedMap__K, _unmodifiableSequencedMap__V]: ...
    _unmodifiableSequencedSet__T = typing.TypeVar('_unmodifiableSequencedSet__T')  # <T>
    @staticmethod
    def unmodifiableSequencedSet(s: SequencedSet[_unmodifiableSequencedSet__T], /) -> SequencedSet[_unmodifiableSequencedSet__T]: ...
    _unmodifiableSet__T = typing.TypeVar('_unmodifiableSet__T')  # <T>
    @staticmethod
    def unmodifiableSet(s: Set[_unmodifiableSet__T], /) -> Set[_unmodifiableSet__T]: ...
    _unmodifiableSortedMap__K = typing.TypeVar('_unmodifiableSortedMap__K')  # <K>
    _unmodifiableSortedMap__V = typing.TypeVar('_unmodifiableSortedMap__V')  # <V>
    @staticmethod
    def unmodifiableSortedMap(m: SortedMap[_unmodifiableSortedMap__K, _unmodifiableSortedMap__V], /) -> SortedMap[_unmodifiableSortedMap__K, _unmodifiableSortedMap__V]: ...
    _unmodifiableSortedSet__T = typing.TypeVar('_unmodifiableSortedSet__T')  # <T>
    @staticmethod
    def unmodifiableSortedSet(s: SortedSet[_unmodifiableSortedSet__T], /) -> SortedSet[_unmodifiableSortedSet__T]: ...

_Comparator__T = typing.TypeVar('_Comparator__T')  # <T>
class Comparator(java.lang.Object, typing.Generic[_Comparator__T]):
    def compare(self, arg1: _Comparator__T, arg2: _Comparator__T, /) -> int: ...
    _comparing_0__T = typing.TypeVar('_comparing_0__T')  # <T>
    _comparing_1__T = typing.TypeVar('_comparing_1__T')  # <T>
    _comparing_1__U = typing.TypeVar('_comparing_1__U')  # <U>
    @typing.overload
    @staticmethod
    def comparing(keyExtractor: java.util.function.Function[_comparing_0__T, java.lang.Object], /) -> Comparator[_comparing_0__T]: ...
    @typing.overload
    @staticmethod
    def comparing(keyExtractor: java.util.function.Function[_comparing_1__T, _comparing_1__U], keyComparator: Comparator[_comparing_1__U], /) -> Comparator[_comparing_1__T]: ...
    _comparingDouble__T = typing.TypeVar('_comparingDouble__T')  # <T>
    @staticmethod
    def comparingDouble(keyExtractor: java.util.function.ToDoubleFunction[_comparingDouble__T], /) -> Comparator[_comparingDouble__T]: ...
    _comparingInt__T = typing.TypeVar('_comparingInt__T')  # <T>
    @staticmethod
    def comparingInt(keyExtractor: java.util.function.ToIntFunction[_comparingInt__T], /) -> Comparator[_comparingInt__T]: ...
    _comparingLong__T = typing.TypeVar('_comparingLong__T')  # <T>
    @staticmethod
    def comparingLong(keyExtractor: java.util.function.ToLongFunction[_comparingLong__T], /) -> Comparator[_comparingLong__T]: ...
    def equals(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def naturalOrder() -> Comparator[java.lang.Object]: ...
    _nullsFirst__T = typing.TypeVar('_nullsFirst__T')  # <T>
    @staticmethod
    def nullsFirst(comparator: Comparator[_nullsFirst__T], /) -> Comparator[_nullsFirst__T]: ...
    _nullsLast__T = typing.TypeVar('_nullsLast__T')  # <T>
    @staticmethod
    def nullsLast(comparator: Comparator[_nullsLast__T], /) -> Comparator[_nullsLast__T]: ...
    @staticmethod
    def reverseOrder() -> Comparator[java.lang.Object]: ...
    def reversed(self) -> Comparator[_Comparator__T]: ...
    _thenComparing_2__U = typing.TypeVar('_thenComparing_2__U')  # <U>
    @typing.overload
    def thenComparing(self, other: Comparator[_Comparator__T], /) -> Comparator[_Comparator__T]: ...
    @typing.overload
    def thenComparing(self, keyExtractor: java.util.function.Function[_Comparator__T, java.lang.Object], /) -> Comparator[_Comparator__T]: ...
    @typing.overload
    def thenComparing(self, keyExtractor: java.util.function.Function[_Comparator__T, _thenComparing_2__U], keyComparator: Comparator[_thenComparing_2__U], /) -> Comparator[_Comparator__T]: ...
    def thenComparingDouble(self, keyExtractor: java.util.function.ToDoubleFunction[_Comparator__T], /) -> Comparator[_Comparator__T]: ...
    def thenComparingInt(self, keyExtractor: java.util.function.ToIntFunction[_Comparator__T], /) -> Comparator[_Comparator__T]: ...
    def thenComparingLong(self, keyExtractor: java.util.function.ToLongFunction[_Comparator__T], /) -> Comparator[_Comparator__T]: ...

class ConcurrentModificationException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: java.lang.Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, cause: java.lang.Throwable, /) -> None: ...

class Currency(java.io.Serializable):
    @staticmethod
    def getAvailableCurrencies() -> Set[Currency]: ...
    def getCurrencyCode(self) -> str: ...
    def getDefaultFractionDigits(self) -> int: ...
    @typing.overload
    def getDisplayName(self) -> str: ...
    @typing.overload
    def getDisplayName(self, locale: Locale, /) -> str: ...
    @typing.overload
    @staticmethod
    def getInstance(currencyCode: str | java.lang.String, /) -> Currency: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: Locale, /) -> Currency: ...
    def getNumericCode(self) -> int: ...
    def getNumericCodeAsString(self) -> str: ...
    @typing.overload
    def getSymbol(self) -> str: ...
    @typing.overload
    def getSymbol(self, locale: Locale, /) -> str: ...
    def toString(self) -> str: ...

class Date(java.lang.Cloneable, java.lang.Comparable[Date], java.io.Serializable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, date: int | java.jlong | java.lang.Long, /) -> None: ...
    @typing.overload
    def __init__(self, s: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, date: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, date: int | java.jint | java.lang.Integer, hrs: int | java.jint | java.lang.Integer, min: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, date: int | java.jint | java.lang.Integer, hrs: int | java.jint | java.lang.Integer, min: int | java.jint | java.lang.Integer, sec: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def UTC(year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, date: int | java.jint | java.lang.Integer, hrs: int | java.jint | java.lang.Integer, min: int | java.jint | java.lang.Integer, sec: int | java.jint | java.lang.Integer, /) -> int: ...
    def after(self, when: Date, /) -> bool: ...
    def before(self, when: Date, /) -> bool: ...
    def clone(self) -> java.lang.Object: ...
    def compareTo(self, anotherDate: Date, /) -> int: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def from_(instant: java.time.Instant, /) -> Date: ...
    def getDate(self) -> int: ...
    def getDay(self) -> int: ...
    def getHours(self) -> int: ...
    def getMinutes(self) -> int: ...
    def getMonth(self) -> int: ...
    def getSeconds(self) -> int: ...
    def getTime(self) -> int: ...
    def getTimezoneOffset(self) -> int: ...
    def getYear(self) -> int: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def parse(s: str | java.lang.String, /) -> int: ...
    def setDate(self, date: int | java.jint | java.lang.Integer, /) -> None: ...
    def setHours(self, hours: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMinutes(self, minutes: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMonth(self, month: int | java.jint | java.lang.Integer, /) -> None: ...
    def setSeconds(self, seconds: int | java.jint | java.lang.Integer, /) -> None: ...
    def setTime(self, time: int | java.jlong | java.lang.Long, /) -> None: ...
    def setYear(self, year: int | java.jint | java.lang.Integer, /) -> None: ...
    def toGMTString(self) -> str: ...
    def toInstant(self) -> java.time.Instant: ...
    def toLocaleString(self) -> str: ...
    def toString(self) -> str: ...

_Deque__E = typing.TypeVar('_Deque__E')  # <E>
class Deque(Queue[_Deque__E], SequencedCollection[_Deque__E], typing.Generic[_Deque__E]):
    def add(self, arg1: _Deque__E, /) -> bool: ...
    def addAll(self, arg1: Collection[_Deque__E], /) -> bool: ...
    def addFirst(self, arg1: _Deque__E, /) -> None: ...
    def addLast(self, arg1: _Deque__E, /) -> None: ...
    def contains(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def descendingIterator(self) -> Iterator[_Deque__E]: ...
    def element(self) -> _Deque__E: ...
    def getFirst(self) -> _Deque__E: ...
    def getLast(self) -> _Deque__E: ...
    def iterator(self) -> Iterator[_Deque__E]: ...
    def offer(self, arg1: _Deque__E, /) -> bool: ...
    def offerFirst(self, arg1: _Deque__E, /) -> bool: ...
    def offerLast(self, arg1: _Deque__E, /) -> bool: ...
    def peek(self) -> _Deque__E | None: ...
    def peekFirst(self) -> _Deque__E | None: ...
    def peekLast(self) -> _Deque__E | None: ...
    def poll(self) -> _Deque__E | None: ...
    def pollFirst(self) -> _Deque__E | None: ...
    def pollLast(self) -> _Deque__E | None: ...
    def pop(self) -> _Deque__E: ...
    def push(self, arg1: _Deque__E, /) -> None: ...
    @typing.overload
    def remove(self) -> _Deque__E: ...
    @typing.overload
    def remove(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeFirst(self) -> _Deque__E: ...
    def removeFirstOccurrence(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeLast(self) -> _Deque__E: ...
    def removeLastOccurrence(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def reversed(self) -> Deque[_Deque__E]: ...
    def size(self) -> int: ...

_Dictionary__K = typing.TypeVar('_Dictionary__K')  # <K>
_Dictionary__V = typing.TypeVar('_Dictionary__V')  # <V>
class Dictionary(java.lang.Object, typing.Generic[_Dictionary__K, _Dictionary__V]):
    def __init__(self) -> None: ...
    def elements(self) -> Enumeration[_Dictionary__V]: ...
    def get(self, arg1: java.lang.Object | int | bool | float | str, /) -> _Dictionary__V | None: ...
    def isEmpty(self) -> bool: ...
    def keys(self) -> Enumeration[_Dictionary__K]: ...
    def put(self, arg1: _Dictionary__K, arg2: _Dictionary__V, /) -> _Dictionary__V | None: ...
    def remove(self, arg1: java.lang.Object | int | bool | float | str, /) -> _Dictionary__V | None: ...
    def size(self) -> int: ...

class DoubleSummaryStatistics(java.util.function.DoubleConsumer):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, count: int | java.jlong | java.lang.Long, min: float | java.jdouble | java.lang.Double, max: float | java.jdouble | java.lang.Double, sum: float | java.jdouble | java.lang.Double, /) -> None: ...
    def accept(self, value: float | java.jdouble | java.lang.Double, /) -> None: ...
    def combine(self, other: DoubleSummaryStatistics, /) -> None: ...
    def getAverage(self) -> float: ...
    def getCount(self) -> int: ...
    def getMax(self) -> float: ...
    def getMin(self) -> float: ...
    def getSum(self) -> float: ...
    def toString(self) -> str: ...

class DuplicateFormatFlagsException(IllegalFormatException):
    def __init__(self, f: str | java.lang.String, /) -> None: ...
    def getFlags(self) -> str: ...
    def getMessage(self) -> str: ...

class EmptyStackException(java.lang.RuntimeException):
    def __init__(self) -> None: ...

_EnumMap__K = typing.TypeVar('_EnumMap__K', bound=java.lang.Enum[K])  # <K>
_EnumMap__V = typing.TypeVar('_EnumMap__V')  # <V>
class EnumMap(AbstractMap[_EnumMap__K, _EnumMap__V], java.lang.Cloneable, java.io.Serializable, typing.Generic[_EnumMap__K, _EnumMap__V]):
    @typing.overload
    def __init__(self, keyType: typing.Type[_EnumMap__K], /) -> None: ...
    @typing.overload
    def __init__(self, m: EnumMap[_EnumMap__K, _EnumMap__V], /) -> None: ...
    @typing.overload
    def __init__(self, m: Map[_EnumMap__K, _EnumMap__V], /) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> EnumMap[_EnumMap__K, _EnumMap__V]: ...
    def containsKey(self, key: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsValue(self, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_EnumMap__K, _EnumMap__V]]: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def get(self, key: java.lang.Object | int | bool | float | str, /) -> _EnumMap__V | None: ...
    def hashCode(self) -> int: ...
    def keySet(self) -> Set[_EnumMap__K]: ...
    def put(self, key: _EnumMap__K, value: _EnumMap__V, /) -> _EnumMap__V | None: ...
    def putAll(self, m: Map[_EnumMap__K, _EnumMap__V], /) -> None: ...
    def remove(self, key: java.lang.Object | int | bool | float | str, /) -> _EnumMap__V | None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_EnumMap__V]: ...

_EnumSet__E = typing.TypeVar('_EnumSet__E', bound=java.lang.Enum[E])  # <E>
class EnumSet(AbstractSet[_EnumSet__E], java.lang.Cloneable, java.io.Serializable, typing.Generic[_EnumSet__E]):
    _allOf__E = typing.TypeVar('_allOf__E', bound=java.lang.Enum[E])  # <E>
    @staticmethod
    def allOf(elementType: typing.Type[_allOf__E], /) -> EnumSet[_allOf__E]: ...
    def clone(self) -> EnumSet[_EnumSet__E]: ...
    _complementOf__E = typing.TypeVar('_complementOf__E', bound=java.lang.Enum[E])  # <E>
    @staticmethod
    def complementOf(s: EnumSet[_complementOf__E], /) -> EnumSet[_complementOf__E]: ...
    _copyOf_0__E = typing.TypeVar('_copyOf_0__E', bound=java.lang.Enum[E])  # <E>
    _copyOf_1__E = typing.TypeVar('_copyOf_1__E', bound=java.lang.Enum[E])  # <E>
    @typing.overload
    @staticmethod
    def copyOf(c: Collection[_copyOf_0__E], /) -> EnumSet[_copyOf_0__E]: ...
    @typing.overload
    @staticmethod
    def copyOf(s: EnumSet[_copyOf_1__E], /) -> EnumSet[_copyOf_1__E]: ...
    _noneOf__E = typing.TypeVar('_noneOf__E', bound=java.lang.Enum[E])  # <E>
    @staticmethod
    def noneOf(elementType: typing.Type[_noneOf__E], /) -> EnumSet[_noneOf__E]: ...
    _of_0__E = typing.TypeVar('_of_0__E', bound=java.lang.Enum[E])  # <E>
    _of_1__E = typing.TypeVar('_of_1__E', bound=java.lang.Enum[E])  # <E>
    _of_2__E = typing.TypeVar('_of_2__E', bound=java.lang.Enum[E])  # <E>
    _of_3__E = typing.TypeVar('_of_3__E', bound=java.lang.Enum[E])  # <E>
    _of_4__E = typing.TypeVar('_of_4__E', bound=java.lang.Enum[E])  # <E>
    _of_5__E = typing.TypeVar('_of_5__E', bound=java.lang.Enum[E])  # <E>
    @typing.overload
    @staticmethod
    def of(e: _of_0__E, /) -> EnumSet[_of_0__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_1__E, e2: _of_1__E, /) -> EnumSet[_of_1__E]: ...
    @typing.overload
    @staticmethod
    def of(first: _of_2__E, /, *rest: _of_2__E) -> EnumSet[_of_2__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_3__E, e2: _of_3__E, e3: _of_3__E, /) -> EnumSet[_of_3__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_4__E, e2: _of_4__E, e3: _of_4__E, e4: _of_4__E, /) -> EnumSet[_of_4__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_5__E, e2: _of_5__E, e3: _of_5__E, e4: _of_5__E, e5: _of_5__E, /) -> EnumSet[_of_5__E]: ...
    _range__E = typing.TypeVar('_range__E', bound=java.lang.Enum[E])  # <E>
    @staticmethod
    def range(from_: _range__E, to: _range__E, /) -> EnumSet[_range__E]: ...

_Enumeration__E = typing.TypeVar('_Enumeration__E')  # <E>
class Enumeration(java.lang.Object, typing.Generic[_Enumeration__E]):
    def asIterator(self) -> Iterator[_Enumeration__E]: ...
    def hasMoreElements(self) -> bool: ...
    def nextElement(self) -> _Enumeration__E: ...

class EventListener(java.lang.Object): ...

_EventListenerProxy__T = typing.TypeVar('_EventListenerProxy__T')  # <T>
class EventListenerProxy(EventListener, typing.Generic[_EventListenerProxy__T]):
    def __init__(self, listener: _EventListenerProxy__T, /) -> None: ...
    def getListener(self) -> _EventListenerProxy__T: ...

class EventObject(java.io.Serializable):
    source: java.lang.Object = ...
    def __init__(self, source: java.lang.Object | int | bool | float | str, /) -> None: ...
    def getSource(self) -> java.lang.Object: ...
    def toString(self) -> str: ...

class FormatFlagsConversionMismatchException(IllegalFormatException):
    def __init__(self, f: str | java.lang.String, c: str | java.jchar | java.lang.Character, /) -> None: ...
    def getConversion(self) -> str: ...
    def getFlags(self) -> str: ...
    def getMessage(self) -> str: ...

class Formattable(java.lang.Object):
    def formatTo(self, arg1: Formatter, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, arg4: int | java.jint | java.lang.Integer, /) -> None: ...

class FormattableFlags(java.lang.Object):
    ALTERNATE: typing.ClassVar[int] = ...
    LEFT_JUSTIFY: typing.ClassVar[int] = ...
    UPPERCASE: typing.ClassVar[int] = ...

class Formatter(java.io.Closeable, java.io.Flushable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, file: java.io.File, /) -> None: ...
    @typing.overload
    def __init__(self, os: java.io.OutputStream, /) -> None: ...
    @typing.overload
    def __init__(self, ps: java.io.PrintStream, /) -> None: ...
    @typing.overload
    def __init__(self, a: java.lang.Appendable, /) -> None: ...
    @typing.overload
    def __init__(self, fileName: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, l: Locale, /) -> None: ...
    @typing.overload
    def __init__(self, file: java.io.File, csn: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, os: java.io.OutputStream, csn: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, a: java.lang.Appendable, l: Locale, /) -> None: ...
    @typing.overload
    def __init__(self, fileName: str | java.lang.String, csn: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, file: java.io.File, csn: str | java.lang.String, l: Locale, /) -> None: ...
    @typing.overload
    def __init__(self, file: java.io.File, charset: java.nio.charset.Charset, l: Locale, /) -> None: ...
    @typing.overload
    def __init__(self, os: java.io.OutputStream, csn: str | java.lang.String, l: Locale, /) -> None: ...
    @typing.overload
    def __init__(self, os: java.io.OutputStream, charset: java.nio.charset.Charset, l: Locale, /) -> None: ...
    @typing.overload
    def __init__(self, fileName: str | java.lang.String, csn: str | java.lang.String, l: Locale, /) -> None: ...
    @typing.overload
    def __init__(self, fileName: str | java.lang.String, charset: java.nio.charset.Charset, l: Locale, /) -> None: ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    @typing.overload
    def format(self, format: str | java.lang.String, /, *args: java.lang.Object) -> Formatter: ...
    @typing.overload
    def format(self, l: Locale, format: str | java.lang.String, /, *args: java.lang.Object) -> Formatter: ...
    def ioException(self) -> java.io.IOException: ...
    def locale(self) -> Locale: ...
    def out(self) -> java.lang.Appendable: ...
    def toString(self) -> str: ...

    class BigDecimalLayoutForm(java.lang.Enum[Formatter.BigDecimalLayoutForm]):
        DECIMAL_FLOAT: typing.ClassVar[Formatter.BigDecimalLayoutForm] = ...
        SCIENTIFIC: typing.ClassVar[Formatter.BigDecimalLayoutForm] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> Formatter.BigDecimalLayoutForm: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[Formatter.BigDecimalLayoutForm]: ...

class FormatterClosedException(java.lang.IllegalStateException):
    def __init__(self) -> None: ...

class GregorianCalendar(Calendar):
    AD: typing.ClassVar[int] = ...
    BC: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, aLocale: Locale, /) -> None: ...
    @typing.overload
    def __init__(self, zone: TimeZone, /) -> None: ...
    @typing.overload
    def __init__(self, zone: TimeZone, aLocale: Locale, /) -> None: ...
    @typing.overload
    def __init__(self, year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, hourOfDay: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, hourOfDay: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, /) -> None: ...
    def add(self, field: int | java.jint | java.lang.Integer, amount: int | java.jint | java.lang.Integer, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def computeFields(self) -> None: ...
    def computeTime(self) -> None: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def from_(zdt: java.time.ZonedDateTime, /) -> GregorianCalendar: ...
    def getActualMaximum(self, field: int | java.jint | java.lang.Integer, /) -> int: ...
    def getActualMinimum(self, field: int | java.jint | java.lang.Integer, /) -> int: ...
    def getCalendarType(self) -> str: ...
    def getGreatestMinimum(self, field: int | java.jint | java.lang.Integer, /) -> int: ...
    def getGregorianChange(self) -> Date: ...
    def getLeastMaximum(self, field: int | java.jint | java.lang.Integer, /) -> int: ...
    def getMaximum(self, field: int | java.jint | java.lang.Integer, /) -> int: ...
    def getMinimum(self, field: int | java.jint | java.lang.Integer, /) -> int: ...
    def getTimeZone(self) -> TimeZone: ...
    def getWeekYear(self) -> int: ...
    def getWeeksInWeekYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isLeapYear(self, year: int | java.jint | java.lang.Integer, /) -> bool: ...
    def isWeekDateSupported(self) -> bool: ...
    @typing.overload
    def roll(self, field: int | java.jint | java.lang.Integer, amount: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def roll(self, field: int | java.jint | java.lang.Integer, up: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setGregorianChange(self, date: Date, /) -> None: ...
    def setTimeZone(self, zone: TimeZone, /) -> None: ...
    def setWeekDate(self, weekYear: int | java.jint | java.lang.Integer, weekOfYear: int | java.jint | java.lang.Integer, dayOfWeek: int | java.jint | java.lang.Integer, /) -> None: ...
    def toZonedDateTime(self) -> java.time.ZonedDateTime: ...

_HashMap__K = typing.TypeVar('_HashMap__K')  # <K>
_HashMap__V = typing.TypeVar('_HashMap__V')  # <V>
class HashMap(AbstractMap[_HashMap__K, _HashMap__V], java.lang.Cloneable, Map[_HashMap__K, _HashMap__V], java.io.Serializable, typing.Generic[_HashMap__K, _HashMap__V]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, m: Map[_HashMap__K, _HashMap__V], /) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, loadFactor: float | java.jfloat | java.lang.Float, /) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def compute(self, key: _HashMap__K, remappingFunction: java.util.function.BiFunction[_HashMap__K, _HashMap__V, _HashMap__V], /) -> _HashMap__V | None: ...
    def computeIfAbsent(self, key: _HashMap__K, mappingFunction: java.util.function.Function[_HashMap__K, _HashMap__V], /) -> _HashMap__V | None: ...
    def computeIfPresent(self, key: _HashMap__K, remappingFunction: java.util.function.BiFunction[_HashMap__K, _HashMap__V, _HashMap__V], /) -> _HashMap__V | None: ...
    def containsKey(self, key: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsValue(self, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_HashMap__K, _HashMap__V]]: ...
    def forEach(self, action: java.util.function.BiConsumer[_HashMap__K, _HashMap__V], /) -> None: ...
    def get(self, key: java.lang.Object | int | bool | float | str, /) -> _HashMap__V | None: ...
    def getOrDefault(self, key: java.lang.Object | int | bool | float | str, defaultValue: _HashMap__V, /) -> _HashMap__V: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_HashMap__K]: ...
    def merge(self, key: _HashMap__K, value: _HashMap__V, remappingFunction: java.util.function.BiFunction[_HashMap__V, _HashMap__V, _HashMap__V], /) -> _HashMap__V | None: ...
    @staticmethod
    def newHashMap(numMappings: int | java.jint | java.lang.Integer, /) -> HashMap[java.lang.Object, java.lang.Object]: ...
    def put(self, key: _HashMap__K, value: _HashMap__V, /) -> _HashMap__V | None: ...
    def putAll(self, m: Map[_HashMap__K, _HashMap__V], /) -> None: ...
    def putIfAbsent(self, key: _HashMap__K, value: _HashMap__V, /) -> _HashMap__V | None: ...
    @typing.overload
    def remove(self, key: java.lang.Object | int | bool | float | str, /) -> _HashMap__V | None: ...
    @typing.overload
    def remove(self, key: java.lang.Object | int | bool | float | str, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def replace(self, key: _HashMap__K, value: _HashMap__V, /) -> _HashMap__V | None: ...
    @typing.overload
    def replace(self, key: _HashMap__K, oldValue: _HashMap__V, newValue: _HashMap__V, /) -> bool: ...
    def replaceAll(self, function: java.util.function.BiFunction[_HashMap__K, _HashMap__V, _HashMap__V], /) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_HashMap__V]: ...

_HashSet__E = typing.TypeVar('_HashSet__E')  # <E>
class HashSet(AbstractSet[_HashSet__E], java.lang.Cloneable, java.io.Serializable, Set[_HashSet__E], typing.Generic[_HashSet__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, c: Collection[_HashSet__E], /) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, loadFactor: float | java.jfloat | java.lang.Float, /) -> None: ...
    def add(self, e: _HashSet__E, /) -> bool: ...
    def clear(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_HashSet__E]: ...
    @staticmethod
    def newHashSet(numElements: int | java.jint | java.lang.Integer, /) -> HashSet[java.lang.Object]: ...
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> Spliterator[_HashSet__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...

_Hashtable__K = typing.TypeVar('_Hashtable__K')  # <K>
_Hashtable__V = typing.TypeVar('_Hashtable__V')  # <V>
class Hashtable(Dictionary[_Hashtable__K, _Hashtable__V], java.lang.Cloneable, Map[_Hashtable__K, _Hashtable__V], java.io.Serializable, typing.Generic[_Hashtable__K, _Hashtable__V]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, t: Map[_Hashtable__K, _Hashtable__V], /) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, loadFactor: float | java.jfloat | java.lang.Float, /) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def compute(self, key: _Hashtable__K, remappingFunction: java.util.function.BiFunction[_Hashtable__K, _Hashtable__V, _Hashtable__V], /) -> _Hashtable__V | None: ...
    def computeIfAbsent(self, key: _Hashtable__K, mappingFunction: java.util.function.Function[_Hashtable__K, _Hashtable__V], /) -> _Hashtable__V | None: ...
    def computeIfPresent(self, key: _Hashtable__K, remappingFunction: java.util.function.BiFunction[_Hashtable__K, _Hashtable__V, _Hashtable__V], /) -> _Hashtable__V | None: ...
    def contains(self, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsKey(self, key: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsValue(self, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def elements(self) -> Enumeration[_Hashtable__V]: ...
    def entrySet(self) -> Set[Map.Entry[_Hashtable__K, _Hashtable__V]]: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def forEach(self, action: java.util.function.BiConsumer[_Hashtable__K, _Hashtable__V], /) -> None: ...
    def get(self, key: java.lang.Object | int | bool | float | str, /) -> _Hashtable__V | None: ...
    def getOrDefault(self, key: java.lang.Object | int | bool | float | str, defaultValue: _Hashtable__V, /) -> _Hashtable__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_Hashtable__K]: ...
    def keys(self) -> Enumeration[_Hashtable__K]: ...
    def merge(self, key: _Hashtable__K, value: _Hashtable__V, remappingFunction: java.util.function.BiFunction[_Hashtable__V, _Hashtable__V, _Hashtable__V], /) -> _Hashtable__V | None: ...
    def put(self, key: _Hashtable__K, value: _Hashtable__V, /) -> _Hashtable__V | None: ...
    def putAll(self, t: Map[_Hashtable__K, _Hashtable__V], /) -> None: ...
    def putIfAbsent(self, key: _Hashtable__K, value: _Hashtable__V, /) -> _Hashtable__V | None: ...
    def rehash(self) -> None: ...
    @typing.overload
    def remove(self, key: java.lang.Object | int | bool | float | str, /) -> _Hashtable__V | None: ...
    @typing.overload
    def remove(self, key: java.lang.Object | int | bool | float | str, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def replace(self, key: _Hashtable__K, value: _Hashtable__V, /) -> _Hashtable__V | None: ...
    @typing.overload
    def replace(self, key: _Hashtable__K, oldValue: _Hashtable__V, newValue: _Hashtable__V, /) -> bool: ...
    def replaceAll(self, function: java.util.function.BiFunction[_Hashtable__K, _Hashtable__V, _Hashtable__V], /) -> None: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def values(self) -> Collection[_Hashtable__V]: ...

class HexFormat(java.lang.Object):
    def delimiter(self) -> str: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    _formatHex_1__A = typing.TypeVar('_formatHex_1__A')  # <A>
    _formatHex_3__A = typing.TypeVar('_formatHex_3__A')  # <A>
    @typing.overload
    def formatHex(self, bytes: java.chaquopy.JavaArrayJByte, /) -> str: ...
    @typing.overload
    def formatHex(self, out: _formatHex_1__A, bytes: java.chaquopy.JavaArrayJByte, /) -> _formatHex_1__A: ...
    @typing.overload
    def formatHex(self, bytes: java.chaquopy.JavaArrayJByte, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> str: ...
    @typing.overload
    def formatHex(self, out: _formatHex_3__A, bytes: java.chaquopy.JavaArrayJByte, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> _formatHex_3__A: ...
    @staticmethod
    def fromHexDigit(ch: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def fromHexDigits(string: java.lang.CharSequence, /) -> int: ...
    @typing.overload
    @staticmethod
    def fromHexDigits(string: java.lang.CharSequence, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def fromHexDigitsToLong(string: java.lang.CharSequence, /) -> int: ...
    @typing.overload
    @staticmethod
    def fromHexDigitsToLong(string: java.lang.CharSequence, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def isHexDigit(ch: int | java.jint | java.lang.Integer, /) -> bool: ...
    def isUpperCase(self) -> bool: ...
    @staticmethod
    def of() -> HexFormat: ...
    @staticmethod
    def ofDelimiter(delimiter: str | java.lang.String, /) -> HexFormat: ...
    @typing.overload
    def parseHex(self, string: java.lang.CharSequence, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def parseHex(self, string: java.lang.CharSequence, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def parseHex(self, chars: java.chaquopy.JavaArrayJChar, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJByte: ...
    def prefix(self) -> str: ...
    def suffix(self) -> str: ...
    _toHexDigits_6__A = typing.TypeVar('_toHexDigits_6__A')  # <A>
    @typing.overload
    def toHexDigits(self, value: int | java.jbyte | java.lang.Byte, /) -> str: ...
    @typing.overload
    def toHexDigits(self, value: str | java.jchar | java.lang.Character, /) -> str: ...
    @typing.overload
    def toHexDigits(self, value: int | java.jint | java.lang.Integer, /) -> str: ...
    @typing.overload
    def toHexDigits(self, value: int | java.jlong | java.lang.Long, /) -> str: ...
    @typing.overload
    def toHexDigits(self, value: int | java.jshort | java.lang.Short, /) -> str: ...
    @typing.overload
    def toHexDigits(self, value: int | java.jlong | java.lang.Long, digits: int | java.jint | java.lang.Integer, /) -> str: ...
    @typing.overload
    def toHexDigits(self, out: _toHexDigits_6__A, value: int | java.jbyte | java.lang.Byte, /) -> _toHexDigits_6__A: ...
    def toHighHexDigit(self, value: int | java.jint | java.lang.Integer, /) -> str: ...
    def toLowHexDigit(self, value: int | java.jint | java.lang.Integer, /) -> str: ...
    def toString(self) -> str: ...
    def withDelimiter(self, delimiter: str | java.lang.String, /) -> HexFormat: ...
    def withLowerCase(self) -> HexFormat: ...
    def withPrefix(self, prefix: str | java.lang.String, /) -> HexFormat: ...
    def withSuffix(self, suffix: str | java.lang.String, /) -> HexFormat: ...
    def withUpperCase(self) -> HexFormat: ...

_IdentityHashMap__K = typing.TypeVar('_IdentityHashMap__K')  # <K>
_IdentityHashMap__V = typing.TypeVar('_IdentityHashMap__V')  # <V>
class IdentityHashMap(AbstractMap[_IdentityHashMap__K, _IdentityHashMap__V], java.lang.Cloneable, Map[_IdentityHashMap__K, _IdentityHashMap__V], java.io.Serializable, typing.Generic[_IdentityHashMap__K, _IdentityHashMap__V]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, expectedMaxSize: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, m: Map[_IdentityHashMap__K, _IdentityHashMap__V], /) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def containsKey(self, key: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsValue(self, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_IdentityHashMap__K, _IdentityHashMap__V]]: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def forEach(self, action: java.util.function.BiConsumer[_IdentityHashMap__K, _IdentityHashMap__V], /) -> None: ...
    def get(self, key: java.lang.Object | int | bool | float | str, /) -> _IdentityHashMap__V | None: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_IdentityHashMap__K]: ...
    def put(self, key: _IdentityHashMap__K, value: _IdentityHashMap__V, /) -> _IdentityHashMap__V | None: ...
    def putAll(self, m: Map[_IdentityHashMap__K, _IdentityHashMap__V], /) -> None: ...
    @typing.overload
    def remove(self, key: java.lang.Object | int | bool | float | str, /) -> _IdentityHashMap__V | None: ...
    @typing.overload
    def remove(self, key: java.lang.Object | int | bool | float | str, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def replace(self, key: _IdentityHashMap__K, oldValue: _IdentityHashMap__V, newValue: _IdentityHashMap__V, /) -> bool: ...
    def replaceAll(self, function: java.util.function.BiFunction[_IdentityHashMap__K, _IdentityHashMap__V, _IdentityHashMap__V], /) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_IdentityHashMap__V]: ...

class IllegalFormatCodePointException(IllegalFormatException):
    def __init__(self, c: int | java.jint | java.lang.Integer, /) -> None: ...
    def getCodePoint(self) -> int: ...
    def getMessage(self) -> str: ...

class IllegalFormatConversionException(IllegalFormatException):
    def __init__(self, c: str | java.jchar | java.lang.Character, arg: typing.Type[java.lang.Object], /) -> None: ...
    def getArgumentClass(self) -> typing.Type[java.lang.Object]: ...
    def getConversion(self) -> str: ...
    def getMessage(self) -> str: ...

class IllegalFormatException(java.lang.IllegalArgumentException): ...

class IllegalFormatFlagsException(IllegalFormatException):
    def __init__(self, f: str | java.lang.String, /) -> None: ...
    def getFlags(self) -> str: ...
    def getMessage(self) -> str: ...

class IllegalFormatPrecisionException(IllegalFormatException):
    def __init__(self, p: int | java.jint | java.lang.Integer, /) -> None: ...
    def getMessage(self) -> str: ...
    def getPrecision(self) -> int: ...

class IllegalFormatWidthException(IllegalFormatException):
    def __init__(self, w: int | java.jint | java.lang.Integer, /) -> None: ...
    def getMessage(self) -> str: ...
    def getWidth(self) -> int: ...

class IllformedLocaleException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, errorIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    def getErrorIndex(self) -> int: ...

class InputMismatchException(NoSuchElementException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | java.lang.String, /) -> None: ...

class IntSummaryStatistics(java.util.function.IntConsumer):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, count: int | java.jlong | java.lang.Long, min: int | java.jint | java.lang.Integer, max: int | java.jint | java.lang.Integer, sum: int | java.jlong | java.lang.Long, /) -> None: ...
    def accept(self, value: int | java.jint | java.lang.Integer, /) -> None: ...
    def combine(self, other: IntSummaryStatistics, /) -> None: ...
    def getAverage(self) -> float: ...
    def getCount(self) -> int: ...
    def getMax(self) -> int: ...
    def getMin(self) -> int: ...
    def getSum(self) -> int: ...
    def toString(self) -> str: ...

class InvalidPropertiesFormatException(java.io.IOException):
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: java.lang.Throwable, /) -> None: ...

_Iterator__E = typing.TypeVar('_Iterator__E')  # <E>
class Iterator(java.lang.Object, typing.Generic[_Iterator__E]):
    def forEachRemaining(self, action: java.util.function.Consumer[_Iterator__E], /) -> None: ...
    def hasNext(self) -> bool: ...
    def next(self) -> _Iterator__E: ...
    def remove(self) -> None: ...

_LinkedHashMap__K = typing.TypeVar('_LinkedHashMap__K')  # <K>
_LinkedHashMap__V = typing.TypeVar('_LinkedHashMap__V')  # <V>
class LinkedHashMap(HashMap[_LinkedHashMap__K, _LinkedHashMap__V], Map[_LinkedHashMap__K, _LinkedHashMap__V], SequencedMap[_LinkedHashMap__K, _LinkedHashMap__V], typing.Generic[_LinkedHashMap__K, _LinkedHashMap__V]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, m: Map[_LinkedHashMap__K, _LinkedHashMap__V], /) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, loadFactor: float | java.jfloat | java.lang.Float, /) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, loadFactor: float | java.jfloat | java.lang.Float, accessOrder: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def clear(self) -> None: ...
    def containsValue(self, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_LinkedHashMap__K, _LinkedHashMap__V]]: ...
    def forEach(self, action: java.util.function.BiConsumer[_LinkedHashMap__K, _LinkedHashMap__V], /) -> None: ...
    def get(self, key: java.lang.Object | int | bool | float | str, /) -> _LinkedHashMap__V | None: ...
    def getOrDefault(self, key: java.lang.Object | int | bool | float | str, defaultValue: _LinkedHashMap__V, /) -> _LinkedHashMap__V: ...
    def keySet(self) -> Set[_LinkedHashMap__K]: ...
    @staticmethod
    def newLinkedHashMap(numMappings: int | java.jint | java.lang.Integer, /) -> LinkedHashMap[java.lang.Object, java.lang.Object]: ...
    def putFirst(self, k: _LinkedHashMap__K, v: _LinkedHashMap__V, /) -> _LinkedHashMap__V: ...
    def putLast(self, k: _LinkedHashMap__K, v: _LinkedHashMap__V, /) -> _LinkedHashMap__V: ...
    def removeEldestEntry(self, eldest: Map.Entry[_LinkedHashMap__K, _LinkedHashMap__V], /) -> bool: ...
    def replaceAll(self, function: java.util.function.BiFunction[_LinkedHashMap__K, _LinkedHashMap__V, _LinkedHashMap__V], /) -> None: ...
    def reversed(self) -> SequencedMap[_LinkedHashMap__K, _LinkedHashMap__V]: ...
    def sequencedEntrySet(self) -> SequencedSet[Map.Entry[_LinkedHashMap__K, _LinkedHashMap__V]]: ...
    def sequencedKeySet(self) -> SequencedSet[_LinkedHashMap__K]: ...
    def sequencedValues(self) -> SequencedCollection[_LinkedHashMap__V]: ...
    def values(self) -> Collection[_LinkedHashMap__V]: ...

_LinkedHashSet__E = typing.TypeVar('_LinkedHashSet__E')  # <E>
class LinkedHashSet(HashSet[_LinkedHashSet__E], java.lang.Cloneable, SequencedSet[_LinkedHashSet__E], java.io.Serializable, Set[_LinkedHashSet__E], typing.Generic[_LinkedHashSet__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, c: Collection[_LinkedHashSet__E], /) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, loadFactor: float | java.jfloat | java.lang.Float, /) -> None: ...
    def addFirst(self, e: _LinkedHashSet__E, /) -> None: ...
    def addLast(self, e: _LinkedHashSet__E, /) -> None: ...
    def getFirst(self) -> _LinkedHashSet__E: ...
    def getLast(self) -> _LinkedHashSet__E: ...
    @staticmethod
    def newLinkedHashSet(numElements: int | java.jint | java.lang.Integer, /) -> LinkedHashSet[java.lang.Object]: ...
    def removeFirst(self) -> _LinkedHashSet__E: ...
    def removeLast(self) -> _LinkedHashSet__E: ...
    def reversed(self) -> SequencedSet[_LinkedHashSet__E]: ...
    def spliterator(self) -> Spliterator[_LinkedHashSet__E]: ...

_LinkedList__E = typing.TypeVar('_LinkedList__E')  # <E>
class LinkedList(AbstractSequentialList[_LinkedList__E], java.lang.Cloneable, Deque[_LinkedList__E], List[_LinkedList__E], java.io.Serializable, typing.Generic[_LinkedList__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, c: Collection[_LinkedList__E], /) -> None: ...
    @typing.overload
    def add(self, e: _LinkedList__E, /) -> bool: ...
    @typing.overload
    def add(self, index: int | java.jint | java.lang.Integer, element: _LinkedList__E, /) -> None: ...
    @typing.overload
    def addAll(self, c: Collection[_LinkedList__E], /) -> bool: ...
    @typing.overload
    def addAll(self, index: int | java.jint | java.lang.Integer, c: Collection[_LinkedList__E], /) -> bool: ...
    def addFirst(self, e: _LinkedList__E, /) -> None: ...
    def addLast(self, e: _LinkedList__E, /) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def descendingIterator(self) -> Iterator[_LinkedList__E]: ...
    def element(self) -> _LinkedList__E: ...
    def get(self, index: int | java.jint | java.lang.Integer, /) -> _LinkedList__E: ...
    def getFirst(self) -> _LinkedList__E: ...
    def getLast(self) -> _LinkedList__E: ...
    def indexOf(self, o: java.lang.Object | int | bool | float | str, /) -> int: ...
    def lastIndexOf(self, o: java.lang.Object | int | bool | float | str, /) -> int: ...
    def listIterator(self, index: int | java.jint | java.lang.Integer, /) -> ListIterator[_LinkedList__E]: ...
    def offer(self, e: _LinkedList__E, /) -> bool: ...
    def offerFirst(self, e: _LinkedList__E, /) -> bool: ...
    def offerLast(self, e: _LinkedList__E, /) -> bool: ...
    def peek(self) -> _LinkedList__E | None: ...
    def peekFirst(self) -> _LinkedList__E | None: ...
    def peekLast(self) -> _LinkedList__E | None: ...
    def poll(self) -> _LinkedList__E | None: ...
    def pollFirst(self) -> _LinkedList__E | None: ...
    def pollLast(self) -> _LinkedList__E | None: ...
    def pop(self) -> _LinkedList__E: ...
    def push(self, e: _LinkedList__E, /) -> None: ...
    @typing.overload
    def remove(self) -> _LinkedList__E: ...
    @typing.overload
    def remove(self, index: int | java.jint | java.lang.Integer, /) -> _LinkedList__E: ...
    @typing.overload
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeFirst(self) -> _LinkedList__E: ...
    def removeFirstOccurrence(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeLast(self) -> _LinkedList__E: ...
    def removeLastOccurrence(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def reversed(self) -> LinkedList[_LinkedList__E]: ...
    def set(self, index: int | java.jint | java.lang.Integer, element: _LinkedList__E, /) -> _LinkedList__E: ...
    def size(self) -> int: ...
    def spliterator(self) -> Spliterator[_LinkedList__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...

_List__E = typing.TypeVar('_List__E')  # <E>
class List(Collection[_List__E], SequencedCollection[_List__E], typing.Generic[_List__E]):
    @typing.overload
    def add(self, arg1: _List__E, /) -> bool: ...
    @typing.overload
    def add(self, arg1: int | java.jint | java.lang.Integer, arg2: _List__E, /) -> None: ...
    @typing.overload
    def addAll(self, arg1: Collection[_List__E], /) -> bool: ...
    @typing.overload
    def addAll(self, arg1: int | java.jint | java.lang.Integer, arg2: Collection[_List__E], /) -> bool: ...
    def addFirst(self, e: _List__E, /) -> None: ...
    def addLast(self, e: _List__E, /) -> None: ...
    def clear(self) -> None: ...
    def contains(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsAll(self, arg1: Collection[java.lang.Object], /) -> bool: ...
    _copyOf__E = typing.TypeVar('_copyOf__E')  # <E>
    @staticmethod
    def copyOf(coll: Collection[_copyOf__E], /) -> List[_copyOf__E]: ...
    def equals(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def get(self, arg1: int | java.jint | java.lang.Integer, /) -> _List__E: ...
    def getFirst(self) -> _List__E: ...
    def getLast(self) -> _List__E: ...
    def hashCode(self) -> int: ...
    def indexOf(self, arg1: java.lang.Object | int | bool | float | str, /) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_List__E]: ...
    def lastIndexOf(self, arg1: java.lang.Object | int | bool | float | str, /) -> int: ...
    @typing.overload
    def listIterator(self) -> ListIterator[_List__E]: ...
    @typing.overload
    def listIterator(self, arg1: int | java.jint | java.lang.Integer, /) -> ListIterator[_List__E]: ...
    _of_1__E = typing.TypeVar('_of_1__E')  # <E>
    _of_2__E = typing.TypeVar('_of_2__E')  # <E>
    _of_3__E = typing.TypeVar('_of_3__E')  # <E>
    _of_4__E = typing.TypeVar('_of_4__E')  # <E>
    _of_5__E = typing.TypeVar('_of_5__E')  # <E>
    _of_6__E = typing.TypeVar('_of_6__E')  # <E>
    _of_7__E = typing.TypeVar('_of_7__E')  # <E>
    _of_8__E = typing.TypeVar('_of_8__E')  # <E>
    _of_9__E = typing.TypeVar('_of_9__E')  # <E>
    _of_10__E = typing.TypeVar('_of_10__E')  # <E>
    _of_11__E = typing.TypeVar('_of_11__E')  # <E>
    @typing.overload
    @staticmethod
    def of() -> List[java.lang.Object]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_1__E, /) -> List[_of_1__E]: ...
    @typing.overload
    @staticmethod
    def of(*elements: _of_2__E) -> List[_of_2__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_3__E, e2: _of_3__E, /) -> List[_of_3__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_4__E, e2: _of_4__E, e3: _of_4__E, /) -> List[_of_4__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_5__E, e2: _of_5__E, e3: _of_5__E, e4: _of_5__E, /) -> List[_of_5__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_6__E, e2: _of_6__E, e3: _of_6__E, e4: _of_6__E, e5: _of_6__E, /) -> List[_of_6__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_7__E, e2: _of_7__E, e3: _of_7__E, e4: _of_7__E, e5: _of_7__E, e6: _of_7__E, /) -> List[_of_7__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_8__E, e2: _of_8__E, e3: _of_8__E, e4: _of_8__E, e5: _of_8__E, e6: _of_8__E, e7: _of_8__E, /) -> List[_of_8__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_9__E, e2: _of_9__E, e3: _of_9__E, e4: _of_9__E, e5: _of_9__E, e6: _of_9__E, e7: _of_9__E, e8: _of_9__E, /) -> List[_of_9__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_10__E, e2: _of_10__E, e3: _of_10__E, e4: _of_10__E, e5: _of_10__E, e6: _of_10__E, e7: _of_10__E, e8: _of_10__E, e9: _of_10__E, /) -> List[_of_10__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_11__E, e2: _of_11__E, e3: _of_11__E, e4: _of_11__E, e5: _of_11__E, e6: _of_11__E, e7: _of_11__E, e8: _of_11__E, e9: _of_11__E, e10: _of_11__E, /) -> List[_of_11__E]: ...
    @typing.overload
    def remove(self, arg1: int | java.jint | java.lang.Integer, /) -> _List__E: ...
    @typing.overload
    def remove(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, arg1: Collection[java.lang.Object], /) -> bool: ...
    def removeFirst(self) -> _List__E: ...
    def removeLast(self) -> _List__E: ...
    def replaceAll(self, operator: java.util.function.UnaryOperator[_List__E], /) -> None: ...
    def retainAll(self, arg1: Collection[java.lang.Object], /) -> bool: ...
    def reversed(self) -> List[_List__E]: ...
    def set(self, arg1: int | java.jint | java.lang.Integer, arg2: _List__E, /) -> _List__E: ...
    def size(self) -> int: ...
    def sort(self, c: Comparator[_List__E], /) -> None: ...
    def spliterator(self) -> Spliterator[_List__E]: ...
    def subList(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, /) -> List[_List__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, arg1: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...

_ListIterator__E = typing.TypeVar('_ListIterator__E')  # <E>
class ListIterator(Iterator[_ListIterator__E], typing.Generic[_ListIterator__E]):
    def add(self, arg1: _ListIterator__E, /) -> None: ...
    def hasNext(self) -> bool: ...
    def hasPrevious(self) -> bool: ...
    def next(self) -> _ListIterator__E: ...
    def nextIndex(self) -> int: ...
    def previous(self) -> _ListIterator__E: ...
    def previousIndex(self) -> int: ...
    def remove(self) -> None: ...
    def set(self, arg1: _ListIterator__E, /) -> None: ...

class ListResourceBundle(ResourceBundle):
    def __init__(self) -> None: ...
    def getContents(self) -> java.chaquopy.JavaArray[java.chaquopy.JavaArray[java.lang.Object]]: ...
    def getKeys(self) -> Enumeration[java.lang.String]: ...
    def handleGetObject(self, key: str | java.lang.String, /) -> java.lang.Object: ...
    def handleKeySet(self) -> Set[java.lang.String]: ...

class Locale(java.lang.Cloneable, java.io.Serializable):
    CANADA: typing.ClassVar[Locale] = ...
    CANADA_FRENCH: typing.ClassVar[Locale] = ...
    CHINA: typing.ClassVar[Locale] = ...
    CHINESE: typing.ClassVar[Locale] = ...
    ENGLISH: typing.ClassVar[Locale] = ...
    FRANCE: typing.ClassVar[Locale] = ...
    FRENCH: typing.ClassVar[Locale] = ...
    GERMAN: typing.ClassVar[Locale] = ...
    GERMANY: typing.ClassVar[Locale] = ...
    ITALIAN: typing.ClassVar[Locale] = ...
    ITALY: typing.ClassVar[Locale] = ...
    JAPAN: typing.ClassVar[Locale] = ...
    JAPANESE: typing.ClassVar[Locale] = ...
    KOREA: typing.ClassVar[Locale] = ...
    KOREAN: typing.ClassVar[Locale] = ...
    PRC: typing.ClassVar[Locale] = ...
    PRIVATE_USE_EXTENSION: typing.ClassVar[str] = ...
    ROOT: typing.ClassVar[Locale] = ...
    SIMPLIFIED_CHINESE: typing.ClassVar[Locale] = ...
    TAIWAN: typing.ClassVar[Locale] = ...
    TRADITIONAL_CHINESE: typing.ClassVar[Locale] = ...
    UK: typing.ClassVar[Locale] = ...
    UNICODE_LOCALE_EXTENSION: typing.ClassVar[str] = ...
    US: typing.ClassVar[Locale] = ...
    @typing.overload
    def __init__(self, language: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, language: str | java.lang.String, country: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, language: str | java.lang.String, country: str | java.lang.String, variant: str | java.lang.String, /) -> None: ...
    @staticmethod
    def availableLocales() -> java.util.stream.Stream[Locale]: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    @staticmethod
    def filter(priorityList: List[Locale.LanguageRange], locales: Collection[Locale], /) -> List[Locale]: ...
    @typing.overload
    @staticmethod
    def filter(priorityList: List[Locale.LanguageRange], locales: Collection[Locale], mode: Locale.FilteringMode, /) -> List[Locale]: ...
    @typing.overload
    @staticmethod
    def filterTags(priorityList: List[Locale.LanguageRange], tags: Collection[java.lang.String], /) -> List[java.lang.String]: ...
    @typing.overload
    @staticmethod
    def filterTags(priorityList: List[Locale.LanguageRange], tags: Collection[java.lang.String], mode: Locale.FilteringMode, /) -> List[java.lang.String]: ...
    @staticmethod
    def forLanguageTag(languageTag: str | java.lang.String, /) -> Locale: ...
    @staticmethod
    def getAvailableLocales() -> java.chaquopy.JavaArray[Locale]: ...
    def getCountry(self) -> str: ...
    @typing.overload
    @staticmethod
    def getDefault() -> Locale: ...
    @typing.overload
    @staticmethod
    def getDefault(category: Locale.Category, /) -> Locale: ...
    @typing.overload
    def getDisplayCountry(self) -> str: ...
    @typing.overload
    def getDisplayCountry(self, locale: Locale, /) -> str: ...
    @typing.overload
    def getDisplayLanguage(self) -> str: ...
    @typing.overload
    def getDisplayLanguage(self, locale: Locale, /) -> str: ...
    @typing.overload
    def getDisplayName(self) -> str: ...
    @typing.overload
    def getDisplayName(self, locale: Locale, /) -> str: ...
    @typing.overload
    def getDisplayScript(self) -> str: ...
    @typing.overload
    def getDisplayScript(self, inLocale: Locale, /) -> str: ...
    @typing.overload
    def getDisplayVariant(self) -> str: ...
    @typing.overload
    def getDisplayVariant(self, inLocale: Locale, /) -> str: ...
    def getExtension(self, key: str | java.jchar | java.lang.Character, /) -> str: ...
    def getExtensionKeys(self) -> Set[java.lang.Character]: ...
    def getISO3Country(self) -> str: ...
    def getISO3Language(self) -> str: ...
    @typing.overload
    @staticmethod
    def getISOCountries() -> java.chaquopy.JavaArray[java.lang.String]: ...
    @typing.overload
    @staticmethod
    def getISOCountries(type: Locale.IsoCountryCode, /) -> Set[java.lang.String]: ...
    @staticmethod
    def getISOLanguages() -> java.chaquopy.JavaArray[java.lang.String]: ...
    def getLanguage(self) -> str: ...
    def getScript(self) -> str: ...
    def getUnicodeLocaleAttributes(self) -> Set[java.lang.String]: ...
    def getUnicodeLocaleKeys(self) -> Set[java.lang.String]: ...
    def getUnicodeLocaleType(self, key: str | java.lang.String, /) -> str: ...
    def getVariant(self) -> str: ...
    def hasExtensions(self) -> bool: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def lookup(priorityList: List[Locale.LanguageRange], locales: Collection[Locale], /) -> Locale: ...
    @staticmethod
    def lookupTag(priorityList: List[Locale.LanguageRange], tags: Collection[java.lang.String], /) -> str: ...
    @typing.overload
    @staticmethod
    def of(language: str | java.lang.String, /) -> Locale: ...
    @typing.overload
    @staticmethod
    def of(language: str | java.lang.String, country: str | java.lang.String, /) -> Locale: ...
    @typing.overload
    @staticmethod
    def of(language: str | java.lang.String, country: str | java.lang.String, variant: str | java.lang.String, /) -> Locale: ...
    @typing.overload
    @staticmethod
    def setDefault(newLocale: Locale, /) -> None: ...
    @typing.overload
    @staticmethod
    def setDefault(category: Locale.Category, newLocale: Locale, /) -> None: ...
    def stripExtensions(self) -> Locale: ...
    def toLanguageTag(self) -> str: ...
    def toString(self) -> str: ...

    class LanguageRange(java.lang.Object):
        MAX_WEIGHT: typing.ClassVar[float] = ...
        MIN_WEIGHT: typing.ClassVar[float] = ...
        @typing.overload
        def __init__(self, range: str | java.lang.String, /) -> None: ...
        @typing.overload
        def __init__(self, range: str | java.lang.String, weight: float | java.jdouble | java.lang.Double, /) -> None: ...
        def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
        def getRange(self) -> str: ...
        def getWeight(self) -> float: ...
        def hashCode(self) -> int: ...
        @staticmethod
        def mapEquivalents(priorityList: List[Locale.LanguageRange], map: Map[java.lang.String, List[java.lang.String]], /) -> List[Locale.LanguageRange]: ...
        @typing.overload
        @staticmethod
        def parse(ranges: str | java.lang.String, /) -> List[Locale.LanguageRange]: ...
        @typing.overload
        @staticmethod
        def parse(ranges: str | java.lang.String, map: Map[java.lang.String, List[java.lang.String]], /) -> List[Locale.LanguageRange]: ...
        def toString(self) -> str: ...

    class IsoCountryCode(java.lang.Enum[Locale.IsoCountryCode]):
        PART1_ALPHA2: typing.ClassVar[Locale.IsoCountryCode] = ...
        PART1_ALPHA3: typing.ClassVar[Locale.IsoCountryCode] = ...
        PART3: typing.ClassVar[Locale.IsoCountryCode] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> Locale.IsoCountryCode: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[Locale.IsoCountryCode]: ...

    class FilteringMode(java.lang.Enum[Locale.FilteringMode]):
        AUTOSELECT_FILTERING: typing.ClassVar[Locale.FilteringMode] = ...
        EXTENDED_FILTERING: typing.ClassVar[Locale.FilteringMode] = ...
        IGNORE_EXTENDED_RANGES: typing.ClassVar[Locale.FilteringMode] = ...
        MAP_EXTENDED_RANGES: typing.ClassVar[Locale.FilteringMode] = ...
        REJECT_EXTENDED_RANGES: typing.ClassVar[Locale.FilteringMode] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> Locale.FilteringMode: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[Locale.FilteringMode]: ...

    class Category(java.lang.Enum[Locale.Category]):
        DISPLAY: typing.ClassVar[Locale.Category] = ...
        FORMAT: typing.ClassVar[Locale.Category] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> Locale.Category: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[Locale.Category]: ...

    class Builder(java.lang.Object):
        def __init__(self) -> None: ...
        def addUnicodeLocaleAttribute(self, attribute: str | java.lang.String, /) -> Locale.Builder: ...
        def build(self) -> Locale: ...
        def clear(self) -> Locale.Builder: ...
        def clearExtensions(self) -> Locale.Builder: ...
        def removeUnicodeLocaleAttribute(self, attribute: str | java.lang.String, /) -> Locale.Builder: ...
        def setExtension(self, key: str | java.jchar | java.lang.Character, value: str | java.lang.String, /) -> Locale.Builder: ...
        def setLanguage(self, language: str | java.lang.String, /) -> Locale.Builder: ...
        def setLanguageTag(self, languageTag: str | java.lang.String, /) -> Locale.Builder: ...
        def setLocale(self, locale: Locale, /) -> Locale.Builder: ...
        def setRegion(self, region: str | java.lang.String, /) -> Locale.Builder: ...
        def setScript(self, script: str | java.lang.String, /) -> Locale.Builder: ...
        def setUnicodeLocaleKeyword(self, key: str | java.lang.String, type: str | java.lang.String, /) -> Locale.Builder: ...
        def setVariant(self, variant: str | java.lang.String, /) -> Locale.Builder: ...

class LongSummaryStatistics(java.util.function.IntConsumer, java.util.function.LongConsumer):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, count: int | java.jlong | java.lang.Long, min: int | java.jlong | java.lang.Long, max: int | java.jlong | java.lang.Long, sum: int | java.jlong | java.lang.Long, /) -> None: ...
    @typing.overload
    def accept(self, value: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def accept(self, value: int | java.jlong | java.lang.Long, /) -> None: ...
    def combine(self, other: LongSummaryStatistics, /) -> None: ...
    def getAverage(self) -> float: ...
    def getCount(self) -> int: ...
    def getMax(self) -> int: ...
    def getMin(self) -> int: ...
    def getSum(self) -> int: ...
    def toString(self) -> str: ...

_Map__K = typing.TypeVar('_Map__K')  # <K>
_Map__V = typing.TypeVar('_Map__V')  # <V>

_Map__Entry__K = typing.TypeVar('_Map__Entry__K')  # <K>
_Map__Entry__V = typing.TypeVar('_Map__Entry__V')  # <V>
class Map(java.lang.Object, typing.Generic[_Map__K, _Map__V]):
    def clear(self) -> None: ...
    def compute(self, key: _Map__K, remappingFunction: java.util.function.BiFunction[_Map__K, _Map__V, _Map__V], /) -> _Map__V | None: ...
    def computeIfAbsent(self, key: _Map__K, mappingFunction: java.util.function.Function[_Map__K, _Map__V], /) -> _Map__V | None: ...
    def computeIfPresent(self, key: _Map__K, remappingFunction: java.util.function.BiFunction[_Map__K, _Map__V, _Map__V], /) -> _Map__V | None: ...
    def containsKey(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsValue(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    _copyOf__K = typing.TypeVar('_copyOf__K')  # <K>
    _copyOf__V = typing.TypeVar('_copyOf__V')  # <V>
    @staticmethod
    def copyOf(map: Map[_copyOf__K, _copyOf__V], /) -> Map[_copyOf__K, _copyOf__V]: ...
    _entry__K = typing.TypeVar('_entry__K')  # <K>
    _entry__V = typing.TypeVar('_entry__V')  # <V>
    @staticmethod
    def entry(k: _entry__K, v: _entry__V, /) -> Map.Entry[_entry__K, _entry__V]: ...
    def entrySet(self) -> Set[Map.Entry[_Map__K, _Map__V]]: ...
    def equals(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def forEach(self, action: java.util.function.BiConsumer[_Map__K, _Map__V], /) -> None: ...
    def get(self, arg1: java.lang.Object | int | bool | float | str, /) -> _Map__V | None: ...
    def getOrDefault(self, key: java.lang.Object | int | bool | float | str, defaultValue: _Map__V, /) -> _Map__V: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_Map__K]: ...
    def merge(self, key: _Map__K, value: _Map__V, remappingFunction: java.util.function.BiFunction[_Map__V, _Map__V, _Map__V], /) -> _Map__V | None: ...
    _of_1__K = typing.TypeVar('_of_1__K')  # <K>
    _of_1__V = typing.TypeVar('_of_1__V')  # <V>
    _of_2__K = typing.TypeVar('_of_2__K')  # <K>
    _of_2__V = typing.TypeVar('_of_2__V')  # <V>
    _of_3__K = typing.TypeVar('_of_3__K')  # <K>
    _of_3__V = typing.TypeVar('_of_3__V')  # <V>
    _of_4__K = typing.TypeVar('_of_4__K')  # <K>
    _of_4__V = typing.TypeVar('_of_4__V')  # <V>
    _of_5__K = typing.TypeVar('_of_5__K')  # <K>
    _of_5__V = typing.TypeVar('_of_5__V')  # <V>
    _of_6__K = typing.TypeVar('_of_6__K')  # <K>
    _of_6__V = typing.TypeVar('_of_6__V')  # <V>
    _of_7__K = typing.TypeVar('_of_7__K')  # <K>
    _of_7__V = typing.TypeVar('_of_7__V')  # <V>
    _of_8__K = typing.TypeVar('_of_8__K')  # <K>
    _of_8__V = typing.TypeVar('_of_8__V')  # <V>
    _of_9__K = typing.TypeVar('_of_9__K')  # <K>
    _of_9__V = typing.TypeVar('_of_9__V')  # <V>
    _of_10__K = typing.TypeVar('_of_10__K')  # <K>
    _of_10__V = typing.TypeVar('_of_10__V')  # <V>
    @typing.overload
    @staticmethod
    def of() -> Map[java.lang.Object, java.lang.Object]: ...
    @typing.overload
    @staticmethod
    def of(k1: _of_1__K, v1: _of_1__V, /) -> Map[_of_1__K, _of_1__V]: ...
    @typing.overload
    @staticmethod
    def of(k1: _of_2__K, v1: _of_2__V, k2: _of_2__K, v2: _of_2__V, /) -> Map[_of_2__K, _of_2__V]: ...
    @typing.overload
    @staticmethod
    def of(k1: _of_3__K, v1: _of_3__V, k2: _of_3__K, v2: _of_3__V, k3: _of_3__K, v3: _of_3__V, /) -> Map[_of_3__K, _of_3__V]: ...
    @typing.overload
    @staticmethod
    def of(k1: _of_4__K, v1: _of_4__V, k2: _of_4__K, v2: _of_4__V, k3: _of_4__K, v3: _of_4__V, k4: _of_4__K, v4: _of_4__V, /) -> Map[_of_4__K, _of_4__V]: ...
    @typing.overload
    @staticmethod
    def of(k1: _of_5__K, v1: _of_5__V, k2: _of_5__K, v2: _of_5__V, k3: _of_5__K, v3: _of_5__V, k4: _of_5__K, v4: _of_5__V, k5: _of_5__K, v5: _of_5__V, /) -> Map[_of_5__K, _of_5__V]: ...
    @typing.overload
    @staticmethod
    def of(k1: _of_6__K, v1: _of_6__V, k2: _of_6__K, v2: _of_6__V, k3: _of_6__K, v3: _of_6__V, k4: _of_6__K, v4: _of_6__V, k5: _of_6__K, v5: _of_6__V, k6: _of_6__K, v6: _of_6__V, /) -> Map[_of_6__K, _of_6__V]: ...
    @typing.overload
    @staticmethod
    def of(k1: _of_7__K, v1: _of_7__V, k2: _of_7__K, v2: _of_7__V, k3: _of_7__K, v3: _of_7__V, k4: _of_7__K, v4: _of_7__V, k5: _of_7__K, v5: _of_7__V, k6: _of_7__K, v6: _of_7__V, k7: _of_7__K, v7: _of_7__V, /) -> Map[_of_7__K, _of_7__V]: ...
    @typing.overload
    @staticmethod
    def of(k1: _of_8__K, v1: _of_8__V, k2: _of_8__K, v2: _of_8__V, k3: _of_8__K, v3: _of_8__V, k4: _of_8__K, v4: _of_8__V, k5: _of_8__K, v5: _of_8__V, k6: _of_8__K, v6: _of_8__V, k7: _of_8__K, v7: _of_8__V, k8: _of_8__K, v8: _of_8__V, /) -> Map[_of_8__K, _of_8__V]: ...
    @typing.overload
    @staticmethod
    def of(k1: _of_9__K, v1: _of_9__V, k2: _of_9__K, v2: _of_9__V, k3: _of_9__K, v3: _of_9__V, k4: _of_9__K, v4: _of_9__V, k5: _of_9__K, v5: _of_9__V, k6: _of_9__K, v6: _of_9__V, k7: _of_9__K, v7: _of_9__V, k8: _of_9__K, v8: _of_9__V, k9: _of_9__K, v9: _of_9__V, /) -> Map[_of_9__K, _of_9__V]: ...
    @typing.overload
    @staticmethod
    def of(k1: _of_10__K, v1: _of_10__V, k2: _of_10__K, v2: _of_10__V, k3: _of_10__K, v3: _of_10__V, k4: _of_10__K, v4: _of_10__V, k5: _of_10__K, v5: _of_10__V, k6: _of_10__K, v6: _of_10__V, k7: _of_10__K, v7: _of_10__V, k8: _of_10__K, v8: _of_10__V, k9: _of_10__K, v9: _of_10__V, k10: _of_10__K, v10: _of_10__V, /) -> Map[_of_10__K, _of_10__V]: ...
    _ofEntries__K = typing.TypeVar('_ofEntries__K')  # <K>
    _ofEntries__V = typing.TypeVar('_ofEntries__V')  # <V>
    @staticmethod
    def ofEntries(*entries: Map.Entry[_ofEntries__K, _ofEntries__V]) -> Map[_ofEntries__K, _ofEntries__V]: ...
    def put(self, arg1: _Map__K, arg2: _Map__V, /) -> _Map__V | None: ...
    def putAll(self, arg1: Map[_Map__K, _Map__V], /) -> None: ...
    def putIfAbsent(self, key: _Map__K, value: _Map__V, /) -> _Map__V | None: ...
    @typing.overload
    def remove(self, arg1: java.lang.Object | int | bool | float | str, /) -> _Map__V | None: ...
    @typing.overload
    def remove(self, key: java.lang.Object | int | bool | float | str, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def replace(self, key: _Map__K, value: _Map__V, /) -> _Map__V | None: ...
    @typing.overload
    def replace(self, key: _Map__K, oldValue: _Map__V, newValue: _Map__V, /) -> bool: ...
    def replaceAll(self, function: java.util.function.BiFunction[_Map__K, _Map__V, _Map__V], /) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_Map__V]: ...
    class Entry(java.lang.Object, typing.Generic[_Map__Entry__K, _Map__Entry__V]):
        _comparingByKey_1__K = typing.TypeVar('_comparingByKey_1__K')  # <K>
        @typing.overload
        @staticmethod
        def comparingByKey() -> Comparator[Map.Entry[java.lang.Object, java.lang.Object]]: ...
        @typing.overload
        @staticmethod
        def comparingByKey(cmp: Comparator[_comparingByKey_1__K], /) -> Comparator[Map.Entry[_comparingByKey_1__K, java.lang.Object]]: ...
        _comparingByValue_1__V = typing.TypeVar('_comparingByValue_1__V')  # <V>
        @typing.overload
        @staticmethod
        def comparingByValue() -> Comparator[Map.Entry[java.lang.Object, java.lang.Object]]: ...
        @typing.overload
        @staticmethod
        def comparingByValue(cmp: Comparator[_comparingByValue_1__V], /) -> Comparator[Map.Entry[java.lang.Object, _comparingByValue_1__V]]: ...
        _copyOf__K = typing.TypeVar('_copyOf__K')  # <K>
        _copyOf__V = typing.TypeVar('_copyOf__V')  # <V>
        @staticmethod
        def copyOf(e: Map.Entry[_copyOf__K, _copyOf__V], /) -> Map.Entry[_copyOf__K, _copyOf__V]: ...
        def equals(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
        def getKey(self) -> _Map__Entry__K: ...
        def getValue(self) -> _Map__Entry__V: ...
        def hashCode(self) -> int: ...
        def setValue(self, arg1: _Map__Entry__V, /) -> _Map__Entry__V: ...

class MissingFormatArgumentException(IllegalFormatException):
    def __init__(self, s: str | java.lang.String, /) -> None: ...
    def getFormatSpecifier(self) -> str: ...
    def getMessage(self) -> str: ...

class MissingFormatWidthException(IllegalFormatException):
    def __init__(self, s: str | java.lang.String, /) -> None: ...
    def getFormatSpecifier(self) -> str: ...
    def getMessage(self) -> str: ...

class MissingResourceException(java.lang.RuntimeException):
    def __init__(self, s: str | java.lang.String, className: str | java.lang.String, key: str | java.lang.String, /) -> None: ...
    def getClassName(self) -> str: ...
    def getKey(self) -> str: ...

_NavigableMap__K = typing.TypeVar('_NavigableMap__K')  # <K>
_NavigableMap__V = typing.TypeVar('_NavigableMap__V')  # <V>
class NavigableMap(SortedMap[_NavigableMap__K, _NavigableMap__V], typing.Generic[_NavigableMap__K, _NavigableMap__V]):
    def ceilingEntry(self, arg1: _NavigableMap__K, /) -> Map.Entry[_NavigableMap__K, _NavigableMap__V] | None: ...
    def ceilingKey(self, arg1: _NavigableMap__K, /) -> _NavigableMap__K | None: ...
    def descendingKeySet(self) -> NavigableSet[_NavigableMap__K]: ...
    def descendingMap(self) -> NavigableMap[_NavigableMap__K, _NavigableMap__V]: ...
    def firstEntry(self) -> Map.Entry[_NavigableMap__K, _NavigableMap__V] | None: ...
    def floorEntry(self, arg1: _NavigableMap__K, /) -> Map.Entry[_NavigableMap__K, _NavigableMap__V] | None: ...
    def floorKey(self, arg1: _NavigableMap__K, /) -> _NavigableMap__K | None: ...
    @typing.overload
    def headMap(self, arg1: _NavigableMap__K, /) -> SortedMap[_NavigableMap__K, _NavigableMap__V]: ...
    @typing.overload
    def headMap(self, arg1: _NavigableMap__K, arg2: bool | java.jboolean | java.lang.Boolean, /) -> NavigableMap[_NavigableMap__K, _NavigableMap__V]: ...
    def higherEntry(self, arg1: _NavigableMap__K, /) -> Map.Entry[_NavigableMap__K, _NavigableMap__V] | None: ...
    def higherKey(self, arg1: _NavigableMap__K, /) -> _NavigableMap__K | None: ...
    def lastEntry(self) -> Map.Entry[_NavigableMap__K, _NavigableMap__V] | None: ...
    def lowerEntry(self, arg1: _NavigableMap__K, /) -> Map.Entry[_NavigableMap__K, _NavigableMap__V] | None: ...
    def lowerKey(self, arg1: _NavigableMap__K, /) -> _NavigableMap__K | None: ...
    def navigableKeySet(self) -> NavigableSet[_NavigableMap__K]: ...
    def pollFirstEntry(self) -> Map.Entry[_NavigableMap__K, _NavigableMap__V] | None: ...
    def pollLastEntry(self) -> Map.Entry[_NavigableMap__K, _NavigableMap__V] | None: ...
    def reversed(self) -> NavigableMap[_NavigableMap__K, _NavigableMap__V]: ...
    @typing.overload
    def subMap(self, arg1: _NavigableMap__K, arg2: _NavigableMap__K, /) -> SortedMap[_NavigableMap__K, _NavigableMap__V]: ...
    @typing.overload
    def subMap(self, arg1: _NavigableMap__K, arg2: bool | java.jboolean | java.lang.Boolean, arg3: _NavigableMap__K, arg4: bool | java.jboolean | java.lang.Boolean, /) -> NavigableMap[_NavigableMap__K, _NavigableMap__V]: ...
    @typing.overload
    def tailMap(self, arg1: _NavigableMap__K, /) -> SortedMap[_NavigableMap__K, _NavigableMap__V]: ...
    @typing.overload
    def tailMap(self, arg1: _NavigableMap__K, arg2: bool | java.jboolean | java.lang.Boolean, /) -> NavigableMap[_NavigableMap__K, _NavigableMap__V]: ...

_NavigableSet__E = typing.TypeVar('_NavigableSet__E')  # <E>
class NavigableSet(SortedSet[_NavigableSet__E], typing.Generic[_NavigableSet__E]):
    def ceiling(self, arg1: _NavigableSet__E, /) -> _NavigableSet__E | None: ...
    def descendingIterator(self) -> Iterator[_NavigableSet__E]: ...
    def descendingSet(self) -> NavigableSet[_NavigableSet__E]: ...
    def floor(self, arg1: _NavigableSet__E, /) -> _NavigableSet__E | None: ...
    @typing.overload
    def headSet(self, arg1: _NavigableSet__E, /) -> SortedSet[_NavigableSet__E]: ...
    @typing.overload
    def headSet(self, arg1: _NavigableSet__E, arg2: bool | java.jboolean | java.lang.Boolean, /) -> NavigableSet[_NavigableSet__E]: ...
    def higher(self, arg1: _NavigableSet__E, /) -> _NavigableSet__E | None: ...
    def iterator(self) -> Iterator[_NavigableSet__E]: ...
    def lower(self, arg1: _NavigableSet__E, /) -> _NavigableSet__E | None: ...
    def pollFirst(self) -> _NavigableSet__E | None: ...
    def pollLast(self) -> _NavigableSet__E | None: ...
    def removeFirst(self) -> _NavigableSet__E: ...
    def removeLast(self) -> _NavigableSet__E: ...
    def reversed(self) -> NavigableSet[_NavigableSet__E]: ...
    @typing.overload
    def subSet(self, arg1: _NavigableSet__E, arg2: _NavigableSet__E, /) -> SortedSet[_NavigableSet__E]: ...
    @typing.overload
    def subSet(self, arg1: _NavigableSet__E, arg2: bool | java.jboolean | java.lang.Boolean, arg3: _NavigableSet__E, arg4: bool | java.jboolean | java.lang.Boolean, /) -> NavigableSet[_NavigableSet__E]: ...
    @typing.overload
    def tailSet(self, arg1: _NavigableSet__E, /) -> SortedSet[_NavigableSet__E]: ...
    @typing.overload
    def tailSet(self, arg1: _NavigableSet__E, arg2: bool | java.jboolean | java.lang.Boolean, /) -> NavigableSet[_NavigableSet__E]: ...

class NoSuchElementException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: java.lang.Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, s: str | java.lang.String, cause: java.lang.Throwable, /) -> None: ...

class Objects(java.lang.Object):
    @typing.overload
    @staticmethod
    def checkFromIndexSize(fromIndex: int | java.jint | java.lang.Integer, size: int | java.jint | java.lang.Integer, length: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def checkFromIndexSize(fromIndex: int | java.jlong | java.lang.Long, size: int | java.jlong | java.lang.Long, length: int | java.jlong | java.lang.Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def checkFromToIndex(fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, length: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def checkFromToIndex(fromIndex: int | java.jlong | java.lang.Long, toIndex: int | java.jlong | java.lang.Long, length: int | java.jlong | java.lang.Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def checkIndex(index: int | java.jint | java.lang.Integer, length: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def checkIndex(index: int | java.jlong | java.lang.Long, length: int | java.jlong | java.lang.Long, /) -> int: ...
    _compare__T = typing.TypeVar('_compare__T')  # <T>
    @staticmethod
    def compare(a: _compare__T, b: _compare__T, c: Comparator[_compare__T], /) -> int: ...
    @staticmethod
    def deepEquals(a: java.lang.Object | int | bool | float | str, b: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def equals(a: java.lang.Object | int | bool | float | str, b: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def hash(*values: java.lang.Object) -> int: ...
    @staticmethod
    def hashCode(o: java.lang.Object | int | bool | float | str, /) -> int: ...
    @staticmethod
    def isNull(obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def nonNull(obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    _requireNonNull_0__T = typing.TypeVar('_requireNonNull_0__T')  # <T>
    _requireNonNull_1__T = typing.TypeVar('_requireNonNull_1__T')  # <T>
    _requireNonNull_2__T = typing.TypeVar('_requireNonNull_2__T')  # <T>
    @typing.overload
    @staticmethod
    def requireNonNull(obj: _requireNonNull_0__T, /) -> _requireNonNull_0__T: ...
    @typing.overload
    @staticmethod
    def requireNonNull(obj: _requireNonNull_1__T, message: str | java.lang.String, /) -> _requireNonNull_1__T: ...
    @typing.overload
    @staticmethod
    def requireNonNull(obj: _requireNonNull_2__T, messageSupplier: java.util.function.Supplier[java.lang.String], /) -> _requireNonNull_2__T: ...
    _requireNonNullElse__T = typing.TypeVar('_requireNonNullElse__T')  # <T>
    @staticmethod
    def requireNonNullElse(obj: _requireNonNullElse__T, defaultObj: _requireNonNullElse__T, /) -> _requireNonNullElse__T: ...
    _requireNonNullElseGet__T = typing.TypeVar('_requireNonNullElseGet__T')  # <T>
    @staticmethod
    def requireNonNullElseGet(obj: _requireNonNullElseGet__T, supplier: java.util.function.Supplier[_requireNonNullElseGet__T], /) -> _requireNonNullElseGet__T: ...
    @staticmethod
    def toIdentityString(o: java.lang.Object | int | bool | float | str, /) -> str: ...
    @typing.overload
    @staticmethod
    def toString(o: java.lang.Object | int | bool | float | str, /) -> str: ...
    @typing.overload
    @staticmethod
    def toString(o: java.lang.Object | int | bool | float | str, nullDefault: str | java.lang.String, /) -> str: ...

class Observable(java.lang.Object):
    def __init__(self) -> None: ...
    def addObserver(self, o: Observer, /) -> None: ...
    def clearChanged(self) -> None: ...
    def countObservers(self) -> int: ...
    def deleteObserver(self, o: Observer, /) -> None: ...
    def deleteObservers(self) -> None: ...
    def hasChanged(self) -> bool: ...
    @typing.overload
    def notifyObservers(self) -> None: ...
    @typing.overload
    def notifyObservers(self, arg: java.lang.Object | int | bool | float | str, /) -> None: ...
    def setChanged(self) -> None: ...

class Observer(java.lang.Object):
    def update(self, arg1: Observable, arg2: java.lang.Object | int | bool | float | str, /) -> None: ...

_Optional__T = typing.TypeVar('_Optional__T')  # <T>
class Optional(java.lang.Object, typing.Generic[_Optional__T]):
    @staticmethod
    def empty() -> Optional[java.lang.Object]: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def filter(self, predicate: java.util.function.Predicate[_Optional__T], /) -> Optional[_Optional__T]: ...
    _flatMap__U = typing.TypeVar('_flatMap__U')  # <U>
    def flatMap(self, mapper: java.util.function.Function[_Optional__T, Optional[_flatMap__U]], /) -> Optional[_flatMap__U]: ...
    def get(self) -> _Optional__T: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, action: java.util.function.Consumer[_Optional__T], /) -> None: ...
    def ifPresentOrElse(self, action: java.util.function.Consumer[_Optional__T], emptyAction: java.lang.Runnable, /) -> None: ...
    def isEmpty(self) -> bool: ...
    def isPresent(self) -> bool: ...
    _map__U = typing.TypeVar('_map__U')  # <U>
    def map(self, mapper: java.util.function.Function[_Optional__T, _map__U], /) -> Optional[_map__U]: ...
    _of__T = typing.TypeVar('_of__T')  # <T>
    @staticmethod
    def of(value: _of__T, /) -> Optional[_of__T]: ...
    _ofNullable__T = typing.TypeVar('_ofNullable__T')  # <T>
    @staticmethod
    def ofNullable(value: _ofNullable__T, /) -> Optional[_ofNullable__T]: ...
    def orElse(self, other: _Optional__T, /) -> _Optional__T: ...
    def orElseGet(self, supplier: java.util.function.Supplier[_Optional__T], /) -> _Optional__T: ...
    @typing.overload
    def orElseThrow(self) -> _Optional__T: ...
    @typing.overload
    def orElseThrow(self, exceptionSupplier: java.util.function.Supplier[java.lang.Throwable], /) -> _Optional__T: ...
    def or_(self, supplier: java.util.function.Supplier[Optional[_Optional__T]], /) -> Optional[_Optional__T]: ...
    def stream(self) -> java.util.stream.Stream[_Optional__T]: ...
    def toString(self) -> str: ...

class OptionalDouble(java.lang.Object):
    @staticmethod
    def empty() -> OptionalDouble: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getAsDouble(self) -> float: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, action: java.util.function.DoubleConsumer, /) -> None: ...
    def ifPresentOrElse(self, action: java.util.function.DoubleConsumer, emptyAction: java.lang.Runnable, /) -> None: ...
    def isEmpty(self) -> bool: ...
    def isPresent(self) -> bool: ...
    @staticmethod
    def of(value: float | java.jdouble | java.lang.Double, /) -> OptionalDouble: ...
    def orElse(self, other: float | java.jdouble | java.lang.Double, /) -> float: ...
    def orElseGet(self, supplier: java.util.function.DoubleSupplier, /) -> float: ...
    @typing.overload
    def orElseThrow(self) -> float: ...
    @typing.overload
    def orElseThrow(self, exceptionSupplier: java.util.function.Supplier[java.lang.Throwable], /) -> float: ...
    def stream(self) -> java.util.stream.DoubleStream: ...
    def toString(self) -> str: ...

class OptionalInt(java.lang.Object):
    @staticmethod
    def empty() -> OptionalInt: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getAsInt(self) -> int: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, action: java.util.function.IntConsumer, /) -> None: ...
    def ifPresentOrElse(self, action: java.util.function.IntConsumer, emptyAction: java.lang.Runnable, /) -> None: ...
    def isEmpty(self) -> bool: ...
    def isPresent(self) -> bool: ...
    @staticmethod
    def of(value: int | java.jint | java.lang.Integer, /) -> OptionalInt: ...
    def orElse(self, other: int | java.jint | java.lang.Integer, /) -> int: ...
    def orElseGet(self, supplier: java.util.function.IntSupplier, /) -> int: ...
    @typing.overload
    def orElseThrow(self) -> int: ...
    @typing.overload
    def orElseThrow(self, exceptionSupplier: java.util.function.Supplier[java.lang.Throwable], /) -> int: ...
    def stream(self) -> java.util.stream.IntStream: ...
    def toString(self) -> str: ...

class OptionalLong(java.lang.Object):
    @staticmethod
    def empty() -> OptionalLong: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getAsLong(self) -> int: ...
    def hashCode(self) -> int: ...
    def ifPresent(self, action: java.util.function.LongConsumer, /) -> None: ...
    def ifPresentOrElse(self, action: java.util.function.LongConsumer, emptyAction: java.lang.Runnable, /) -> None: ...
    def isEmpty(self) -> bool: ...
    def isPresent(self) -> bool: ...
    @staticmethod
    def of(value: int | java.jlong | java.lang.Long, /) -> OptionalLong: ...
    def orElse(self, other: int | java.jlong | java.lang.Long, /) -> int: ...
    def orElseGet(self, supplier: java.util.function.LongSupplier, /) -> int: ...
    @typing.overload
    def orElseThrow(self) -> int: ...
    @typing.overload
    def orElseThrow(self, exceptionSupplier: java.util.function.Supplier[java.lang.Throwable], /) -> int: ...
    def stream(self) -> java.util.stream.LongStream: ...
    def toString(self) -> str: ...

_PrimitiveIterator__T = typing.TypeVar('_PrimitiveIterator__T')  # <T>
_PrimitiveIterator__T_CONS = typing.TypeVar('_PrimitiveIterator__T_CONS')  # <T_CONS>
class PrimitiveIterator(Iterator[_PrimitiveIterator__T], typing.Generic[_PrimitiveIterator__T, _PrimitiveIterator__T_CONS]):
    def forEachRemaining(self, arg1: _PrimitiveIterator__T_CONS, /) -> None: ...

    class OfLong(PrimitiveIterator[java.lang.Long, java.util.function.LongConsumer]):
        @typing.overload
        def forEachRemaining(self, action: java.util.function.Consumer[int], /) -> None: ...
        @typing.overload
        def forEachRemaining(self, action: java.util.function.LongConsumer, /) -> None: ...
        def next(self) -> int: ...
        def nextLong(self) -> int: ...

    class OfInt(PrimitiveIterator[java.lang.Integer, java.util.function.IntConsumer]):
        @typing.overload
        def forEachRemaining(self, action: java.util.function.Consumer[int], /) -> None: ...
        @typing.overload
        def forEachRemaining(self, action: java.util.function.IntConsumer, /) -> None: ...
        def next(self) -> int: ...
        def nextInt(self) -> int: ...

    class OfDouble(PrimitiveIterator[java.lang.Double, java.util.function.DoubleConsumer]):
        @typing.overload
        def forEachRemaining(self, action: java.util.function.Consumer[float], /) -> None: ...
        @typing.overload
        def forEachRemaining(self, action: java.util.function.DoubleConsumer, /) -> None: ...
        def next(self) -> float: ...
        def nextDouble(self) -> float: ...

_PriorityQueue__E = typing.TypeVar('_PriorityQueue__E')  # <E>
class PriorityQueue(AbstractQueue[_PriorityQueue__E], java.io.Serializable, typing.Generic[_PriorityQueue__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, c: Collection[_PriorityQueue__E], /) -> None: ...
    @typing.overload
    def __init__(self, comparator: Comparator[_PriorityQueue__E], /) -> None: ...
    @typing.overload
    def __init__(self, c: PriorityQueue[_PriorityQueue__E], /) -> None: ...
    @typing.overload
    def __init__(self, c: SortedSet[_PriorityQueue__E], /) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, comparator: Comparator[_PriorityQueue__E], /) -> None: ...
    def add(self, e: _PriorityQueue__E, /) -> bool: ...
    def clear(self) -> None: ...
    def comparator(self) -> Comparator[_PriorityQueue__E] | None: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def forEach(self, action: java.util.function.Consumer[_PriorityQueue__E], /) -> None: ...
    def iterator(self) -> Iterator[_PriorityQueue__E]: ...
    def offer(self, e: _PriorityQueue__E, /) -> bool: ...
    def peek(self) -> _PriorityQueue__E | None: ...
    def poll(self) -> _PriorityQueue__E | None: ...
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, c: Collection[java.lang.Object], /) -> bool: ...
    def removeIf(self, filter: java.util.function.Predicate[_PriorityQueue__E], /) -> bool: ...
    def retainAll(self, c: Collection[java.lang.Object], /) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> Spliterator[_PriorityQueue__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...

class Properties(Hashtable[java.lang.Object, java.lang.Object]):
    defaults: Properties = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, defaults: Properties, /) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def compute(self, key: java.lang.Object | int | bool | float | str, remappingFunction: java.util.function.BiFunction[java.lang.Object, java.lang.Object, java.lang.Object], /) -> java.lang.Object: ...
    def computeIfAbsent(self, key: java.lang.Object | int | bool | float | str, mappingFunction: java.util.function.Function[java.lang.Object, java.lang.Object], /) -> java.lang.Object: ...
    def computeIfPresent(self, key: java.lang.Object | int | bool | float | str, remappingFunction: java.util.function.BiFunction[java.lang.Object, java.lang.Object, java.lang.Object], /) -> java.lang.Object: ...
    def contains(self, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsKey(self, key: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsValue(self, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def elements(self) -> Enumeration[java.lang.Object]: ...
    def entrySet(self) -> Set[Map.Entry[java.lang.Object, java.lang.Object]]: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def forEach(self, action: java.util.function.BiConsumer[java.lang.Object, java.lang.Object], /) -> None: ...
    def get(self, key: java.lang.Object | int | bool | float | str, /) -> java.lang.Object: ...
    def getOrDefault(self, key: java.lang.Object | int | bool | float | str, defaultValue: java.lang.Object | int | bool | float | str, /) -> java.lang.Object: ...
    @typing.overload
    def getProperty(self, key: str | java.lang.String, /) -> str | None: ...
    @typing.overload
    def getProperty(self, key: str | java.lang.String, defaultValue: str | java.lang.String, /) -> str: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[java.lang.Object]: ...
    def keys(self) -> Enumeration[java.lang.Object]: ...
    @typing.overload
    def list(self, out: java.io.PrintStream, /) -> None: ...
    @typing.overload
    def list(self, out: java.io.PrintWriter, /) -> None: ...
    @typing.overload
    def load(self, inStream: java.io.InputStream, /) -> None: ...
    @typing.overload
    def load(self, reader: java.io.Reader, /) -> None: ...
    def loadFromXML(self, in_: java.io.InputStream, /) -> None: ...
    def merge(self, key: java.lang.Object | int | bool | float | str, value: java.lang.Object | int | bool | float | str, remappingFunction: java.util.function.BiFunction[java.lang.Object, java.lang.Object, java.lang.Object], /) -> java.lang.Object: ...
    def propertyNames(self) -> Enumeration[java.lang.Object]: ...
    def put(self, key: java.lang.Object | int | bool | float | str, value: java.lang.Object | int | bool | float | str, /) -> java.lang.Object: ...
    def putAll(self, t: Map[java.lang.Object, java.lang.Object], /) -> None: ...
    def putIfAbsent(self, key: java.lang.Object | int | bool | float | str, value: java.lang.Object | int | bool | float | str, /) -> java.lang.Object: ...
    def rehash(self) -> None: ...
    @typing.overload
    def remove(self, key: java.lang.Object | int | bool | float | str, /) -> java.lang.Object: ...
    @typing.overload
    def remove(self, key: java.lang.Object | int | bool | float | str, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def replace(self, key: java.lang.Object | int | bool | float | str, value: java.lang.Object | int | bool | float | str, /) -> java.lang.Object: ...
    @typing.overload
    def replace(self, key: java.lang.Object | int | bool | float | str, oldValue: java.lang.Object | int | bool | float | str, newValue: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def replaceAll(self, function: java.util.function.BiFunction[java.lang.Object, java.lang.Object, java.lang.Object], /) -> None: ...
    def save(self, out: java.io.OutputStream, comments: str | java.lang.String, /) -> None: ...
    def setProperty(self, key: str | java.lang.String, value: str | java.lang.String, /) -> java.lang.Object | None: ...
    def size(self) -> int: ...
    @typing.overload
    def store(self, out: java.io.OutputStream, comments: str | java.lang.String, /) -> None: ...
    @typing.overload
    def store(self, writer: java.io.Writer, comments: str | java.lang.String, /) -> None: ...
    @typing.overload
    def storeToXML(self, os: java.io.OutputStream, comment: str | java.lang.String, /) -> None: ...
    @typing.overload
    def storeToXML(self, os: java.io.OutputStream, comment: str | java.lang.String, encoding: str | java.lang.String, /) -> None: ...
    @typing.overload
    def storeToXML(self, os: java.io.OutputStream, comment: str | java.lang.String, charset: java.nio.charset.Charset, /) -> None: ...
    def stringPropertyNames(self) -> Set[java.lang.String]: ...
    def toString(self) -> str: ...
    def values(self) -> Collection[java.lang.Object]: ...

class PropertyPermission(java.security.BasicPermission):
    def __init__(self, name: str | java.lang.String, actions: str | java.lang.String, /) -> None: ...

class PropertyResourceBundle(ResourceBundle):
    @typing.overload
    def __init__(self, stream: java.io.InputStream, /) -> None: ...
    @typing.overload
    def __init__(self, reader: java.io.Reader, /) -> None: ...
    def getKeys(self) -> Enumeration[java.lang.String]: ...
    def handleGetObject(self, key: str | java.lang.String, /) -> java.lang.Object: ...
    def handleKeySet(self) -> Set[java.lang.String]: ...

_Queue__E = typing.TypeVar('_Queue__E')  # <E>
class Queue(Collection[_Queue__E], typing.Generic[_Queue__E]):
    def add(self, arg1: _Queue__E, /) -> bool: ...
    def element(self) -> _Queue__E: ...
    def offer(self, arg1: _Queue__E, /) -> bool: ...
    def peek(self) -> _Queue__E | None: ...
    def poll(self) -> _Queue__E | None: ...
    def remove(self) -> _Queue__E: ...

class Random(java.util.random.RandomGenerator, java.io.Serializable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, seed: int | java.jlong | java.lang.Long, /) -> None: ...
    @typing.overload
    def doubles(self) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, streamSize: int | java.jlong | java.lang.Long, /) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, randomNumberOrigin: float | java.jdouble | java.lang.Double, randomNumberBound: float | java.jdouble | java.lang.Double, /) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, streamSize: int | java.jlong | java.lang.Long, randomNumberOrigin: float | java.jdouble | java.lang.Double, randomNumberBound: float | java.jdouble | java.lang.Double, /) -> java.util.stream.DoubleStream: ...
    @staticmethod
    def from_(generator: java.util.random.RandomGenerator, /) -> Random: ...
    @typing.overload
    def ints(self) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, streamSize: int | java.jlong | java.lang.Long, /) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, randomNumberOrigin: int | java.jint | java.lang.Integer, randomNumberBound: int | java.jint | java.lang.Integer, /) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, streamSize: int | java.jlong | java.lang.Long, randomNumberOrigin: int | java.jint | java.lang.Integer, randomNumberBound: int | java.jint | java.lang.Integer, /) -> java.util.stream.IntStream: ...
    @typing.overload
    def longs(self) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, streamSize: int | java.jlong | java.lang.Long, /) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, randomNumberOrigin: int | java.jlong | java.lang.Long, randomNumberBound: int | java.jlong | java.lang.Long, /) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, streamSize: int | java.jlong | java.lang.Long, randomNumberOrigin: int | java.jlong | java.lang.Long, randomNumberBound: int | java.jlong | java.lang.Long, /) -> java.util.stream.LongStream: ...
    def next(self, bits: int | java.jint | java.lang.Integer, /) -> int: ...
    def nextBoolean(self) -> bool: ...
    def nextBytes(self, bytes: java.chaquopy.JavaArrayJByte, /) -> None: ...
    def nextDouble(self) -> float: ...
    def nextFloat(self) -> float: ...
    def nextGaussian(self) -> float: ...
    @typing.overload
    def nextInt(self) -> int: ...
    @typing.overload
    def nextInt(self, bound: int | java.jint | java.lang.Integer, /) -> int: ...
    def nextLong(self) -> int: ...
    def setSeed(self, seed: int | java.jlong | java.lang.Long, /) -> None: ...

class RandomAccess(java.lang.Object): ...

class ResourceBundle(java.lang.Object):
    parent: ResourceBundle = ...
    def __init__(self) -> None: ...
    @typing.overload
    @staticmethod
    def clearCache() -> None: ...
    @typing.overload
    @staticmethod
    def clearCache(loader: java.lang.ClassLoader, /) -> None: ...
    def containsKey(self, key: str | java.lang.String, /) -> bool: ...
    def getBaseBundleName(self) -> str: ...
    @typing.overload
    @staticmethod
    def getBundle(baseName: str | java.lang.String, /) -> ResourceBundle: ...
    @typing.overload
    @staticmethod
    def getBundle(baseName: str | java.lang.String, locale: Locale, /) -> ResourceBundle: ...
    @typing.overload
    @staticmethod
    def getBundle(baseName: str | java.lang.String, control: ResourceBundle.Control, /) -> ResourceBundle: ...
    @typing.overload
    @staticmethod
    def getBundle(baseName: str | java.lang.String, locale: Locale, loader: java.lang.ClassLoader, /) -> ResourceBundle: ...
    @typing.overload
    @staticmethod
    def getBundle(baseName: str | java.lang.String, targetLocale: Locale, control: ResourceBundle.Control, /) -> ResourceBundle: ...
    @typing.overload
    @staticmethod
    def getBundle(baseName: str | java.lang.String, targetLocale: Locale, loader: java.lang.ClassLoader, control: ResourceBundle.Control, /) -> ResourceBundle: ...
    def getKeys(self) -> Enumeration[java.lang.String]: ...
    def getLocale(self) -> Locale: ...
    def getObject(self, key: str | java.lang.String, /) -> java.lang.Object: ...
    def getString(self, key: str | java.lang.String, /) -> str: ...
    def getStringArray(self, key: str | java.lang.String, /) -> java.chaquopy.JavaArray[java.lang.String]: ...
    def handleGetObject(self, arg1: str | java.lang.String, /) -> java.lang.Object: ...
    def handleKeySet(self) -> Set[java.lang.String]: ...
    def keySet(self) -> Set[java.lang.String]: ...
    def setParent(self, parent: ResourceBundle, /) -> None: ...

    class Control(java.lang.Object):
        FORMAT_CLASS: typing.ClassVar[List[java.lang.String]] = ...
        FORMAT_DEFAULT: typing.ClassVar[List[java.lang.String]] = ...
        FORMAT_PROPERTIES: typing.ClassVar[List[java.lang.String]] = ...
        TTL_DONT_CACHE: typing.ClassVar[int] = ...
        TTL_NO_EXPIRATION_CONTROL: typing.ClassVar[int] = ...
        def __init__(self) -> None: ...
        def getCandidateLocales(self, baseName: str | java.lang.String, locale: Locale, /) -> List[Locale]: ...
        @staticmethod
        def getControl(formats: List[java.lang.String], /) -> ResourceBundle.Control: ...
        def getFallbackLocale(self, baseName: str | java.lang.String, locale: Locale, /) -> Locale: ...
        def getFormats(self, baseName: str | java.lang.String, /) -> List[java.lang.String]: ...
        @staticmethod
        def getNoFallbackControl(formats: List[java.lang.String], /) -> ResourceBundle.Control: ...
        def getTimeToLive(self, baseName: str | java.lang.String, locale: Locale, /) -> int: ...
        def needsReload(self, baseName: str | java.lang.String, locale: Locale, format: str | java.lang.String, loader: java.lang.ClassLoader, bundle: ResourceBundle, loadTime: int | java.jlong | java.lang.Long, /) -> bool: ...
        def newBundle(self, baseName: str | java.lang.String, locale: Locale, format: str | java.lang.String, loader: java.lang.ClassLoader, reload: bool | java.jboolean | java.lang.Boolean, /) -> ResourceBundle: ...
        def toBundleName(self, baseName: str | java.lang.String, locale: Locale, /) -> str: ...
        def toResourceName(self, bundleName: str | java.lang.String, suffix: str | java.lang.String, /) -> str: ...

class Scanner(java.io.Closeable, Iterator[java.lang.String]):
    @typing.overload
    def __init__(self, source: java.io.File, /) -> None: ...
    @typing.overload
    def __init__(self, source: java.io.InputStream, /) -> None: ...
    @typing.overload
    def __init__(self, source: java.lang.Readable, /) -> None: ...
    @typing.overload
    def __init__(self, source: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, source: java.nio.channels.ReadableByteChannel, /) -> None: ...
    @typing.overload
    def __init__(self, source: java.nio.file.Path, /) -> None: ...
    @typing.overload
    def __init__(self, source: java.io.File, charsetName: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, source: java.io.File, charset: java.nio.charset.Charset, /) -> None: ...
    @typing.overload
    def __init__(self, source: java.io.InputStream, charsetName: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, source: java.io.InputStream, charset: java.nio.charset.Charset, /) -> None: ...
    @typing.overload
    def __init__(self, source: java.nio.channels.ReadableByteChannel, charsetName: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, source: java.nio.channels.ReadableByteChannel, charset: java.nio.charset.Charset, /) -> None: ...
    @typing.overload
    def __init__(self, source: java.nio.file.Path, charsetName: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, source: java.nio.file.Path, charset: java.nio.charset.Charset, /) -> None: ...
    def close(self) -> None: ...
    def delimiter(self) -> java.util.regex.Pattern: ...
    @typing.overload
    def findAll(self, patString: str | java.lang.String, /) -> java.util.stream.Stream[java.util.regex.MatchResult]: ...
    @typing.overload
    def findAll(self, pattern: java.util.regex.Pattern, /) -> java.util.stream.Stream[java.util.regex.MatchResult]: ...
    @typing.overload
    def findInLine(self, pattern: str | java.lang.String, /) -> str: ...
    @typing.overload
    def findInLine(self, pattern: java.util.regex.Pattern, /) -> str: ...
    @typing.overload
    def findWithinHorizon(self, pattern: str | java.lang.String, horizon: int | java.jint | java.lang.Integer, /) -> str: ...
    @typing.overload
    def findWithinHorizon(self, pattern: java.util.regex.Pattern, horizon: int | java.jint | java.lang.Integer, /) -> str: ...
    @typing.overload
    def hasNext(self) -> bool: ...
    @typing.overload
    def hasNext(self, pattern: str | java.lang.String, /) -> bool: ...
    @typing.overload
    def hasNext(self, pattern: java.util.regex.Pattern, /) -> bool: ...
    def hasNextBigDecimal(self) -> bool: ...
    @typing.overload
    def hasNextBigInteger(self) -> bool: ...
    @typing.overload
    def hasNextBigInteger(self, radix: int | java.jint | java.lang.Integer, /) -> bool: ...
    def hasNextBoolean(self) -> bool: ...
    @typing.overload
    def hasNextByte(self) -> bool: ...
    @typing.overload
    def hasNextByte(self, radix: int | java.jint | java.lang.Integer, /) -> bool: ...
    def hasNextDouble(self) -> bool: ...
    def hasNextFloat(self) -> bool: ...
    @typing.overload
    def hasNextInt(self) -> bool: ...
    @typing.overload
    def hasNextInt(self, radix: int | java.jint | java.lang.Integer, /) -> bool: ...
    def hasNextLine(self) -> bool: ...
    @typing.overload
    def hasNextLong(self) -> bool: ...
    @typing.overload
    def hasNextLong(self, radix: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    def hasNextShort(self) -> bool: ...
    @typing.overload
    def hasNextShort(self, radix: int | java.jint | java.lang.Integer, /) -> bool: ...
    def ioException(self) -> java.io.IOException: ...
    def locale(self) -> Locale: ...
    def match(self) -> java.util.regex.MatchResult: ...
    @typing.overload
    def next(self) -> str: ...
    @typing.overload
    def next(self, pattern: str | java.lang.String, /) -> str: ...
    @typing.overload
    def next(self, pattern: java.util.regex.Pattern, /) -> str: ...
    def nextBigDecimal(self) -> java.math.BigDecimal: ...
    @typing.overload
    def nextBigInteger(self) -> java.math.BigInteger: ...
    @typing.overload
    def nextBigInteger(self, radix: int | java.jint | java.lang.Integer, /) -> java.math.BigInteger: ...
    def nextBoolean(self) -> bool: ...
    @typing.overload
    def nextByte(self) -> int: ...
    @typing.overload
    def nextByte(self, radix: int | java.jint | java.lang.Integer, /) -> int: ...
    def nextDouble(self) -> float: ...
    def nextFloat(self) -> float: ...
    @typing.overload
    def nextInt(self) -> int: ...
    @typing.overload
    def nextInt(self, radix: int | java.jint | java.lang.Integer, /) -> int: ...
    def nextLine(self) -> str: ...
    @typing.overload
    def nextLong(self) -> int: ...
    @typing.overload
    def nextLong(self, radix: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def nextShort(self) -> int: ...
    @typing.overload
    def nextShort(self, radix: int | java.jint | java.lang.Integer, /) -> int: ...
    def radix(self) -> int: ...
    def remove(self) -> None: ...
    def reset(self) -> Scanner: ...
    @typing.overload
    def skip(self, pattern: str | java.lang.String, /) -> Scanner: ...
    @typing.overload
    def skip(self, pattern: java.util.regex.Pattern, /) -> Scanner: ...
    def toString(self) -> str: ...
    def tokens(self) -> java.util.stream.Stream[java.lang.String]: ...
    @typing.overload
    def useDelimiter(self, pattern: str | java.lang.String, /) -> Scanner: ...
    @typing.overload
    def useDelimiter(self, pattern: java.util.regex.Pattern, /) -> Scanner: ...
    def useLocale(self, locale: Locale, /) -> Scanner: ...
    def useRadix(self, radix: int | java.jint | java.lang.Integer, /) -> Scanner: ...

_SequencedCollection__E = typing.TypeVar('_SequencedCollection__E')  # <E>
class SequencedCollection(Collection[_SequencedCollection__E], typing.Generic[_SequencedCollection__E]):
    def addFirst(self, e: _SequencedCollection__E, /) -> None: ...
    def addLast(self, e: _SequencedCollection__E, /) -> None: ...
    def getFirst(self) -> _SequencedCollection__E: ...
    def getLast(self) -> _SequencedCollection__E: ...
    def removeFirst(self) -> _SequencedCollection__E: ...
    def removeLast(self) -> _SequencedCollection__E: ...
    def reversed(self) -> SequencedCollection[_SequencedCollection__E]: ...

_SequencedMap__K = typing.TypeVar('_SequencedMap__K')  # <K>
_SequencedMap__V = typing.TypeVar('_SequencedMap__V')  # <V>
class SequencedMap(Map[_SequencedMap__K, _SequencedMap__V], typing.Generic[_SequencedMap__K, _SequencedMap__V]):
    def firstEntry(self) -> Map.Entry[_SequencedMap__K, _SequencedMap__V]: ...
    def lastEntry(self) -> Map.Entry[_SequencedMap__K, _SequencedMap__V]: ...
    def pollFirstEntry(self) -> Map.Entry[_SequencedMap__K, _SequencedMap__V]: ...
    def pollLastEntry(self) -> Map.Entry[_SequencedMap__K, _SequencedMap__V]: ...
    def putFirst(self, k: _SequencedMap__K, v: _SequencedMap__V, /) -> _SequencedMap__V: ...
    def putLast(self, k: _SequencedMap__K, v: _SequencedMap__V, /) -> _SequencedMap__V: ...
    def reversed(self) -> SequencedMap[_SequencedMap__K, _SequencedMap__V]: ...
    def sequencedEntrySet(self) -> SequencedSet[Map.Entry[_SequencedMap__K, _SequencedMap__V]]: ...
    def sequencedKeySet(self) -> SequencedSet[_SequencedMap__K]: ...
    def sequencedValues(self) -> SequencedCollection[_SequencedMap__V]: ...

_SequencedSet__E = typing.TypeVar('_SequencedSet__E')  # <E>
class SequencedSet(SequencedCollection[_SequencedSet__E], Set[_SequencedSet__E], typing.Generic[_SequencedSet__E]):
    def reversed(self) -> SequencedSet[_SequencedSet__E]: ...

class ServiceConfigurationError(java.lang.Error):
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, cause: java.lang.Throwable, /) -> None: ...

_ServiceLoader__S = typing.TypeVar('_ServiceLoader__S')  # <S>

_ServiceLoader__Provider__S = typing.TypeVar('_ServiceLoader__Provider__S')  # <S>
class ServiceLoader(java.lang.Iterable[_ServiceLoader__S], typing.Generic[_ServiceLoader__S]):
    def findFirst(self) -> Optional[_ServiceLoader__S]: ...
    def iterator(self) -> Iterator[_ServiceLoader__S]: ...
    _load_0__S = typing.TypeVar('_load_0__S')  # <S>
    _load_1__S = typing.TypeVar('_load_1__S')  # <S>
    @typing.overload
    @staticmethod
    def load(service: typing.Type[_load_0__S], /) -> ServiceLoader[_load_0__S]: ...
    @typing.overload
    @staticmethod
    def load(service: typing.Type[_load_1__S], loader: java.lang.ClassLoader, /) -> ServiceLoader[_load_1__S]: ...
    _loadInstalled__S = typing.TypeVar('_loadInstalled__S')  # <S>
    @staticmethod
    def loadInstalled(service: typing.Type[_loadInstalled__S], /) -> ServiceLoader[_loadInstalled__S]: ...
    def reload(self) -> None: ...
    def stream(self) -> java.util.stream.Stream[ServiceLoader.Provider[_ServiceLoader__S]]: ...
    def toString(self) -> str: ...
    class Provider(java.util.function.Supplier[_ServiceLoader__Provider__S], typing.Generic[_ServiceLoader__Provider__S]):
        def get(self) -> _ServiceLoader__Provider__S: ...
        def type(self) -> typing.Type[_ServiceLoader__Provider__S]: ...

_Set__E = typing.TypeVar('_Set__E')  # <E>
class Set(Collection[_Set__E], typing.Generic[_Set__E]):
    def add(self, arg1: _Set__E, /) -> bool: ...
    def addAll(self, arg1: Collection[_Set__E], /) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsAll(self, arg1: Collection[java.lang.Object], /) -> bool: ...
    _copyOf__E = typing.TypeVar('_copyOf__E')  # <E>
    @staticmethod
    def copyOf(coll: Collection[_copyOf__E], /) -> Set[_copyOf__E]: ...
    def equals(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def hashCode(self) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_Set__E]: ...
    _of_1__E = typing.TypeVar('_of_1__E')  # <E>
    _of_2__E = typing.TypeVar('_of_2__E')  # <E>
    _of_3__E = typing.TypeVar('_of_3__E')  # <E>
    _of_4__E = typing.TypeVar('_of_4__E')  # <E>
    _of_5__E = typing.TypeVar('_of_5__E')  # <E>
    _of_6__E = typing.TypeVar('_of_6__E')  # <E>
    _of_7__E = typing.TypeVar('_of_7__E')  # <E>
    _of_8__E = typing.TypeVar('_of_8__E')  # <E>
    _of_9__E = typing.TypeVar('_of_9__E')  # <E>
    _of_10__E = typing.TypeVar('_of_10__E')  # <E>
    _of_11__E = typing.TypeVar('_of_11__E')  # <E>
    @typing.overload
    @staticmethod
    def of() -> Set[java.lang.Object]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_1__E, /) -> Set[_of_1__E]: ...
    @typing.overload
    @staticmethod
    def of(*elements: _of_2__E) -> Set[_of_2__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_3__E, e2: _of_3__E, /) -> Set[_of_3__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_4__E, e2: _of_4__E, e3: _of_4__E, /) -> Set[_of_4__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_5__E, e2: _of_5__E, e3: _of_5__E, e4: _of_5__E, /) -> Set[_of_5__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_6__E, e2: _of_6__E, e3: _of_6__E, e4: _of_6__E, e5: _of_6__E, /) -> Set[_of_6__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_7__E, e2: _of_7__E, e3: _of_7__E, e4: _of_7__E, e5: _of_7__E, e6: _of_7__E, /) -> Set[_of_7__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_8__E, e2: _of_8__E, e3: _of_8__E, e4: _of_8__E, e5: _of_8__E, e6: _of_8__E, e7: _of_8__E, /) -> Set[_of_8__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_9__E, e2: _of_9__E, e3: _of_9__E, e4: _of_9__E, e5: _of_9__E, e6: _of_9__E, e7: _of_9__E, e8: _of_9__E, /) -> Set[_of_9__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_10__E, e2: _of_10__E, e3: _of_10__E, e4: _of_10__E, e5: _of_10__E, e6: _of_10__E, e7: _of_10__E, e8: _of_10__E, e9: _of_10__E, /) -> Set[_of_10__E]: ...
    @typing.overload
    @staticmethod
    def of(e1: _of_11__E, e2: _of_11__E, e3: _of_11__E, e4: _of_11__E, e5: _of_11__E, e6: _of_11__E, e7: _of_11__E, e8: _of_11__E, e9: _of_11__E, e10: _of_11__E, /) -> Set[_of_11__E]: ...
    def remove(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, arg1: Collection[java.lang.Object], /) -> bool: ...
    def retainAll(self, arg1: Collection[java.lang.Object], /) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> Spliterator[_Set__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, arg1: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...

class SimpleTimeZone(TimeZone):
    STANDARD_TIME: typing.ClassVar[int] = ...
    UTC_TIME: typing.ClassVar[int] = ...
    WALL_TIME: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, rawOffset: int | java.jint | java.lang.Integer, ID: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, rawOffset: int | java.jint | java.lang.Integer, ID: str | java.lang.String, startMonth: int | java.jint | java.lang.Integer, startDay: int | java.jint | java.lang.Integer, startDayOfWeek: int | java.jint | java.lang.Integer, startTime: int | java.jint | java.lang.Integer, endMonth: int | java.jint | java.lang.Integer, endDay: int | java.jint | java.lang.Integer, endDayOfWeek: int | java.jint | java.lang.Integer, endTime: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, rawOffset: int | java.jint | java.lang.Integer, ID: str | java.lang.String, startMonth: int | java.jint | java.lang.Integer, startDay: int | java.jint | java.lang.Integer, startDayOfWeek: int | java.jint | java.lang.Integer, startTime: int | java.jint | java.lang.Integer, endMonth: int | java.jint | java.lang.Integer, endDay: int | java.jint | java.lang.Integer, endDayOfWeek: int | java.jint | java.lang.Integer, endTime: int | java.jint | java.lang.Integer, dstSavings: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, rawOffset: int | java.jint | java.lang.Integer, ID: str | java.lang.String, startMonth: int | java.jint | java.lang.Integer, startDay: int | java.jint | java.lang.Integer, startDayOfWeek: int | java.jint | java.lang.Integer, startTime: int | java.jint | java.lang.Integer, startTimeMode: int | java.jint | java.lang.Integer, endMonth: int | java.jint | java.lang.Integer, endDay: int | java.jint | java.lang.Integer, endDayOfWeek: int | java.jint | java.lang.Integer, endTime: int | java.jint | java.lang.Integer, endTimeMode: int | java.jint | java.lang.Integer, dstSavings: int | java.jint | java.lang.Integer, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getDSTSavings(self) -> int: ...
    @typing.overload
    def getOffset(self, date: int | java.jlong | java.lang.Long, /) -> int: ...
    @typing.overload
    def getOffset(self, era: int | java.jint | java.lang.Integer, year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, day: int | java.jint | java.lang.Integer, dayOfWeek: int | java.jint | java.lang.Integer, millis: int | java.jint | java.lang.Integer, /) -> int: ...
    def getRawOffset(self) -> int: ...
    def hasSameRules(self, other: TimeZone, /) -> bool: ...
    def hashCode(self) -> int: ...
    def inDaylightTime(self, date: Date, /) -> bool: ...
    def observesDaylightTime(self) -> bool: ...
    def setDSTSavings(self, millisSavedDuringDST: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def setEndRule(self, endMonth: int | java.jint | java.lang.Integer, endDay: int | java.jint | java.lang.Integer, endTime: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def setEndRule(self, endMonth: int | java.jint | java.lang.Integer, endDay: int | java.jint | java.lang.Integer, endDayOfWeek: int | java.jint | java.lang.Integer, endTime: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def setEndRule(self, endMonth: int | java.jint | java.lang.Integer, endDay: int | java.jint | java.lang.Integer, endDayOfWeek: int | java.jint | java.lang.Integer, endTime: int | java.jint | java.lang.Integer, after: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setRawOffset(self, offsetMillis: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def setStartRule(self, startMonth: int | java.jint | java.lang.Integer, startDay: int | java.jint | java.lang.Integer, startTime: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def setStartRule(self, startMonth: int | java.jint | java.lang.Integer, startDay: int | java.jint | java.lang.Integer, startDayOfWeek: int | java.jint | java.lang.Integer, startTime: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def setStartRule(self, startMonth: int | java.jint | java.lang.Integer, startDay: int | java.jint | java.lang.Integer, startDayOfWeek: int | java.jint | java.lang.Integer, startTime: int | java.jint | java.lang.Integer, after: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setStartYear(self, year: int | java.jint | java.lang.Integer, /) -> None: ...
    def toString(self) -> str: ...
    def useDaylightTime(self) -> bool: ...

_SortedMap__K = typing.TypeVar('_SortedMap__K')  # <K>
_SortedMap__V = typing.TypeVar('_SortedMap__V')  # <V>
class SortedMap(Map[_SortedMap__K, _SortedMap__V], SequencedMap[_SortedMap__K, _SortedMap__V], typing.Generic[_SortedMap__K, _SortedMap__V]):
    def comparator(self) -> Comparator[_SortedMap__K]: ...
    def entrySet(self) -> Set[Map.Entry[_SortedMap__K, _SortedMap__V]]: ...
    def firstKey(self) -> _SortedMap__K | None: ...
    def headMap(self, arg1: _SortedMap__K, /) -> SortedMap[_SortedMap__K, _SortedMap__V]: ...
    def keySet(self) -> Set[_SortedMap__K]: ...
    def lastKey(self) -> _SortedMap__K | None: ...
    def putFirst(self, k: _SortedMap__K, v: _SortedMap__V, /) -> _SortedMap__V: ...
    def putLast(self, k: _SortedMap__K, v: _SortedMap__V, /) -> _SortedMap__V: ...
    def reversed(self) -> SortedMap[_SortedMap__K, _SortedMap__V]: ...
    def subMap(self, arg1: _SortedMap__K, arg2: _SortedMap__K, /) -> SortedMap[_SortedMap__K, _SortedMap__V]: ...
    def tailMap(self, arg1: _SortedMap__K, /) -> SortedMap[_SortedMap__K, _SortedMap__V]: ...
    def values(self) -> Collection[_SortedMap__V]: ...

_SortedSet__E = typing.TypeVar('_SortedSet__E')  # <E>
class SortedSet(SequencedSet[_SortedSet__E], Set[_SortedSet__E], typing.Generic[_SortedSet__E]):
    def addFirst(self, e: _SortedSet__E, /) -> None: ...
    def addLast(self, e: _SortedSet__E, /) -> None: ...
    def comparator(self) -> Comparator[_SortedSet__E] | None: ...
    def first(self) -> _SortedSet__E: ...
    def getFirst(self) -> _SortedSet__E: ...
    def getLast(self) -> _SortedSet__E: ...
    def headSet(self, arg1: _SortedSet__E, /) -> SortedSet[_SortedSet__E]: ...
    def last(self) -> _SortedSet__E: ...
    def removeFirst(self) -> _SortedSet__E: ...
    def removeLast(self) -> _SortedSet__E: ...
    def reversed(self) -> SortedSet[_SortedSet__E]: ...
    def spliterator(self) -> Spliterator[_SortedSet__E]: ...
    def subSet(self, arg1: _SortedSet__E, arg2: _SortedSet__E, /) -> SortedSet[_SortedSet__E]: ...
    def tailSet(self, arg1: _SortedSet__E, /) -> SortedSet[_SortedSet__E]: ...

_Spliterator__T = typing.TypeVar('_Spliterator__T')  # <T>

_Spliterator__OfPrimitive__T = typing.TypeVar('_Spliterator__OfPrimitive__T')  # <T>
_Spliterator__OfPrimitive__T_CONS = typing.TypeVar('_Spliterator__OfPrimitive__T_CONS')  # <T_CONS>
_Spliterator__OfPrimitive__T_SPLITR = typing.TypeVar('_Spliterator__OfPrimitive__T_SPLITR')  # <T_SPLITR>
class Spliterator(java.lang.Object, typing.Generic[_Spliterator__T]):
    CONCURRENT: typing.ClassVar[int] = ...
    DISTINCT: typing.ClassVar[int] = ...
    IMMUTABLE: typing.ClassVar[int] = ...
    NONNULL: typing.ClassVar[int] = ...
    ORDERED: typing.ClassVar[int] = ...
    SIZED: typing.ClassVar[int] = ...
    SORTED: typing.ClassVar[int] = ...
    SUBSIZED: typing.ClassVar[int] = ...
    def characteristics(self) -> int: ...
    def estimateSize(self) -> int: ...
    def forEachRemaining(self, action: java.util.function.Consumer[_Spliterator__T], /) -> None: ...
    def getComparator(self) -> Comparator[_Spliterator__T]: ...
    def getExactSizeIfKnown(self) -> int: ...
    def hasCharacteristics(self, characteristics: int | java.jint | java.lang.Integer, /) -> bool: ...
    def tryAdvance(self, arg1: java.util.function.Consumer[_Spliterator__T], /) -> bool: ...
    def trySplit(self) -> Spliterator[_Spliterator__T]: ...
    class OfPrimitive(Spliterator[_Spliterator__OfPrimitive__T], typing.Generic[_Spliterator__OfPrimitive__T, _Spliterator__OfPrimitive__T_CONS, _Spliterator__OfPrimitive__T_SPLITR]):
        def forEachRemaining(self, action: _Spliterator__OfPrimitive__T_CONS, /) -> None: ...
        def tryAdvance(self, arg1: _Spliterator__OfPrimitive__T_CONS, /) -> bool: ...
        def trySplit(self) -> _Spliterator__OfPrimitive__T_SPLITR: ...

    class OfLong(java.util.Spliterator.OfPrimitive[java.lang.Long, java.util.function.LongConsumer, Spliterator.OfLong]):
        @typing.overload
        def forEachRemaining(self, action: java.util.function.Consumer[int], /) -> None: ...
        @typing.overload
        def forEachRemaining(self, action: java.util.function.LongConsumer, /) -> None: ...
        @typing.overload
        def tryAdvance(self, action: java.util.function.Consumer[int], /) -> bool: ...
        @typing.overload
        def tryAdvance(self, arg1: java.util.function.LongConsumer, /) -> bool: ...
        def trySplit(self) -> Spliterator.OfLong: ...

    class OfInt(java.util.Spliterator.OfPrimitive[java.lang.Integer, java.util.function.IntConsumer, Spliterator.OfInt]):
        @typing.overload
        def forEachRemaining(self, action: java.util.function.Consumer[int], /) -> None: ...
        @typing.overload
        def forEachRemaining(self, action: java.util.function.IntConsumer, /) -> None: ...
        @typing.overload
        def tryAdvance(self, action: java.util.function.Consumer[int], /) -> bool: ...
        @typing.overload
        def tryAdvance(self, arg1: java.util.function.IntConsumer, /) -> bool: ...
        def trySplit(self) -> Spliterator.OfInt: ...

    class OfDouble(java.util.Spliterator.OfPrimitive[java.lang.Double, java.util.function.DoubleConsumer, Spliterator.OfDouble]):
        @typing.overload
        def forEachRemaining(self, action: java.util.function.Consumer[float], /) -> None: ...
        @typing.overload
        def forEachRemaining(self, action: java.util.function.DoubleConsumer, /) -> None: ...
        @typing.overload
        def tryAdvance(self, action: java.util.function.Consumer[float], /) -> bool: ...
        @typing.overload
        def tryAdvance(self, arg1: java.util.function.DoubleConsumer, /) -> bool: ...
        def trySplit(self) -> Spliterator.OfDouble: ...


_Spliterators__AbstractSpliterator__T = typing.TypeVar('_Spliterators__AbstractSpliterator__T')  # <T>
class Spliterators(java.lang.Object):
    @staticmethod
    def emptyDoubleSpliterator() -> Spliterator.OfDouble: ...
    @staticmethod
    def emptyIntSpliterator() -> Spliterator.OfInt: ...
    @staticmethod
    def emptyLongSpliterator() -> Spliterator.OfLong: ...
    @staticmethod
    def emptySpliterator() -> Spliterator[java.lang.Object]: ...
    _iterator_3__T = typing.TypeVar('_iterator_3__T')  # <T>
    @typing.overload
    @staticmethod
    def iterator(spliterator: Spliterator.OfDouble, /) -> PrimitiveIterator.OfDouble: ...
    @typing.overload
    @staticmethod
    def iterator(spliterator: Spliterator.OfInt, /) -> PrimitiveIterator.OfInt: ...
    @typing.overload
    @staticmethod
    def iterator(spliterator: Spliterator.OfLong, /) -> PrimitiveIterator.OfLong: ...
    @typing.overload
    @staticmethod
    def iterator(spliterator: Spliterator[_iterator_3__T], /) -> Iterator[_iterator_3__T]: ...
    _spliterator_0__T = typing.TypeVar('_spliterator_0__T')  # <T>
    _spliterator_5__T = typing.TypeVar('_spliterator_5__T')  # <T>
    @typing.overload
    @staticmethod
    def spliterator(c: Collection[_spliterator_0__T], characteristics: int | java.jint | java.lang.Integer, /) -> Spliterator[_spliterator_0__T]: ...
    @typing.overload
    @staticmethod
    def spliterator(array: java.chaquopy.JavaArrayJDouble, additionalCharacteristics: int | java.jint | java.lang.Integer, /) -> Spliterator.OfDouble: ...
    @typing.overload
    @staticmethod
    def spliterator(array: java.chaquopy.JavaArrayJInt, additionalCharacteristics: int | java.jint | java.lang.Integer, /) -> Spliterator.OfInt: ...
    @typing.overload
    @staticmethod
    def spliterator(array: java.chaquopy.JavaArrayJLong, additionalCharacteristics: int | java.jint | java.lang.Integer, /) -> Spliterator.OfLong: ...
    @typing.overload
    @staticmethod
    def spliterator(array: java.chaquopy.JavaArray[java.lang.Object], additionalCharacteristics: int | java.jint | java.lang.Integer, /) -> Spliterator[java.lang.Object]: ...
    @typing.overload
    @staticmethod
    def spliterator(iterator: Iterator[_spliterator_5__T], size: int | java.jlong | java.lang.Long, characteristics: int | java.jint | java.lang.Integer, /) -> Spliterator[_spliterator_5__T]: ...
    @typing.overload
    @staticmethod
    def spliterator(iterator: PrimitiveIterator.OfDouble, size: int | java.jlong | java.lang.Long, characteristics: int | java.jint | java.lang.Integer, /) -> Spliterator.OfDouble: ...
    @typing.overload
    @staticmethod
    def spliterator(iterator: PrimitiveIterator.OfInt, size: int | java.jlong | java.lang.Long, characteristics: int | java.jint | java.lang.Integer, /) -> Spliterator.OfInt: ...
    @typing.overload
    @staticmethod
    def spliterator(iterator: PrimitiveIterator.OfLong, size: int | java.jlong | java.lang.Long, characteristics: int | java.jint | java.lang.Integer, /) -> Spliterator.OfLong: ...
    @typing.overload
    @staticmethod
    def spliterator(array: java.chaquopy.JavaArrayJDouble, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, additionalCharacteristics: int | java.jint | java.lang.Integer, /) -> Spliterator.OfDouble: ...
    @typing.overload
    @staticmethod
    def spliterator(array: java.chaquopy.JavaArrayJInt, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, additionalCharacteristics: int | java.jint | java.lang.Integer, /) -> Spliterator.OfInt: ...
    @typing.overload
    @staticmethod
    def spliterator(array: java.chaquopy.JavaArrayJLong, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, additionalCharacteristics: int | java.jint | java.lang.Integer, /) -> Spliterator.OfLong: ...
    @typing.overload
    @staticmethod
    def spliterator(array: java.chaquopy.JavaArray[java.lang.Object], fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, additionalCharacteristics: int | java.jint | java.lang.Integer, /) -> Spliterator[java.lang.Object]: ...
    _spliteratorUnknownSize_0__T = typing.TypeVar('_spliteratorUnknownSize_0__T')  # <T>
    @typing.overload
    @staticmethod
    def spliteratorUnknownSize(iterator: Iterator[_spliteratorUnknownSize_0__T], characteristics: int | java.jint | java.lang.Integer, /) -> Spliterator[_spliteratorUnknownSize_0__T]: ...
    @typing.overload
    @staticmethod
    def spliteratorUnknownSize(iterator: PrimitiveIterator.OfDouble, characteristics: int | java.jint | java.lang.Integer, /) -> Spliterator.OfDouble: ...
    @typing.overload
    @staticmethod
    def spliteratorUnknownSize(iterator: PrimitiveIterator.OfInt, characteristics: int | java.jint | java.lang.Integer, /) -> Spliterator.OfInt: ...
    @typing.overload
    @staticmethod
    def spliteratorUnknownSize(iterator: PrimitiveIterator.OfLong, characteristics: int | java.jint | java.lang.Integer, /) -> Spliterator.OfLong: ...
    class AbstractSpliterator(Spliterator[_Spliterators__AbstractSpliterator__T], typing.Generic[_Spliterators__AbstractSpliterator__T]):
        def __init__(self, est: int | java.jlong | java.lang.Long, additionalCharacteristics: int | java.jint | java.lang.Integer, /) -> None: ...
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        def trySplit(self) -> Spliterator[_Spliterators__AbstractSpliterator__T]: ...

    class AbstractLongSpliterator(java.util.Spliterator.OfLong):
        def __init__(self, est: int | java.jlong | java.lang.Long, additionalCharacteristics: int | java.jint | java.lang.Integer, /) -> None: ...
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        def trySplit(self) -> Spliterator.OfLong: ...

    class AbstractIntSpliterator(java.util.Spliterator.OfInt):
        def __init__(self, est: int | java.jlong | java.lang.Long, additionalCharacteristics: int | java.jint | java.lang.Integer, /) -> None: ...
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        def trySplit(self) -> Spliterator.OfInt: ...

    class AbstractDoubleSpliterator(java.util.Spliterator.OfDouble):
        def __init__(self, est: int | java.jlong | java.lang.Long, additionalCharacteristics: int | java.jint | java.lang.Integer, /) -> None: ...
        def characteristics(self) -> int: ...
        def estimateSize(self) -> int: ...
        def trySplit(self) -> Spliterator.OfDouble: ...

class SplittableRandom(java.util.random.RandomGenerator, java.util.random.RandomGenerator.SplittableGenerator):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, seed: int | java.jlong | java.lang.Long, /) -> None: ...
    @typing.overload
    def doubles(self) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, streamSize: int | java.jlong | java.lang.Long, /) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, randomNumberOrigin: float | java.jdouble | java.lang.Double, randomNumberBound: float | java.jdouble | java.lang.Double, /) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def doubles(self, streamSize: int | java.jlong | java.lang.Long, randomNumberOrigin: float | java.jdouble | java.lang.Double, randomNumberBound: float | java.jdouble | java.lang.Double, /) -> java.util.stream.DoubleStream: ...
    @typing.overload
    def ints(self) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, streamSize: int | java.jlong | java.lang.Long, /) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, randomNumberOrigin: int | java.jint | java.lang.Integer, randomNumberBound: int | java.jint | java.lang.Integer, /) -> java.util.stream.IntStream: ...
    @typing.overload
    def ints(self, streamSize: int | java.jlong | java.lang.Long, randomNumberOrigin: int | java.jint | java.lang.Integer, randomNumberBound: int | java.jint | java.lang.Integer, /) -> java.util.stream.IntStream: ...
    @typing.overload
    def longs(self) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, streamSize: int | java.jlong | java.lang.Long, /) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, randomNumberOrigin: int | java.jlong | java.lang.Long, randomNumberBound: int | java.jlong | java.lang.Long, /) -> java.util.stream.LongStream: ...
    @typing.overload
    def longs(self, streamSize: int | java.jlong | java.lang.Long, randomNumberOrigin: int | java.jlong | java.lang.Long, randomNumberBound: int | java.jlong | java.lang.Long, /) -> java.util.stream.LongStream: ...
    def nextBytes(self, bytes: java.chaquopy.JavaArrayJByte, /) -> None: ...
    def nextInt(self) -> int: ...
    def nextLong(self) -> int: ...
    @typing.overload
    def split(self) -> SplittableRandom: ...
    @typing.overload
    def split(self, source: java.util.random.RandomGenerator.SplittableGenerator, /) -> SplittableRandom: ...
    @typing.overload
    def splits(self) -> java.util.stream.Stream[java.util.random.RandomGenerator.SplittableGenerator]: ...
    @typing.overload
    def splits(self, streamSize: int | java.jlong | java.lang.Long, /) -> java.util.stream.Stream[java.util.random.RandomGenerator.SplittableGenerator]: ...
    @typing.overload
    def splits(self, source: java.util.random.RandomGenerator.SplittableGenerator, /) -> java.util.stream.Stream[java.util.random.RandomGenerator.SplittableGenerator]: ...
    @typing.overload
    def splits(self, streamSize: int | java.jlong | java.lang.Long, source: java.util.random.RandomGenerator.SplittableGenerator, /) -> java.util.stream.Stream[java.util.random.RandomGenerator.SplittableGenerator]: ...

_Stack__E = typing.TypeVar('_Stack__E')  # <E>
class Stack(Vector[_Stack__E], typing.Generic[_Stack__E]):
    def __init__(self) -> None: ...
    def empty(self) -> bool: ...
    def peek(self) -> _Stack__E: ...
    def pop(self) -> _Stack__E: ...
    def push(self, item: _Stack__E, /) -> _Stack__E: ...
    def search(self, o: java.lang.Object | int | bool | float | str, /) -> int: ...

class StringJoiner(java.lang.Object):
    @typing.overload
    def __init__(self, delimiter: java.lang.CharSequence, /) -> None: ...
    @typing.overload
    def __init__(self, delimiter: java.lang.CharSequence, prefix: java.lang.CharSequence, suffix: java.lang.CharSequence, /) -> None: ...
    def add(self, newElement: java.lang.CharSequence, /) -> StringJoiner: ...
    def length(self) -> int: ...
    def merge(self, other: StringJoiner, /) -> StringJoiner: ...
    def setEmptyValue(self, emptyValue: java.lang.CharSequence, /) -> StringJoiner: ...
    def toString(self) -> str: ...

class StringTokenizer(Enumeration[java.lang.Object]):
    @typing.overload
    def __init__(self, str: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, str: str | java.lang.String, delim: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, str: str | java.lang.String, delim: str | java.lang.String, returnDelims: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def countTokens(self) -> int: ...
    def hasMoreElements(self) -> bool: ...
    def hasMoreTokens(self) -> bool: ...
    def nextElement(self) -> java.lang.Object: ...
    @typing.overload
    def nextToken(self) -> str: ...
    @typing.overload
    def nextToken(self, delim: str | java.lang.String, /) -> str: ...

class TimeZone(java.lang.Cloneable, java.io.Serializable):
    LONG: typing.ClassVar[int] = ...
    SHORT: typing.ClassVar[int] = ...
    def __init__(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    @typing.overload
    @staticmethod
    def getAvailableIDs() -> java.chaquopy.JavaArray[java.lang.String]: ...
    @typing.overload
    @staticmethod
    def getAvailableIDs(rawOffset: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArray[java.lang.String]: ...
    def getDSTSavings(self) -> int: ...
    @staticmethod
    def getDefault() -> TimeZone: ...
    @typing.overload
    def getDisplayName(self) -> str: ...
    @typing.overload
    def getDisplayName(self, locale: Locale, /) -> str: ...
    @typing.overload
    def getDisplayName(self, daylight: bool | java.jboolean | java.lang.Boolean, style: int | java.jint | java.lang.Integer, /) -> str: ...
    @typing.overload
    def getDisplayName(self, daylightTime: bool | java.jboolean | java.lang.Boolean, style: int | java.jint | java.lang.Integer, locale: Locale, /) -> str: ...
    def getID(self) -> str: ...
    @typing.overload
    def getOffset(self, date: int | java.jlong | java.lang.Long, /) -> int: ...
    @typing.overload
    def getOffset(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, arg4: int | java.jint | java.lang.Integer, arg5: int | java.jint | java.lang.Integer, arg6: int | java.jint | java.lang.Integer, /) -> int: ...
    def getRawOffset(self) -> int: ...
    @typing.overload
    @staticmethod
    def getTimeZone(id: str | java.lang.String, /) -> TimeZone: ...
    @typing.overload
    @staticmethod
    def getTimeZone(zoneId: java.time.ZoneId, /) -> TimeZone: ...
    def hasSameRules(self, other: TimeZone, /) -> bool: ...
    def inDaylightTime(self, arg1: Date, /) -> bool: ...
    def observesDaylightTime(self) -> bool: ...
    @staticmethod
    def setDefault(timeZone: TimeZone, /) -> None: ...
    def setID(self, ID: str | java.lang.String, /) -> None: ...
    def setRawOffset(self, arg1: int | java.jint | java.lang.Integer, /) -> None: ...
    def toZoneId(self) -> java.time.ZoneId: ...
    def useDaylightTime(self) -> bool: ...

class Timer(java.lang.Object):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, name: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, isDaemon: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def __init__(self, name: str | java.lang.String, isDaemon: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def cancel(self) -> None: ...
    def purge(self) -> int: ...
    @typing.overload
    def schedule(self, task: TimerTask, delay: int | java.jlong | java.lang.Long, /) -> None: ...
    @typing.overload
    def schedule(self, task: TimerTask, time: Date, /) -> None: ...
    @typing.overload
    def schedule(self, task: TimerTask, delay: int | java.jlong | java.lang.Long, period: int | java.jlong | java.lang.Long, /) -> None: ...
    @typing.overload
    def schedule(self, task: TimerTask, firstTime: Date, period: int | java.jlong | java.lang.Long, /) -> None: ...
    @typing.overload
    def scheduleAtFixedRate(self, task: TimerTask, delay: int | java.jlong | java.lang.Long, period: int | java.jlong | java.lang.Long, /) -> None: ...
    @typing.overload
    def scheduleAtFixedRate(self, task: TimerTask, firstTime: Date, period: int | java.jlong | java.lang.Long, /) -> None: ...

class TimerTask(java.lang.Runnable):
    def __init__(self) -> None: ...
    def cancel(self) -> bool: ...
    def run(self) -> None: ...
    def scheduledExecutionTime(self) -> int: ...

class TooManyListenersException(java.lang.Exception):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | java.lang.String, /) -> None: ...

_TreeMap__K = typing.TypeVar('_TreeMap__K')  # <K>
_TreeMap__V = typing.TypeVar('_TreeMap__V')  # <V>
class TreeMap(AbstractMap[_TreeMap__K, _TreeMap__V], java.lang.Cloneable, NavigableMap[_TreeMap__K, _TreeMap__V], java.io.Serializable, typing.Generic[_TreeMap__K, _TreeMap__V]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, comparator: Comparator[_TreeMap__K], /) -> None: ...
    @typing.overload
    def __init__(self, m: Map[_TreeMap__K, _TreeMap__V], /) -> None: ...
    @typing.overload
    def __init__(self, m: SortedMap[_TreeMap__K, _TreeMap__V], /) -> None: ...
    def ceilingEntry(self, key: _TreeMap__K, /) -> Map.Entry[_TreeMap__K, _TreeMap__V] | None: ...
    def ceilingKey(self, key: _TreeMap__K, /) -> _TreeMap__K | None: ...
    def clear(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def comparator(self) -> Comparator[_TreeMap__K]: ...
    def compute(self, key: _TreeMap__K, remappingFunction: java.util.function.BiFunction[_TreeMap__K, _TreeMap__V, _TreeMap__V], /) -> _TreeMap__V | None: ...
    def computeIfAbsent(self, key: _TreeMap__K, mappingFunction: java.util.function.Function[_TreeMap__K, _TreeMap__V], /) -> _TreeMap__V | None: ...
    def computeIfPresent(self, key: _TreeMap__K, remappingFunction: java.util.function.BiFunction[_TreeMap__K, _TreeMap__V, _TreeMap__V], /) -> _TreeMap__V | None: ...
    def containsKey(self, key: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsValue(self, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def descendingKeySet(self) -> NavigableSet[_TreeMap__K]: ...
    def descendingMap(self) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    def entrySet(self) -> Set[Map.Entry[_TreeMap__K, _TreeMap__V]]: ...
    def firstEntry(self) -> Map.Entry[_TreeMap__K, _TreeMap__V] | None: ...
    def firstKey(self) -> _TreeMap__K: ...
    def floorEntry(self, key: _TreeMap__K, /) -> Map.Entry[_TreeMap__K, _TreeMap__V] | None: ...
    def floorKey(self, key: _TreeMap__K, /) -> _TreeMap__K | None: ...
    def forEach(self, action: java.util.function.BiConsumer[_TreeMap__K, _TreeMap__V], /) -> None: ...
    def get(self, key: java.lang.Object | int | bool | float | str, /) -> _TreeMap__V | None: ...
    @typing.overload
    def headMap(self, toKey: _TreeMap__K, /) -> SortedMap[_TreeMap__K, _TreeMap__V]: ...
    @typing.overload
    def headMap(self, toKey: _TreeMap__K, inclusive: bool | java.jboolean | java.lang.Boolean, /) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    def higherEntry(self, key: _TreeMap__K, /) -> Map.Entry[_TreeMap__K, _TreeMap__V] | None: ...
    def higherKey(self, key: _TreeMap__K, /) -> _TreeMap__K | None: ...
    def keySet(self) -> Set[_TreeMap__K]: ...
    def lastEntry(self) -> Map.Entry[_TreeMap__K, _TreeMap__V] | None: ...
    def lastKey(self) -> _TreeMap__K: ...
    def lowerEntry(self, key: _TreeMap__K, /) -> Map.Entry[_TreeMap__K, _TreeMap__V] | None: ...
    def lowerKey(self, key: _TreeMap__K, /) -> _TreeMap__K | None: ...
    def merge(self, key: _TreeMap__K, value: _TreeMap__V, remappingFunction: java.util.function.BiFunction[_TreeMap__V, _TreeMap__V, _TreeMap__V], /) -> _TreeMap__V | None: ...
    def navigableKeySet(self) -> NavigableSet[_TreeMap__K]: ...
    def pollFirstEntry(self) -> Map.Entry[_TreeMap__K, _TreeMap__V] | None: ...
    def pollLastEntry(self) -> Map.Entry[_TreeMap__K, _TreeMap__V] | None: ...
    def put(self, key: _TreeMap__K, value: _TreeMap__V, /) -> _TreeMap__V | None: ...
    def putAll(self, map: Map[_TreeMap__K, _TreeMap__V], /) -> None: ...
    def putFirst(self, k: _TreeMap__K, v: _TreeMap__V, /) -> _TreeMap__V: ...
    def putIfAbsent(self, key: _TreeMap__K, value: _TreeMap__V, /) -> _TreeMap__V | None: ...
    def putLast(self, k: _TreeMap__K, v: _TreeMap__V, /) -> _TreeMap__V: ...
    def remove(self, key: java.lang.Object | int | bool | float | str, /) -> _TreeMap__V | None: ...
    @typing.overload
    def replace(self, key: _TreeMap__K, value: _TreeMap__V, /) -> _TreeMap__V | None: ...
    @typing.overload
    def replace(self, key: _TreeMap__K, oldValue: _TreeMap__V, newValue: _TreeMap__V, /) -> bool: ...
    def replaceAll(self, function: java.util.function.BiFunction[_TreeMap__K, _TreeMap__V, _TreeMap__V], /) -> None: ...
    def size(self) -> int: ...
    @typing.overload
    def subMap(self, fromKey: _TreeMap__K, toKey: _TreeMap__K, /) -> SortedMap[_TreeMap__K, _TreeMap__V]: ...
    @typing.overload
    def subMap(self, fromKey: _TreeMap__K, fromInclusive: bool | java.jboolean | java.lang.Boolean, toKey: _TreeMap__K, toInclusive: bool | java.jboolean | java.lang.Boolean, /) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    @typing.overload
    def tailMap(self, fromKey: _TreeMap__K, /) -> SortedMap[_TreeMap__K, _TreeMap__V]: ...
    @typing.overload
    def tailMap(self, fromKey: _TreeMap__K, inclusive: bool | java.jboolean | java.lang.Boolean, /) -> NavigableMap[_TreeMap__K, _TreeMap__V]: ...
    def values(self) -> Collection[_TreeMap__V]: ...

_TreeSet__E = typing.TypeVar('_TreeSet__E')  # <E>
class TreeSet(AbstractSet[_TreeSet__E], java.lang.Cloneable, NavigableSet[_TreeSet__E], java.io.Serializable, typing.Generic[_TreeSet__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, c: Collection[_TreeSet__E], /) -> None: ...
    @typing.overload
    def __init__(self, comparator: Comparator[_TreeSet__E], /) -> None: ...
    @typing.overload
    def __init__(self, s: SortedSet[_TreeSet__E], /) -> None: ...
    def add(self, e: _TreeSet__E, /) -> bool: ...
    def addAll(self, c: Collection[_TreeSet__E], /) -> bool: ...
    def addFirst(self, e: _TreeSet__E, /) -> None: ...
    def addLast(self, e: _TreeSet__E, /) -> None: ...
    def ceiling(self, e: _TreeSet__E, /) -> _TreeSet__E | None: ...
    def clear(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def comparator(self) -> Comparator[_TreeSet__E]: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def descendingIterator(self) -> Iterator[_TreeSet__E]: ...
    def descendingSet(self) -> NavigableSet[_TreeSet__E]: ...
    def first(self) -> _TreeSet__E: ...
    def floor(self, e: _TreeSet__E, /) -> _TreeSet__E | None: ...
    @typing.overload
    def headSet(self, toElement: _TreeSet__E, /) -> SortedSet[_TreeSet__E]: ...
    @typing.overload
    def headSet(self, toElement: _TreeSet__E, inclusive: bool | java.jboolean | java.lang.Boolean, /) -> NavigableSet[_TreeSet__E]: ...
    def higher(self, e: _TreeSet__E, /) -> _TreeSet__E | None: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_TreeSet__E]: ...
    def last(self) -> _TreeSet__E: ...
    def lower(self, e: _TreeSet__E, /) -> _TreeSet__E | None: ...
    def pollFirst(self) -> _TreeSet__E | None: ...
    def pollLast(self) -> _TreeSet__E | None: ...
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def size(self) -> int: ...
    def spliterator(self) -> Spliterator[_TreeSet__E]: ...
    @typing.overload
    def subSet(self, fromElement: _TreeSet__E, toElement: _TreeSet__E, /) -> SortedSet[_TreeSet__E]: ...
    @typing.overload
    def subSet(self, fromElement: _TreeSet__E, fromInclusive: bool | java.jboolean | java.lang.Boolean, toElement: _TreeSet__E, toInclusive: bool | java.jboolean | java.lang.Boolean, /) -> NavigableSet[_TreeSet__E]: ...
    @typing.overload
    def tailSet(self, fromElement: _TreeSet__E, /) -> SortedSet[_TreeSet__E]: ...
    @typing.overload
    def tailSet(self, fromElement: _TreeSet__E, inclusive: bool | java.jboolean | java.lang.Boolean, /) -> NavigableSet[_TreeSet__E]: ...

class UUID(java.lang.Comparable[UUID], java.io.Serializable):
    def __init__(self, mostSigBits: int | java.jlong | java.lang.Long, leastSigBits: int | java.jlong | java.lang.Long, /) -> None: ...
    def clockSequence(self) -> int: ...
    def compareTo(self, val: UUID, /) -> int: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def fromString(name: str | java.lang.String, /) -> UUID: ...
    def getLeastSignificantBits(self) -> int: ...
    def getMostSignificantBits(self) -> int: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def nameUUIDFromBytes(name: java.chaquopy.JavaArrayJByte, /) -> UUID: ...
    def node(self) -> int: ...
    @staticmethod
    def randomUUID() -> UUID: ...
    def timestamp(self) -> int: ...
    def toString(self) -> str: ...
    def variant(self) -> int: ...
    def version(self) -> int: ...

class UnknownFormatConversionException(IllegalFormatException):
    def __init__(self, s: str | java.lang.String, /) -> None: ...
    def getConversion(self) -> str: ...
    def getMessage(self) -> str: ...

class UnknownFormatFlagsException(IllegalFormatException):
    def __init__(self, f: str | java.lang.String, /) -> None: ...
    def getFlags(self) -> str: ...
    def getMessage(self) -> str: ...

_Vector__E = typing.TypeVar('_Vector__E')  # <E>
class Vector(AbstractList[_Vector__E], java.lang.Cloneable, List[_Vector__E], RandomAccess, java.io.Serializable, typing.Generic[_Vector__E]):
    capacityIncrement: int = ...
    elementCount: int = ...
    elementData: java.chaquopy.JavaArray[java.lang.Object] = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, c: Collection[_Vector__E], /) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, capacityIncrement: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def add(self, e: _Vector__E, /) -> bool: ...
    @typing.overload
    def add(self, index: int | java.jint | java.lang.Integer, element: _Vector__E, /) -> None: ...
    @typing.overload
    def addAll(self, c: Collection[_Vector__E], /) -> bool: ...
    @typing.overload
    def addAll(self, index: int | java.jint | java.lang.Integer, c: Collection[_Vector__E], /) -> bool: ...
    def addElement(self, obj: _Vector__E, /) -> None: ...
    def capacity(self) -> int: ...
    def clear(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def contains(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsAll(self, c: Collection[java.lang.Object], /) -> bool: ...
    def copyInto(self, anArray: java.chaquopy.JavaArray[java.lang.Object], /) -> None: ...
    def elementAt(self, index: int | java.jint | java.lang.Integer, /) -> _Vector__E: ...
    def elements(self) -> Enumeration[_Vector__E]: ...
    def ensureCapacity(self, minCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def firstElement(self) -> _Vector__E: ...
    def forEach(self, action: java.util.function.Consumer[_Vector__E], /) -> None: ...
    def get(self, index: int | java.jint | java.lang.Integer, /) -> _Vector__E: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def indexOf(self, o: java.lang.Object | int | bool | float | str, /) -> int: ...
    @typing.overload
    def indexOf(self, o: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, /) -> int: ...
    def insertElementAt(self, obj: _Vector__E, index: int | java.jint | java.lang.Integer, /) -> None: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> Iterator[_Vector__E]: ...
    def lastElement(self) -> _Vector__E: ...
    @typing.overload
    def lastIndexOf(self, o: java.lang.Object | int | bool | float | str, /) -> int: ...
    @typing.overload
    def lastIndexOf(self, o: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def listIterator(self) -> ListIterator[_Vector__E]: ...
    @typing.overload
    def listIterator(self, index: int | java.jint | java.lang.Integer, /) -> ListIterator[_Vector__E]: ...
    @typing.overload
    def remove(self, index: int | java.jint | java.lang.Integer, /) -> _Vector__E: ...
    @typing.overload
    def remove(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeAll(self, c: Collection[java.lang.Object], /) -> bool: ...
    def removeAllElements(self) -> None: ...
    def removeElement(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def removeElementAt(self, index: int | java.jint | java.lang.Integer, /) -> None: ...
    def removeIf(self, filter: java.util.function.Predicate[_Vector__E], /) -> bool: ...
    def removeRange(self, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    def replaceAll(self, operator: java.util.function.UnaryOperator[_Vector__E], /) -> None: ...
    def retainAll(self, c: Collection[java.lang.Object], /) -> bool: ...
    def set(self, index: int | java.jint | java.lang.Integer, element: _Vector__E, /) -> _Vector__E: ...
    def setElementAt(self, obj: _Vector__E, index: int | java.jint | java.lang.Integer, /) -> None: ...
    def setSize(self, newSize: int | java.jint | java.lang.Integer, /) -> None: ...
    def size(self) -> int: ...
    def sort(self, c: Comparator[_Vector__E], /) -> None: ...
    def spliterator(self) -> Spliterator[_Vector__E]: ...
    def subList(self, fromIndex: int | java.jint | java.lang.Integer, toIndex: int | java.jint | java.lang.Integer, /) -> List[_Vector__E]: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, a: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...
    def toString(self) -> str: ...
    def trimToSize(self) -> None: ...

_WeakHashMap__K = typing.TypeVar('_WeakHashMap__K')  # <K>
_WeakHashMap__V = typing.TypeVar('_WeakHashMap__V')  # <V>
class WeakHashMap(AbstractMap[_WeakHashMap__K, _WeakHashMap__V], Map[_WeakHashMap__K, _WeakHashMap__V], typing.Generic[_WeakHashMap__K, _WeakHashMap__V]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, m: Map[_WeakHashMap__K, _WeakHashMap__V], /) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, loadFactor: float | java.jfloat | java.lang.Float, /) -> None: ...
    def clear(self) -> None: ...
    def containsKey(self, key: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsValue(self, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def entrySet(self) -> Set[Map.Entry[_WeakHashMap__K, _WeakHashMap__V]]: ...
    def forEach(self, action: java.util.function.BiConsumer[_WeakHashMap__K, _WeakHashMap__V], /) -> None: ...
    def get(self, key: java.lang.Object | int | bool | float | str, /) -> _WeakHashMap__V | None: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> Set[_WeakHashMap__K]: ...
    @staticmethod
    def newWeakHashMap(numMappings: int | java.jint | java.lang.Integer, /) -> WeakHashMap[java.lang.Object, java.lang.Object]: ...
    def put(self, key: _WeakHashMap__K, value: _WeakHashMap__V, /) -> _WeakHashMap__V | None: ...
    def putAll(self, m: Map[_WeakHashMap__K, _WeakHashMap__V], /) -> None: ...
    def remove(self, key: java.lang.Object | int | bool | float | str, /) -> _WeakHashMap__V | None: ...
    def replaceAll(self, function: java.util.function.BiFunction[_WeakHashMap__K, _WeakHashMap__V, _WeakHashMap__V], /) -> None: ...
    def size(self) -> int: ...
    def values(self) -> Collection[_WeakHashMap__V]: ...
