import java
import java.chaquopy
import java.io
import java.lang
import java.math
import java.util
import typing



class Annotation(java.lang.Object):
    def __init__(self, value: java.lang.Object | int | bool | float | str, /) -> None: ...
    def getValue(self) -> java.lang.Object: ...
    def toString(self) -> str: ...

class AttributedCharacterIterator(CharacterIterator):
    def getAllAttributeKeys(self) -> java.util.Set[AttributedCharacterIterator.Attribute]: ...
    def getAttribute(self, arg1: AttributedCharacterIterator.Attribute, /) -> java.lang.Object: ...
    def getAttributes(self) -> java.util.Map[AttributedCharacterIterator.Attribute, java.lang.Object]: ...
    @typing.overload
    def getRunLimit(self) -> int: ...
    @typing.overload
    def getRunLimit(self, arg1: AttributedCharacterIterator.Attribute, /) -> int: ...
    @typing.overload
    def getRunLimit(self, arg1: java.util.Set[AttributedCharacterIterator.Attribute], /) -> int: ...
    @typing.overload
    def getRunStart(self) -> int: ...
    @typing.overload
    def getRunStart(self, arg1: AttributedCharacterIterator.Attribute, /) -> int: ...
    @typing.overload
    def getRunStart(self, arg1: java.util.Set[AttributedCharacterIterator.Attribute], /) -> int: ...

    class Attribute(java.io.Serializable):
        INPUT_METHOD_SEGMENT: typing.ClassVar[AttributedCharacterIterator.Attribute] = ...
        LANGUAGE: typing.ClassVar[AttributedCharacterIterator.Attribute] = ...
        READING: typing.ClassVar[AttributedCharacterIterator.Attribute] = ...
        def __init__(self, name: str | java.lang.String, /) -> None: ...
        def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
        def getName(self) -> str: ...
        def hashCode(self) -> int: ...
        def readResolve(self) -> java.lang.Object: ...
        def toString(self) -> str: ...

class AttributedString(java.lang.Object):
    @typing.overload
    def __init__(self, text: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, text: AttributedCharacterIterator, /) -> None: ...
    @typing.overload
    def __init__(self, text: str | java.lang.String, attributes: java.util.Map[AttributedCharacterIterator.Attribute, java.lang.Object], /) -> None: ...
    @typing.overload
    def __init__(self, text: AttributedCharacterIterator, beginIndex: int | java.jint | java.lang.Integer, endIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, text: AttributedCharacterIterator, beginIndex: int | java.jint | java.lang.Integer, endIndex: int | java.jint | java.lang.Integer, attributes: java.chaquopy.JavaArray[AttributedCharacterIterator.Attribute], /) -> None: ...
    @typing.overload
    def addAttribute(self, attribute: AttributedCharacterIterator.Attribute, value: java.lang.Object | int | bool | float | str, /) -> None: ...
    @typing.overload
    def addAttribute(self, attribute: AttributedCharacterIterator.Attribute, value: java.lang.Object | int | bool | float | str, beginIndex: int | java.jint | java.lang.Integer, endIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    def addAttributes(self, attributes: java.util.Map[AttributedCharacterIterator.Attribute, java.lang.Object], beginIndex: int | java.jint | java.lang.Integer, endIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def getIterator(self) -> AttributedCharacterIterator: ...
    @typing.overload
    def getIterator(self, attributes: java.chaquopy.JavaArray[AttributedCharacterIterator.Attribute], /) -> AttributedCharacterIterator: ...
    @typing.overload
    def getIterator(self, attributes: java.chaquopy.JavaArray[AttributedCharacterIterator.Attribute], beginIndex: int | java.jint | java.lang.Integer, endIndex: int | java.jint | java.lang.Integer, /) -> AttributedCharacterIterator: ...

class Bidi(java.lang.Object):
    DIRECTION_DEFAULT_LEFT_TO_RIGHT: typing.ClassVar[int] = ...
    DIRECTION_DEFAULT_RIGHT_TO_LEFT: typing.ClassVar[int] = ...
    DIRECTION_LEFT_TO_RIGHT: typing.ClassVar[int] = ...
    DIRECTION_RIGHT_TO_LEFT: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, paragraph: AttributedCharacterIterator, /) -> None: ...
    @typing.overload
    def __init__(self, paragraph: str | java.lang.String, flags: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, text: java.chaquopy.JavaArrayJChar, textStart: int | java.jint | java.lang.Integer, embeddings: java.chaquopy.JavaArrayJByte, embStart: int | java.jint | java.lang.Integer, paragraphLength: int | java.jint | java.lang.Integer, flags: int | java.jint | java.lang.Integer, /) -> None: ...
    def baseIsLeftToRight(self) -> bool: ...
    def createLineBidi(self, lineStart: int | java.jint | java.lang.Integer, lineLimit: int | java.jint | java.lang.Integer, /) -> Bidi: ...
    def getBaseLevel(self) -> int: ...
    def getLength(self) -> int: ...
    def getLevelAt(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...
    def getRunCount(self) -> int: ...
    def getRunLevel(self, run: int | java.jint | java.lang.Integer, /) -> int: ...
    def getRunLimit(self, run: int | java.jint | java.lang.Integer, /) -> int: ...
    def getRunStart(self, run: int | java.jint | java.lang.Integer, /) -> int: ...
    def isLeftToRight(self) -> bool: ...
    def isMixed(self) -> bool: ...
    def isRightToLeft(self) -> bool: ...
    @staticmethod
    def reorderVisually(levels: java.chaquopy.JavaArrayJByte, levelStart: int | java.jint | java.lang.Integer, objects: java.chaquopy.JavaArray[java.lang.Object], objectStart: int | java.jint | java.lang.Integer, count: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def requiresBidi(text: java.chaquopy.JavaArrayJChar, start: int | java.jint | java.lang.Integer, limit: int | java.jint | java.lang.Integer, /) -> bool: ...
    def toString(self) -> str: ...

class BreakIterator(java.lang.Cloneable):
    DONE: typing.ClassVar[int] = ...
    def __init__(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def current(self) -> int: ...
    def first(self) -> int: ...
    def following(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def getAvailableLocales() -> java.chaquopy.JavaArray[java.util.Locale]: ...
    @typing.overload
    @staticmethod
    def getCharacterInstance() -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getCharacterInstance(locale: java.util.Locale, /) -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getLineInstance() -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getLineInstance(locale: java.util.Locale, /) -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getSentenceInstance() -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getSentenceInstance(locale: java.util.Locale, /) -> BreakIterator: ...
    def getText(self) -> CharacterIterator: ...
    @typing.overload
    @staticmethod
    def getWordInstance() -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getWordInstance(locale: java.util.Locale, /) -> BreakIterator: ...
    def isBoundary(self, offset: int | java.jint | java.lang.Integer, /) -> bool: ...
    def last(self) -> int: ...
    @typing.overload
    def next(self) -> int: ...
    @typing.overload
    def next(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def preceding(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...
    def previous(self) -> int: ...
    @typing.overload
    def setText(self, newText: str | java.lang.String, /) -> None: ...
    @typing.overload
    def setText(self, arg1: CharacterIterator, /) -> None: ...

class CharacterIterator(java.lang.Cloneable):
    DONE: typing.ClassVar[str] = ...
    def clone(self) -> java.lang.Object: ...
    def current(self) -> str: ...
    def first(self) -> str: ...
    def getBeginIndex(self) -> int: ...
    def getEndIndex(self) -> int: ...
    def getIndex(self) -> int: ...
    def last(self) -> str: ...
    def next(self) -> str: ...
    def previous(self) -> str: ...
    def setIndex(self, arg1: int | java.jint | java.lang.Integer, /) -> str: ...

class ChoiceFormat(NumberFormat):
    @typing.overload
    def __init__(self, newPattern: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, limits: java.chaquopy.JavaArrayJDouble, formats: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def applyPattern(self, newPattern: str | java.lang.String, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def format(self, number: float | java.jdouble | java.lang.Double, toAppendTo: java.lang.StringBuffer, status: FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, number: int | java.jlong | java.lang.Long, toAppendTo: java.lang.StringBuffer, status: FieldPosition, /) -> java.lang.StringBuffer: ...
    def getFormats(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    def getLimits(self) -> java.chaquopy.JavaArrayJDouble: ...
    def hashCode(self) -> int: ...
    @typing.overload
    @staticmethod
    def nextDouble(d: float | java.jdouble | java.lang.Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def nextDouble(d: float | java.jdouble | java.lang.Double, positive: bool | java.jboolean | java.lang.Boolean, /) -> float: ...
    def parse(self, text: str | java.lang.String, status: ParsePosition, /) -> java.lang.Number: ...
    @staticmethod
    def previousDouble(d: float | java.jdouble | java.lang.Double, /) -> float: ...
    def setChoices(self, limits: java.chaquopy.JavaArrayJDouble, formats: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def toPattern(self) -> str: ...

class CollationElementIterator(java.lang.Object):
    NULLORDER: typing.ClassVar[int] = ...
    def getMaxExpansion(self, order: int | java.jint | java.lang.Integer, /) -> int: ...
    def getOffset(self) -> int: ...
    def next(self) -> int: ...
    def previous(self) -> int: ...
    @staticmethod
    def primaryOrder(order: int | java.jint | java.lang.Integer, /) -> int: ...
    def reset(self) -> None: ...
    @staticmethod
    def secondaryOrder(order: int | java.jint | java.lang.Integer, /) -> int: ...
    def setOffset(self, newOffset: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def setText(self, source: str | java.lang.String, /) -> None: ...
    @typing.overload
    def setText(self, source: CharacterIterator, /) -> None: ...
    @staticmethod
    def tertiaryOrder(order: int | java.jint | java.lang.Integer, /) -> int: ...

class CollationKey(java.lang.Comparable[CollationKey]):
    def __init__(self, source: str | java.lang.String, /) -> None: ...
    def compareTo(self, arg1: CollationKey, /) -> int: ...
    def getSourceString(self) -> str: ...
    def toByteArray(self) -> java.chaquopy.JavaArrayJByte: ...

class Collator(java.lang.Cloneable, java.util.Comparator[java.lang.Object]):
    CANONICAL_DECOMPOSITION: typing.ClassVar[int] = ...
    FULL_DECOMPOSITION: typing.ClassVar[int] = ...
    IDENTICAL: typing.ClassVar[int] = ...
    NO_DECOMPOSITION: typing.ClassVar[int] = ...
    PRIMARY: typing.ClassVar[int] = ...
    SECONDARY: typing.ClassVar[int] = ...
    TERTIARY: typing.ClassVar[int] = ...
    def __init__(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    @typing.overload
    def compare(self, o1: java.lang.Object | int | bool | float | str, o2: java.lang.Object | int | bool | float | str, /) -> int: ...
    @typing.overload
    def compare(self, arg1: str | java.lang.String, arg2: str | java.lang.String, /) -> int: ...
    @typing.overload
    def equals(self, that: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def equals(self, source: str | java.lang.String, target: str | java.lang.String, /) -> bool: ...
    @staticmethod
    def getAvailableLocales() -> java.chaquopy.JavaArray[java.util.Locale]: ...
    def getCollationKey(self, arg1: str | java.lang.String, /) -> CollationKey: ...
    def getDecomposition(self) -> int: ...
    @typing.overload
    @staticmethod
    def getInstance() -> Collator: ...
    @typing.overload
    @staticmethod
    def getInstance(desiredLocale: java.util.Locale, /) -> Collator: ...
    def getStrength(self) -> int: ...
    def hashCode(self) -> int: ...
    def setDecomposition(self, decompositionMode: int | java.jint | java.lang.Integer, /) -> None: ...
    def setStrength(self, newStrength: int | java.jint | java.lang.Integer, /) -> None: ...

class DateFormat(Format):
    AM_PM_FIELD: typing.ClassVar[int] = ...
    DATE_FIELD: typing.ClassVar[int] = ...
    DAY_OF_WEEK_FIELD: typing.ClassVar[int] = ...
    DAY_OF_WEEK_IN_MONTH_FIELD: typing.ClassVar[int] = ...
    DAY_OF_YEAR_FIELD: typing.ClassVar[int] = ...
    DEFAULT: typing.ClassVar[int] = ...
    ERA_FIELD: typing.ClassVar[int] = ...
    FULL: typing.ClassVar[int] = ...
    HOUR0_FIELD: typing.ClassVar[int] = ...
    HOUR1_FIELD: typing.ClassVar[int] = ...
    HOUR_OF_DAY0_FIELD: typing.ClassVar[int] = ...
    HOUR_OF_DAY1_FIELD: typing.ClassVar[int] = ...
    LONG: typing.ClassVar[int] = ...
    MEDIUM: typing.ClassVar[int] = ...
    MILLISECOND_FIELD: typing.ClassVar[int] = ...
    MINUTE_FIELD: typing.ClassVar[int] = ...
    MONTH_FIELD: typing.ClassVar[int] = ...
    SECOND_FIELD: typing.ClassVar[int] = ...
    SHORT: typing.ClassVar[int] = ...
    TIMEZONE_FIELD: typing.ClassVar[int] = ...
    WEEK_OF_MONTH_FIELD: typing.ClassVar[int] = ...
    WEEK_OF_YEAR_FIELD: typing.ClassVar[int] = ...
    YEAR_FIELD: typing.ClassVar[int] = ...
    calendar: java.util.Calendar = ...
    numberFormat: NumberFormat = ...
    def __init__(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def format(self, date: java.util.Date, /) -> str: ...
    @typing.overload
    def format(self, obj: java.lang.Object | int | bool | float | str, toAppendTo: java.lang.StringBuffer, fieldPosition: FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, arg1: java.util.Date, arg2: java.lang.StringBuffer, arg3: FieldPosition, /) -> java.lang.StringBuffer: ...
    @staticmethod
    def getAvailableLocales() -> java.chaquopy.JavaArray[java.util.Locale]: ...
    def getCalendar(self) -> java.util.Calendar: ...
    @typing.overload
    @staticmethod
    def getDateInstance() -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateInstance(style: int | java.jint | java.lang.Integer, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateInstance(style: int | java.jint | java.lang.Integer, aLocale: java.util.Locale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateTimeInstance() -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateTimeInstance(dateStyle: int | java.jint | java.lang.Integer, timeStyle: int | java.jint | java.lang.Integer, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateTimeInstance(dateStyle: int | java.jint | java.lang.Integer, timeStyle: int | java.jint | java.lang.Integer, aLocale: java.util.Locale, /) -> DateFormat: ...
    @staticmethod
    def getInstance() -> DateFormat: ...
    def getNumberFormat(self) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getTimeInstance() -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getTimeInstance(style: int | java.jint | java.lang.Integer, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getTimeInstance(style: int | java.jint | java.lang.Integer, aLocale: java.util.Locale, /) -> DateFormat: ...
    def getTimeZone(self) -> java.util.TimeZone: ...
    def hashCode(self) -> int: ...
    def isLenient(self) -> bool: ...
    @typing.overload
    def parse(self, source: str | java.lang.String, /) -> java.util.Date: ...
    @typing.overload
    def parse(self, arg1: str | java.lang.String, arg2: ParsePosition, /) -> java.util.Date: ...
    def parseObject(self, source: str | java.lang.String, pos: ParsePosition, /) -> java.lang.Object: ...
    def setCalendar(self, newCalendar: java.util.Calendar, /) -> None: ...
    def setLenient(self, lenient: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setNumberFormat(self, newNumberFormat: NumberFormat, /) -> None: ...
    def setTimeZone(self, zone: java.util.TimeZone, /) -> None: ...

    class Field(java.text.Format.Field):
        AM_PM: typing.ClassVar[DateFormat.Field] = ...
        DAY_OF_MONTH: typing.ClassVar[DateFormat.Field] = ...
        DAY_OF_WEEK: typing.ClassVar[DateFormat.Field] = ...
        DAY_OF_WEEK_IN_MONTH: typing.ClassVar[DateFormat.Field] = ...
        DAY_OF_YEAR: typing.ClassVar[DateFormat.Field] = ...
        ERA: typing.ClassVar[DateFormat.Field] = ...
        HOUR0: typing.ClassVar[DateFormat.Field] = ...
        HOUR1: typing.ClassVar[DateFormat.Field] = ...
        HOUR_OF_DAY0: typing.ClassVar[DateFormat.Field] = ...
        HOUR_OF_DAY1: typing.ClassVar[DateFormat.Field] = ...
        MILLISECOND: typing.ClassVar[DateFormat.Field] = ...
        MINUTE: typing.ClassVar[DateFormat.Field] = ...
        MONTH: typing.ClassVar[DateFormat.Field] = ...
        SECOND: typing.ClassVar[DateFormat.Field] = ...
        TIME_ZONE: typing.ClassVar[DateFormat.Field] = ...
        WEEK_OF_MONTH: typing.ClassVar[DateFormat.Field] = ...
        WEEK_OF_YEAR: typing.ClassVar[DateFormat.Field] = ...
        YEAR: typing.ClassVar[DateFormat.Field] = ...
        def __init__(self, name: str | java.lang.String, calendarField: int | java.jint | java.lang.Integer, /) -> None: ...
        def getCalendarField(self) -> int: ...
        @staticmethod
        def ofCalendarField(calendarField: int | java.jint | java.lang.Integer, /) -> DateFormat.Field: ...
        def readResolve(self) -> java.lang.Object: ...

class DateFormatSymbols(java.lang.Cloneable, java.io.Serializable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, locale: java.util.Locale, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getAmPmStrings(self) -> java.chaquopy.JavaArray[java.lang.String]: ...
    @staticmethod
    def getAvailableLocales() -> java.chaquopy.JavaArray[java.util.Locale]: ...
    def getEras(self) -> java.chaquopy.JavaArray[java.lang.String]: ...
    @typing.overload
    @staticmethod
    def getInstance() -> DateFormatSymbols: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, /) -> DateFormatSymbols: ...
    def getLocalPatternChars(self) -> str: ...
    def getMonths(self) -> java.chaquopy.JavaArray[java.lang.String]: ...
    def getShortMonths(self) -> java.chaquopy.JavaArray[java.lang.String]: ...
    def getShortWeekdays(self) -> java.chaquopy.JavaArray[java.lang.String]: ...
    def getWeekdays(self) -> java.chaquopy.JavaArray[java.lang.String]: ...
    def getZoneStrings(self) -> java.chaquopy.JavaArray[java.chaquopy.JavaArray[java.lang.String]]: ...
    def hashCode(self) -> int: ...
    def setAmPmStrings(self, newAmpms: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def setEras(self, newEras: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def setLocalPatternChars(self, newLocalPatternChars: str | java.lang.String, /) -> None: ...
    def setMonths(self, newMonths: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def setShortMonths(self, newShortMonths: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def setShortWeekdays(self, newShortWeekdays: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def setWeekdays(self, newWeekdays: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def setZoneStrings(self, newZoneStrings: java.chaquopy.JavaArray[java.chaquopy.JavaArray[java.lang.String]], /) -> None: ...

class DecimalFormat(NumberFormat):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, symbols: DecimalFormatSymbols, /) -> None: ...
    def applyLocalizedPattern(self, pattern: str | java.lang.String, /) -> None: ...
    def applyPattern(self, pattern: str | java.lang.String, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def format(self, number: float | java.jdouble | java.lang.Double, result: java.lang.StringBuffer, fieldPosition: FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, number: int | java.jlong | java.lang.Long, result: java.lang.StringBuffer, fieldPosition: FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, number: java.lang.Object | int | bool | float | str, toAppendTo: java.lang.StringBuffer, pos: FieldPosition, /) -> java.lang.StringBuffer: ...
    def formatToCharacterIterator(self, obj: java.lang.Object | int | bool | float | str, /) -> AttributedCharacterIterator: ...
    def getCurrency(self) -> java.util.Currency: ...
    def getDecimalFormatSymbols(self) -> DecimalFormatSymbols: ...
    def getGroupingSize(self) -> int: ...
    def getMaximumFractionDigits(self) -> int: ...
    def getMaximumIntegerDigits(self) -> int: ...
    def getMinimumFractionDigits(self) -> int: ...
    def getMinimumIntegerDigits(self) -> int: ...
    def getMultiplier(self) -> int: ...
    def getNegativePrefix(self) -> str: ...
    def getNegativeSuffix(self) -> str: ...
    def getPositivePrefix(self) -> str: ...
    def getPositiveSuffix(self) -> str: ...
    def getRoundingMode(self) -> java.math.RoundingMode: ...
    def hashCode(self) -> int: ...
    def isDecimalSeparatorAlwaysShown(self) -> bool: ...
    def isGroupingUsed(self) -> bool: ...
    def isParseBigDecimal(self) -> bool: ...
    def isParseIntegerOnly(self) -> bool: ...
    def parse(self, text: str | java.lang.String, pos: ParsePosition, /) -> java.lang.Number: ...
    def setCurrency(self, currency: java.util.Currency, /) -> None: ...
    def setDecimalFormatSymbols(self, newSymbols: DecimalFormatSymbols, /) -> None: ...
    def setDecimalSeparatorAlwaysShown(self, newValue: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setGroupingSize(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setGroupingUsed(self, newValue: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setMaximumFractionDigits(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMaximumIntegerDigits(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMinimumFractionDigits(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMinimumIntegerDigits(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMultiplier(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setNegativePrefix(self, newValue: str | java.lang.String, /) -> None: ...
    def setNegativeSuffix(self, newValue: str | java.lang.String, /) -> None: ...
    def setParseBigDecimal(self, newValue: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setParseIntegerOnly(self, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setPositivePrefix(self, newValue: str | java.lang.String, /) -> None: ...
    def setPositiveSuffix(self, newValue: str | java.lang.String, /) -> None: ...
    def setRoundingMode(self, roundingMode: java.math.RoundingMode, /) -> None: ...
    def toLocalizedPattern(self) -> str: ...
    def toPattern(self) -> str: ...

class DecimalFormatSymbols(java.lang.Cloneable, java.io.Serializable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, locale: java.util.Locale, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def getAvailableLocales() -> java.chaquopy.JavaArray[java.util.Locale]: ...
    def getCurrency(self) -> java.util.Currency: ...
    def getCurrencySymbol(self) -> str: ...
    def getDecimalSeparator(self) -> str: ...
    def getDigit(self) -> str: ...
    def getExponentSeparator(self) -> str: ...
    def getGroupingSeparator(self) -> str: ...
    def getInfinity(self) -> str: ...
    @typing.overload
    @staticmethod
    def getInstance() -> DecimalFormatSymbols: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, /) -> DecimalFormatSymbols: ...
    def getInternationalCurrencySymbol(self) -> str: ...
    def getMinusSign(self) -> str: ...
    def getMonetaryDecimalSeparator(self) -> str: ...
    def getMonetaryGroupingSeparator(self) -> str: ...
    def getNaN(self) -> str: ...
    def getPatternSeparator(self) -> str: ...
    def getPerMill(self) -> str: ...
    def getPercent(self) -> str: ...
    def getZeroDigit(self) -> str: ...
    def hashCode(self) -> int: ...
    def setCurrency(self, currency: java.util.Currency, /) -> None: ...
    def setCurrencySymbol(self, currency: str | java.lang.String, /) -> None: ...
    def setDecimalSeparator(self, decimalSeparator: str | java.jchar | java.lang.Character, /) -> None: ...
    def setDigit(self, digit: str | java.jchar | java.lang.Character, /) -> None: ...
    def setExponentSeparator(self, exp: str | java.lang.String, /) -> None: ...
    def setGroupingSeparator(self, groupingSeparator: str | java.jchar | java.lang.Character, /) -> None: ...
    def setInfinity(self, infinity: str | java.lang.String, /) -> None: ...
    def setInternationalCurrencySymbol(self, currencyCode: str | java.lang.String, /) -> None: ...
    def setMinusSign(self, minusSign: str | java.jchar | java.lang.Character, /) -> None: ...
    def setMonetaryDecimalSeparator(self, sep: str | java.jchar | java.lang.Character, /) -> None: ...
    def setMonetaryGroupingSeparator(self, monetaryGroupingSeparator: str | java.jchar | java.lang.Character, /) -> None: ...
    def setNaN(self, NaN: str | java.lang.String, /) -> None: ...
    def setPatternSeparator(self, patternSeparator: str | java.jchar | java.lang.Character, /) -> None: ...
    def setPerMill(self, perMill: str | java.jchar | java.lang.Character, /) -> None: ...
    def setPercent(self, percent: str | java.jchar | java.lang.Character, /) -> None: ...
    def setZeroDigit(self, zeroDigit: str | java.jchar | java.lang.Character, /) -> None: ...

class FieldPosition(java.lang.Object):
    @typing.overload
    def __init__(self, field: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, attribute: Format.Field, /) -> None: ...
    @typing.overload
    def __init__(self, attribute: Format.Field, fieldID: int | java.jint | java.lang.Integer, /) -> None: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getBeginIndex(self) -> int: ...
    def getEndIndex(self) -> int: ...
    def getField(self) -> int: ...
    def getFieldAttribute(self) -> Format.Field: ...
    def hashCode(self) -> int: ...
    def setBeginIndex(self, bi: int | java.jint | java.lang.Integer, /) -> None: ...
    def setEndIndex(self, ei: int | java.jint | java.lang.Integer, /) -> None: ...
    def toString(self) -> str: ...

class Format(java.lang.Cloneable, java.io.Serializable):
    def __init__(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    @typing.overload
    def format(self, obj: java.lang.Object | int | bool | float | str, /) -> str: ...
    @typing.overload
    def format(self, arg1: java.lang.Object | int | bool | float | str, arg2: java.lang.StringBuffer, arg3: FieldPosition, /) -> java.lang.StringBuffer: ...
    def formatToCharacterIterator(self, obj: java.lang.Object | int | bool | float | str, /) -> AttributedCharacterIterator: ...
    @typing.overload
    def parseObject(self, source: str | java.lang.String, /) -> java.lang.Object: ...
    @typing.overload
    def parseObject(self, arg1: str | java.lang.String, arg2: ParsePosition, /) -> java.lang.Object: ...

    class Field(java.text.AttributedCharacterIterator.Attribute):
        def __init__(self, name: str | java.lang.String, /) -> None: ...

class MessageFormat(Format):
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, locale: java.util.Locale, /) -> None: ...
    def applyPattern(self, pattern: str | java.lang.String, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    @staticmethod
    def format(pattern: str | java.lang.String, /, *arguments: java.lang.Object) -> str: ...
    @typing.overload
    def format(self, arguments: java.lang.Object | int | bool | float | str, result: java.lang.StringBuffer, pos: FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, arguments: java.chaquopy.JavaArray[java.lang.Object], result: java.lang.StringBuffer, pos: FieldPosition, /) -> java.lang.StringBuffer: ...
    def formatToCharacterIterator(self, arguments: java.lang.Object | int | bool | float | str, /) -> AttributedCharacterIterator: ...
    def getFormats(self) -> java.chaquopy.JavaArray[Format]: ...
    def getFormatsByArgumentIndex(self) -> java.chaquopy.JavaArray[Format]: ...
    def getLocale(self) -> java.util.Locale: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def parse(self, source: str | java.lang.String, /) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def parse(self, source: str | java.lang.String, pos: ParsePosition, /) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    def parseObject(self, source: str | java.lang.String, pos: ParsePosition, /) -> java.lang.Object: ...
    def setFormat(self, formatElementIndex: int | java.jint | java.lang.Integer, newFormat: Format, /) -> None: ...
    def setFormatByArgumentIndex(self, argumentIndex: int | java.jint | java.lang.Integer, newFormat: Format, /) -> None: ...
    def setFormats(self, newFormats: java.chaquopy.JavaArray[Format], /) -> None: ...
    def setFormatsByArgumentIndex(self, newFormats: java.chaquopy.JavaArray[Format], /) -> None: ...
    def setLocale(self, locale: java.util.Locale, /) -> None: ...
    def toPattern(self) -> str: ...

    class Field(java.text.Format.Field):
        ARGUMENT: typing.ClassVar[MessageFormat.Field] = ...
        def __init__(self, name: str | java.lang.String, /) -> None: ...
        def readResolve(self) -> java.lang.Object: ...

class Normalizer(java.lang.Object):
    @staticmethod
    def isNormalized(src: java.lang.CharSequence, form: Normalizer.Form, /) -> bool: ...
    @staticmethod
    def normalize(src: java.lang.CharSequence, form: Normalizer.Form, /) -> str: ...

    class Form(java.lang.Enum[Normalizer.Form]):
        NFC: typing.ClassVar[Normalizer.Form] = ...
        NFD: typing.ClassVar[Normalizer.Form] = ...
        NFKC: typing.ClassVar[Normalizer.Form] = ...
        NFKD: typing.ClassVar[Normalizer.Form] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> Normalizer.Form: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[Normalizer.Form]: ...

class NumberFormat(Format):
    FRACTION_FIELD: typing.ClassVar[int] = ...
    INTEGER_FIELD: typing.ClassVar[int] = ...
    def __init__(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def format(self, number: float | java.jdouble | java.lang.Double, /) -> str: ...
    @typing.overload
    def format(self, number: int | java.jlong | java.lang.Long, /) -> str: ...
    @typing.overload
    def format(self, arg1: float | java.jdouble | java.lang.Double, arg2: java.lang.StringBuffer, arg3: FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, arg1: int | java.jlong | java.lang.Long, arg2: java.lang.StringBuffer, arg3: FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, number: java.lang.Object | int | bool | float | str, toAppendTo: java.lang.StringBuffer, pos: FieldPosition, /) -> java.lang.StringBuffer: ...
    @staticmethod
    def getAvailableLocales() -> java.chaquopy.JavaArray[java.util.Locale]: ...
    def getCurrency(self) -> java.util.Currency: ...
    @typing.overload
    @staticmethod
    def getCurrencyInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getCurrencyInstance(inLocale: java.util.Locale, /) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(inLocale: java.util.Locale, /) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getIntegerInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getIntegerInstance(inLocale: java.util.Locale, /) -> NumberFormat: ...
    def getMaximumFractionDigits(self) -> int: ...
    def getMaximumIntegerDigits(self) -> int: ...
    def getMinimumFractionDigits(self) -> int: ...
    def getMinimumIntegerDigits(self) -> int: ...
    @typing.overload
    @staticmethod
    def getNumberInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getNumberInstance(inLocale: java.util.Locale, /) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getPercentInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getPercentInstance(inLocale: java.util.Locale, /) -> NumberFormat: ...
    def getRoundingMode(self) -> java.math.RoundingMode: ...
    def hashCode(self) -> int: ...
    def isGroupingUsed(self) -> bool: ...
    def isParseIntegerOnly(self) -> bool: ...
    @typing.overload
    def parse(self, source: str | java.lang.String, /) -> java.lang.Number: ...
    @typing.overload
    def parse(self, arg1: str | java.lang.String, arg2: ParsePosition, /) -> java.lang.Number: ...
    def parseObject(self, source: str | java.lang.String, pos: ParsePosition, /) -> java.lang.Object: ...
    def setCurrency(self, currency: java.util.Currency, /) -> None: ...
    def setGroupingUsed(self, newValue: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setMaximumFractionDigits(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMaximumIntegerDigits(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMinimumFractionDigits(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMinimumIntegerDigits(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setParseIntegerOnly(self, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setRoundingMode(self, roundingMode: java.math.RoundingMode, /) -> None: ...

    class Field(java.text.Format.Field):
        CURRENCY: typing.ClassVar[NumberFormat.Field] = ...
        DECIMAL_SEPARATOR: typing.ClassVar[NumberFormat.Field] = ...
        EXPONENT: typing.ClassVar[NumberFormat.Field] = ...
        EXPONENT_SIGN: typing.ClassVar[NumberFormat.Field] = ...
        EXPONENT_SYMBOL: typing.ClassVar[NumberFormat.Field] = ...
        FRACTION: typing.ClassVar[NumberFormat.Field] = ...
        GROUPING_SEPARATOR: typing.ClassVar[NumberFormat.Field] = ...
        INTEGER: typing.ClassVar[NumberFormat.Field] = ...
        PERCENT: typing.ClassVar[NumberFormat.Field] = ...
        PERMILLE: typing.ClassVar[NumberFormat.Field] = ...
        SIGN: typing.ClassVar[NumberFormat.Field] = ...
        def __init__(self, name: str | java.lang.String, /) -> None: ...
        def readResolve(self) -> java.lang.Object: ...

class ParseException(java.lang.Exception):
    def __init__(self, s: str | java.lang.String, errorOffset: int | java.jint | java.lang.Integer, /) -> None: ...
    def getErrorOffset(self) -> int: ...

class ParsePosition(java.lang.Object):
    def __init__(self, index: int | java.jint | java.lang.Integer, /) -> None: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getErrorIndex(self) -> int: ...
    def getIndex(self) -> int: ...
    def hashCode(self) -> int: ...
    def setErrorIndex(self, ei: int | java.jint | java.lang.Integer, /) -> None: ...
    def setIndex(self, index: int | java.jint | java.lang.Integer, /) -> None: ...
    def toString(self) -> str: ...

class RuleBasedCollator(Collator):
    def __init__(self, rules: str | java.lang.String, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def compare(self, source: str | java.lang.String, target: str | java.lang.String, /) -> int: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def getCollationElementIterator(self, source: str | java.lang.String, /) -> CollationElementIterator: ...
    @typing.overload
    def getCollationElementIterator(self, source: CharacterIterator, /) -> CollationElementIterator: ...
    def getCollationKey(self, source: str | java.lang.String, /) -> CollationKey: ...
    def getRules(self) -> str: ...
    def hashCode(self) -> int: ...

class SimpleDateFormat(DateFormat):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, formatSymbols: DateFormatSymbols, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, locale: java.util.Locale, /) -> None: ...
    def applyLocalizedPattern(self, pattern: str | java.lang.String, /) -> None: ...
    def applyPattern(self, pattern: str | java.lang.String, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def format(self, date: java.util.Date, toAppendTo: java.lang.StringBuffer, pos: FieldPosition, /) -> java.lang.StringBuffer: ...
    def formatToCharacterIterator(self, obj: java.lang.Object | int | bool | float | str, /) -> AttributedCharacterIterator: ...
    def get2DigitYearStart(self) -> java.util.Date: ...
    def getDateFormatSymbols(self) -> DateFormatSymbols: ...
    def hashCode(self) -> int: ...
    def parse(self, text: str | java.lang.String, pos: ParsePosition, /) -> java.util.Date: ...
    def set2DigitYearStart(self, startDate: java.util.Date, /) -> None: ...
    def setDateFormatSymbols(self, newFormatSymbols: DateFormatSymbols, /) -> None: ...
    def toLocalizedPattern(self) -> str: ...
    def toPattern(self) -> str: ...

class StringCharacterIterator(CharacterIterator):
    @typing.overload
    def __init__(self, text: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, text: str | java.lang.String, pos: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, text: str | java.lang.String, begin: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, pos: int | java.jint | java.lang.Integer, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def current(self) -> str: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def first(self) -> str: ...
    def getBeginIndex(self) -> int: ...
    def getEndIndex(self) -> int: ...
    def getIndex(self) -> int: ...
    def hashCode(self) -> int: ...
    def last(self) -> str: ...
    def next(self) -> str: ...
    def previous(self) -> str: ...
    def setIndex(self, p: int | java.jint | java.lang.Integer, /) -> str: ...
    def setText(self, text: str | java.lang.String, /) -> None: ...
