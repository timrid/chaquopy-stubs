import java
import java.chaquopy
import java.lang
import java.text
import java.time
import java.time.chrono
import java.time.temporal
import java.util
import typing



class DateTimeFormatter(java.lang.Object):
    BASIC_ISO_DATE: typing.ClassVar[DateTimeFormatter] = ...
    ISO_DATE: typing.ClassVar[DateTimeFormatter] = ...
    ISO_DATE_TIME: typing.ClassVar[DateTimeFormatter] = ...
    ISO_INSTANT: typing.ClassVar[DateTimeFormatter] = ...
    ISO_LOCAL_DATE: typing.ClassVar[DateTimeFormatter] = ...
    ISO_LOCAL_DATE_TIME: typing.ClassVar[DateTimeFormatter] = ...
    ISO_LOCAL_TIME: typing.ClassVar[DateTimeFormatter] = ...
    ISO_OFFSET_DATE: typing.ClassVar[DateTimeFormatter] = ...
    ISO_OFFSET_DATE_TIME: typing.ClassVar[DateTimeFormatter] = ...
    ISO_OFFSET_TIME: typing.ClassVar[DateTimeFormatter] = ...
    ISO_ORDINAL_DATE: typing.ClassVar[DateTimeFormatter] = ...
    ISO_TIME: typing.ClassVar[DateTimeFormatter] = ...
    ISO_WEEK_DATE: typing.ClassVar[DateTimeFormatter] = ...
    ISO_ZONED_DATE_TIME: typing.ClassVar[DateTimeFormatter] = ...
    RFC_1123_DATE_TIME: typing.ClassVar[DateTimeFormatter] = ...
    def format(self, temporal: java.time.temporal.TemporalAccessor, /) -> str: ...
    def formatTo(self, temporal: java.time.temporal.TemporalAccessor, appendable: java.lang.Appendable, /) -> None: ...
    def getChronology(self) -> java.time.chrono.Chronology: ...
    def getDecimalStyle(self) -> DecimalStyle: ...
    def getLocale(self) -> java.util.Locale: ...
    def getResolverFields(self) -> java.util.Set[java.time.temporal.TemporalField]: ...
    def getResolverStyle(self) -> ResolverStyle: ...
    def getZone(self) -> java.time.ZoneId: ...
    def localizedBy(self, locale: java.util.Locale, /) -> DateTimeFormatter: ...
    @staticmethod
    def ofLocalizedDate(dateStyle: FormatStyle, /) -> DateTimeFormatter: ...
    @typing.overload
    @staticmethod
    def ofLocalizedDateTime(dateTimeStyle: FormatStyle, /) -> DateTimeFormatter: ...
    @typing.overload
    @staticmethod
    def ofLocalizedDateTime(dateStyle: FormatStyle, timeStyle: FormatStyle, /) -> DateTimeFormatter: ...
    @staticmethod
    def ofLocalizedTime(timeStyle: FormatStyle, /) -> DateTimeFormatter: ...
    @typing.overload
    @staticmethod
    def ofPattern(pattern: str | java.lang.String, /) -> DateTimeFormatter: ...
    @typing.overload
    @staticmethod
    def ofPattern(pattern: str | java.lang.String, locale: java.util.Locale, /) -> DateTimeFormatter: ...
    _parse_2__T = typing.TypeVar('_parse_2__T')  # <T>
    @typing.overload
    def parse(self, text: java.lang.CharSequence, /) -> java.time.temporal.TemporalAccessor: ...
    @typing.overload
    def parse(self, text: java.lang.CharSequence, position: java.text.ParsePosition, /) -> java.time.temporal.TemporalAccessor: ...
    @typing.overload
    def parse(self, text: java.lang.CharSequence, query: java.time.temporal.TemporalQuery[_parse_2__T], /) -> _parse_2__T: ...
    def parseBest(self, text: java.lang.CharSequence, /, *queries: java.time.temporal.TemporalQuery[java.lang.Object]) -> java.time.temporal.TemporalAccessor: ...
    def parseUnresolved(self, text: java.lang.CharSequence, position: java.text.ParsePosition, /) -> java.time.temporal.TemporalAccessor: ...
    @staticmethod
    def parsedExcessDays() -> java.time.temporal.TemporalQuery[java.time.Period]: ...
    @staticmethod
    def parsedLeapSecond() -> java.time.temporal.TemporalQuery[java.lang.Boolean]: ...
    @typing.overload
    def toFormat(self) -> java.text.Format: ...
    @typing.overload
    def toFormat(self, parseQuery: java.time.temporal.TemporalQuery[java.lang.Object], /) -> java.text.Format: ...
    def toString(self) -> str: ...
    def withChronology(self, chrono: java.time.chrono.Chronology, /) -> DateTimeFormatter: ...
    def withDecimalStyle(self, decimalStyle: DecimalStyle, /) -> DateTimeFormatter: ...
    def withLocale(self, locale: java.util.Locale, /) -> DateTimeFormatter: ...
    @typing.overload
    def withResolverFields(self, resolverFields: java.util.Set[java.time.temporal.TemporalField], /) -> DateTimeFormatter: ...
    @typing.overload
    def withResolverFields(self, *resolverFields: java.time.temporal.TemporalField) -> DateTimeFormatter: ...
    def withResolverStyle(self, resolverStyle: ResolverStyle, /) -> DateTimeFormatter: ...
    def withZone(self, zone: java.time.ZoneId, /) -> DateTimeFormatter: ...

class DateTimeFormatterBuilder(java.lang.Object):
    def __init__(self) -> None: ...
    def append(self, formatter: DateTimeFormatter, /) -> DateTimeFormatterBuilder: ...
    def appendChronologyId(self) -> DateTimeFormatterBuilder: ...
    def appendChronologyText(self, textStyle: TextStyle, /) -> DateTimeFormatterBuilder: ...
    def appendFraction(self, field: java.time.temporal.TemporalField, minWidth: int | java.jint | java.lang.Integer, maxWidth: int | java.jint | java.lang.Integer, decimalPoint: bool | java.jboolean | java.lang.Boolean, /) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def appendGenericZoneText(self, textStyle: TextStyle, /) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def appendGenericZoneText(self, textStyle: TextStyle, preferredZones: java.util.Set[java.time.ZoneId], /) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def appendInstant(self) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def appendInstant(self, fractionalDigits: int | java.jint | java.lang.Integer, /) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def appendLiteral(self, literal: str | java.jchar | java.lang.Character, /) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def appendLiteral(self, literal: str | java.lang.String, /) -> DateTimeFormatterBuilder: ...
    def appendLocalized(self, dateStyle: FormatStyle, timeStyle: FormatStyle, /) -> DateTimeFormatterBuilder: ...
    def appendLocalizedOffset(self, style: TextStyle, /) -> DateTimeFormatterBuilder: ...
    def appendOffset(self, pattern: str | java.lang.String, noOffsetText: str | java.lang.String, /) -> DateTimeFormatterBuilder: ...
    def appendOffsetId(self) -> DateTimeFormatterBuilder: ...
    def appendOptional(self, formatter: DateTimeFormatter, /) -> DateTimeFormatterBuilder: ...
    def appendPattern(self, pattern: str | java.lang.String, /) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def appendText(self, field: java.time.temporal.TemporalField, /) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def appendText(self, field: java.time.temporal.TemporalField, textStyle: TextStyle, /) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def appendText(self, field: java.time.temporal.TemporalField, textLookup: java.util.Map[java.lang.Long, java.lang.String], /) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def appendValue(self, field: java.time.temporal.TemporalField, /) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def appendValue(self, field: java.time.temporal.TemporalField, width: int | java.jint | java.lang.Integer, /) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def appendValue(self, field: java.time.temporal.TemporalField, minWidth: int | java.jint | java.lang.Integer, maxWidth: int | java.jint | java.lang.Integer, signStyle: SignStyle, /) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def appendValueReduced(self, field: java.time.temporal.TemporalField, width: int | java.jint | java.lang.Integer, maxWidth: int | java.jint | java.lang.Integer, baseValue: int | java.jint | java.lang.Integer, /) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def appendValueReduced(self, field: java.time.temporal.TemporalField, width: int | java.jint | java.lang.Integer, maxWidth: int | java.jint | java.lang.Integer, baseDate: java.time.chrono.ChronoLocalDate, /) -> DateTimeFormatterBuilder: ...
    def appendZoneId(self) -> DateTimeFormatterBuilder: ...
    def appendZoneOrOffsetId(self) -> DateTimeFormatterBuilder: ...
    def appendZoneRegionId(self) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def appendZoneText(self, textStyle: TextStyle, /) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def appendZoneText(self, textStyle: TextStyle, preferredZones: java.util.Set[java.time.ZoneId], /) -> DateTimeFormatterBuilder: ...
    @staticmethod
    def getLocalizedDateTimePattern(dateStyle: FormatStyle, timeStyle: FormatStyle, chrono: java.time.chrono.Chronology, locale: java.util.Locale, /) -> str: ...
    def optionalEnd(self) -> DateTimeFormatterBuilder: ...
    def optionalStart(self) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def padNext(self, padWidth: int | java.jint | java.lang.Integer, /) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def padNext(self, padWidth: int | java.jint | java.lang.Integer, padChar: str | java.jchar | java.lang.Character, /) -> DateTimeFormatterBuilder: ...
    def parseCaseInsensitive(self) -> DateTimeFormatterBuilder: ...
    def parseCaseSensitive(self) -> DateTimeFormatterBuilder: ...
    def parseDefaulting(self, field: java.time.temporal.TemporalField, value: int | java.jlong | java.lang.Long, /) -> DateTimeFormatterBuilder: ...
    def parseLenient(self) -> DateTimeFormatterBuilder: ...
    def parseStrict(self) -> DateTimeFormatterBuilder: ...
    @typing.overload
    def toFormatter(self) -> DateTimeFormatter: ...
    @typing.overload
    def toFormatter(self, locale: java.util.Locale, /) -> DateTimeFormatter: ...

class DateTimeParseException(java.time.DateTimeException):
    @typing.overload
    def __init__(self, message: str | java.lang.String, parsedData: java.lang.CharSequence, errorIndex: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, parsedData: java.lang.CharSequence, errorIndex: int | java.jint | java.lang.Integer, cause: java.lang.Throwable, /) -> None: ...
    def getErrorIndex(self) -> int: ...
    def getParsedString(self) -> str: ...

class DecimalStyle(java.lang.Object):
    STANDARD: typing.ClassVar[DecimalStyle] = ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def getAvailableLocales() -> java.util.Set[java.util.Locale]: ...
    def getDecimalSeparator(self) -> str: ...
    def getNegativeSign(self) -> str: ...
    def getPositiveSign(self) -> str: ...
    def getZeroDigit(self) -> str: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def of(locale: java.util.Locale, /) -> DecimalStyle: ...
    @staticmethod
    def ofDefaultLocale() -> DecimalStyle: ...
    def toString(self) -> str: ...
    def withDecimalSeparator(self, decimalSeparator: str | java.jchar | java.lang.Character, /) -> DecimalStyle: ...
    def withNegativeSign(self, negativeSign: str | java.jchar | java.lang.Character, /) -> DecimalStyle: ...
    def withPositiveSign(self, positiveSign: str | java.jchar | java.lang.Character, /) -> DecimalStyle: ...
    def withZeroDigit(self, zeroDigit: str | java.jchar | java.lang.Character, /) -> DecimalStyle: ...

class FormatStyle(java.lang.Enum[FormatStyle]):
    FULL: typing.ClassVar[FormatStyle] = ...
    LONG: typing.ClassVar[FormatStyle] = ...
    MEDIUM: typing.ClassVar[FormatStyle] = ...
    SHORT: typing.ClassVar[FormatStyle] = ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> FormatStyle: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[FormatStyle]: ...

class ResolverStyle(java.lang.Enum[ResolverStyle]):
    STRICT: typing.ClassVar[ResolverStyle] = ...
    SMART: typing.ClassVar[ResolverStyle] = ...
    LENIENT: typing.ClassVar[ResolverStyle] = ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> ResolverStyle: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[ResolverStyle]: ...

class SignStyle(java.lang.Enum[SignStyle]):
    NORMAL: typing.ClassVar[SignStyle] = ...
    ALWAYS: typing.ClassVar[SignStyle] = ...
    NEVER: typing.ClassVar[SignStyle] = ...
    NOT_NEGATIVE: typing.ClassVar[SignStyle] = ...
    EXCEEDS_PAD: typing.ClassVar[SignStyle] = ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> SignStyle: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[SignStyle]: ...

class TextStyle(java.lang.Enum[TextStyle]):
    FULL: typing.ClassVar[TextStyle] = ...
    FULL_STANDALONE: typing.ClassVar[TextStyle] = ...
    SHORT: typing.ClassVar[TextStyle] = ...
    SHORT_STANDALONE: typing.ClassVar[TextStyle] = ...
    NARROW: typing.ClassVar[TextStyle] = ...
    NARROW_STANDALONE: typing.ClassVar[TextStyle] = ...
    def asNormal(self) -> TextStyle: ...
    def asStandalone(self) -> TextStyle: ...
    def isStandalone(self) -> bool: ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> TextStyle: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[TextStyle]: ...
