import java
import java.chaquopy
import java.io
import java.lang
import java.time
import java.time.chrono
import java.time.format
import java.util
import java.util.function
import typing



class ChronoField(java.lang.Enum[ChronoField], TemporalField):
    NANO_OF_SECOND: typing.ClassVar[ChronoField] = ...
    NANO_OF_DAY: typing.ClassVar[ChronoField] = ...
    MICRO_OF_SECOND: typing.ClassVar[ChronoField] = ...
    MICRO_OF_DAY: typing.ClassVar[ChronoField] = ...
    MILLI_OF_SECOND: typing.ClassVar[ChronoField] = ...
    MILLI_OF_DAY: typing.ClassVar[ChronoField] = ...
    SECOND_OF_MINUTE: typing.ClassVar[ChronoField] = ...
    SECOND_OF_DAY: typing.ClassVar[ChronoField] = ...
    MINUTE_OF_HOUR: typing.ClassVar[ChronoField] = ...
    MINUTE_OF_DAY: typing.ClassVar[ChronoField] = ...
    HOUR_OF_AMPM: typing.ClassVar[ChronoField] = ...
    CLOCK_HOUR_OF_AMPM: typing.ClassVar[ChronoField] = ...
    HOUR_OF_DAY: typing.ClassVar[ChronoField] = ...
    CLOCK_HOUR_OF_DAY: typing.ClassVar[ChronoField] = ...
    AMPM_OF_DAY: typing.ClassVar[ChronoField] = ...
    DAY_OF_WEEK: typing.ClassVar[ChronoField] = ...
    ALIGNED_DAY_OF_WEEK_IN_MONTH: typing.ClassVar[ChronoField] = ...
    ALIGNED_DAY_OF_WEEK_IN_YEAR: typing.ClassVar[ChronoField] = ...
    DAY_OF_MONTH: typing.ClassVar[ChronoField] = ...
    DAY_OF_YEAR: typing.ClassVar[ChronoField] = ...
    EPOCH_DAY: typing.ClassVar[ChronoField] = ...
    ALIGNED_WEEK_OF_MONTH: typing.ClassVar[ChronoField] = ...
    ALIGNED_WEEK_OF_YEAR: typing.ClassVar[ChronoField] = ...
    MONTH_OF_YEAR: typing.ClassVar[ChronoField] = ...
    PROLEPTIC_MONTH: typing.ClassVar[ChronoField] = ...
    YEAR_OF_ERA: typing.ClassVar[ChronoField] = ...
    YEAR: typing.ClassVar[ChronoField] = ...
    ERA: typing.ClassVar[ChronoField] = ...
    INSTANT_SECONDS: typing.ClassVar[ChronoField] = ...
    OFFSET_SECONDS: typing.ClassVar[ChronoField] = ...
    _adjustInto__R = typing.TypeVar('_adjustInto__R')  # <R>
    def adjustInto(self, temporal: _adjustInto__R, newValue: int | java.jlong | java.lang.Long, /) -> _adjustInto__R: ...
    def checkValidIntValue(self, value: int | java.jlong | java.lang.Long, /) -> int: ...
    def checkValidValue(self, value: int | java.jlong | java.lang.Long, /) -> int: ...
    def getBaseUnit(self) -> TemporalUnit: ...
    def getDisplayName(self, locale: java.util.Locale, /) -> str: ...
    def getFrom(self, temporal: TemporalAccessor, /) -> int: ...
    def getRangeUnit(self) -> TemporalUnit: ...
    def isDateBased(self) -> bool: ...
    def isSupportedBy(self, temporal: TemporalAccessor, /) -> bool: ...
    def isTimeBased(self) -> bool: ...
    def range(self) -> ValueRange: ...
    def rangeRefinedBy(self, temporal: TemporalAccessor, /) -> ValueRange: ...
    def toString(self) -> str: ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> ChronoField: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[ChronoField]: ...

class ChronoUnit(java.lang.Enum[ChronoUnit], TemporalUnit):
    NANOS: typing.ClassVar[ChronoUnit] = ...
    MICROS: typing.ClassVar[ChronoUnit] = ...
    MILLIS: typing.ClassVar[ChronoUnit] = ...
    SECONDS: typing.ClassVar[ChronoUnit] = ...
    MINUTES: typing.ClassVar[ChronoUnit] = ...
    HOURS: typing.ClassVar[ChronoUnit] = ...
    HALF_DAYS: typing.ClassVar[ChronoUnit] = ...
    DAYS: typing.ClassVar[ChronoUnit] = ...
    WEEKS: typing.ClassVar[ChronoUnit] = ...
    MONTHS: typing.ClassVar[ChronoUnit] = ...
    YEARS: typing.ClassVar[ChronoUnit] = ...
    DECADES: typing.ClassVar[ChronoUnit] = ...
    CENTURIES: typing.ClassVar[ChronoUnit] = ...
    MILLENNIA: typing.ClassVar[ChronoUnit] = ...
    ERAS: typing.ClassVar[ChronoUnit] = ...
    FOREVER: typing.ClassVar[ChronoUnit] = ...
    _addTo__R = typing.TypeVar('_addTo__R')  # <R>
    def addTo(self, temporal: _addTo__R, amount: int | java.jlong | java.lang.Long, /) -> _addTo__R: ...
    def between(self, temporal1Inclusive: Temporal, temporal2Exclusive: Temporal, /) -> int: ...
    def getDuration(self) -> java.time.Duration: ...
    def isDateBased(self) -> bool: ...
    def isDurationEstimated(self) -> bool: ...
    def isSupportedBy(self, temporal: Temporal, /) -> bool: ...
    def isTimeBased(self) -> bool: ...
    def toString(self) -> str: ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> ChronoUnit: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[ChronoUnit]: ...

class IsoFields(java.lang.Object):
    DAY_OF_QUARTER: typing.ClassVar[TemporalField] = ...
    QUARTER_OF_YEAR: typing.ClassVar[TemporalField] = ...
    QUARTER_YEARS: typing.ClassVar[TemporalUnit] = ...
    WEEK_BASED_YEAR: typing.ClassVar[TemporalField] = ...
    WEEK_BASED_YEARS: typing.ClassVar[TemporalUnit] = ...
    WEEK_OF_WEEK_BASED_YEAR: typing.ClassVar[TemporalField] = ...

class JulianFields(java.lang.Object):
    JULIAN_DAY: typing.ClassVar[TemporalField] = ...
    MODIFIED_JULIAN_DAY: typing.ClassVar[TemporalField] = ...
    RATA_DIE: typing.ClassVar[TemporalField] = ...

class Temporal(TemporalAccessor):
    def isSupported(self, arg1: TemporalUnit, /) -> bool: ...
    @typing.overload
    def minus(self, amount: TemporalAmount, /) -> Temporal: ...
    @typing.overload
    def minus(self, amountToSubtract: int | java.jlong | java.lang.Long, unit: TemporalUnit, /) -> Temporal: ...
    @typing.overload
    def plus(self, amount: TemporalAmount, /) -> Temporal: ...
    @typing.overload
    def plus(self, arg1: int | java.jlong | java.lang.Long, arg2: TemporalUnit, /) -> Temporal: ...
    def until(self, arg1: Temporal, arg2: TemporalUnit, /) -> int: ...
    @typing.overload
    def with_(self, adjuster: TemporalAdjuster, /) -> Temporal: ...
    @typing.overload
    def with_(self, arg1: TemporalField, arg2: int | java.jlong | java.lang.Long, /) -> Temporal: ...

class TemporalAccessor(java.lang.Object):
    def get(self, field: TemporalField, /) -> int: ...
    def getLong(self, arg1: TemporalField, /) -> int: ...
    def isSupported(self, arg1: TemporalField, /) -> bool: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: TemporalQuery[_query__R], /) -> _query__R: ...
    def range(self, field: TemporalField, /) -> ValueRange: ...

class TemporalAdjuster(java.lang.Object):
    def adjustInto(self, arg1: Temporal, /) -> Temporal: ...

class TemporalAdjusters(java.lang.Object):
    @staticmethod
    def dayOfWeekInMonth(ordinal: int | java.jint | java.lang.Integer, dayOfWeek: java.time.DayOfWeek, /) -> TemporalAdjuster: ...
    @staticmethod
    def firstDayOfMonth() -> TemporalAdjuster: ...
    @staticmethod
    def firstDayOfNextMonth() -> TemporalAdjuster: ...
    @staticmethod
    def firstDayOfNextYear() -> TemporalAdjuster: ...
    @staticmethod
    def firstDayOfYear() -> TemporalAdjuster: ...
    @staticmethod
    def firstInMonth(dayOfWeek: java.time.DayOfWeek, /) -> TemporalAdjuster: ...
    @staticmethod
    def lastDayOfMonth() -> TemporalAdjuster: ...
    @staticmethod
    def lastDayOfYear() -> TemporalAdjuster: ...
    @staticmethod
    def lastInMonth(dayOfWeek: java.time.DayOfWeek, /) -> TemporalAdjuster: ...
    @staticmethod
    def next(dayOfWeek: java.time.DayOfWeek, /) -> TemporalAdjuster: ...
    @staticmethod
    def nextOrSame(dayOfWeek: java.time.DayOfWeek, /) -> TemporalAdjuster: ...
    @staticmethod
    def ofDateAdjuster(dateBasedAdjuster: java.util.function.UnaryOperator[java.time.LocalDate], /) -> TemporalAdjuster: ...
    @staticmethod
    def previous(dayOfWeek: java.time.DayOfWeek, /) -> TemporalAdjuster: ...
    @staticmethod
    def previousOrSame(dayOfWeek: java.time.DayOfWeek, /) -> TemporalAdjuster: ...

class TemporalAmount(java.lang.Object):
    def addTo(self, arg1: Temporal, /) -> Temporal: ...
    def get(self, arg1: TemporalUnit, /) -> int: ...
    def getUnits(self) -> java.util.List[TemporalUnit]: ...
    def subtractFrom(self, arg1: Temporal, /) -> Temporal: ...

class TemporalField(java.lang.Object):
    _adjustInto__R = typing.TypeVar('_adjustInto__R')  # <R>
    def adjustInto(self, arg1: _adjustInto__R, arg2: int | java.jlong | java.lang.Long, /) -> _adjustInto__R: ...
    def getBaseUnit(self) -> TemporalUnit: ...
    def getDisplayName(self, locale: java.util.Locale, /) -> str: ...
    def getFrom(self, arg1: TemporalAccessor, /) -> int: ...
    def getRangeUnit(self) -> TemporalUnit: ...
    def isDateBased(self) -> bool: ...
    def isSupportedBy(self, arg1: TemporalAccessor, /) -> bool: ...
    def isTimeBased(self) -> bool: ...
    def range(self) -> ValueRange: ...
    def rangeRefinedBy(self, arg1: TemporalAccessor, /) -> ValueRange: ...
    def resolve(self, fieldValues: java.util.Map[TemporalField, java.lang.Long], partialTemporal: TemporalAccessor, resolverStyle: java.time.format.ResolverStyle, /) -> TemporalAccessor: ...
    def toString(self) -> str: ...

class TemporalQueries(java.lang.Object):
    @staticmethod
    def chronology() -> TemporalQuery[java.time.chrono.Chronology]: ...
    @staticmethod
    def localDate() -> TemporalQuery[java.time.LocalDate]: ...
    @staticmethod
    def localTime() -> TemporalQuery[java.time.LocalTime]: ...
    @staticmethod
    def offset() -> TemporalQuery[java.time.ZoneOffset]: ...
    @staticmethod
    def precision() -> TemporalQuery[TemporalUnit]: ...
    @staticmethod
    def zone() -> TemporalQuery[java.time.ZoneId]: ...
    @staticmethod
    def zoneId() -> TemporalQuery[java.time.ZoneId]: ...

_TemporalQuery__R = typing.TypeVar('_TemporalQuery__R')  # <R>
class TemporalQuery(java.lang.Object, typing.Generic[_TemporalQuery__R]):
    def queryFrom(self, arg1: TemporalAccessor, /) -> _TemporalQuery__R: ...

class TemporalUnit(java.lang.Object):
    _addTo__R = typing.TypeVar('_addTo__R')  # <R>
    def addTo(self, arg1: _addTo__R, arg2: int | java.jlong | java.lang.Long, /) -> _addTo__R: ...
    def between(self, arg1: Temporal, arg2: Temporal, /) -> int: ...
    def getDuration(self) -> java.time.Duration: ...
    def isDateBased(self) -> bool: ...
    def isDurationEstimated(self) -> bool: ...
    def isSupportedBy(self, temporal: Temporal, /) -> bool: ...
    def isTimeBased(self) -> bool: ...
    def toString(self) -> str: ...

class UnsupportedTemporalTypeException(java.time.DateTimeException):
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, cause: java.lang.Throwable, /) -> None: ...

class ValueRange(java.io.Serializable):
    def checkValidIntValue(self, value: int | java.jlong | java.lang.Long, field: TemporalField, /) -> int: ...
    def checkValidValue(self, value: int | java.jlong | java.lang.Long, field: TemporalField, /) -> int: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getLargestMinimum(self) -> int: ...
    def getMaximum(self) -> int: ...
    def getMinimum(self) -> int: ...
    def getSmallestMaximum(self) -> int: ...
    def hashCode(self) -> int: ...
    def isFixed(self) -> bool: ...
    def isIntValue(self) -> bool: ...
    def isValidIntValue(self, value: int | java.jlong | java.lang.Long, /) -> bool: ...
    def isValidValue(self, value: int | java.jlong | java.lang.Long, /) -> bool: ...
    @typing.overload
    @staticmethod
    def of(min: int | java.jlong | java.lang.Long, max: int | java.jlong | java.lang.Long, /) -> ValueRange: ...
    @typing.overload
    @staticmethod
    def of(min: int | java.jlong | java.lang.Long, maxSmallest: int | java.jlong | java.lang.Long, maxLargest: int | java.jlong | java.lang.Long, /) -> ValueRange: ...
    @typing.overload
    @staticmethod
    def of(minSmallest: int | java.jlong | java.lang.Long, minLargest: int | java.jlong | java.lang.Long, maxSmallest: int | java.jlong | java.lang.Long, maxLargest: int | java.jlong | java.lang.Long, /) -> ValueRange: ...
    def toString(self) -> str: ...

class WeekFields(java.io.Serializable):
    ISO: typing.ClassVar[WeekFields] = ...
    SUNDAY_START: typing.ClassVar[WeekFields] = ...
    WEEK_BASED_YEARS: typing.ClassVar[TemporalUnit] = ...
    def dayOfWeek(self) -> TemporalField: ...
    def equals(self, object: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getFirstDayOfWeek(self) -> java.time.DayOfWeek: ...
    def getMinimalDaysInFirstWeek(self) -> int: ...
    def hashCode(self) -> int: ...
    @typing.overload
    @staticmethod
    def of(locale: java.util.Locale, /) -> WeekFields: ...
    @typing.overload
    @staticmethod
    def of(firstDayOfWeek: java.time.DayOfWeek, minimalDaysInFirstWeek: int | java.jint | java.lang.Integer, /) -> WeekFields: ...
    def toString(self) -> str: ...
    def weekBasedYear(self) -> TemporalField: ...
    def weekOfMonth(self) -> TemporalField: ...
    def weekOfWeekBasedYear(self) -> TemporalField: ...
    def weekOfYear(self) -> TemporalField: ...
