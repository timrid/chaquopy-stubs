import java
import java.chaquopy
import java.io
import java.lang
import java.time.chrono
import java.time.format
import java.time.temporal
import java.time.zone
import java.util
import java.util.stream
import typing



class Clock(InstantSource):
    def __init__(self) -> None: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def fixed(fixedInstant: Instant, zone: ZoneId, /) -> Clock: ...
    def getZone(self) -> ZoneId: ...
    def hashCode(self) -> int: ...
    def instant(self) -> Instant: ...
    def millis(self) -> int: ...
    @staticmethod
    def offset(baseClock: Clock, offsetDuration: Duration, /) -> Clock: ...
    @staticmethod
    def system(zone: ZoneId, /) -> Clock: ...
    @staticmethod
    def systemDefaultZone() -> Clock: ...
    @staticmethod
    def systemUTC() -> Clock: ...
    @staticmethod
    def tick(baseClock: Clock, tickDuration: Duration, /) -> Clock: ...
    @staticmethod
    def tickMillis(zone: ZoneId, /) -> Clock: ...
    @staticmethod
    def tickMinutes(zone: ZoneId, /) -> Clock: ...
    @staticmethod
    def tickSeconds(zone: ZoneId, /) -> Clock: ...
    def withZone(self, arg1: ZoneId, /) -> Clock: ...

class DateTimeException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, cause: java.lang.Throwable, /) -> None: ...

class DayOfWeek(java.lang.Enum[DayOfWeek], java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster):
    MONDAY: typing.ClassVar[DayOfWeek] = ...
    TUESDAY: typing.ClassVar[DayOfWeek] = ...
    WEDNESDAY: typing.ClassVar[DayOfWeek] = ...
    THURSDAY: typing.ClassVar[DayOfWeek] = ...
    FRIDAY: typing.ClassVar[DayOfWeek] = ...
    SATURDAY: typing.ClassVar[DayOfWeek] = ...
    SUNDAY: typing.ClassVar[DayOfWeek] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> DayOfWeek: ...
    def get(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getDisplayName(self, style: java.time.format.TextStyle, locale: java.util.Locale, /) -> str: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getValue(self) -> int: ...
    def isSupported(self, field: java.time.temporal.TemporalField, /) -> bool: ...
    def minus(self, days: int | java.jlong | java.lang.Long, /) -> DayOfWeek: ...
    @staticmethod
    def of(dayOfWeek: int | java.jint | java.lang.Integer, /) -> DayOfWeek: ...
    def plus(self, days: int | java.jlong | java.lang.Long, /) -> DayOfWeek: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> DayOfWeek: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[DayOfWeek]: ...

class Duration(java.time.temporal.TemporalAmount, java.lang.Comparable[Duration], java.io.Serializable):
    ZERO: typing.ClassVar[Duration] = ...
    def abs(self) -> Duration: ...
    def addTo(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    @staticmethod
    def between(startInclusive: java.time.temporal.Temporal, endExclusive: java.time.temporal.Temporal, /) -> Duration: ...
    def compareTo(self, otherDuration: Duration, /) -> int: ...
    @typing.overload
    def dividedBy(self, divisor: int | java.jlong | java.lang.Long, /) -> Duration: ...
    @typing.overload
    def dividedBy(self, divisor: Duration, /) -> int: ...
    def equals(self, other: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def from_(amount: java.time.temporal.TemporalAmount, /) -> Duration: ...
    def get(self, unit: java.time.temporal.TemporalUnit, /) -> int: ...
    def getNano(self) -> int: ...
    def getSeconds(self) -> int: ...
    def getUnits(self) -> java.util.List[java.time.temporal.TemporalUnit]: ...
    def hashCode(self) -> int: ...
    def isNegative(self) -> bool: ...
    def isZero(self) -> bool: ...
    @typing.overload
    def minus(self, duration: Duration, /) -> Duration: ...
    @typing.overload
    def minus(self, amountToSubtract: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> Duration: ...
    def minusDays(self, daysToSubtract: int | java.jlong | java.lang.Long, /) -> Duration: ...
    def minusHours(self, hoursToSubtract: int | java.jlong | java.lang.Long, /) -> Duration: ...
    def minusMillis(self, millisToSubtract: int | java.jlong | java.lang.Long, /) -> Duration: ...
    def minusMinutes(self, minutesToSubtract: int | java.jlong | java.lang.Long, /) -> Duration: ...
    def minusNanos(self, nanosToSubtract: int | java.jlong | java.lang.Long, /) -> Duration: ...
    def minusSeconds(self, secondsToSubtract: int | java.jlong | java.lang.Long, /) -> Duration: ...
    def multipliedBy(self, multiplicand: int | java.jlong | java.lang.Long, /) -> Duration: ...
    def negated(self) -> Duration: ...
    @staticmethod
    def of(amount: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> Duration: ...
    @staticmethod
    def ofDays(days: int | java.jlong | java.lang.Long, /) -> Duration: ...
    @staticmethod
    def ofHours(hours: int | java.jlong | java.lang.Long, /) -> Duration: ...
    @staticmethod
    def ofMillis(millis: int | java.jlong | java.lang.Long, /) -> Duration: ...
    @staticmethod
    def ofMinutes(minutes: int | java.jlong | java.lang.Long, /) -> Duration: ...
    @staticmethod
    def ofNanos(nanos: int | java.jlong | java.lang.Long, /) -> Duration: ...
    @typing.overload
    @staticmethod
    def ofSeconds(seconds: int | java.jlong | java.lang.Long, /) -> Duration: ...
    @typing.overload
    @staticmethod
    def ofSeconds(seconds: int | java.jlong | java.lang.Long, nanoAdjustment: int | java.jlong | java.lang.Long, /) -> Duration: ...
    @staticmethod
    def parse(text: java.lang.CharSequence, /) -> Duration: ...
    @typing.overload
    def plus(self, duration: Duration, /) -> Duration: ...
    @typing.overload
    def plus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> Duration: ...
    def plusDays(self, daysToAdd: int | java.jlong | java.lang.Long, /) -> Duration: ...
    def plusHours(self, hoursToAdd: int | java.jlong | java.lang.Long, /) -> Duration: ...
    def plusMillis(self, millisToAdd: int | java.jlong | java.lang.Long, /) -> Duration: ...
    def plusMinutes(self, minutesToAdd: int | java.jlong | java.lang.Long, /) -> Duration: ...
    def plusNanos(self, nanosToAdd: int | java.jlong | java.lang.Long, /) -> Duration: ...
    def plusSeconds(self, secondsToAdd: int | java.jlong | java.lang.Long, /) -> Duration: ...
    def subtractFrom(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    def toDays(self) -> int: ...
    def toDaysPart(self) -> int: ...
    def toHours(self) -> int: ...
    def toHoursPart(self) -> int: ...
    def toMillis(self) -> int: ...
    def toMillisPart(self) -> int: ...
    def toMinutes(self) -> int: ...
    def toMinutesPart(self) -> int: ...
    def toNanos(self) -> int: ...
    def toNanosPart(self) -> int: ...
    def toSeconds(self) -> int: ...
    def toSecondsPart(self) -> int: ...
    def toString(self) -> str: ...
    def truncatedTo(self, unit: java.time.temporal.TemporalUnit, /) -> Duration: ...
    def withNanos(self, nanoOfSecond: int | java.jint | java.lang.Integer, /) -> Duration: ...
    def withSeconds(self, seconds: int | java.jlong | java.lang.Long, /) -> Duration: ...

class Instant(java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable[Instant], java.io.Serializable):
    EPOCH: typing.ClassVar[Instant] = ...
    MAX: typing.ClassVar[Instant] = ...
    MIN: typing.ClassVar[Instant] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    def atOffset(self, offset: ZoneOffset, /) -> OffsetDateTime: ...
    def atZone(self, zone: ZoneId, /) -> ZonedDateTime: ...
    def compareTo(self, otherInstant: Instant, /) -> int: ...
    def equals(self, other: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> Instant: ...
    def get(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getEpochSecond(self) -> int: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getNano(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, otherInstant: Instant, /) -> bool: ...
    def isBefore(self, otherInstant: Instant, /) -> bool: ...
    @typing.overload
    def isSupported(self, field: java.time.temporal.TemporalField, /) -> bool: ...
    @typing.overload
    def isSupported(self, unit: java.time.temporal.TemporalUnit, /) -> bool: ...
    @typing.overload
    def minus(self, amountToSubtract: java.time.temporal.TemporalAmount, /) -> Instant: ...
    @typing.overload
    def minus(self, amountToSubtract: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> Instant: ...
    def minusMillis(self, millisToSubtract: int | java.jlong | java.lang.Long, /) -> Instant: ...
    def minusNanos(self, nanosToSubtract: int | java.jlong | java.lang.Long, /) -> Instant: ...
    def minusSeconds(self, secondsToSubtract: int | java.jlong | java.lang.Long, /) -> Instant: ...
    @typing.overload
    @staticmethod
    def now() -> Instant: ...
    @typing.overload
    @staticmethod
    def now(clock: Clock, /) -> Instant: ...
    @staticmethod
    def ofEpochMilli(epochMilli: int | java.jlong | java.lang.Long, /) -> Instant: ...
    @typing.overload
    @staticmethod
    def ofEpochSecond(epochSecond: int | java.jlong | java.lang.Long, /) -> Instant: ...
    @typing.overload
    @staticmethod
    def ofEpochSecond(epochSecond: int | java.jlong | java.lang.Long, nanoAdjustment: int | java.jlong | java.lang.Long, /) -> Instant: ...
    @staticmethod
    def parse(text: java.lang.CharSequence, /) -> Instant: ...
    @typing.overload
    def plus(self, amountToAdd: java.time.temporal.TemporalAmount, /) -> Instant: ...
    @typing.overload
    def plus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> Instant: ...
    def plusMillis(self, millisToAdd: int | java.jlong | java.lang.Long, /) -> Instant: ...
    def plusNanos(self, nanosToAdd: int | java.jlong | java.lang.Long, /) -> Instant: ...
    def plusSeconds(self, secondsToAdd: int | java.jlong | java.lang.Long, /) -> Instant: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    def toEpochMilli(self) -> int: ...
    def toString(self) -> str: ...
    def truncatedTo(self, unit: java.time.temporal.TemporalUnit, /) -> Instant: ...
    def until(self, endExclusive: java.time.temporal.Temporal, unit: java.time.temporal.TemporalUnit, /) -> int: ...
    @typing.overload
    def with_(self, adjuster: java.time.temporal.TemporalAdjuster, /) -> Instant: ...
    @typing.overload
    def with_(self, field: java.time.temporal.TemporalField, newValue: int | java.jlong | java.lang.Long, /) -> Instant: ...

class InstantSource(java.lang.Object):
    @staticmethod
    def fixed(fixedInstant: Instant, /) -> InstantSource: ...
    def instant(self) -> Instant: ...
    def millis(self) -> int: ...
    @staticmethod
    def offset(baseSource: InstantSource, offsetDuration: Duration, /) -> InstantSource: ...
    @staticmethod
    def system() -> InstantSource: ...
    @staticmethod
    def tick(baseSource: InstantSource, tickDuration: Duration, /) -> InstantSource: ...
    def withZone(self, zone: ZoneId, /) -> Clock: ...

class LocalDate(java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.time.chrono.ChronoLocalDate, java.io.Serializable):
    EPOCH: typing.ClassVar[LocalDate] = ...
    MAX: typing.ClassVar[LocalDate] = ...
    MIN: typing.ClassVar[LocalDate] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    @typing.overload
    def atStartOfDay(self) -> LocalDateTime: ...
    @typing.overload
    def atStartOfDay(self, zone: ZoneId, /) -> ZonedDateTime: ...
    @typing.overload
    def atTime(self, time: LocalTime, /) -> LocalDateTime: ...
    @typing.overload
    def atTime(self, time: OffsetTime, /) -> OffsetDateTime: ...
    @typing.overload
    def atTime(self, hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    @typing.overload
    def atTime(self, hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    @typing.overload
    def atTime(self, hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, nanoOfSecond: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    def compareTo(self, other: java.time.chrono.ChronoLocalDate, /) -> int: ...
    @typing.overload
    def datesUntil(self, endExclusive: LocalDate, /) -> java.util.stream.Stream[LocalDate]: ...
    @typing.overload
    def datesUntil(self, endExclusive: LocalDate, step: Period, /) -> java.util.stream.Stream[LocalDate]: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def format(self, formatter: java.time.format.DateTimeFormatter, /) -> str: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> LocalDate: ...
    def get(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getChronology(self) -> java.time.chrono.IsoChronology: ...
    def getDayOfMonth(self) -> int: ...
    def getDayOfWeek(self) -> DayOfWeek: ...
    def getDayOfYear(self) -> int: ...
    def getEra(self) -> java.time.chrono.Era: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getMonth(self) -> Month: ...
    def getMonthValue(self) -> int: ...
    def getYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, other: java.time.chrono.ChronoLocalDate, /) -> bool: ...
    def isBefore(self, other: java.time.chrono.ChronoLocalDate, /) -> bool: ...
    def isEqual(self, other: java.time.chrono.ChronoLocalDate, /) -> bool: ...
    def isLeapYear(self) -> bool: ...
    @typing.overload
    def isSupported(self, field: java.time.temporal.TemporalField, /) -> bool: ...
    @typing.overload
    def isSupported(self, unit: java.time.temporal.TemporalUnit, /) -> bool: ...
    def lengthOfMonth(self) -> int: ...
    def lengthOfYear(self) -> int: ...
    @typing.overload
    def minus(self, amountToSubtract: java.time.temporal.TemporalAmount, /) -> LocalDate: ...
    @typing.overload
    def minus(self, amountToSubtract: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> LocalDate: ...
    def minusDays(self, daysToSubtract: int | java.jlong | java.lang.Long, /) -> LocalDate: ...
    def minusMonths(self, monthsToSubtract: int | java.jlong | java.lang.Long, /) -> LocalDate: ...
    def minusWeeks(self, weeksToSubtract: int | java.jlong | java.lang.Long, /) -> LocalDate: ...
    def minusYears(self, yearsToSubtract: int | java.jlong | java.lang.Long, /) -> LocalDate: ...
    @typing.overload
    @staticmethod
    def now() -> LocalDate: ...
    @typing.overload
    @staticmethod
    def now(clock: Clock, /) -> LocalDate: ...
    @typing.overload
    @staticmethod
    def now(zone: ZoneId, /) -> LocalDate: ...
    @typing.overload
    @staticmethod
    def of(year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> LocalDate: ...
    @typing.overload
    @staticmethod
    def of(year: int | java.jint | java.lang.Integer, month: Month, dayOfMonth: int | java.jint | java.lang.Integer, /) -> LocalDate: ...
    @staticmethod
    def ofEpochDay(epochDay: int | java.jlong | java.lang.Long, /) -> LocalDate: ...
    @staticmethod
    def ofInstant(instant: Instant, zone: ZoneId, /) -> LocalDate: ...
    @staticmethod
    def ofYearDay(year: int | java.jint | java.lang.Integer, dayOfYear: int | java.jint | java.lang.Integer, /) -> LocalDate: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, /) -> LocalDate: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, formatter: java.time.format.DateTimeFormatter, /) -> LocalDate: ...
    @typing.overload
    def plus(self, amountToAdd: java.time.temporal.TemporalAmount, /) -> LocalDate: ...
    @typing.overload
    def plus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> LocalDate: ...
    def plusDays(self, daysToAdd: int | java.jlong | java.lang.Long, /) -> LocalDate: ...
    def plusMonths(self, monthsToAdd: int | java.jlong | java.lang.Long, /) -> LocalDate: ...
    def plusWeeks(self, weeksToAdd: int | java.jlong | java.lang.Long, /) -> LocalDate: ...
    def plusYears(self, yearsToAdd: int | java.jlong | java.lang.Long, /) -> LocalDate: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    def toEpochDay(self) -> int: ...
    def toEpochSecond(self, time: LocalTime, offset: ZoneOffset, /) -> int: ...
    def toString(self) -> str: ...
    @typing.overload
    def until(self, endDateExclusive: java.time.chrono.ChronoLocalDate, /) -> Period: ...
    @typing.overload
    def until(self, endExclusive: java.time.temporal.Temporal, unit: java.time.temporal.TemporalUnit, /) -> int: ...
    def withDayOfMonth(self, dayOfMonth: int | java.jint | java.lang.Integer, /) -> LocalDate: ...
    def withDayOfYear(self, dayOfYear: int | java.jint | java.lang.Integer, /) -> LocalDate: ...
    def withMonth(self, month: int | java.jint | java.lang.Integer, /) -> LocalDate: ...
    def withYear(self, year: int | java.jint | java.lang.Integer, /) -> LocalDate: ...
    @typing.overload
    def with_(self, adjuster: java.time.temporal.TemporalAdjuster, /) -> LocalDate: ...
    @typing.overload
    def with_(self, field: java.time.temporal.TemporalField, newValue: int | java.jlong | java.lang.Long, /) -> LocalDate: ...

class LocalDateTime(java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.time.chrono.ChronoLocalDateTime[LocalDate], java.io.Serializable):
    MAX: typing.ClassVar[LocalDateTime] = ...
    MIN: typing.ClassVar[LocalDateTime] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    def atOffset(self, offset: ZoneOffset, /) -> OffsetDateTime: ...
    def atZone(self, zone: ZoneId, /) -> ZonedDateTime: ...
    def compareTo(self, other: java.time.chrono.ChronoLocalDateTime[java.lang.Object], /) -> int: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def format(self, formatter: java.time.format.DateTimeFormatter, /) -> str: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> LocalDateTime: ...
    def get(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getDayOfMonth(self) -> int: ...
    def getDayOfWeek(self) -> DayOfWeek: ...
    def getDayOfYear(self) -> int: ...
    def getHour(self) -> int: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getMinute(self) -> int: ...
    def getMonth(self) -> Month: ...
    def getMonthValue(self) -> int: ...
    def getNano(self) -> int: ...
    def getSecond(self) -> int: ...
    def getYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, other: java.time.chrono.ChronoLocalDateTime[java.lang.Object], /) -> bool: ...
    def isBefore(self, other: java.time.chrono.ChronoLocalDateTime[java.lang.Object], /) -> bool: ...
    def isEqual(self, other: java.time.chrono.ChronoLocalDateTime[java.lang.Object], /) -> bool: ...
    @typing.overload
    def isSupported(self, field: java.time.temporal.TemporalField, /) -> bool: ...
    @typing.overload
    def isSupported(self, unit: java.time.temporal.TemporalUnit, /) -> bool: ...
    @typing.overload
    def minus(self, amountToSubtract: java.time.temporal.TemporalAmount, /) -> LocalDateTime: ...
    @typing.overload
    def minus(self, amountToSubtract: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> LocalDateTime: ...
    def minusDays(self, days: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...
    def minusHours(self, hours: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...
    def minusMinutes(self, minutes: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...
    def minusMonths(self, months: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...
    def minusNanos(self, nanos: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...
    def minusSeconds(self, seconds: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...
    def minusWeeks(self, weeks: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...
    def minusYears(self, years: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...
    @typing.overload
    @staticmethod
    def now() -> LocalDateTime: ...
    @typing.overload
    @staticmethod
    def now(clock: Clock, /) -> LocalDateTime: ...
    @typing.overload
    @staticmethod
    def now(zone: ZoneId, /) -> LocalDateTime: ...
    @typing.overload
    @staticmethod
    def of(date: LocalDate, time: LocalTime, /) -> LocalDateTime: ...
    @typing.overload
    @staticmethod
    def of(year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    @typing.overload
    @staticmethod
    def of(year: int | java.jint | java.lang.Integer, month: Month, dayOfMonth: int | java.jint | java.lang.Integer, hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    @typing.overload
    @staticmethod
    def of(year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    @typing.overload
    @staticmethod
    def of(year: int | java.jint | java.lang.Integer, month: Month, dayOfMonth: int | java.jint | java.lang.Integer, hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    @typing.overload
    @staticmethod
    def of(year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, nanoOfSecond: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    @typing.overload
    @staticmethod
    def of(year: int | java.jint | java.lang.Integer, month: Month, dayOfMonth: int | java.jint | java.lang.Integer, hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, nanoOfSecond: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    @staticmethod
    def ofEpochSecond(epochSecond: int | java.jlong | java.lang.Long, nanoOfSecond: int | java.jint | java.lang.Integer, offset: ZoneOffset, /) -> LocalDateTime: ...
    @staticmethod
    def ofInstant(instant: Instant, zone: ZoneId, /) -> LocalDateTime: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, /) -> LocalDateTime: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, formatter: java.time.format.DateTimeFormatter, /) -> LocalDateTime: ...
    @typing.overload
    def plus(self, amountToAdd: java.time.temporal.TemporalAmount, /) -> LocalDateTime: ...
    @typing.overload
    def plus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> LocalDateTime: ...
    def plusDays(self, days: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...
    def plusHours(self, hours: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...
    def plusMinutes(self, minutes: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...
    def plusMonths(self, months: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...
    def plusNanos(self, nanos: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...
    def plusSeconds(self, seconds: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...
    def plusWeeks(self, weeks: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...
    def plusYears(self, years: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    def toLocalDate(self) -> LocalDate: ...
    def toLocalTime(self) -> LocalTime: ...
    def toString(self) -> str: ...
    def truncatedTo(self, unit: java.time.temporal.TemporalUnit, /) -> LocalDateTime: ...
    def until(self, endExclusive: java.time.temporal.Temporal, unit: java.time.temporal.TemporalUnit, /) -> int: ...
    def withDayOfMonth(self, dayOfMonth: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    def withDayOfYear(self, dayOfYear: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    def withHour(self, hour: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    def withMinute(self, minute: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    def withMonth(self, month: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    def withNano(self, nanoOfSecond: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    def withSecond(self, second: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    def withYear(self, year: int | java.jint | java.lang.Integer, /) -> LocalDateTime: ...
    @typing.overload
    def with_(self, adjuster: java.time.temporal.TemporalAdjuster, /) -> LocalDateTime: ...
    @typing.overload
    def with_(self, field: java.time.temporal.TemporalField, newValue: int | java.jlong | java.lang.Long, /) -> LocalDateTime: ...

class LocalTime(java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable[LocalTime], java.io.Serializable):
    MAX: typing.ClassVar[LocalTime] = ...
    MIDNIGHT: typing.ClassVar[LocalTime] = ...
    MIN: typing.ClassVar[LocalTime] = ...
    NOON: typing.ClassVar[LocalTime] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    def atDate(self, date: LocalDate, /) -> LocalDateTime: ...
    def atOffset(self, offset: ZoneOffset, /) -> OffsetTime: ...
    def compareTo(self, other: LocalTime, /) -> int: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def format(self, formatter: java.time.format.DateTimeFormatter, /) -> str: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> LocalTime: ...
    def get(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getHour(self) -> int: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getMinute(self) -> int: ...
    def getNano(self) -> int: ...
    def getSecond(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, other: LocalTime, /) -> bool: ...
    def isBefore(self, other: LocalTime, /) -> bool: ...
    @typing.overload
    def isSupported(self, field: java.time.temporal.TemporalField, /) -> bool: ...
    @typing.overload
    def isSupported(self, unit: java.time.temporal.TemporalUnit, /) -> bool: ...
    @typing.overload
    def minus(self, amountToSubtract: java.time.temporal.TemporalAmount, /) -> LocalTime: ...
    @typing.overload
    def minus(self, amountToSubtract: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> LocalTime: ...
    def minusHours(self, hoursToSubtract: int | java.jlong | java.lang.Long, /) -> LocalTime: ...
    def minusMinutes(self, minutesToSubtract: int | java.jlong | java.lang.Long, /) -> LocalTime: ...
    def minusNanos(self, nanosToSubtract: int | java.jlong | java.lang.Long, /) -> LocalTime: ...
    def minusSeconds(self, secondsToSubtract: int | java.jlong | java.lang.Long, /) -> LocalTime: ...
    @typing.overload
    @staticmethod
    def now() -> LocalTime: ...
    @typing.overload
    @staticmethod
    def now(clock: Clock, /) -> LocalTime: ...
    @typing.overload
    @staticmethod
    def now(zone: ZoneId, /) -> LocalTime: ...
    @typing.overload
    @staticmethod
    def of(hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, /) -> LocalTime: ...
    @typing.overload
    @staticmethod
    def of(hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, /) -> LocalTime: ...
    @typing.overload
    @staticmethod
    def of(hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, nanoOfSecond: int | java.jint | java.lang.Integer, /) -> LocalTime: ...
    @staticmethod
    def ofInstant(instant: Instant, zone: ZoneId, /) -> LocalTime: ...
    @staticmethod
    def ofNanoOfDay(nanoOfDay: int | java.jlong | java.lang.Long, /) -> LocalTime: ...
    @staticmethod
    def ofSecondOfDay(secondOfDay: int | java.jlong | java.lang.Long, /) -> LocalTime: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, /) -> LocalTime: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, formatter: java.time.format.DateTimeFormatter, /) -> LocalTime: ...
    @typing.overload
    def plus(self, amountToAdd: java.time.temporal.TemporalAmount, /) -> LocalTime: ...
    @typing.overload
    def plus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> LocalTime: ...
    def plusHours(self, hoursToAdd: int | java.jlong | java.lang.Long, /) -> LocalTime: ...
    def plusMinutes(self, minutesToAdd: int | java.jlong | java.lang.Long, /) -> LocalTime: ...
    def plusNanos(self, nanosToAdd: int | java.jlong | java.lang.Long, /) -> LocalTime: ...
    def plusSeconds(self, secondstoAdd: int | java.jlong | java.lang.Long, /) -> LocalTime: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    def toEpochSecond(self, date: LocalDate, offset: ZoneOffset, /) -> int: ...
    def toNanoOfDay(self) -> int: ...
    def toSecondOfDay(self) -> int: ...
    def toString(self) -> str: ...
    def truncatedTo(self, unit: java.time.temporal.TemporalUnit, /) -> LocalTime: ...
    def until(self, endExclusive: java.time.temporal.Temporal, unit: java.time.temporal.TemporalUnit, /) -> int: ...
    def withHour(self, hour: int | java.jint | java.lang.Integer, /) -> LocalTime: ...
    def withMinute(self, minute: int | java.jint | java.lang.Integer, /) -> LocalTime: ...
    def withNano(self, nanoOfSecond: int | java.jint | java.lang.Integer, /) -> LocalTime: ...
    def withSecond(self, second: int | java.jint | java.lang.Integer, /) -> LocalTime: ...
    @typing.overload
    def with_(self, adjuster: java.time.temporal.TemporalAdjuster, /) -> LocalTime: ...
    @typing.overload
    def with_(self, field: java.time.temporal.TemporalField, newValue: int | java.jlong | java.lang.Long, /) -> LocalTime: ...

class Month(java.lang.Enum[Month], java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster):
    JANUARY: typing.ClassVar[Month] = ...
    FEBRUARY: typing.ClassVar[Month] = ...
    MARCH: typing.ClassVar[Month] = ...
    APRIL: typing.ClassVar[Month] = ...
    MAY: typing.ClassVar[Month] = ...
    JUNE: typing.ClassVar[Month] = ...
    JULY: typing.ClassVar[Month] = ...
    AUGUST: typing.ClassVar[Month] = ...
    SEPTEMBER: typing.ClassVar[Month] = ...
    OCTOBER: typing.ClassVar[Month] = ...
    NOVEMBER: typing.ClassVar[Month] = ...
    DECEMBER: typing.ClassVar[Month] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    def firstDayOfYear(self, leapYear: bool | java.jboolean | java.lang.Boolean, /) -> int: ...
    def firstMonthOfQuarter(self) -> Month: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> Month: ...
    def get(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getDisplayName(self, style: java.time.format.TextStyle, locale: java.util.Locale, /) -> str: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getValue(self) -> int: ...
    def isSupported(self, field: java.time.temporal.TemporalField, /) -> bool: ...
    def length(self, leapYear: bool | java.jboolean | java.lang.Boolean, /) -> int: ...
    def maxLength(self) -> int: ...
    def minLength(self) -> int: ...
    def minus(self, months: int | java.jlong | java.lang.Long, /) -> Month: ...
    @staticmethod
    def of(month: int | java.jint | java.lang.Integer, /) -> Month: ...
    def plus(self, months: int | java.jlong | java.lang.Long, /) -> Month: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> Month: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[Month]: ...

class MonthDay(java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster, java.lang.Comparable[MonthDay], java.io.Serializable):
    def adjustInto(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    def atYear(self, year: int | java.jint | java.lang.Integer, /) -> LocalDate: ...
    def compareTo(self, other: MonthDay, /) -> int: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def format(self, formatter: java.time.format.DateTimeFormatter, /) -> str: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> MonthDay: ...
    def get(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getDayOfMonth(self) -> int: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getMonth(self) -> Month: ...
    def getMonthValue(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, other: MonthDay, /) -> bool: ...
    def isBefore(self, other: MonthDay, /) -> bool: ...
    def isSupported(self, field: java.time.temporal.TemporalField, /) -> bool: ...
    def isValidYear(self, year: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def now() -> MonthDay: ...
    @typing.overload
    @staticmethod
    def now(clock: Clock, /) -> MonthDay: ...
    @typing.overload
    @staticmethod
    def now(zone: ZoneId, /) -> MonthDay: ...
    @typing.overload
    @staticmethod
    def of(month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, /) -> MonthDay: ...
    @typing.overload
    @staticmethod
    def of(month: Month, dayOfMonth: int | java.jint | java.lang.Integer, /) -> MonthDay: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, /) -> MonthDay: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, formatter: java.time.format.DateTimeFormatter, /) -> MonthDay: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    def toString(self) -> str: ...
    def withDayOfMonth(self, dayOfMonth: int | java.jint | java.lang.Integer, /) -> MonthDay: ...
    def withMonth(self, month: int | java.jint | java.lang.Integer, /) -> MonthDay: ...
    def with_(self, month: Month, /) -> MonthDay: ...

class OffsetDateTime(java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable[OffsetDateTime], java.io.Serializable):
    MAX: typing.ClassVar[OffsetDateTime] = ...
    MIN: typing.ClassVar[OffsetDateTime] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    def atZoneSameInstant(self, zone: ZoneId, /) -> ZonedDateTime: ...
    def atZoneSimilarLocal(self, zone: ZoneId, /) -> ZonedDateTime: ...
    def compareTo(self, other: OffsetDateTime, /) -> int: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def format(self, formatter: java.time.format.DateTimeFormatter, /) -> str: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> OffsetDateTime: ...
    def get(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getDayOfMonth(self) -> int: ...
    def getDayOfWeek(self) -> DayOfWeek: ...
    def getDayOfYear(self) -> int: ...
    def getHour(self) -> int: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getMinute(self) -> int: ...
    def getMonth(self) -> Month: ...
    def getMonthValue(self) -> int: ...
    def getNano(self) -> int: ...
    def getOffset(self) -> ZoneOffset: ...
    def getSecond(self) -> int: ...
    def getYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, other: OffsetDateTime, /) -> bool: ...
    def isBefore(self, other: OffsetDateTime, /) -> bool: ...
    def isEqual(self, other: OffsetDateTime, /) -> bool: ...
    @typing.overload
    def isSupported(self, field: java.time.temporal.TemporalField, /) -> bool: ...
    @typing.overload
    def isSupported(self, unit: java.time.temporal.TemporalUnit, /) -> bool: ...
    @typing.overload
    def minus(self, amountToSubtract: java.time.temporal.TemporalAmount, /) -> OffsetDateTime: ...
    @typing.overload
    def minus(self, amountToSubtract: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> OffsetDateTime: ...
    def minusDays(self, days: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...
    def minusHours(self, hours: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...
    def minusMinutes(self, minutes: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...
    def minusMonths(self, months: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...
    def minusNanos(self, nanos: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...
    def minusSeconds(self, seconds: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...
    def minusWeeks(self, weeks: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...
    def minusYears(self, years: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...
    @typing.overload
    @staticmethod
    def now() -> OffsetDateTime: ...
    @typing.overload
    @staticmethod
    def now(clock: Clock, /) -> OffsetDateTime: ...
    @typing.overload
    @staticmethod
    def now(zone: ZoneId, /) -> OffsetDateTime: ...
    @typing.overload
    @staticmethod
    def of(dateTime: LocalDateTime, offset: ZoneOffset, /) -> OffsetDateTime: ...
    @typing.overload
    @staticmethod
    def of(date: LocalDate, time: LocalTime, offset: ZoneOffset, /) -> OffsetDateTime: ...
    @typing.overload
    @staticmethod
    def of(year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, nanoOfSecond: int | java.jint | java.lang.Integer, offset: ZoneOffset, /) -> OffsetDateTime: ...
    @staticmethod
    def ofInstant(instant: Instant, zone: ZoneId, /) -> OffsetDateTime: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, /) -> OffsetDateTime: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, formatter: java.time.format.DateTimeFormatter, /) -> OffsetDateTime: ...
    @typing.overload
    def plus(self, amountToAdd: java.time.temporal.TemporalAmount, /) -> OffsetDateTime: ...
    @typing.overload
    def plus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> OffsetDateTime: ...
    def plusDays(self, days: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...
    def plusHours(self, hours: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...
    def plusMinutes(self, minutes: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...
    def plusMonths(self, months: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...
    def plusNanos(self, nanos: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...
    def plusSeconds(self, seconds: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...
    def plusWeeks(self, weeks: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...
    def plusYears(self, years: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    @staticmethod
    def timeLineOrder() -> java.util.Comparator[OffsetDateTime]: ...
    def toEpochSecond(self) -> int: ...
    def toInstant(self) -> Instant: ...
    def toLocalDate(self) -> LocalDate: ...
    def toLocalDateTime(self) -> LocalDateTime: ...
    def toLocalTime(self) -> LocalTime: ...
    def toOffsetTime(self) -> OffsetTime: ...
    def toString(self) -> str: ...
    def toZonedDateTime(self) -> ZonedDateTime: ...
    def truncatedTo(self, unit: java.time.temporal.TemporalUnit, /) -> OffsetDateTime: ...
    def until(self, endExclusive: java.time.temporal.Temporal, unit: java.time.temporal.TemporalUnit, /) -> int: ...
    def withDayOfMonth(self, dayOfMonth: int | java.jint | java.lang.Integer, /) -> OffsetDateTime: ...
    def withDayOfYear(self, dayOfYear: int | java.jint | java.lang.Integer, /) -> OffsetDateTime: ...
    def withHour(self, hour: int | java.jint | java.lang.Integer, /) -> OffsetDateTime: ...
    def withMinute(self, minute: int | java.jint | java.lang.Integer, /) -> OffsetDateTime: ...
    def withMonth(self, month: int | java.jint | java.lang.Integer, /) -> OffsetDateTime: ...
    def withNano(self, nanoOfSecond: int | java.jint | java.lang.Integer, /) -> OffsetDateTime: ...
    def withOffsetSameInstant(self, offset: ZoneOffset, /) -> OffsetDateTime: ...
    def withOffsetSameLocal(self, offset: ZoneOffset, /) -> OffsetDateTime: ...
    def withSecond(self, second: int | java.jint | java.lang.Integer, /) -> OffsetDateTime: ...
    def withYear(self, year: int | java.jint | java.lang.Integer, /) -> OffsetDateTime: ...
    @typing.overload
    def with_(self, adjuster: java.time.temporal.TemporalAdjuster, /) -> OffsetDateTime: ...
    @typing.overload
    def with_(self, field: java.time.temporal.TemporalField, newValue: int | java.jlong | java.lang.Long, /) -> OffsetDateTime: ...

class OffsetTime(java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable[OffsetTime], java.io.Serializable):
    MAX: typing.ClassVar[OffsetTime] = ...
    MIN: typing.ClassVar[OffsetTime] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    def atDate(self, date: LocalDate, /) -> OffsetDateTime: ...
    def compareTo(self, other: OffsetTime, /) -> int: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def format(self, formatter: java.time.format.DateTimeFormatter, /) -> str: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> OffsetTime: ...
    def get(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getHour(self) -> int: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getMinute(self) -> int: ...
    def getNano(self) -> int: ...
    def getOffset(self) -> ZoneOffset: ...
    def getSecond(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, other: OffsetTime, /) -> bool: ...
    def isBefore(self, other: OffsetTime, /) -> bool: ...
    def isEqual(self, other: OffsetTime, /) -> bool: ...
    @typing.overload
    def isSupported(self, field: java.time.temporal.TemporalField, /) -> bool: ...
    @typing.overload
    def isSupported(self, unit: java.time.temporal.TemporalUnit, /) -> bool: ...
    @typing.overload
    def minus(self, amountToSubtract: java.time.temporal.TemporalAmount, /) -> OffsetTime: ...
    @typing.overload
    def minus(self, amountToSubtract: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> OffsetTime: ...
    def minusHours(self, hours: int | java.jlong | java.lang.Long, /) -> OffsetTime: ...
    def minusMinutes(self, minutes: int | java.jlong | java.lang.Long, /) -> OffsetTime: ...
    def minusNanos(self, nanos: int | java.jlong | java.lang.Long, /) -> OffsetTime: ...
    def minusSeconds(self, seconds: int | java.jlong | java.lang.Long, /) -> OffsetTime: ...
    @typing.overload
    @staticmethod
    def now() -> OffsetTime: ...
    @typing.overload
    @staticmethod
    def now(clock: Clock, /) -> OffsetTime: ...
    @typing.overload
    @staticmethod
    def now(zone: ZoneId, /) -> OffsetTime: ...
    @typing.overload
    @staticmethod
    def of(time: LocalTime, offset: ZoneOffset, /) -> OffsetTime: ...
    @typing.overload
    @staticmethod
    def of(hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, nanoOfSecond: int | java.jint | java.lang.Integer, offset: ZoneOffset, /) -> OffsetTime: ...
    @staticmethod
    def ofInstant(instant: Instant, zone: ZoneId, /) -> OffsetTime: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, /) -> OffsetTime: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, formatter: java.time.format.DateTimeFormatter, /) -> OffsetTime: ...
    @typing.overload
    def plus(self, amountToAdd: java.time.temporal.TemporalAmount, /) -> OffsetTime: ...
    @typing.overload
    def plus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> OffsetTime: ...
    def plusHours(self, hours: int | java.jlong | java.lang.Long, /) -> OffsetTime: ...
    def plusMinutes(self, minutes: int | java.jlong | java.lang.Long, /) -> OffsetTime: ...
    def plusNanos(self, nanos: int | java.jlong | java.lang.Long, /) -> OffsetTime: ...
    def plusSeconds(self, seconds: int | java.jlong | java.lang.Long, /) -> OffsetTime: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    def toEpochSecond(self, date: LocalDate, /) -> int: ...
    def toLocalTime(self) -> LocalTime: ...
    def toString(self) -> str: ...
    def truncatedTo(self, unit: java.time.temporal.TemporalUnit, /) -> OffsetTime: ...
    def until(self, endExclusive: java.time.temporal.Temporal, unit: java.time.temporal.TemporalUnit, /) -> int: ...
    def withHour(self, hour: int | java.jint | java.lang.Integer, /) -> OffsetTime: ...
    def withMinute(self, minute: int | java.jint | java.lang.Integer, /) -> OffsetTime: ...
    def withNano(self, nanoOfSecond: int | java.jint | java.lang.Integer, /) -> OffsetTime: ...
    def withOffsetSameInstant(self, offset: ZoneOffset, /) -> OffsetTime: ...
    def withOffsetSameLocal(self, offset: ZoneOffset, /) -> OffsetTime: ...
    def withSecond(self, second: int | java.jint | java.lang.Integer, /) -> OffsetTime: ...
    @typing.overload
    def with_(self, adjuster: java.time.temporal.TemporalAdjuster, /) -> OffsetTime: ...
    @typing.overload
    def with_(self, field: java.time.temporal.TemporalField, newValue: int | java.jlong | java.lang.Long, /) -> OffsetTime: ...

class Period(java.time.chrono.ChronoPeriod, java.io.Serializable):
    ZERO: typing.ClassVar[Period] = ...
    def addTo(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    @staticmethod
    def between(startDateInclusive: LocalDate, endDateExclusive: LocalDate, /) -> Period: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def from_(amount: java.time.temporal.TemporalAmount, /) -> Period: ...
    def get(self, unit: java.time.temporal.TemporalUnit, /) -> int: ...
    def getChronology(self) -> java.time.chrono.IsoChronology: ...
    def getDays(self) -> int: ...
    def getMonths(self) -> int: ...
    def getUnits(self) -> java.util.List[java.time.temporal.TemporalUnit]: ...
    def getYears(self) -> int: ...
    def hashCode(self) -> int: ...
    def isNegative(self) -> bool: ...
    def isZero(self) -> bool: ...
    def minus(self, amountToSubtract: java.time.temporal.TemporalAmount, /) -> Period: ...
    def minusDays(self, daysToSubtract: int | java.jlong | java.lang.Long, /) -> Period: ...
    def minusMonths(self, monthsToSubtract: int | java.jlong | java.lang.Long, /) -> Period: ...
    def minusYears(self, yearsToSubtract: int | java.jlong | java.lang.Long, /) -> Period: ...
    def multipliedBy(self, scalar: int | java.jint | java.lang.Integer, /) -> Period: ...
    def negated(self) -> Period: ...
    def normalized(self) -> Period: ...
    @staticmethod
    def of(years: int | java.jint | java.lang.Integer, months: int | java.jint | java.lang.Integer, days: int | java.jint | java.lang.Integer, /) -> Period: ...
    @staticmethod
    def ofDays(days: int | java.jint | java.lang.Integer, /) -> Period: ...
    @staticmethod
    def ofMonths(months: int | java.jint | java.lang.Integer, /) -> Period: ...
    @staticmethod
    def ofWeeks(weeks: int | java.jint | java.lang.Integer, /) -> Period: ...
    @staticmethod
    def ofYears(years: int | java.jint | java.lang.Integer, /) -> Period: ...
    @staticmethod
    def parse(text: java.lang.CharSequence, /) -> Period: ...
    def plus(self, amountToAdd: java.time.temporal.TemporalAmount, /) -> Period: ...
    def plusDays(self, daysToAdd: int | java.jlong | java.lang.Long, /) -> Period: ...
    def plusMonths(self, monthsToAdd: int | java.jlong | java.lang.Long, /) -> Period: ...
    def plusYears(self, yearsToAdd: int | java.jlong | java.lang.Long, /) -> Period: ...
    def subtractFrom(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    def toString(self) -> str: ...
    def toTotalMonths(self) -> int: ...
    def withDays(self, days: int | java.jint | java.lang.Integer, /) -> Period: ...
    def withMonths(self, months: int | java.jint | java.lang.Integer, /) -> Period: ...
    def withYears(self, years: int | java.jint | java.lang.Integer, /) -> Period: ...

class Year(java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable[Year], java.io.Serializable):
    MAX_VALUE: typing.ClassVar[int] = ...
    MIN_VALUE: typing.ClassVar[int] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    def atDay(self, dayOfYear: int | java.jint | java.lang.Integer, /) -> LocalDate: ...
    @typing.overload
    def atMonth(self, month: int | java.jint | java.lang.Integer, /) -> YearMonth: ...
    @typing.overload
    def atMonth(self, month: Month, /) -> YearMonth: ...
    def atMonthDay(self, monthDay: MonthDay, /) -> LocalDate: ...
    def compareTo(self, other: Year, /) -> int: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def format(self, formatter: java.time.format.DateTimeFormatter, /) -> str: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> Year: ...
    def get(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getValue(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, other: Year, /) -> bool: ...
    def isBefore(self, other: Year, /) -> bool: ...
    @typing.overload
    def isLeap(self) -> bool: ...
    @typing.overload
    @staticmethod
    def isLeap(year: int | java.jlong | java.lang.Long, /) -> bool: ...
    @typing.overload
    def isSupported(self, field: java.time.temporal.TemporalField, /) -> bool: ...
    @typing.overload
    def isSupported(self, unit: java.time.temporal.TemporalUnit, /) -> bool: ...
    def isValidMonthDay(self, monthDay: MonthDay, /) -> bool: ...
    def length(self) -> int: ...
    @typing.overload
    def minus(self, amountToSubtract: java.time.temporal.TemporalAmount, /) -> Year: ...
    @typing.overload
    def minus(self, amountToSubtract: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> Year: ...
    def minusYears(self, yearsToSubtract: int | java.jlong | java.lang.Long, /) -> Year: ...
    @typing.overload
    @staticmethod
    def now() -> Year: ...
    @typing.overload
    @staticmethod
    def now(clock: Clock, /) -> Year: ...
    @typing.overload
    @staticmethod
    def now(zone: ZoneId, /) -> Year: ...
    @staticmethod
    def of(isoYear: int | java.jint | java.lang.Integer, /) -> Year: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, /) -> Year: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, formatter: java.time.format.DateTimeFormatter, /) -> Year: ...
    @typing.overload
    def plus(self, amountToAdd: java.time.temporal.TemporalAmount, /) -> Year: ...
    @typing.overload
    def plus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> Year: ...
    def plusYears(self, yearsToAdd: int | java.jlong | java.lang.Long, /) -> Year: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    def toString(self) -> str: ...
    def until(self, endExclusive: java.time.temporal.Temporal, unit: java.time.temporal.TemporalUnit, /) -> int: ...
    @typing.overload
    def with_(self, adjuster: java.time.temporal.TemporalAdjuster, /) -> Year: ...
    @typing.overload
    def with_(self, field: java.time.temporal.TemporalField, newValue: int | java.jlong | java.lang.Long, /) -> Year: ...

class YearMonth(java.time.temporal.Temporal, java.time.temporal.TemporalAdjuster, java.lang.Comparable[YearMonth], java.io.Serializable):
    def adjustInto(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    def atDay(self, dayOfMonth: int | java.jint | java.lang.Integer, /) -> LocalDate: ...
    def atEndOfMonth(self) -> LocalDate: ...
    def compareTo(self, other: YearMonth, /) -> int: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def format(self, formatter: java.time.format.DateTimeFormatter, /) -> str: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> YearMonth: ...
    def get(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getMonth(self) -> Month: ...
    def getMonthValue(self) -> int: ...
    def getYear(self) -> int: ...
    def hashCode(self) -> int: ...
    def isAfter(self, other: YearMonth, /) -> bool: ...
    def isBefore(self, other: YearMonth, /) -> bool: ...
    def isLeapYear(self) -> bool: ...
    @typing.overload
    def isSupported(self, field: java.time.temporal.TemporalField, /) -> bool: ...
    @typing.overload
    def isSupported(self, unit: java.time.temporal.TemporalUnit, /) -> bool: ...
    def isValidDay(self, dayOfMonth: int | java.jint | java.lang.Integer, /) -> bool: ...
    def lengthOfMonth(self) -> int: ...
    def lengthOfYear(self) -> int: ...
    @typing.overload
    def minus(self, amountToSubtract: java.time.temporal.TemporalAmount, /) -> YearMonth: ...
    @typing.overload
    def minus(self, amountToSubtract: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> YearMonth: ...
    def minusMonths(self, monthsToSubtract: int | java.jlong | java.lang.Long, /) -> YearMonth: ...
    def minusYears(self, yearsToSubtract: int | java.jlong | java.lang.Long, /) -> YearMonth: ...
    @typing.overload
    @staticmethod
    def now() -> YearMonth: ...
    @typing.overload
    @staticmethod
    def now(clock: Clock, /) -> YearMonth: ...
    @typing.overload
    @staticmethod
    def now(zone: ZoneId, /) -> YearMonth: ...
    @typing.overload
    @staticmethod
    def of(year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, /) -> YearMonth: ...
    @typing.overload
    @staticmethod
    def of(year: int | java.jint | java.lang.Integer, month: Month, /) -> YearMonth: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, /) -> YearMonth: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, formatter: java.time.format.DateTimeFormatter, /) -> YearMonth: ...
    @typing.overload
    def plus(self, amountToAdd: java.time.temporal.TemporalAmount, /) -> YearMonth: ...
    @typing.overload
    def plus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> YearMonth: ...
    def plusMonths(self, monthsToAdd: int | java.jlong | java.lang.Long, /) -> YearMonth: ...
    def plusYears(self, yearsToAdd: int | java.jlong | java.lang.Long, /) -> YearMonth: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    def toString(self) -> str: ...
    def until(self, endExclusive: java.time.temporal.Temporal, unit: java.time.temporal.TemporalUnit, /) -> int: ...
    def withMonth(self, month: int | java.jint | java.lang.Integer, /) -> YearMonth: ...
    def withYear(self, year: int | java.jint | java.lang.Integer, /) -> YearMonth: ...
    @typing.overload
    def with_(self, adjuster: java.time.temporal.TemporalAdjuster, /) -> YearMonth: ...
    @typing.overload
    def with_(self, field: java.time.temporal.TemporalField, newValue: int | java.jlong | java.lang.Long, /) -> YearMonth: ...

class ZoneId(java.io.Serializable):
    SHORT_IDS: typing.ClassVar[java.util.Map[java.lang.String, java.lang.String]] = ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> ZoneId: ...
    @staticmethod
    def getAvailableZoneIds() -> java.util.Set[java.lang.String]: ...
    def getDisplayName(self, style: java.time.format.TextStyle, locale: java.util.Locale, /) -> str: ...
    def getId(self) -> str: ...
    def getRules(self) -> java.time.zone.ZoneRules: ...
    def hashCode(self) -> int: ...
    def normalized(self) -> ZoneId: ...
    @typing.overload
    @staticmethod
    def of(zoneId: str | java.lang.String, /) -> ZoneId: ...
    @typing.overload
    @staticmethod
    def of(zoneId: str | java.lang.String, aliasMap: java.util.Map[java.lang.String, java.lang.String], /) -> ZoneId: ...
    @staticmethod
    def ofOffset(prefix: str | java.lang.String, offset: ZoneOffset, /) -> ZoneId: ...
    @staticmethod
    def systemDefault() -> ZoneId: ...
    def toString(self) -> str: ...

class ZoneOffset(ZoneId, java.time.temporal.TemporalAccessor, java.time.temporal.TemporalAdjuster, java.lang.Comparable[ZoneOffset], java.io.Serializable):
    MAX: typing.ClassVar[ZoneOffset] = ...
    MIN: typing.ClassVar[ZoneOffset] = ...
    UTC: typing.ClassVar[ZoneOffset] = ...
    def adjustInto(self, temporal: java.time.temporal.Temporal, /) -> java.time.temporal.Temporal: ...
    def compareTo(self, other: ZoneOffset, /) -> int: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> ZoneOffset: ...
    def get(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getId(self) -> str: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getRules(self) -> java.time.zone.ZoneRules: ...
    def getTotalSeconds(self) -> int: ...
    def hashCode(self) -> int: ...
    def isSupported(self, field: java.time.temporal.TemporalField, /) -> bool: ...
    @staticmethod
    def of(offsetId: str | java.lang.String, /) -> ZoneOffset: ...
    @staticmethod
    def ofHours(hours: int | java.jint | java.lang.Integer, /) -> ZoneOffset: ...
    @staticmethod
    def ofHoursMinutes(hours: int | java.jint | java.lang.Integer, minutes: int | java.jint | java.lang.Integer, /) -> ZoneOffset: ...
    @staticmethod
    def ofHoursMinutesSeconds(hours: int | java.jint | java.lang.Integer, minutes: int | java.jint | java.lang.Integer, seconds: int | java.jint | java.lang.Integer, /) -> ZoneOffset: ...
    @staticmethod
    def ofTotalSeconds(totalSeconds: int | java.jint | java.lang.Integer, /) -> ZoneOffset: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    def toString(self) -> str: ...

class ZonedDateTime(java.time.temporal.Temporal, java.time.chrono.ChronoZonedDateTime[LocalDate], java.io.Serializable):
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def format(self, formatter: java.time.format.DateTimeFormatter, /) -> str: ...
    @staticmethod
    def from_(temporal: java.time.temporal.TemporalAccessor, /) -> ZonedDateTime: ...
    def get(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getDayOfMonth(self) -> int: ...
    def getDayOfWeek(self) -> DayOfWeek: ...
    def getDayOfYear(self) -> int: ...
    def getHour(self) -> int: ...
    def getLong(self, field: java.time.temporal.TemporalField, /) -> int: ...
    def getMinute(self) -> int: ...
    def getMonth(self) -> Month: ...
    def getMonthValue(self) -> int: ...
    def getNano(self) -> int: ...
    def getOffset(self) -> ZoneOffset: ...
    def getSecond(self) -> int: ...
    def getYear(self) -> int: ...
    def getZone(self) -> ZoneId: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def isSupported(self, field: java.time.temporal.TemporalField, /) -> bool: ...
    @typing.overload
    def isSupported(self, unit: java.time.temporal.TemporalUnit, /) -> bool: ...
    @typing.overload
    def minus(self, amountToSubtract: java.time.temporal.TemporalAmount, /) -> ZonedDateTime: ...
    @typing.overload
    def minus(self, amountToSubtract: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> ZonedDateTime: ...
    def minusDays(self, days: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
    def minusHours(self, hours: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
    def minusMinutes(self, minutes: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
    def minusMonths(self, months: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
    def minusNanos(self, nanos: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
    def minusSeconds(self, seconds: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
    def minusWeeks(self, weeks: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
    def minusYears(self, years: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
    @typing.overload
    @staticmethod
    def now() -> ZonedDateTime: ...
    @typing.overload
    @staticmethod
    def now(clock: Clock, /) -> ZonedDateTime: ...
    @typing.overload
    @staticmethod
    def now(zone: ZoneId, /) -> ZonedDateTime: ...
    @typing.overload
    @staticmethod
    def of(localDateTime: LocalDateTime, zone: ZoneId, /) -> ZonedDateTime: ...
    @typing.overload
    @staticmethod
    def of(date: LocalDate, time: LocalTime, zone: ZoneId, /) -> ZonedDateTime: ...
    @typing.overload
    @staticmethod
    def of(year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, dayOfMonth: int | java.jint | java.lang.Integer, hour: int | java.jint | java.lang.Integer, minute: int | java.jint | java.lang.Integer, second: int | java.jint | java.lang.Integer, nanoOfSecond: int | java.jint | java.lang.Integer, zone: ZoneId, /) -> ZonedDateTime: ...
    @typing.overload
    @staticmethod
    def ofInstant(instant: Instant, zone: ZoneId, /) -> ZonedDateTime: ...
    @typing.overload
    @staticmethod
    def ofInstant(localDateTime: LocalDateTime, offset: ZoneOffset, zone: ZoneId, /) -> ZonedDateTime: ...
    @staticmethod
    def ofLocal(localDateTime: LocalDateTime, zone: ZoneId, preferredOffset: ZoneOffset, /) -> ZonedDateTime: ...
    @staticmethod
    def ofStrict(localDateTime: LocalDateTime, offset: ZoneOffset, zone: ZoneId, /) -> ZonedDateTime: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, /) -> ZonedDateTime: ...
    @typing.overload
    @staticmethod
    def parse(text: java.lang.CharSequence, formatter: java.time.format.DateTimeFormatter, /) -> ZonedDateTime: ...
    @typing.overload
    def plus(self, amountToAdd: java.time.temporal.TemporalAmount, /) -> ZonedDateTime: ...
    @typing.overload
    def plus(self, amountToAdd: int | java.jlong | java.lang.Long, unit: java.time.temporal.TemporalUnit, /) -> ZonedDateTime: ...
    def plusDays(self, days: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
    def plusHours(self, hours: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
    def plusMinutes(self, minutes: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
    def plusMonths(self, months: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
    def plusNanos(self, nanos: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
    def plusSeconds(self, seconds: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
    def plusWeeks(self, weeks: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
    def plusYears(self, years: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
    _query__R = typing.TypeVar('_query__R')  # <R>
    def query(self, query: java.time.temporal.TemporalQuery[_query__R], /) -> _query__R: ...
    def range(self, field: java.time.temporal.TemporalField, /) -> java.time.temporal.ValueRange: ...
    def toLocalDate(self) -> LocalDate: ...
    def toLocalDateTime(self) -> LocalDateTime: ...
    def toLocalTime(self) -> LocalTime: ...
    def toOffsetDateTime(self) -> OffsetDateTime: ...
    def toString(self) -> str: ...
    def truncatedTo(self, unit: java.time.temporal.TemporalUnit, /) -> ZonedDateTime: ...
    def until(self, endExclusive: java.time.temporal.Temporal, unit: java.time.temporal.TemporalUnit, /) -> int: ...
    def withDayOfMonth(self, dayOfMonth: int | java.jint | java.lang.Integer, /) -> ZonedDateTime: ...
    def withDayOfYear(self, dayOfYear: int | java.jint | java.lang.Integer, /) -> ZonedDateTime: ...
    def withEarlierOffsetAtOverlap(self) -> ZonedDateTime: ...
    def withFixedOffsetZone(self) -> ZonedDateTime: ...
    def withHour(self, hour: int | java.jint | java.lang.Integer, /) -> ZonedDateTime: ...
    def withLaterOffsetAtOverlap(self) -> ZonedDateTime: ...
    def withMinute(self, minute: int | java.jint | java.lang.Integer, /) -> ZonedDateTime: ...
    def withMonth(self, month: int | java.jint | java.lang.Integer, /) -> ZonedDateTime: ...
    def withNano(self, nanoOfSecond: int | java.jint | java.lang.Integer, /) -> ZonedDateTime: ...
    def withSecond(self, second: int | java.jint | java.lang.Integer, /) -> ZonedDateTime: ...
    def withYear(self, year: int | java.jint | java.lang.Integer, /) -> ZonedDateTime: ...
    def withZoneSameInstant(self, zone: ZoneId, /) -> ZonedDateTime: ...
    def withZoneSameLocal(self, zone: ZoneId, /) -> ZonedDateTime: ...
    @typing.overload
    def with_(self, adjuster: java.time.temporal.TemporalAdjuster, /) -> ZonedDateTime: ...
    @typing.overload
    def with_(self, field: java.time.temporal.TemporalField, newValue: int | java.jlong | java.lang.Long, /) -> ZonedDateTime: ...
