import java
import java.lang
import java.util
import typing



_BiConsumer__T = typing.TypeVar('_BiConsumer__T')  # <T>
_BiConsumer__U = typing.TypeVar('_BiConsumer__U')  # <U>
class BiConsumer(java.lang.Object, typing.Generic[_BiConsumer__T, _BiConsumer__U]):
    def accept(self, arg1: _BiConsumer__T, arg2: _BiConsumer__U, /) -> None: ...
    def andThen(self, after: BiConsumer[_BiConsumer__T, _BiConsumer__U], /) -> BiConsumer[_BiConsumer__T, _BiConsumer__U]: ...

_BiFunction__T = typing.TypeVar('_BiFunction__T')  # <T>
_BiFunction__U = typing.TypeVar('_BiFunction__U')  # <U>
_BiFunction__R = typing.TypeVar('_BiFunction__R')  # <R>
class BiFunction(java.lang.Object, typing.Generic[_BiFunction__T, _BiFunction__U, _BiFunction__R]):
    _andThen__V = typing.TypeVar('_andThen__V')  # <V>
    def andThen(self, after: Function[_BiFunction__R, _andThen__V], /) -> BiFunction[_BiFunction__T, _BiFunction__U, _andThen__V]: ...
    def apply(self, arg1: _BiFunction__T, arg2: _BiFunction__U, /) -> _BiFunction__R: ...

_BiPredicate__T = typing.TypeVar('_BiPredicate__T')  # <T>
_BiPredicate__U = typing.TypeVar('_BiPredicate__U')  # <U>
class BiPredicate(java.lang.Object, typing.Generic[_BiPredicate__T, _BiPredicate__U]):
    def and_(self, other: BiPredicate[_BiPredicate__T, _BiPredicate__U], /) -> BiPredicate[_BiPredicate__T, _BiPredicate__U]: ...
    def negate(self) -> BiPredicate[_BiPredicate__T, _BiPredicate__U]: ...
    def or_(self, other: BiPredicate[_BiPredicate__T, _BiPredicate__U], /) -> BiPredicate[_BiPredicate__T, _BiPredicate__U]: ...
    def test(self, arg1: _BiPredicate__T, arg2: _BiPredicate__U, /) -> bool: ...

_BinaryOperator__T = typing.TypeVar('_BinaryOperator__T')  # <T>
class BinaryOperator(BiFunction[_BinaryOperator__T, _BinaryOperator__T, _BinaryOperator__T], typing.Generic[_BinaryOperator__T]):
    _maxBy__T = typing.TypeVar('_maxBy__T')  # <T>
    @staticmethod
    def maxBy(comparator: java.util.Comparator[_maxBy__T], /) -> BinaryOperator[_maxBy__T]: ...
    _minBy__T = typing.TypeVar('_minBy__T')  # <T>
    @staticmethod
    def minBy(comparator: java.util.Comparator[_minBy__T], /) -> BinaryOperator[_minBy__T]: ...

class BooleanSupplier(java.lang.Object):
    def getAsBoolean(self) -> bool: ...

_Consumer__T = typing.TypeVar('_Consumer__T')  # <T>
class Consumer(java.lang.Object, typing.Generic[_Consumer__T]):
    def accept(self, arg1: _Consumer__T, /) -> None: ...
    def andThen(self, after: Consumer[_Consumer__T], /) -> Consumer[_Consumer__T]: ...

class DoubleBinaryOperator(java.lang.Object):
    def applyAsDouble(self, arg1: float | java.jdouble | java.lang.Double, arg2: float | java.jdouble | java.lang.Double, /) -> float: ...

class DoubleConsumer(java.lang.Object):
    def accept(self, arg1: float | java.jdouble | java.lang.Double, /) -> None: ...
    def andThen(self, after: DoubleConsumer, /) -> DoubleConsumer: ...

_DoubleFunction__R = typing.TypeVar('_DoubleFunction__R')  # <R>
class DoubleFunction(java.lang.Object, typing.Generic[_DoubleFunction__R]):
    def apply(self, arg1: float | java.jdouble | java.lang.Double, /) -> _DoubleFunction__R: ...

class DoublePredicate(java.lang.Object):
    def and_(self, other: DoublePredicate, /) -> DoublePredicate: ...
    def negate(self) -> DoublePredicate: ...
    def or_(self, other: DoublePredicate, /) -> DoublePredicate: ...
    def test(self, arg1: float | java.jdouble | java.lang.Double, /) -> bool: ...

class DoubleSupplier(java.lang.Object):
    def getAsDouble(self) -> float: ...

class DoubleToIntFunction(java.lang.Object):
    def applyAsInt(self, arg1: float | java.jdouble | java.lang.Double, /) -> int: ...

class DoubleToLongFunction(java.lang.Object):
    def applyAsLong(self, arg1: float | java.jdouble | java.lang.Double, /) -> int: ...

class DoubleUnaryOperator(java.lang.Object):
    def andThen(self, after: DoubleUnaryOperator, /) -> DoubleUnaryOperator: ...
    def applyAsDouble(self, arg1: float | java.jdouble | java.lang.Double, /) -> float: ...
    def compose(self, before: DoubleUnaryOperator, /) -> DoubleUnaryOperator: ...
    @staticmethod
    def identity() -> DoubleUnaryOperator: ...

_Function__T = typing.TypeVar('_Function__T')  # <T>
_Function__R = typing.TypeVar('_Function__R')  # <R>
class Function(java.lang.Object, typing.Generic[_Function__T, _Function__R]):
    _andThen__V = typing.TypeVar('_andThen__V')  # <V>
    def andThen(self, after: Function[_Function__R, _andThen__V], /) -> Function[_Function__T, _andThen__V]: ...
    def apply(self, arg1: _Function__T, /) -> _Function__R: ...
    _compose__V = typing.TypeVar('_compose__V')  # <V>
    def compose(self, before: Function[_compose__V, _Function__T], /) -> Function[_compose__V, _Function__R]: ...
    _identity__T = typing.TypeVar('_identity__T')  # <T>
    @staticmethod
    def identity() -> Function[_identity__T, _identity__T]: ...

class IntBinaryOperator(java.lang.Object):
    def applyAsInt(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, /) -> int: ...

class IntConsumer(java.lang.Object):
    def accept(self, arg1: int | java.jint | java.lang.Integer, /) -> None: ...
    def andThen(self, after: IntConsumer, /) -> IntConsumer: ...

_IntFunction__R = typing.TypeVar('_IntFunction__R')  # <R>
class IntFunction(java.lang.Object, typing.Generic[_IntFunction__R]):
    def apply(self, arg1: int | java.jint | java.lang.Integer, /) -> _IntFunction__R: ...

class IntPredicate(java.lang.Object):
    def and_(self, other: IntPredicate, /) -> IntPredicate: ...
    def negate(self) -> IntPredicate: ...
    def or_(self, other: IntPredicate, /) -> IntPredicate: ...
    def test(self, arg1: int | java.jint | java.lang.Integer, /) -> bool: ...

class IntSupplier(java.lang.Object):
    def getAsInt(self) -> int: ...

class IntToDoubleFunction(java.lang.Object):
    def applyAsDouble(self, arg1: int | java.jint | java.lang.Integer, /) -> float: ...

class IntToLongFunction(java.lang.Object):
    def applyAsLong(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...

class IntUnaryOperator(java.lang.Object):
    def andThen(self, after: IntUnaryOperator, /) -> IntUnaryOperator: ...
    def applyAsInt(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def compose(self, before: IntUnaryOperator, /) -> IntUnaryOperator: ...
    @staticmethod
    def identity() -> IntUnaryOperator: ...

class LongBinaryOperator(java.lang.Object):
    def applyAsLong(self, arg1: int | java.jlong | java.lang.Long, arg2: int | java.jlong | java.lang.Long, /) -> int: ...

class LongConsumer(java.lang.Object):
    def accept(self, arg1: int | java.jlong | java.lang.Long, /) -> None: ...
    def andThen(self, after: LongConsumer, /) -> LongConsumer: ...

_LongFunction__R = typing.TypeVar('_LongFunction__R')  # <R>
class LongFunction(java.lang.Object, typing.Generic[_LongFunction__R]):
    def apply(self, arg1: int | java.jlong | java.lang.Long, /) -> _LongFunction__R: ...

class LongPredicate(java.lang.Object):
    def and_(self, other: LongPredicate, /) -> LongPredicate: ...
    def negate(self) -> LongPredicate: ...
    def or_(self, other: LongPredicate, /) -> LongPredicate: ...
    def test(self, arg1: int | java.jlong | java.lang.Long, /) -> bool: ...

class LongSupplier(java.lang.Object):
    def getAsLong(self) -> int: ...

class LongToDoubleFunction(java.lang.Object):
    def applyAsDouble(self, arg1: int | java.jlong | java.lang.Long, /) -> float: ...

class LongToIntFunction(java.lang.Object):
    def applyAsInt(self, arg1: int | java.jlong | java.lang.Long, /) -> int: ...

class LongUnaryOperator(java.lang.Object):
    def andThen(self, after: LongUnaryOperator, /) -> LongUnaryOperator: ...
    def applyAsLong(self, arg1: int | java.jlong | java.lang.Long, /) -> int: ...
    def compose(self, before: LongUnaryOperator, /) -> LongUnaryOperator: ...
    @staticmethod
    def identity() -> LongUnaryOperator: ...

_ObjDoubleConsumer__T = typing.TypeVar('_ObjDoubleConsumer__T')  # <T>
class ObjDoubleConsumer(java.lang.Object, typing.Generic[_ObjDoubleConsumer__T]):
    def accept(self, arg1: _ObjDoubleConsumer__T, arg2: float | java.jdouble | java.lang.Double, /) -> None: ...

_ObjIntConsumer__T = typing.TypeVar('_ObjIntConsumer__T')  # <T>
class ObjIntConsumer(java.lang.Object, typing.Generic[_ObjIntConsumer__T]):
    def accept(self, arg1: _ObjIntConsumer__T, arg2: int | java.jint | java.lang.Integer, /) -> None: ...

_ObjLongConsumer__T = typing.TypeVar('_ObjLongConsumer__T')  # <T>
class ObjLongConsumer(java.lang.Object, typing.Generic[_ObjLongConsumer__T]):
    def accept(self, arg1: _ObjLongConsumer__T, arg2: int | java.jlong | java.lang.Long, /) -> None: ...

_Predicate__T = typing.TypeVar('_Predicate__T')  # <T>
class Predicate(java.lang.Object, typing.Generic[_Predicate__T]):
    def and_(self, other: Predicate[_Predicate__T], /) -> Predicate[_Predicate__T]: ...
    @staticmethod
    def isEqual(targetRef: java.lang.Object | int | bool | float | str, /) -> Predicate[java.lang.Object]: ...
    def negate(self) -> Predicate[_Predicate__T]: ...
    _not___T = typing.TypeVar('_not___T')  # <T>
    @staticmethod
    def not_(target: Predicate[_not___T], /) -> Predicate[_not___T]: ...
    def or_(self, other: Predicate[_Predicate__T], /) -> Predicate[_Predicate__T]: ...
    def test(self, arg1: _Predicate__T, /) -> bool: ...

_Supplier__T = typing.TypeVar('_Supplier__T')  # <T>
class Supplier(java.lang.Object, typing.Generic[_Supplier__T]):
    def get(self) -> _Supplier__T: ...

_ToDoubleBiFunction__T = typing.TypeVar('_ToDoubleBiFunction__T')  # <T>
_ToDoubleBiFunction__U = typing.TypeVar('_ToDoubleBiFunction__U')  # <U>
class ToDoubleBiFunction(java.lang.Object, typing.Generic[_ToDoubleBiFunction__T, _ToDoubleBiFunction__U]):
    def applyAsDouble(self, arg1: _ToDoubleBiFunction__T, arg2: _ToDoubleBiFunction__U, /) -> float: ...

_ToDoubleFunction__T = typing.TypeVar('_ToDoubleFunction__T')  # <T>
class ToDoubleFunction(java.lang.Object, typing.Generic[_ToDoubleFunction__T]):
    def applyAsDouble(self, arg1: _ToDoubleFunction__T, /) -> float: ...

_ToIntBiFunction__T = typing.TypeVar('_ToIntBiFunction__T')  # <T>
_ToIntBiFunction__U = typing.TypeVar('_ToIntBiFunction__U')  # <U>
class ToIntBiFunction(java.lang.Object, typing.Generic[_ToIntBiFunction__T, _ToIntBiFunction__U]):
    def applyAsInt(self, arg1: _ToIntBiFunction__T, arg2: _ToIntBiFunction__U, /) -> int: ...

_ToIntFunction__T = typing.TypeVar('_ToIntFunction__T')  # <T>
class ToIntFunction(java.lang.Object, typing.Generic[_ToIntFunction__T]):
    def applyAsInt(self, arg1: _ToIntFunction__T, /) -> int: ...

_ToLongBiFunction__T = typing.TypeVar('_ToLongBiFunction__T')  # <T>
_ToLongBiFunction__U = typing.TypeVar('_ToLongBiFunction__U')  # <U>
class ToLongBiFunction(java.lang.Object, typing.Generic[_ToLongBiFunction__T, _ToLongBiFunction__U]):
    def applyAsLong(self, arg1: _ToLongBiFunction__T, arg2: _ToLongBiFunction__U, /) -> int: ...

_ToLongFunction__T = typing.TypeVar('_ToLongFunction__T')  # <T>
class ToLongFunction(java.lang.Object, typing.Generic[_ToLongFunction__T]):
    def applyAsLong(self, arg1: _ToLongFunction__T, /) -> int: ...

_UnaryOperator__T = typing.TypeVar('_UnaryOperator__T')  # <T>
class UnaryOperator(Function[_UnaryOperator__T, _UnaryOperator__T], typing.Generic[_UnaryOperator__T]):
    @staticmethod
    def identity() -> UnaryOperator[java.lang.Object]: ...
