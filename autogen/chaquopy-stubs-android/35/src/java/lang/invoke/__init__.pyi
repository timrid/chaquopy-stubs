import java
import java.chaquopy
import java.io
import java.lang
import java.lang.reflect
import java.nio
import java.util
import typing



class CallSite(java.lang.Object):
    def dynamicInvoker(self) -> MethodHandle: ...
    def getTarget(self) -> MethodHandle: ...
    def setTarget(self, arg1: MethodHandle, /) -> None: ...
    def type(self) -> MethodType: ...

class ConstantCallSite(CallSite):
    @typing.overload
    def __init__(self, target: MethodHandle, /) -> None: ...
    @typing.overload
    def __init__(self, targetType: MethodType, createTargetHook: MethodHandle, /) -> None: ...
    def dynamicInvoker(self) -> MethodHandle: ...
    def getTarget(self) -> MethodHandle: ...
    def setTarget(self, ignore: MethodHandle, /) -> None: ...

class LambdaConversionException(java.lang.Exception):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: java.lang.Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, cause: java.lang.Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, cause: java.lang.Throwable, enableSuppression: bool | java.jboolean | java.lang.Boolean, writableStackTrace: bool | java.jboolean | java.lang.Boolean, /) -> None: ...

class MethodHandle(java.lang.Object):
    @typing.overload
    def asCollector(self, arrayType: typing.Type[java.lang.Object], arrayLength: int | java.jint | java.lang.Integer, /) -> MethodHandle: ...
    @typing.overload
    def asCollector(self, collectArgPos: int | java.jint | java.lang.Integer, arrayType: typing.Type[java.lang.Object], arrayLength: int | java.jint | java.lang.Integer, /) -> MethodHandle: ...
    def asFixedArity(self) -> MethodHandle: ...
    @typing.overload
    def asSpreader(self, arrayType: typing.Type[java.lang.Object], arrayLength: int | java.jint | java.lang.Integer, /) -> MethodHandle: ...
    @typing.overload
    def asSpreader(self, spreadArgPos: int | java.jint | java.lang.Integer, arrayType: typing.Type[java.lang.Object], arrayLength: int | java.jint | java.lang.Integer, /) -> MethodHandle: ...
    def asType(self, newType: MethodType, /) -> MethodHandle: ...
    def asVarargsCollector(self, arrayType: typing.Type[java.lang.Object], /) -> MethodHandle: ...
    def bindTo(self, x: java.lang.Object | int | bool | float | str, /) -> MethodHandle: ...
    def invoke(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def invokeExact(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    @typing.overload
    def invokeWithArguments(self, arguments: java.util.List[java.lang.Object], /) -> java.lang.Object: ...
    @typing.overload
    def invokeWithArguments(self, *arguments: java.lang.Object) -> java.lang.Object: ...
    def isVarargsCollector(self) -> bool: ...
    def toString(self) -> str: ...
    def type(self) -> MethodType: ...
    def withVarargs(self, makeVarargs: bool | java.jboolean | java.lang.Boolean, /) -> MethodHandle: ...

class MethodHandleInfo(java.lang.Object):
    REF_getField: typing.ClassVar[int] = ...
    REF_getStatic: typing.ClassVar[int] = ...
    REF_invokeInterface: typing.ClassVar[int] = ...
    REF_invokeSpecial: typing.ClassVar[int] = ...
    REF_invokeStatic: typing.ClassVar[int] = ...
    REF_invokeVirtual: typing.ClassVar[int] = ...
    REF_newInvokeSpecial: typing.ClassVar[int] = ...
    REF_putField: typing.ClassVar[int] = ...
    REF_putStatic: typing.ClassVar[int] = ...
    def getDeclaringClass(self) -> typing.Type[java.lang.Object]: ...
    def getMethodType(self) -> MethodType: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getReferenceKind(self) -> int: ...
    def isVarArgs(self) -> bool: ...
    @staticmethod
    def refKindIsField(refKind: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def refKindIsValid(refKind: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def refKindName(refKind: int | java.jint | java.lang.Integer, /) -> str: ...
    @staticmethod
    def referenceKindToString(referenceKind: int | java.jint | java.lang.Integer, /) -> str: ...
    _reflectAs__T = typing.TypeVar('_reflectAs__T')  # <T>
    def reflectAs(self, arg1: typing.Type[_reflectAs__T], arg2: MethodHandles.Lookup, /) -> _reflectAs__T: ...
    @staticmethod
    def toString(kind: int | java.jint | java.lang.Integer, defc: typing.Type[java.lang.Object], name: str | java.lang.String, type: MethodType, /) -> str: ...

class MethodHandles(java.lang.Object):
    @staticmethod
    def arrayConstructor(arrayClass: typing.Type[java.lang.Object], /) -> MethodHandle: ...
    @staticmethod
    def arrayElementGetter(arrayClass: typing.Type[java.lang.Object], /) -> MethodHandle: ...
    @staticmethod
    def arrayElementSetter(arrayClass: typing.Type[java.lang.Object], /) -> MethodHandle: ...
    @staticmethod
    def arrayElementVarHandle(arrayClass: typing.Type[java.lang.Object], /) -> VarHandle: ...
    @staticmethod
    def arrayLength(arrayClass: typing.Type[java.lang.Object], /) -> MethodHandle: ...
    @staticmethod
    def byteArrayViewVarHandle(viewArrayClass: typing.Type[java.lang.Object], byteOrder: java.nio.ByteOrder, /) -> VarHandle: ...
    @staticmethod
    def byteBufferViewVarHandle(viewArrayClass: typing.Type[java.lang.Object], byteOrder: java.nio.ByteOrder, /) -> VarHandle: ...
    @staticmethod
    def catchException(target: MethodHandle, exType: typing.Type[java.lang.Throwable], handler: MethodHandle, /) -> MethodHandle: ...
    @staticmethod
    def collectArguments(target: MethodHandle, pos: int | java.jint | java.lang.Integer, filter: MethodHandle, /) -> MethodHandle: ...
    @staticmethod
    def constant(type: typing.Type[java.lang.Object], value: java.lang.Object | int | bool | float | str, /) -> MethodHandle: ...
    @typing.overload
    @staticmethod
    def countedLoop(iterations: MethodHandle, init: MethodHandle, body: MethodHandle, /) -> MethodHandle: ...
    @typing.overload
    @staticmethod
    def countedLoop(start: MethodHandle, end: MethodHandle, init: MethodHandle, body: MethodHandle, /) -> MethodHandle: ...
    @staticmethod
    def doWhileLoop(init: MethodHandle, body: MethodHandle, pred: MethodHandle, /) -> MethodHandle: ...
    @typing.overload
    @staticmethod
    def dropArguments(target: MethodHandle, pos: int | java.jint | java.lang.Integer, valueTypes: java.util.List[typing.Type[java.lang.Object]], /) -> MethodHandle: ...
    @typing.overload
    @staticmethod
    def dropArguments(target: MethodHandle, pos: int | java.jint | java.lang.Integer, /, *valueTypes: typing.Type[java.lang.Object]) -> MethodHandle: ...
    @staticmethod
    def dropArgumentsToMatch(target: MethodHandle, skip: int | java.jint | java.lang.Integer, newTypes: java.util.List[typing.Type[java.lang.Object]], pos: int | java.jint | java.lang.Integer, /) -> MethodHandle: ...
    @staticmethod
    def dropReturn(target: MethodHandle, /) -> MethodHandle: ...
    @staticmethod
    def empty(type: MethodType, /) -> MethodHandle: ...
    @staticmethod
    def exactInvoker(type: MethodType, /) -> MethodHandle: ...
    @staticmethod
    def explicitCastArguments(target: MethodHandle, newType: MethodType, /) -> MethodHandle: ...
    @staticmethod
    def filterArguments(target: MethodHandle, pos: int | java.jint | java.lang.Integer, /, *filters: MethodHandle) -> MethodHandle: ...
    @staticmethod
    def filterReturnValue(target: MethodHandle, filter: MethodHandle, /) -> MethodHandle: ...
    @typing.overload
    @staticmethod
    def foldArguments(target: MethodHandle, combiner: MethodHandle, /) -> MethodHandle: ...
    @typing.overload
    @staticmethod
    def foldArguments(target: MethodHandle, pos: int | java.jint | java.lang.Integer, combiner: MethodHandle, /) -> MethodHandle: ...
    @staticmethod
    def guardWithTest(test: MethodHandle, target: MethodHandle, fallback: MethodHandle, /) -> MethodHandle: ...
    @staticmethod
    def identity(type: typing.Type[java.lang.Object], /) -> MethodHandle: ...
    @staticmethod
    def insertArguments(target: MethodHandle, pos: int | java.jint | java.lang.Integer, /, *values: java.lang.Object) -> MethodHandle: ...
    @staticmethod
    def invoker(type: MethodType, /) -> MethodHandle: ...
    @staticmethod
    def iteratedLoop(iterator: MethodHandle, init: MethodHandle, body: MethodHandle, /) -> MethodHandle: ...
    @staticmethod
    def lookup() -> MethodHandles.Lookup: ...
    @staticmethod
    def loop(*clauses: java.chaquopy.JavaArray[MethodHandle]) -> MethodHandle: ...
    @staticmethod
    def permuteArguments(target: MethodHandle, newType: MethodType, /, *reorder: java.chaquopy.JavaArrayJInt) -> MethodHandle: ...
    @staticmethod
    def privateLookupIn(targetClass: typing.Type[java.lang.Object], lookup: MethodHandles.Lookup, /) -> MethodHandles.Lookup: ...
    @staticmethod
    def publicLookup() -> MethodHandles.Lookup: ...
    _reflectAs__T = typing.TypeVar('_reflectAs__T')  # <T>
    @staticmethod
    def reflectAs(expected: typing.Type[_reflectAs__T], target: MethodHandle, /) -> _reflectAs__T: ...
    @staticmethod
    def spreadInvoker(type: MethodType, leadingArgCount: int | java.jint | java.lang.Integer, /) -> MethodHandle: ...
    @staticmethod
    def tableSwitch(fallback: MethodHandle, /, *targets: MethodHandle) -> MethodHandle: ...
    @staticmethod
    def throwException(returnType: typing.Type[java.lang.Object], exType: typing.Type[java.lang.Throwable], /) -> MethodHandle: ...
    @staticmethod
    def tryFinally(target: MethodHandle, cleanup: MethodHandle, /) -> MethodHandle: ...
    @staticmethod
    def varHandleExactInvoker(accessMode: VarHandle.AccessMode, type: MethodType, /) -> MethodHandle: ...
    @staticmethod
    def varHandleInvoker(accessMode: VarHandle.AccessMode, type: MethodType, /) -> MethodHandle: ...
    @staticmethod
    def whileLoop(init: MethodHandle, pred: MethodHandle, body: MethodHandle, /) -> MethodHandle: ...
    @staticmethod
    def zero(type: typing.Type[java.lang.Object], /) -> MethodHandle: ...

    class Lookup(java.lang.Object):
        PACKAGE: typing.ClassVar[int] = ...
        PRIVATE: typing.ClassVar[int] = ...
        PROTECTED: typing.ClassVar[int] = ...
        PUBLIC: typing.ClassVar[int] = ...
        def bind(self, receiver: java.lang.Object | int | bool | float | str, name: str | java.lang.String, type: MethodType, /) -> MethodHandle: ...
        def findConstructor(self, refc: typing.Type[java.lang.Object], type: MethodType, /) -> MethodHandle: ...
        def findGetter(self, refc: typing.Type[java.lang.Object], name: str | java.lang.String, type: typing.Type[java.lang.Object], /) -> MethodHandle: ...
        def findSetter(self, refc: typing.Type[java.lang.Object], name: str | java.lang.String, type: typing.Type[java.lang.Object], /) -> MethodHandle: ...
        def findSpecial(self, refc: typing.Type[java.lang.Object], name: str | java.lang.String, type: MethodType, specialCaller: typing.Type[java.lang.Object], /) -> MethodHandle: ...
        def findStatic(self, refc: typing.Type[java.lang.Object], name: str | java.lang.String, type: MethodType, /) -> MethodHandle: ...
        def findStaticGetter(self, refc: typing.Type[java.lang.Object], name: str | java.lang.String, type: typing.Type[java.lang.Object], /) -> MethodHandle: ...
        def findStaticSetter(self, refc: typing.Type[java.lang.Object], name: str | java.lang.String, type: typing.Type[java.lang.Object], /) -> MethodHandle: ...
        def findStaticVarHandle(self, decl: typing.Type[java.lang.Object], name: str | java.lang.String, type: typing.Type[java.lang.Object], /) -> VarHandle: ...
        def findVarHandle(self, recv: typing.Type[java.lang.Object], name: str | java.lang.String, type: typing.Type[java.lang.Object], /) -> VarHandle: ...
        def findVirtual(self, refc: typing.Type[java.lang.Object], name: str | java.lang.String, type: MethodType, /) -> MethodHandle: ...
        def in_(self, requestedLookupClass: typing.Type[java.lang.Object], /) -> MethodHandles.Lookup: ...
        def lookupClass(self) -> typing.Type[java.lang.Object]: ...
        def lookupModes(self) -> int: ...
        def revealDirect(self, target: MethodHandle, /) -> MethodHandleInfo: ...
        def toString(self) -> str: ...
        def unreflect(self, m: java.lang.reflect.Method, /) -> MethodHandle: ...
        def unreflectConstructor(self, c: java.lang.reflect.Constructor[java.lang.Object], /) -> MethodHandle: ...
        def unreflectGetter(self, f: java.lang.reflect.Field, /) -> MethodHandle: ...
        def unreflectSetter(self, f: java.lang.reflect.Field, /) -> MethodHandle: ...
        def unreflectSpecial(self, m: java.lang.reflect.Method, specialCaller: typing.Type[java.lang.Object], /) -> MethodHandle: ...
        def unreflectVarHandle(self, f: java.lang.reflect.Field, /) -> VarHandle: ...

class MethodType(java.lang.invoke.TypeDescriptor.OfMethod[typing.Type[java.lang.Object], MethodType], java.io.Serializable):
    @typing.overload
    def appendParameterTypes(self, ptypesToInsert: java.util.List[typing.Type[java.lang.Object]], /) -> MethodType: ...
    @typing.overload
    def appendParameterTypes(self, *ptypesToInsert: typing.Type[java.lang.Object]) -> MethodType: ...
    def changeParameterType(self, num: int | java.jint | java.lang.Integer, nptype: typing.Type[java.lang.Object], /) -> MethodType: ...
    def changeReturnType(self, nrtype: typing.Type[java.lang.Object], /) -> MethodType: ...
    def descriptorString(self) -> str: ...
    def dropParameterTypes(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> MethodType: ...
    def equals(self, x: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def erase(self) -> MethodType: ...
    @staticmethod
    def fromMethodDescriptorString(descriptor: str | java.lang.String, loader: java.lang.ClassLoader, /) -> MethodType: ...
    def generic(self) -> MethodType: ...
    @typing.overload
    @staticmethod
    def genericMethodType(objectArgCount: int | java.jint | java.lang.Integer, /) -> MethodType: ...
    @typing.overload
    @staticmethod
    def genericMethodType(objectArgCount: int | java.jint | java.lang.Integer, finalArray: bool | java.jboolean | java.lang.Boolean, /) -> MethodType: ...
    def hasPrimitives(self) -> bool: ...
    def hasWrappers(self) -> bool: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def insertParameterTypes(self, num: int | java.jint | java.lang.Integer, ptypesToInsert: java.util.List[typing.Type[java.lang.Object]], /) -> MethodType: ...
    @typing.overload
    def insertParameterTypes(self, num: int | java.jint | java.lang.Integer, /, *ptypesToInsert: typing.Type[java.lang.Object]) -> MethodType: ...
    def lastParameterType(self) -> typing.Type[java.lang.Object]: ...
    @typing.overload
    @staticmethod
    def methodType(rtype: typing.Type[java.lang.Object], /) -> MethodType: ...
    @typing.overload
    @staticmethod
    def methodType(rtype: typing.Type[java.lang.Object], ptype0: typing.Type[java.lang.Object], /) -> MethodType: ...
    @typing.overload
    @staticmethod
    def methodType(rtype: typing.Type[java.lang.Object], ptypes: MethodType, /) -> MethodType: ...
    @typing.overload
    @staticmethod
    def methodType(rtype: typing.Type[java.lang.Object], ptypes: java.util.List[typing.Type[java.lang.Object]], /) -> MethodType: ...
    @typing.overload
    @staticmethod
    def methodType(rtype: typing.Type[java.lang.Object], ptypes: java.chaquopy.JavaArray[typing.Type[java.lang.Object]], /) -> MethodType: ...
    @typing.overload
    @staticmethod
    def methodType(rtype: typing.Type[java.lang.Object], ptype0: typing.Type[java.lang.Object], /, *ptypes: typing.Type[java.lang.Object]) -> MethodType: ...
    def parameterArray(self) -> java.chaquopy.JavaArray[typing.Type[java.lang.Object]]: ...
    def parameterCount(self) -> int: ...
    def parameterList(self) -> java.util.List[typing.Type[java.lang.Object]]: ...
    def parameterType(self, num: int | java.jint | java.lang.Integer, /) -> typing.Type[java.lang.Object]: ...
    def returnType(self) -> typing.Type[java.lang.Object]: ...
    def toMethodDescriptorString(self) -> str: ...
    def toString(self) -> str: ...
    def unwrap(self) -> MethodType: ...
    def wrap(self) -> MethodType: ...

class MutableCallSite(CallSite):
    @typing.overload
    def __init__(self, target: MethodHandle, /) -> None: ...
    @typing.overload
    def __init__(self, type: MethodType, /) -> None: ...
    def dynamicInvoker(self) -> MethodHandle: ...
    def getTarget(self) -> MethodHandle: ...
    def setTarget(self, newTarget: MethodHandle, /) -> None: ...


_TypeDescriptor__OfMethod__F = typing.TypeVar('_TypeDescriptor__OfMethod__F')  # <F>
_TypeDescriptor__OfMethod__M = typing.TypeVar('_TypeDescriptor__OfMethod__M')  # <M>

_TypeDescriptor__OfField__F = typing.TypeVar('_TypeDescriptor__OfField__F')  # <F>
class TypeDescriptor(java.lang.Object):
    def descriptorString(self) -> str: ...
    class OfMethod(TypeDescriptor, typing.Generic[_TypeDescriptor__OfMethod__F, _TypeDescriptor__OfMethod__M]):
        def changeParameterType(self, arg1: int | java.jint | java.lang.Integer, arg2: _TypeDescriptor__OfMethod__F, /) -> _TypeDescriptor__OfMethod__M: ...
        def changeReturnType(self, arg1: _TypeDescriptor__OfMethod__F, /) -> _TypeDescriptor__OfMethod__M: ...
        def dropParameterTypes(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, /) -> _TypeDescriptor__OfMethod__M: ...
        def insertParameterTypes(self, arg1: int | java.jint | java.lang.Integer, /, *arg2: _TypeDescriptor__OfMethod__F) -> _TypeDescriptor__OfMethod__M: ...
        def parameterArray(self) -> java.chaquopy.JavaArray[_TypeDescriptor__OfMethod__F]: ...
        def parameterCount(self) -> int: ...
        def parameterList(self) -> java.util.List[_TypeDescriptor__OfMethod__F]: ...
        def parameterType(self, arg1: int | java.jint | java.lang.Integer, /) -> _TypeDescriptor__OfMethod__F: ...
        def returnType(self) -> _TypeDescriptor__OfMethod__F: ...
    class OfField(TypeDescriptor, typing.Generic[_TypeDescriptor__OfField__F]):
        def arrayType(self) -> _TypeDescriptor__OfField__F: ...
        def componentType(self) -> _TypeDescriptor__OfField__F: ...
        def isArray(self) -> bool: ...
        def isPrimitive(self) -> bool: ...

class VarHandle(java.lang.Object):
    def accessModeType(self, accessMode: VarHandle.AccessMode, /) -> MethodType: ...
    @staticmethod
    def acquireFence() -> None: ...
    def compareAndExchange(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def compareAndExchangeAcquire(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def compareAndExchangeRelease(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def compareAndSet(self, *arg1: java.lang.Object) -> bool: ...
    def coordinateTypes(self) -> java.util.List[typing.Type[java.lang.Object]]: ...
    @staticmethod
    def fullFence() -> None: ...
    def get(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getAcquire(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getAndAdd(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getAndAddAcquire(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getAndAddRelease(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getAndBitwiseAnd(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getAndBitwiseAndAcquire(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getAndBitwiseAndRelease(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getAndBitwiseOr(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getAndBitwiseOrAcquire(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getAndBitwiseOrRelease(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getAndBitwiseXor(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getAndBitwiseXorAcquire(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getAndBitwiseXorRelease(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getAndSet(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getAndSetAcquire(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getAndSetRelease(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getOpaque(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def getVolatile(self, *arg1: java.lang.Object) -> java.lang.Object: ...
    def isAccessModeSupported(self, accessMode: VarHandle.AccessMode, /) -> bool: ...
    @staticmethod
    def loadLoadFence() -> None: ...
    @staticmethod
    def releaseFence() -> None: ...
    def set(self, *arg1: java.lang.Object) -> None: ...
    def setOpaque(self, *arg1: java.lang.Object) -> None: ...
    def setRelease(self, *arg1: java.lang.Object) -> None: ...
    def setVolatile(self, *arg1: java.lang.Object) -> None: ...
    @staticmethod
    def storeStoreFence() -> None: ...
    def toMethodHandle(self, accessMode: VarHandle.AccessMode, /) -> MethodHandle: ...
    def toString(self) -> str: ...
    def varType(self) -> typing.Type[java.lang.Object]: ...
    def weakCompareAndSet(self, *arg1: java.lang.Object) -> bool: ...
    def weakCompareAndSetAcquire(self, *arg1: java.lang.Object) -> bool: ...
    def weakCompareAndSetPlain(self, *arg1: java.lang.Object) -> bool: ...
    def weakCompareAndSetRelease(self, *arg1: java.lang.Object) -> bool: ...

    class AccessMode(java.lang.Enum[VarHandle.AccessMode]):
        GET: typing.ClassVar[VarHandle.AccessMode] = ...
        SET: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_VOLATILE: typing.ClassVar[VarHandle.AccessMode] = ...
        SET_VOLATILE: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_ACQUIRE: typing.ClassVar[VarHandle.AccessMode] = ...
        SET_RELEASE: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_OPAQUE: typing.ClassVar[VarHandle.AccessMode] = ...
        SET_OPAQUE: typing.ClassVar[VarHandle.AccessMode] = ...
        COMPARE_AND_SET: typing.ClassVar[VarHandle.AccessMode] = ...
        COMPARE_AND_EXCHANGE: typing.ClassVar[VarHandle.AccessMode] = ...
        COMPARE_AND_EXCHANGE_ACQUIRE: typing.ClassVar[VarHandle.AccessMode] = ...
        COMPARE_AND_EXCHANGE_RELEASE: typing.ClassVar[VarHandle.AccessMode] = ...
        WEAK_COMPARE_AND_SET_PLAIN: typing.ClassVar[VarHandle.AccessMode] = ...
        WEAK_COMPARE_AND_SET: typing.ClassVar[VarHandle.AccessMode] = ...
        WEAK_COMPARE_AND_SET_ACQUIRE: typing.ClassVar[VarHandle.AccessMode] = ...
        WEAK_COMPARE_AND_SET_RELEASE: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_AND_SET: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_AND_SET_ACQUIRE: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_AND_SET_RELEASE: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_AND_ADD: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_AND_ADD_ACQUIRE: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_AND_ADD_RELEASE: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_AND_BITWISE_OR: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_AND_BITWISE_OR_RELEASE: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_AND_BITWISE_OR_ACQUIRE: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_AND_BITWISE_AND: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_AND_BITWISE_AND_RELEASE: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_AND_BITWISE_AND_ACQUIRE: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_AND_BITWISE_XOR: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_AND_BITWISE_XOR_RELEASE: typing.ClassVar[VarHandle.AccessMode] = ...
        GET_AND_BITWISE_XOR_ACQUIRE: typing.ClassVar[VarHandle.AccessMode] = ...
        def methodName(self) -> str: ...
        @staticmethod
        def valueFromMethodName(methodName: str | java.lang.String, /) -> VarHandle.AccessMode: ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> VarHandle.AccessMode: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[VarHandle.AccessMode]: ...

class VolatileCallSite(CallSite):
    @typing.overload
    def __init__(self, target: MethodHandle, /) -> None: ...
    @typing.overload
    def __init__(self, type: MethodType, /) -> None: ...
    def dynamicInvoker(self) -> MethodHandle: ...
    def getTarget(self) -> MethodHandle: ...
    def setTarget(self, newTarget: MethodHandle, /) -> None: ...

class WrongMethodTypeException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | java.lang.String, /) -> None: ...
