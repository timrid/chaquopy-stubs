import java
import java.chaquopy
import java.io
import java.lang
import java.lang.annotation
import java.security
import typing



class AccessibleObject(AnnotatedElement):
    def __init__(self) -> None: ...
    _getAnnotation__T = typing.TypeVar('_getAnnotation__T')  # <T>
    def getAnnotation(self, annotationClass: typing.Type[_getAnnotation__T], /) -> _getAnnotation__T | None: ...
    def getAnnotations(self) -> java.chaquopy.JavaArray[java.lang.annotation.Annotation]: ...
    _getAnnotationsByType__T = typing.TypeVar('_getAnnotationsByType__T')  # <T>
    def getAnnotationsByType(self, annotationClass: typing.Type[_getAnnotationsByType__T], /) -> java.chaquopy.JavaArray[_getAnnotationsByType__T]: ...
    _getDeclaredAnnotation__T = typing.TypeVar('_getDeclaredAnnotation__T')  # <T>
    def getDeclaredAnnotation(self, annotationClass: typing.Type[_getDeclaredAnnotation__T], /) -> _getDeclaredAnnotation__T | None: ...
    def getDeclaredAnnotations(self) -> java.chaquopy.JavaArray[java.lang.annotation.Annotation]: ...
    _getDeclaredAnnotationsByType__T = typing.TypeVar('_getDeclaredAnnotationsByType__T')  # <T>
    def getDeclaredAnnotationsByType(self, annotationClass: typing.Type[_getDeclaredAnnotationsByType__T], /) -> java.chaquopy.JavaArray[_getDeclaredAnnotationsByType__T]: ...
    def isAccessible(self) -> bool: ...
    def isAnnotationPresent(self, annotationClass: typing.Type[java.lang.annotation.Annotation], /) -> bool: ...
    @typing.overload
    def setAccessible(self, flag: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    @staticmethod
    def setAccessible(array: java.chaquopy.JavaArray[AccessibleObject], flag: bool | java.jboolean | java.lang.Boolean, /) -> None: ...

class AnnotatedElement(java.lang.Object):
    _getAnnotation__T = typing.TypeVar('_getAnnotation__T')  # <T>
    def getAnnotation(self, arg1: typing.Type[_getAnnotation__T], /) -> _getAnnotation__T | None: ...
    def getAnnotations(self) -> java.chaquopy.JavaArray[java.lang.annotation.Annotation]: ...
    _getAnnotationsByType__T = typing.TypeVar('_getAnnotationsByType__T')  # <T>
    def getAnnotationsByType(self, annotationClass: typing.Type[_getAnnotationsByType__T], /) -> java.chaquopy.JavaArray[_getAnnotationsByType__T]: ...
    _getDeclaredAnnotation__T = typing.TypeVar('_getDeclaredAnnotation__T')  # <T>
    def getDeclaredAnnotation(self, annotationClass: typing.Type[_getDeclaredAnnotation__T], /) -> _getDeclaredAnnotation__T | None: ...
    def getDeclaredAnnotations(self) -> java.chaquopy.JavaArray[java.lang.annotation.Annotation]: ...
    _getDeclaredAnnotationsByType__T = typing.TypeVar('_getDeclaredAnnotationsByType__T')  # <T>
    def getDeclaredAnnotationsByType(self, annotationClass: typing.Type[_getDeclaredAnnotationsByType__T], /) -> java.chaquopy.JavaArray[_getDeclaredAnnotationsByType__T]: ...
    def isAnnotationPresent(self, annotationClass: typing.Type[java.lang.annotation.Annotation], /) -> bool: ...

class Array(java.lang.Object):
    @staticmethod
    def get(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, /) -> java.lang.Object: ...
    @staticmethod
    def getBoolean(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def getByte(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def getChar(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, /) -> str: ...
    @staticmethod
    def getDouble(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, /) -> float: ...
    @staticmethod
    def getFloat(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, /) -> float: ...
    @staticmethod
    def getInt(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def getLength(array: java.lang.Object | int | bool | float | str, /) -> int: ...
    @staticmethod
    def getLong(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def getShort(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def newInstance(componentType: typing.Type[java.lang.Object], length: int | java.jint | java.lang.Integer, /) -> java.lang.Object: ...
    @typing.overload
    @staticmethod
    def newInstance(componentType: typing.Type[java.lang.Object], /, *dimensions: java.chaquopy.JavaArrayJInt) -> java.lang.Object: ...
    @staticmethod
    def set(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, value: java.lang.Object | int | bool | float | str, /) -> None: ...
    @staticmethod
    def setBoolean(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, z: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @staticmethod
    def setByte(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, b: int | java.jbyte | java.lang.Byte, /) -> None: ...
    @staticmethod
    def setChar(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, c: str | java.jchar | java.lang.Character, /) -> None: ...
    @staticmethod
    def setDouble(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, d: float | java.jdouble | java.lang.Double, /) -> None: ...
    @staticmethod
    def setFloat(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, f: float | java.jfloat | java.lang.Float, /) -> None: ...
    @staticmethod
    def setInt(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, i: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def setLong(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, l: int | java.jlong | java.lang.Long, /) -> None: ...
    @staticmethod
    def setShort(array: java.lang.Object | int | bool | float | str, index: int | java.jint | java.lang.Integer, s: int | java.jshort | java.lang.Short, /) -> None: ...

_Constructor__T = typing.TypeVar('_Constructor__T')  # <T>
class Constructor(Executable, typing.Generic[_Constructor__T]):
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    _getAnnotation__T = typing.TypeVar('_getAnnotation__T')  # <T>
    def getAnnotation(self, annotationClass: typing.Type[_getAnnotation__T], /) -> _getAnnotation__T | None: ...
    def getDeclaredAnnotations(self) -> java.chaquopy.JavaArray[java.lang.annotation.Annotation]: ...
    def getDeclaringClass(self) -> typing.Type[_Constructor__T]: ...
    def getExceptionTypes(self) -> java.chaquopy.JavaArray[typing.Type[java.lang.Object]]: ...
    def getGenericExceptionTypes(self) -> java.chaquopy.JavaArray[Type]: ...
    def getGenericParameterTypes(self) -> java.chaquopy.JavaArray[Type]: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getParameterAnnotations(self) -> java.chaquopy.JavaArray[java.chaquopy.JavaArray[java.lang.annotation.Annotation]]: ...
    def getParameterCount(self) -> int: ...
    def getParameterTypes(self) -> java.chaquopy.JavaArray[typing.Type[java.lang.Object]]: ...
    def getTypeParameters(self) -> java.chaquopy.JavaArray[TypeVariable[Constructor[_Constructor__T]]]: ...
    def hashCode(self) -> int: ...
    def isSynthetic(self) -> bool: ...
    def isVarArgs(self) -> bool: ...
    def newInstance(self, *initargs: java.lang.Object) -> _Constructor__T: ...
    def toGenericString(self) -> str: ...
    def toString(self) -> str: ...

class Executable(AccessibleObject, Member, GenericDeclaration):
    _getAnnotation__T = typing.TypeVar('_getAnnotation__T')  # <T>
    def getAnnotation(self, annotationClass: typing.Type[_getAnnotation__T], /) -> _getAnnotation__T | None: ...
    _getAnnotationsByType__T = typing.TypeVar('_getAnnotationsByType__T')  # <T>
    def getAnnotationsByType(self, annotationClass: typing.Type[_getAnnotationsByType__T], /) -> java.chaquopy.JavaArray[_getAnnotationsByType__T]: ...
    def getDeclaredAnnotations(self) -> java.chaquopy.JavaArray[java.lang.annotation.Annotation]: ...
    def getDeclaringClass(self) -> typing.Type[java.lang.Object]: ...
    def getExceptionTypes(self) -> java.chaquopy.JavaArray[typing.Type[java.lang.Object]]: ...
    def getGenericExceptionTypes(self) -> java.chaquopy.JavaArray[Type]: ...
    def getGenericParameterTypes(self) -> java.chaquopy.JavaArray[Type]: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getParameterAnnotations(self) -> java.chaquopy.JavaArray[java.chaquopy.JavaArray[java.lang.annotation.Annotation]]: ...
    def getParameterCount(self) -> int: ...
    def getParameterTypes(self) -> java.chaquopy.JavaArray[typing.Type[java.lang.Object]]: ...
    def getParameters(self) -> java.chaquopy.JavaArray[Parameter]: ...
    def getTypeParameters(self) -> java.chaquopy.JavaArray[TypeVariable[java.lang.Object]]: ...
    def isAnnotationPresent(self, annotationType: typing.Type[java.lang.annotation.Annotation], /) -> bool: ...
    def isSynthetic(self) -> bool: ...
    def isVarArgs(self) -> bool: ...
    def toGenericString(self) -> str: ...

class Field(AccessibleObject, Member):
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def get(self, arg1: java.lang.Object | int | bool | float | str, /) -> java.lang.Object | None: ...
    _getAnnotation__T = typing.TypeVar('_getAnnotation__T')  # <T>
    def getAnnotation(self, annotationClass: typing.Type[_getAnnotation__T], /) -> _getAnnotation__T | None: ...
    _getAnnotationsByType__T = typing.TypeVar('_getAnnotationsByType__T')  # <T>
    def getAnnotationsByType(self, annotationClass: typing.Type[_getAnnotationsByType__T], /) -> java.chaquopy.JavaArray[_getAnnotationsByType__T]: ...
    def getBoolean(self, arg1: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getByte(self, arg1: java.lang.Object | int | bool | float | str, /) -> int: ...
    def getChar(self, arg1: java.lang.Object | int | bool | float | str, /) -> str: ...
    def getDeclaredAnnotations(self) -> java.chaquopy.JavaArray[java.lang.annotation.Annotation]: ...
    def getDeclaringClass(self) -> typing.Type[java.lang.Object]: ...
    def getDouble(self, arg1: java.lang.Object | int | bool | float | str, /) -> float: ...
    def getFloat(self, arg1: java.lang.Object | int | bool | float | str, /) -> float: ...
    def getGenericType(self) -> Type: ...
    def getInt(self, arg1: java.lang.Object | int | bool | float | str, /) -> int: ...
    def getLong(self, arg1: java.lang.Object | int | bool | float | str, /) -> int: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getShort(self, arg1: java.lang.Object | int | bool | float | str, /) -> int: ...
    def getType(self) -> typing.Type[java.lang.Object]: ...
    def hashCode(self) -> int: ...
    def isAnnotationPresent(self, annotationType: typing.Type[java.lang.annotation.Annotation], /) -> bool: ...
    def isEnumConstant(self) -> bool: ...
    def isSynthetic(self) -> bool: ...
    def set(self, arg1: java.lang.Object | int | bool | float | str, arg2: java.lang.Object | int | bool | float | str, /) -> None: ...
    def setBoolean(self, arg1: java.lang.Object | int | bool | float | str, arg2: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setByte(self, arg1: java.lang.Object | int | bool | float | str, arg2: int | java.jbyte | java.lang.Byte, /) -> None: ...
    def setChar(self, arg1: java.lang.Object | int | bool | float | str, arg2: str | java.jchar | java.lang.Character, /) -> None: ...
    def setDouble(self, arg1: java.lang.Object | int | bool | float | str, arg2: float | java.jdouble | java.lang.Double, /) -> None: ...
    def setFloat(self, arg1: java.lang.Object | int | bool | float | str, arg2: float | java.jfloat | java.lang.Float, /) -> None: ...
    def setInt(self, arg1: java.lang.Object | int | bool | float | str, arg2: int | java.jint | java.lang.Integer, /) -> None: ...
    def setLong(self, arg1: java.lang.Object | int | bool | float | str, arg2: int | java.jlong | java.lang.Long, /) -> None: ...
    def setShort(self, arg1: java.lang.Object | int | bool | float | str, arg2: int | java.jshort | java.lang.Short, /) -> None: ...
    def toGenericString(self) -> str: ...
    def toString(self) -> str: ...

class GenericArrayType(Type):
    def getGenericComponentType(self) -> Type: ...

class GenericDeclaration(AnnotatedElement):
    def getTypeParameters(self) -> java.chaquopy.JavaArray[TypeVariable[java.lang.Object]]: ...

class GenericSignatureFormatError(java.lang.ClassFormatError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...

class InvocationHandler(java.lang.Object):
    def invoke(self, arg1: java.lang.Object | int | bool | float | str, arg2: Method, arg3: java.chaquopy.JavaArray[java.lang.Object], /) -> java.lang.Object: ...

class InvocationTargetException(java.lang.ReflectiveOperationException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, target: java.lang.Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, target: java.lang.Throwable, s: str | java.lang.String, /) -> None: ...
    def getCause(self) -> java.lang.Throwable: ...
    def getTargetException(self) -> java.lang.Throwable: ...

class MalformedParameterizedTypeException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...

class MalformedParametersException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, reason: str | java.lang.String, /) -> None: ...

class Member(java.lang.Object):
    DECLARED: typing.ClassVar[int] = ...
    PUBLIC: typing.ClassVar[int] = ...
    def getDeclaringClass(self) -> typing.Type[java.lang.Object]: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def isSynthetic(self) -> bool: ...

class Method(Executable):
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    _getAnnotation__T = typing.TypeVar('_getAnnotation__T')  # <T>
    def getAnnotation(self, annotationClass: typing.Type[_getAnnotation__T], /) -> _getAnnotation__T | None: ...
    def getDeclaredAnnotations(self) -> java.chaquopy.JavaArray[java.lang.annotation.Annotation]: ...
    def getDeclaringClass(self) -> typing.Type[java.lang.Object]: ...
    def getDefaultValue(self) -> java.lang.Object | None: ...
    def getExceptionTypes(self) -> java.chaquopy.JavaArray[typing.Type[java.lang.Object]]: ...
    def getGenericExceptionTypes(self) -> java.chaquopy.JavaArray[Type]: ...
    def getGenericParameterTypes(self) -> java.chaquopy.JavaArray[Type]: ...
    def getGenericReturnType(self) -> Type: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getParameterAnnotations(self) -> java.chaquopy.JavaArray[java.chaquopy.JavaArray[java.lang.annotation.Annotation]]: ...
    def getParameterCount(self) -> int: ...
    def getParameterTypes(self) -> java.chaquopy.JavaArray[typing.Type[java.lang.Object]]: ...
    def getReturnType(self) -> typing.Type[java.lang.Object]: ...
    def getTypeParameters(self) -> java.chaquopy.JavaArray[TypeVariable[Method]]: ...
    def hashCode(self) -> int: ...
    def invoke(self, arg1: java.lang.Object | int | bool | float | str, /, *arg2: java.lang.Object) -> java.lang.Object | None: ...
    def isBridge(self) -> bool: ...
    def isDefault(self) -> bool: ...
    def isSynthetic(self) -> bool: ...
    def isVarArgs(self) -> bool: ...
    def toGenericString(self) -> str: ...
    def toString(self) -> str: ...

class Modifier(java.lang.Object):
    ABSTRACT: typing.ClassVar[int] = ...
    FINAL: typing.ClassVar[int] = ...
    INTERFACE: typing.ClassVar[int] = ...
    NATIVE: typing.ClassVar[int] = ...
    PRIVATE: typing.ClassVar[int] = ...
    PROTECTED: typing.ClassVar[int] = ...
    PUBLIC: typing.ClassVar[int] = ...
    STATIC: typing.ClassVar[int] = ...
    STRICT: typing.ClassVar[int] = ...
    SYNCHRONIZED: typing.ClassVar[int] = ...
    TRANSIENT: typing.ClassVar[int] = ...
    VOLATILE: typing.ClassVar[int] = ...
    def __init__(self) -> None: ...
    @staticmethod
    def classModifiers() -> int: ...
    @staticmethod
    def constructorModifiers() -> int: ...
    @staticmethod
    def fieldModifiers() -> int: ...
    @staticmethod
    def interfaceModifiers() -> int: ...
    @staticmethod
    def isAbstract(mod: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def isFinal(mod: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def isInterface(mod: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def isNative(mod: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def isPrivate(mod: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def isProtected(mod: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def isPublic(mod: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def isStatic(mod: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def isStrict(mod: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def isSynchronized(mod: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def isTransient(mod: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def isVolatile(mod: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def methodModifiers() -> int: ...
    @staticmethod
    def parameterModifiers() -> int: ...
    @staticmethod
    def toString(mod: int | java.jint | java.lang.Integer, /) -> str: ...

class Parameter(AnnotatedElement):
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    _getAnnotation__T = typing.TypeVar('_getAnnotation__T')  # <T>
    def getAnnotation(self, annotationClass: typing.Type[_getAnnotation__T], /) -> _getAnnotation__T | None: ...
    def getAnnotations(self) -> java.chaquopy.JavaArray[java.lang.annotation.Annotation]: ...
    _getAnnotationsByType__T = typing.TypeVar('_getAnnotationsByType__T')  # <T>
    def getAnnotationsByType(self, annotationClass: typing.Type[_getAnnotationsByType__T], /) -> java.chaquopy.JavaArray[_getAnnotationsByType__T]: ...
    _getDeclaredAnnotation__T = typing.TypeVar('_getDeclaredAnnotation__T')  # <T>
    def getDeclaredAnnotation(self, annotationClass: typing.Type[_getDeclaredAnnotation__T], /) -> _getDeclaredAnnotation__T | None: ...
    def getDeclaredAnnotations(self) -> java.chaquopy.JavaArray[java.lang.annotation.Annotation]: ...
    _getDeclaredAnnotationsByType__T = typing.TypeVar('_getDeclaredAnnotationsByType__T')  # <T>
    def getDeclaredAnnotationsByType(self, annotationClass: typing.Type[_getDeclaredAnnotationsByType__T], /) -> java.chaquopy.JavaArray[_getDeclaredAnnotationsByType__T]: ...
    def getDeclaringExecutable(self) -> Executable: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getParameterizedType(self) -> Type: ...
    def getType(self) -> typing.Type[java.lang.Object]: ...
    def hashCode(self) -> int: ...
    def isImplicit(self) -> bool: ...
    def isNamePresent(self) -> bool: ...
    def isSynthetic(self) -> bool: ...
    def isVarArgs(self) -> bool: ...
    def toString(self) -> str: ...

class ParameterizedType(Type):
    def getActualTypeArguments(self) -> java.chaquopy.JavaArray[Type]: ...
    def getOwnerType(self) -> Type: ...
    def getRawType(self) -> Type: ...

class Proxy(java.io.Serializable):
    h: InvocationHandler = ...
    def __init__(self, h: InvocationHandler, /) -> None: ...
    @staticmethod
    def getInvocationHandler(proxy: java.lang.Object | int | bool | float | str, /) -> InvocationHandler: ...
    @staticmethod
    def getProxyClass(loader: java.lang.ClassLoader, /, *interfaces: typing.Type[java.lang.Object]) -> typing.Type[java.lang.Object]: ...
    @staticmethod
    def isProxyClass(cl: typing.Type[java.lang.Object], /) -> bool: ...
    @staticmethod
    def newProxyInstance(loader: java.lang.ClassLoader, interfaces: java.chaquopy.JavaArray[typing.Type[java.lang.Object]], h: InvocationHandler, /) -> java.lang.Object: ...

class RecordComponent(AnnotatedElement):
    def getAccessor(self) -> Method: ...
    _getAnnotation__T = typing.TypeVar('_getAnnotation__T')  # <T>
    def getAnnotation(self, annotationClass: typing.Type[_getAnnotation__T], /) -> _getAnnotation__T: ...
    def getAnnotations(self) -> java.chaquopy.JavaArray[java.lang.annotation.Annotation]: ...
    def getDeclaredAnnotations(self) -> java.chaquopy.JavaArray[java.lang.annotation.Annotation]: ...
    def getDeclaringRecord(self) -> typing.Type[java.lang.Object]: ...
    def getGenericSignature(self) -> str: ...
    def getGenericType(self) -> Type: ...
    def getName(self) -> str: ...
    def getType(self) -> typing.Type[java.lang.Object]: ...
    def toString(self) -> str: ...

class ReflectPermission(java.security.BasicPermission):
    @typing.overload
    def __init__(self, name: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, name: str | java.lang.String, actions: str | java.lang.String, /) -> None: ...

class Type(java.lang.Object):
    def getTypeName(self) -> str: ...

_TypeVariable__D = typing.TypeVar('_TypeVariable__D')  # <D>
class TypeVariable(Type, typing.Generic[_TypeVariable__D]):
    def getBounds(self) -> java.chaquopy.JavaArray[Type]: ...
    def getGenericDeclaration(self) -> _TypeVariable__D: ...
    def getName(self) -> str: ...

class UndeclaredThrowableException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self, undeclaredThrowable: java.lang.Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, undeclaredThrowable: java.lang.Throwable, s: str | java.lang.String, /) -> None: ...
    def getCause(self) -> java.lang.Throwable: ...
    def getUndeclaredThrowable(self) -> java.lang.Throwable: ...

class WildcardType(Type):
    def getLowerBounds(self) -> java.chaquopy.JavaArray[Type]: ...
    def getUpperBounds(self) -> java.chaquopy.JavaArray[Type]: ...
