import builtins
import java
import java.chaquopy
import java.io
import java.lang.annotation
import java.lang.invoke
import java.lang.reflect
import java.net
import java.nio
import java.nio.channels
import java.nio.charset
import java.security
import java.util
import java.util.concurrent
import java.util.function
import java.util.stream
import typing



class AbstractMethodError(IncompatibleClassChangeError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class Appendable(Object):
    @typing.overload
    def append(self, arg1: str | java.jchar | Character, /) -> Appendable: ...
    @typing.overload
    def append(self, arg1: CharSequence, /) -> Appendable: ...
    @typing.overload
    def append(self, arg1: CharSequence, arg2: int | java.jint | Integer, arg3: int | java.jint | Integer, /) -> Appendable: ...

class ArithmeticException(RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class ArrayIndexOutOfBoundsException(IndexOutOfBoundsException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, index: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class ArrayStoreException(RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class AssertionError(Error):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, detailMessage: str | java.jchar | Character, /) -> None: ...
    @typing.overload
    def __init__(self, detailMessage: float | java.jdouble | Double, /) -> None: ...
    @typing.overload
    def __init__(self, detailMessage: float | java.jfloat | Float, /) -> None: ...
    @typing.overload
    def __init__(self, detailMessage: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def __init__(self, detailMessage: int | java.jlong | Long, /) -> None: ...
    @typing.overload
    def __init__(self, detailMessage: Object | int | bool | float | str, /) -> None: ...
    @typing.overload
    def __init__(self, detailMessage: bool | java.jboolean | Boolean, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, cause: Throwable, /) -> None: ...

class AutoCloseable(Object):
    def close(self) -> None: ...

class Boolean(java.io.Serializable, Comparable[Boolean]):
    FALSE: typing.ClassVar[bool] = ...
    TRUE: typing.ClassVar[bool] = ...
    TYPE: typing.ClassVar[typing.Type[Boolean]] = ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, value: bool | java.jboolean | Boolean, /) -> None: ...
    def booleanValue(self) -> bool: ...
    @staticmethod
    def compare(x: bool | java.jboolean | Boolean, y: bool | java.jboolean | Boolean, /) -> int: ...
    def compareTo(self, b: bool | java.jboolean | Boolean, /) -> int: ...
    def equals(self, obj: Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def getBoolean(name: str | String, /) -> bool: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(value: bool | java.jboolean | Boolean, /) -> int: ...
    @staticmethod
    def logicalAnd(a: bool | java.jboolean | Boolean, b: bool | java.jboolean | Boolean, /) -> bool: ...
    @staticmethod
    def logicalOr(a: bool | java.jboolean | Boolean, b: bool | java.jboolean | Boolean, /) -> bool: ...
    @staticmethod
    def logicalXor(a: bool | java.jboolean | Boolean, b: bool | java.jboolean | Boolean, /) -> bool: ...
    @staticmethod
    def parseBoolean(s: str | String, /) -> bool: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def toString(b: bool | java.jboolean | Boolean, /) -> str: ...
    @typing.overload
    @staticmethod
    def valueOf(s: str | String, /) -> bool: ...
    @typing.overload
    @staticmethod
    def valueOf(b: bool | java.jboolean | Boolean, /) -> bool: ...

class BootstrapMethodError(LinkageError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, cause: Throwable, /) -> None: ...

class Byte(Number, Comparable[Byte]):
    BYTES: typing.ClassVar[int] = ...
    MAX_VALUE: typing.ClassVar[int] = ...
    MIN_VALUE: typing.ClassVar[int] = ...
    SIZE: typing.ClassVar[int] = ...
    TYPE: typing.ClassVar[typing.Type[Byte]] = ...
    @typing.overload
    def __init__(self, value: int | java.jbyte | Byte, /) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...
    def byteValue(self) -> int: ...
    @staticmethod
    def compare(x: int | java.jbyte | Byte, y: int | java.jbyte | Byte, /) -> int: ...
    def compareTo(self, anotherByte: int | java.jbyte | Byte, /) -> int: ...
    @staticmethod
    def compareUnsigned(x: int | java.jbyte | Byte, y: int | java.jbyte | Byte, /) -> int: ...
    @staticmethod
    def decode(nm: str | String, /) -> int: ...
    def doubleValue(self) -> float: ...
    def equals(self, obj: Object | int | bool | float | str, /) -> bool: ...
    def floatValue(self) -> float: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(value: int | java.jbyte | Byte, /) -> int: ...
    def intValue(self) -> int: ...
    def longValue(self) -> int: ...
    @typing.overload
    @staticmethod
    def parseByte(s: str | String, /) -> int: ...
    @typing.overload
    @staticmethod
    def parseByte(s: str | String, radix: int | java.jint | Integer, /) -> int: ...
    def shortValue(self) -> int: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def toString(b: int | java.jbyte | Byte, /) -> str: ...
    @staticmethod
    def toUnsignedInt(x: int | java.jbyte | Byte, /) -> int: ...
    @staticmethod
    def toUnsignedLong(x: int | java.jbyte | Byte, /) -> int: ...
    @typing.overload
    @staticmethod
    def valueOf(b: int | java.jbyte | Byte, /) -> int: ...
    @typing.overload
    @staticmethod
    def valueOf(s: str | String, /) -> int: ...
    @typing.overload
    @staticmethod
    def valueOf(s: str | String, radix: int | java.jint | Integer, /) -> int: ...

class CharSequence(Object):
    def charAt(self, arg1: int | java.jint | Integer, /) -> str: ...
    def chars(self) -> java.util.stream.IntStream: ...
    def codePoints(self) -> java.util.stream.IntStream: ...
    @staticmethod
    def compare(cs1: CharSequence, cs2: CharSequence, /) -> int: ...
    def isEmpty(self) -> bool: ...
    def length(self) -> int: ...
    def subSequence(self, arg1: int | java.jint | Integer, arg2: int | java.jint | Integer, /) -> CharSequence: ...
    def toString(self) -> str: ...

class Character(java.io.Serializable, Comparable[Character]):
    BYTES: typing.ClassVar[int] = ...
    COMBINING_SPACING_MARK: typing.ClassVar[int] = ...
    CONNECTOR_PUNCTUATION: typing.ClassVar[int] = ...
    CONTROL: typing.ClassVar[int] = ...
    CURRENCY_SYMBOL: typing.ClassVar[int] = ...
    DASH_PUNCTUATION: typing.ClassVar[int] = ...
    DECIMAL_DIGIT_NUMBER: typing.ClassVar[int] = ...
    DIRECTIONALITY_ARABIC_NUMBER: typing.ClassVar[int] = ...
    DIRECTIONALITY_BOUNDARY_NEUTRAL: typing.ClassVar[int] = ...
    DIRECTIONALITY_COMMON_NUMBER_SEPARATOR: typing.ClassVar[int] = ...
    DIRECTIONALITY_EUROPEAN_NUMBER: typing.ClassVar[int] = ...
    DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR: typing.ClassVar[int] = ...
    DIRECTIONALITY_EUROPEAN_NUMBER_TERMINATOR: typing.ClassVar[int] = ...
    DIRECTIONALITY_FIRST_STRONG_ISOLATE: typing.ClassVar[int] = ...
    DIRECTIONALITY_LEFT_TO_RIGHT: typing.ClassVar[int] = ...
    DIRECTIONALITY_LEFT_TO_RIGHT_EMBEDDING: typing.ClassVar[int] = ...
    DIRECTIONALITY_LEFT_TO_RIGHT_ISOLATE: typing.ClassVar[int] = ...
    DIRECTIONALITY_LEFT_TO_RIGHT_OVERRIDE: typing.ClassVar[int] = ...
    DIRECTIONALITY_NONSPACING_MARK: typing.ClassVar[int] = ...
    DIRECTIONALITY_OTHER_NEUTRALS: typing.ClassVar[int] = ...
    DIRECTIONALITY_PARAGRAPH_SEPARATOR: typing.ClassVar[int] = ...
    DIRECTIONALITY_POP_DIRECTIONAL_FORMAT: typing.ClassVar[int] = ...
    DIRECTIONALITY_POP_DIRECTIONAL_ISOLATE: typing.ClassVar[int] = ...
    DIRECTIONALITY_RIGHT_TO_LEFT: typing.ClassVar[int] = ...
    DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC: typing.ClassVar[int] = ...
    DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING: typing.ClassVar[int] = ...
    DIRECTIONALITY_RIGHT_TO_LEFT_ISOLATE: typing.ClassVar[int] = ...
    DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE: typing.ClassVar[int] = ...
    DIRECTIONALITY_SEGMENT_SEPARATOR: typing.ClassVar[int] = ...
    DIRECTIONALITY_UNDEFINED: typing.ClassVar[int] = ...
    DIRECTIONALITY_WHITESPACE: typing.ClassVar[int] = ...
    ENCLOSING_MARK: typing.ClassVar[int] = ...
    END_PUNCTUATION: typing.ClassVar[int] = ...
    FINAL_QUOTE_PUNCTUATION: typing.ClassVar[int] = ...
    FORMAT: typing.ClassVar[int] = ...
    INITIAL_QUOTE_PUNCTUATION: typing.ClassVar[int] = ...
    LETTER_NUMBER: typing.ClassVar[int] = ...
    LINE_SEPARATOR: typing.ClassVar[int] = ...
    LOWERCASE_LETTER: typing.ClassVar[int] = ...
    MATH_SYMBOL: typing.ClassVar[int] = ...
    MAX_CODE_POINT: typing.ClassVar[int] = ...
    MAX_HIGH_SURROGATE: typing.ClassVar[str] = ...
    MAX_LOW_SURROGATE: typing.ClassVar[str] = ...
    MAX_RADIX: typing.ClassVar[int] = ...
    MAX_SURROGATE: typing.ClassVar[str] = ...
    MAX_VALUE: typing.ClassVar[str] = ...
    MIN_CODE_POINT: typing.ClassVar[int] = ...
    MIN_HIGH_SURROGATE: typing.ClassVar[str] = ...
    MIN_LOW_SURROGATE: typing.ClassVar[str] = ...
    MIN_RADIX: typing.ClassVar[int] = ...
    MIN_SUPPLEMENTARY_CODE_POINT: typing.ClassVar[int] = ...
    MIN_SURROGATE: typing.ClassVar[str] = ...
    MIN_VALUE: typing.ClassVar[str] = ...
    MODIFIER_LETTER: typing.ClassVar[int] = ...
    MODIFIER_SYMBOL: typing.ClassVar[int] = ...
    NON_SPACING_MARK: typing.ClassVar[int] = ...
    OTHER_LETTER: typing.ClassVar[int] = ...
    OTHER_NUMBER: typing.ClassVar[int] = ...
    OTHER_PUNCTUATION: typing.ClassVar[int] = ...
    OTHER_SYMBOL: typing.ClassVar[int] = ...
    PARAGRAPH_SEPARATOR: typing.ClassVar[int] = ...
    PRIVATE_USE: typing.ClassVar[int] = ...
    SIZE: typing.ClassVar[int] = ...
    SPACE_SEPARATOR: typing.ClassVar[int] = ...
    START_PUNCTUATION: typing.ClassVar[int] = ...
    SURROGATE: typing.ClassVar[int] = ...
    TITLECASE_LETTER: typing.ClassVar[int] = ...
    TYPE: typing.ClassVar[typing.Type[Character]] = ...
    UNASSIGNED: typing.ClassVar[int] = ...
    UPPERCASE_LETTER: typing.ClassVar[int] = ...
    def __init__(self, value: str | java.jchar | Character, /) -> None: ...
    @staticmethod
    def charCount(codePoint: int | java.jint | Integer, /) -> int: ...
    def charValue(self) -> str: ...
    @typing.overload
    @staticmethod
    def codePointAt(seq: CharSequence, index: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def codePointAt(a: java.chaquopy.JavaArrayJChar, index: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def codePointAt(a: java.chaquopy.JavaArrayJChar, index: int | java.jint | Integer, limit: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def codePointBefore(seq: CharSequence, index: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def codePointBefore(a: java.chaquopy.JavaArrayJChar, index: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def codePointBefore(a: java.chaquopy.JavaArrayJChar, index: int | java.jint | Integer, start: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def codePointCount(seq: CharSequence, beginIndex: int | java.jint | Integer, endIndex: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def codePointCount(a: java.chaquopy.JavaArrayJChar, offset: int | java.jint | Integer, count: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def codePointOf(name: str | String, /) -> int: ...
    @staticmethod
    def compare(x: str | java.jchar | Character, y: str | java.jchar | Character, /) -> int: ...
    def compareTo(self, anotherCharacter: str | java.jchar | Character, /) -> int: ...
    @typing.overload
    @staticmethod
    def digit(ch: str | java.jchar | Character, radix: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def digit(codePoint: int | java.jint | Integer, radix: int | java.jint | Integer, /) -> int: ...
    def equals(self, obj: Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def forDigit(digit: int | java.jint | Integer, radix: int | java.jint | Integer, /) -> str: ...
    @typing.overload
    @staticmethod
    def getDirectionality(ch: str | java.jchar | Character, /) -> int: ...
    @typing.overload
    @staticmethod
    def getDirectionality(codePoint: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def getName(codePoint: int | java.jint | Integer, /) -> str: ...
    @typing.overload
    @staticmethod
    def getNumericValue(ch: str | java.jchar | Character, /) -> int: ...
    @typing.overload
    @staticmethod
    def getNumericValue(codePoint: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def getType(ch: str | java.jchar | Character, /) -> int: ...
    @typing.overload
    @staticmethod
    def getType(codePoint: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(value: str | java.jchar | Character, /) -> int: ...
    @staticmethod
    def highSurrogate(codePoint: int | java.jint | Integer, /) -> str: ...
    @staticmethod
    def isAlphabetic(codePoint: int | java.jint | Integer, /) -> bool: ...
    @staticmethod
    def isBmpCodePoint(codePoint: int | java.jint | Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isDefined(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isDefined(codePoint: int | java.jint | Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isDigit(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isDigit(codePoint: int | java.jint | Integer, /) -> bool: ...
    @staticmethod
    def isHighSurrogate(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isISOControl(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isISOControl(codePoint: int | java.jint | Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isIdentifierIgnorable(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isIdentifierIgnorable(codePoint: int | java.jint | Integer, /) -> bool: ...
    @staticmethod
    def isIdeographic(codePoint: int | java.jint | Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isJavaIdentifierPart(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isJavaIdentifierPart(codePoint: int | java.jint | Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isJavaIdentifierStart(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isJavaIdentifierStart(codePoint: int | java.jint | Integer, /) -> bool: ...
    @staticmethod
    def isJavaLetter(ch: str | java.jchar | Character, /) -> bool: ...
    @staticmethod
    def isJavaLetterOrDigit(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isLetter(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isLetter(codePoint: int | java.jint | Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isLetterOrDigit(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isLetterOrDigit(codePoint: int | java.jint | Integer, /) -> bool: ...
    @staticmethod
    def isLowSurrogate(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isLowerCase(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isLowerCase(codePoint: int | java.jint | Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isMirrored(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isMirrored(codePoint: int | java.jint | Integer, /) -> bool: ...
    @staticmethod
    def isSpace(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isSpaceChar(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isSpaceChar(codePoint: int | java.jint | Integer, /) -> bool: ...
    @staticmethod
    def isSupplementaryCodePoint(codePoint: int | java.jint | Integer, /) -> bool: ...
    @staticmethod
    def isSurrogate(ch: str | java.jchar | Character, /) -> bool: ...
    @staticmethod
    def isSurrogatePair(high: str | java.jchar | Character, low: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isTitleCase(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isTitleCase(codePoint: int | java.jint | Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isUnicodeIdentifierPart(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isUnicodeIdentifierPart(codePoint: int | java.jint | Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isUnicodeIdentifierStart(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isUnicodeIdentifierStart(codePoint: int | java.jint | Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isUpperCase(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isUpperCase(codePoint: int | java.jint | Integer, /) -> bool: ...
    @staticmethod
    def isValidCodePoint(codePoint: int | java.jint | Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isWhitespace(ch: str | java.jchar | Character, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isWhitespace(codePoint: int | java.jint | Integer, /) -> bool: ...
    @staticmethod
    def lowSurrogate(codePoint: int | java.jint | Integer, /) -> str: ...
    @typing.overload
    @staticmethod
    def offsetByCodePoints(seq: CharSequence, index: int | java.jint | Integer, codePointOffset: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def offsetByCodePoints(a: java.chaquopy.JavaArrayJChar, start: int | java.jint | Integer, count: int | java.jint | Integer, index: int | java.jint | Integer, codePointOffset: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def reverseBytes(ch: str | java.jchar | Character, /) -> str: ...
    @typing.overload
    @staticmethod
    def toChars(codePoint: int | java.jint | Integer, /) -> java.chaquopy.JavaArrayJChar: ...
    @typing.overload
    @staticmethod
    def toChars(codePoint: int | java.jint | Integer, dst: java.chaquopy.JavaArrayJChar, dstIndex: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def toCodePoint(high: str | java.jchar | Character, low: str | java.jchar | Character, /) -> int: ...
    @typing.overload
    @staticmethod
    def toLowerCase(ch: str | java.jchar | Character, /) -> str: ...
    @typing.overload
    @staticmethod
    def toLowerCase(codePoint: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def toString(c: str | java.jchar | Character, /) -> str: ...
    @typing.overload
    @staticmethod
    def toString(codePoint: int | java.jint | Integer, /) -> str: ...
    @typing.overload
    @staticmethod
    def toTitleCase(ch: str | java.jchar | Character, /) -> str: ...
    @typing.overload
    @staticmethod
    def toTitleCase(codePoint: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def toUpperCase(ch: str | java.jchar | Character, /) -> str: ...
    @typing.overload
    @staticmethod
    def toUpperCase(codePoint: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def valueOf(c: str | java.jchar | Character, /) -> str: ...

    class UnicodeScript(Enum[Character.UnicodeScript]):
        COMMON: typing.ClassVar[Character.UnicodeScript] = ...
        LATIN: typing.ClassVar[Character.UnicodeScript] = ...
        GREEK: typing.ClassVar[Character.UnicodeScript] = ...
        CYRILLIC: typing.ClassVar[Character.UnicodeScript] = ...
        ARMENIAN: typing.ClassVar[Character.UnicodeScript] = ...
        HEBREW: typing.ClassVar[Character.UnicodeScript] = ...
        ARABIC: typing.ClassVar[Character.UnicodeScript] = ...
        SYRIAC: typing.ClassVar[Character.UnicodeScript] = ...
        THAANA: typing.ClassVar[Character.UnicodeScript] = ...
        DEVANAGARI: typing.ClassVar[Character.UnicodeScript] = ...
        BENGALI: typing.ClassVar[Character.UnicodeScript] = ...
        GURMUKHI: typing.ClassVar[Character.UnicodeScript] = ...
        GUJARATI: typing.ClassVar[Character.UnicodeScript] = ...
        ORIYA: typing.ClassVar[Character.UnicodeScript] = ...
        TAMIL: typing.ClassVar[Character.UnicodeScript] = ...
        TELUGU: typing.ClassVar[Character.UnicodeScript] = ...
        KANNADA: typing.ClassVar[Character.UnicodeScript] = ...
        MALAYALAM: typing.ClassVar[Character.UnicodeScript] = ...
        SINHALA: typing.ClassVar[Character.UnicodeScript] = ...
        THAI: typing.ClassVar[Character.UnicodeScript] = ...
        LAO: typing.ClassVar[Character.UnicodeScript] = ...
        TIBETAN: typing.ClassVar[Character.UnicodeScript] = ...
        MYANMAR: typing.ClassVar[Character.UnicodeScript] = ...
        GEORGIAN: typing.ClassVar[Character.UnicodeScript] = ...
        HANGUL: typing.ClassVar[Character.UnicodeScript] = ...
        ETHIOPIC: typing.ClassVar[Character.UnicodeScript] = ...
        CHEROKEE: typing.ClassVar[Character.UnicodeScript] = ...
        CANADIAN_ABORIGINAL: typing.ClassVar[Character.UnicodeScript] = ...
        OGHAM: typing.ClassVar[Character.UnicodeScript] = ...
        RUNIC: typing.ClassVar[Character.UnicodeScript] = ...
        KHMER: typing.ClassVar[Character.UnicodeScript] = ...
        MONGOLIAN: typing.ClassVar[Character.UnicodeScript] = ...
        HIRAGANA: typing.ClassVar[Character.UnicodeScript] = ...
        KATAKANA: typing.ClassVar[Character.UnicodeScript] = ...
        BOPOMOFO: typing.ClassVar[Character.UnicodeScript] = ...
        HAN: typing.ClassVar[Character.UnicodeScript] = ...
        YI: typing.ClassVar[Character.UnicodeScript] = ...
        OLD_ITALIC: typing.ClassVar[Character.UnicodeScript] = ...
        GOTHIC: typing.ClassVar[Character.UnicodeScript] = ...
        DESERET: typing.ClassVar[Character.UnicodeScript] = ...
        INHERITED: typing.ClassVar[Character.UnicodeScript] = ...
        TAGALOG: typing.ClassVar[Character.UnicodeScript] = ...
        HANUNOO: typing.ClassVar[Character.UnicodeScript] = ...
        BUHID: typing.ClassVar[Character.UnicodeScript] = ...
        TAGBANWA: typing.ClassVar[Character.UnicodeScript] = ...
        LIMBU: typing.ClassVar[Character.UnicodeScript] = ...
        TAI_LE: typing.ClassVar[Character.UnicodeScript] = ...
        LINEAR_B: typing.ClassVar[Character.UnicodeScript] = ...
        UGARITIC: typing.ClassVar[Character.UnicodeScript] = ...
        SHAVIAN: typing.ClassVar[Character.UnicodeScript] = ...
        OSMANYA: typing.ClassVar[Character.UnicodeScript] = ...
        CYPRIOT: typing.ClassVar[Character.UnicodeScript] = ...
        BRAILLE: typing.ClassVar[Character.UnicodeScript] = ...
        BUGINESE: typing.ClassVar[Character.UnicodeScript] = ...
        COPTIC: typing.ClassVar[Character.UnicodeScript] = ...
        NEW_TAI_LUE: typing.ClassVar[Character.UnicodeScript] = ...
        GLAGOLITIC: typing.ClassVar[Character.UnicodeScript] = ...
        TIFINAGH: typing.ClassVar[Character.UnicodeScript] = ...
        SYLOTI_NAGRI: typing.ClassVar[Character.UnicodeScript] = ...
        OLD_PERSIAN: typing.ClassVar[Character.UnicodeScript] = ...
        KHAROSHTHI: typing.ClassVar[Character.UnicodeScript] = ...
        BALINESE: typing.ClassVar[Character.UnicodeScript] = ...
        CUNEIFORM: typing.ClassVar[Character.UnicodeScript] = ...
        PHOENICIAN: typing.ClassVar[Character.UnicodeScript] = ...
        PHAGS_PA: typing.ClassVar[Character.UnicodeScript] = ...
        NKO: typing.ClassVar[Character.UnicodeScript] = ...
        SUNDANESE: typing.ClassVar[Character.UnicodeScript] = ...
        BATAK: typing.ClassVar[Character.UnicodeScript] = ...
        LEPCHA: typing.ClassVar[Character.UnicodeScript] = ...
        OL_CHIKI: typing.ClassVar[Character.UnicodeScript] = ...
        VAI: typing.ClassVar[Character.UnicodeScript] = ...
        SAURASHTRA: typing.ClassVar[Character.UnicodeScript] = ...
        KAYAH_LI: typing.ClassVar[Character.UnicodeScript] = ...
        REJANG: typing.ClassVar[Character.UnicodeScript] = ...
        LYCIAN: typing.ClassVar[Character.UnicodeScript] = ...
        CARIAN: typing.ClassVar[Character.UnicodeScript] = ...
        LYDIAN: typing.ClassVar[Character.UnicodeScript] = ...
        CHAM: typing.ClassVar[Character.UnicodeScript] = ...
        TAI_THAM: typing.ClassVar[Character.UnicodeScript] = ...
        TAI_VIET: typing.ClassVar[Character.UnicodeScript] = ...
        AVESTAN: typing.ClassVar[Character.UnicodeScript] = ...
        EGYPTIAN_HIEROGLYPHS: typing.ClassVar[Character.UnicodeScript] = ...
        SAMARITAN: typing.ClassVar[Character.UnicodeScript] = ...
        MANDAIC: typing.ClassVar[Character.UnicodeScript] = ...
        LISU: typing.ClassVar[Character.UnicodeScript] = ...
        BAMUM: typing.ClassVar[Character.UnicodeScript] = ...
        JAVANESE: typing.ClassVar[Character.UnicodeScript] = ...
        MEETEI_MAYEK: typing.ClassVar[Character.UnicodeScript] = ...
        IMPERIAL_ARAMAIC: typing.ClassVar[Character.UnicodeScript] = ...
        OLD_SOUTH_ARABIAN: typing.ClassVar[Character.UnicodeScript] = ...
        INSCRIPTIONAL_PARTHIAN: typing.ClassVar[Character.UnicodeScript] = ...
        INSCRIPTIONAL_PAHLAVI: typing.ClassVar[Character.UnicodeScript] = ...
        OLD_TURKIC: typing.ClassVar[Character.UnicodeScript] = ...
        BRAHMI: typing.ClassVar[Character.UnicodeScript] = ...
        KAITHI: typing.ClassVar[Character.UnicodeScript] = ...
        MEROITIC_HIEROGLYPHS: typing.ClassVar[Character.UnicodeScript] = ...
        MEROITIC_CURSIVE: typing.ClassVar[Character.UnicodeScript] = ...
        SORA_SOMPENG: typing.ClassVar[Character.UnicodeScript] = ...
        CHAKMA: typing.ClassVar[Character.UnicodeScript] = ...
        SHARADA: typing.ClassVar[Character.UnicodeScript] = ...
        TAKRI: typing.ClassVar[Character.UnicodeScript] = ...
        MIAO: typing.ClassVar[Character.UnicodeScript] = ...
        CAUCASIAN_ALBANIAN: typing.ClassVar[Character.UnicodeScript] = ...
        BASSA_VAH: typing.ClassVar[Character.UnicodeScript] = ...
        DUPLOYAN: typing.ClassVar[Character.UnicodeScript] = ...
        ELBASAN: typing.ClassVar[Character.UnicodeScript] = ...
        GRANTHA: typing.ClassVar[Character.UnicodeScript] = ...
        PAHAWH_HMONG: typing.ClassVar[Character.UnicodeScript] = ...
        KHOJKI: typing.ClassVar[Character.UnicodeScript] = ...
        LINEAR_A: typing.ClassVar[Character.UnicodeScript] = ...
        MAHAJANI: typing.ClassVar[Character.UnicodeScript] = ...
        MANICHAEAN: typing.ClassVar[Character.UnicodeScript] = ...
        MENDE_KIKAKUI: typing.ClassVar[Character.UnicodeScript] = ...
        MODI: typing.ClassVar[Character.UnicodeScript] = ...
        MRO: typing.ClassVar[Character.UnicodeScript] = ...
        OLD_NORTH_ARABIAN: typing.ClassVar[Character.UnicodeScript] = ...
        NABATAEAN: typing.ClassVar[Character.UnicodeScript] = ...
        PALMYRENE: typing.ClassVar[Character.UnicodeScript] = ...
        PAU_CIN_HAU: typing.ClassVar[Character.UnicodeScript] = ...
        OLD_PERMIC: typing.ClassVar[Character.UnicodeScript] = ...
        PSALTER_PAHLAVI: typing.ClassVar[Character.UnicodeScript] = ...
        SIDDHAM: typing.ClassVar[Character.UnicodeScript] = ...
        KHUDAWADI: typing.ClassVar[Character.UnicodeScript] = ...
        TIRHUTA: typing.ClassVar[Character.UnicodeScript] = ...
        WARANG_CITI: typing.ClassVar[Character.UnicodeScript] = ...
        AHOM: typing.ClassVar[Character.UnicodeScript] = ...
        ANATOLIAN_HIEROGLYPHS: typing.ClassVar[Character.UnicodeScript] = ...
        HATRAN: typing.ClassVar[Character.UnicodeScript] = ...
        MULTANI: typing.ClassVar[Character.UnicodeScript] = ...
        OLD_HUNGARIAN: typing.ClassVar[Character.UnicodeScript] = ...
        SIGNWRITING: typing.ClassVar[Character.UnicodeScript] = ...
        ADLAM: typing.ClassVar[Character.UnicodeScript] = ...
        BHAIKSUKI: typing.ClassVar[Character.UnicodeScript] = ...
        MARCHEN: typing.ClassVar[Character.UnicodeScript] = ...
        NEWA: typing.ClassVar[Character.UnicodeScript] = ...
        OSAGE: typing.ClassVar[Character.UnicodeScript] = ...
        TANGUT: typing.ClassVar[Character.UnicodeScript] = ...
        MASARAM_GONDI: typing.ClassVar[Character.UnicodeScript] = ...
        NUSHU: typing.ClassVar[Character.UnicodeScript] = ...
        SOYOMBO: typing.ClassVar[Character.UnicodeScript] = ...
        ZANABAZAR_SQUARE: typing.ClassVar[Character.UnicodeScript] = ...
        HANIFI_ROHINGYA: typing.ClassVar[Character.UnicodeScript] = ...
        OLD_SOGDIAN: typing.ClassVar[Character.UnicodeScript] = ...
        SOGDIAN: typing.ClassVar[Character.UnicodeScript] = ...
        DOGRA: typing.ClassVar[Character.UnicodeScript] = ...
        GUNJALA_GONDI: typing.ClassVar[Character.UnicodeScript] = ...
        MAKASAR: typing.ClassVar[Character.UnicodeScript] = ...
        MEDEFAIDRIN: typing.ClassVar[Character.UnicodeScript] = ...
        ELYMAIC: typing.ClassVar[Character.UnicodeScript] = ...
        NANDINAGARI: typing.ClassVar[Character.UnicodeScript] = ...
        NYIAKENG_PUACHUE_HMONG: typing.ClassVar[Character.UnicodeScript] = ...
        WANCHO: typing.ClassVar[Character.UnicodeScript] = ...
        YEZIDI: typing.ClassVar[Character.UnicodeScript] = ...
        CHORASMIAN: typing.ClassVar[Character.UnicodeScript] = ...
        DIVES_AKURU: typing.ClassVar[Character.UnicodeScript] = ...
        KHITAN_SMALL_SCRIPT: typing.ClassVar[Character.UnicodeScript] = ...
        UNKNOWN: typing.ClassVar[Character.UnicodeScript] = ...
        @staticmethod
        def forName(scriptName: str | String, /) -> Character.UnicodeScript: ...
        @staticmethod
        def of(codePoint: int | java.jint | Integer, /) -> Character.UnicodeScript: ...
        @staticmethod
        def valueOf(name: str | String, /) -> Character.UnicodeScript: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[Character.UnicodeScript]: ...

    class UnicodeBlock(java.lang.Character.Subset):
        ADLAM: typing.ClassVar[Character.UnicodeBlock] = ...
        AEGEAN_NUMBERS: typing.ClassVar[Character.UnicodeBlock] = ...
        AHOM: typing.ClassVar[Character.UnicodeBlock] = ...
        ALCHEMICAL_SYMBOLS: typing.ClassVar[Character.UnicodeBlock] = ...
        ALPHABETIC_PRESENTATION_FORMS: typing.ClassVar[Character.UnicodeBlock] = ...
        ANATOLIAN_HIEROGLYPHS: typing.ClassVar[Character.UnicodeBlock] = ...
        ANCIENT_GREEK_MUSICAL_NOTATION: typing.ClassVar[Character.UnicodeBlock] = ...
        ANCIENT_GREEK_NUMBERS: typing.ClassVar[Character.UnicodeBlock] = ...
        ANCIENT_SYMBOLS: typing.ClassVar[Character.UnicodeBlock] = ...
        ARABIC: typing.ClassVar[Character.UnicodeBlock] = ...
        ARABIC_EXTENDED_A: typing.ClassVar[Character.UnicodeBlock] = ...
        ARABIC_MATHEMATICAL_ALPHABETIC_SYMBOLS: typing.ClassVar[Character.UnicodeBlock] = ...
        ARABIC_PRESENTATION_FORMS_A: typing.ClassVar[Character.UnicodeBlock] = ...
        ARABIC_PRESENTATION_FORMS_B: typing.ClassVar[Character.UnicodeBlock] = ...
        ARABIC_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        ARMENIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        ARROWS: typing.ClassVar[Character.UnicodeBlock] = ...
        AVESTAN: typing.ClassVar[Character.UnicodeBlock] = ...
        BALINESE: typing.ClassVar[Character.UnicodeBlock] = ...
        BAMUM: typing.ClassVar[Character.UnicodeBlock] = ...
        BAMUM_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        BASIC_LATIN: typing.ClassVar[Character.UnicodeBlock] = ...
        BASSA_VAH: typing.ClassVar[Character.UnicodeBlock] = ...
        BATAK: typing.ClassVar[Character.UnicodeBlock] = ...
        BENGALI: typing.ClassVar[Character.UnicodeBlock] = ...
        BHAIKSUKI: typing.ClassVar[Character.UnicodeBlock] = ...
        BLOCK_ELEMENTS: typing.ClassVar[Character.UnicodeBlock] = ...
        BOPOMOFO: typing.ClassVar[Character.UnicodeBlock] = ...
        BOPOMOFO_EXTENDED: typing.ClassVar[Character.UnicodeBlock] = ...
        BOX_DRAWING: typing.ClassVar[Character.UnicodeBlock] = ...
        BRAHMI: typing.ClassVar[Character.UnicodeBlock] = ...
        BRAILLE_PATTERNS: typing.ClassVar[Character.UnicodeBlock] = ...
        BUGINESE: typing.ClassVar[Character.UnicodeBlock] = ...
        BUHID: typing.ClassVar[Character.UnicodeBlock] = ...
        BYZANTINE_MUSICAL_SYMBOLS: typing.ClassVar[Character.UnicodeBlock] = ...
        CARIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        CAUCASIAN_ALBANIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        CHAKMA: typing.ClassVar[Character.UnicodeBlock] = ...
        CHAM: typing.ClassVar[Character.UnicodeBlock] = ...
        CHEROKEE: typing.ClassVar[Character.UnicodeBlock] = ...
        CHEROKEE_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        CHESS_SYMBOLS: typing.ClassVar[Character.UnicodeBlock] = ...
        CHORASMIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        CJK_COMPATIBILITY: typing.ClassVar[Character.UnicodeBlock] = ...
        CJK_COMPATIBILITY_FORMS: typing.ClassVar[Character.UnicodeBlock] = ...
        CJK_COMPATIBILITY_IDEOGRAPHS: typing.ClassVar[Character.UnicodeBlock] = ...
        CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        CJK_RADICALS_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        CJK_STROKES: typing.ClassVar[Character.UnicodeBlock] = ...
        CJK_SYMBOLS_AND_PUNCTUATION: typing.ClassVar[Character.UnicodeBlock] = ...
        CJK_UNIFIED_IDEOGRAPHS: typing.ClassVar[Character.UnicodeBlock] = ...
        CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A: typing.ClassVar[Character.UnicodeBlock] = ...
        CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B: typing.ClassVar[Character.UnicodeBlock] = ...
        CJK_UNIFIED_IDEOGRAPHS_EXTENSION_C: typing.ClassVar[Character.UnicodeBlock] = ...
        CJK_UNIFIED_IDEOGRAPHS_EXTENSION_D: typing.ClassVar[Character.UnicodeBlock] = ...
        CJK_UNIFIED_IDEOGRAPHS_EXTENSION_E: typing.ClassVar[Character.UnicodeBlock] = ...
        CJK_UNIFIED_IDEOGRAPHS_EXTENSION_F: typing.ClassVar[Character.UnicodeBlock] = ...
        CJK_UNIFIED_IDEOGRAPHS_EXTENSION_G: typing.ClassVar[Character.UnicodeBlock] = ...
        COMBINING_DIACRITICAL_MARKS: typing.ClassVar[Character.UnicodeBlock] = ...
        COMBINING_DIACRITICAL_MARKS_EXTENDED: typing.ClassVar[Character.UnicodeBlock] = ...
        COMBINING_DIACRITICAL_MARKS_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        COMBINING_HALF_MARKS: typing.ClassVar[Character.UnicodeBlock] = ...
        COMBINING_MARKS_FOR_SYMBOLS: typing.ClassVar[Character.UnicodeBlock] = ...
        COMMON_INDIC_NUMBER_FORMS: typing.ClassVar[Character.UnicodeBlock] = ...
        CONTROL_PICTURES: typing.ClassVar[Character.UnicodeBlock] = ...
        COPTIC: typing.ClassVar[Character.UnicodeBlock] = ...
        COPTIC_EPACT_NUMBERS: typing.ClassVar[Character.UnicodeBlock] = ...
        COUNTING_ROD_NUMERALS: typing.ClassVar[Character.UnicodeBlock] = ...
        CUNEIFORM: typing.ClassVar[Character.UnicodeBlock] = ...
        CUNEIFORM_NUMBERS_AND_PUNCTUATION: typing.ClassVar[Character.UnicodeBlock] = ...
        CURRENCY_SYMBOLS: typing.ClassVar[Character.UnicodeBlock] = ...
        CYPRIOT_SYLLABARY: typing.ClassVar[Character.UnicodeBlock] = ...
        CYRILLIC: typing.ClassVar[Character.UnicodeBlock] = ...
        CYRILLIC_EXTENDED_A: typing.ClassVar[Character.UnicodeBlock] = ...
        CYRILLIC_EXTENDED_B: typing.ClassVar[Character.UnicodeBlock] = ...
        CYRILLIC_EXTENDED_C: typing.ClassVar[Character.UnicodeBlock] = ...
        CYRILLIC_SUPPLEMENTARY: typing.ClassVar[Character.UnicodeBlock] = ...
        DESERET: typing.ClassVar[Character.UnicodeBlock] = ...
        DEVANAGARI: typing.ClassVar[Character.UnicodeBlock] = ...
        DEVANAGARI_EXTENDED: typing.ClassVar[Character.UnicodeBlock] = ...
        DINGBATS: typing.ClassVar[Character.UnicodeBlock] = ...
        DIVES_AKURU: typing.ClassVar[Character.UnicodeBlock] = ...
        DOGRA: typing.ClassVar[Character.UnicodeBlock] = ...
        DOMINO_TILES: typing.ClassVar[Character.UnicodeBlock] = ...
        DUPLOYAN: typing.ClassVar[Character.UnicodeBlock] = ...
        EARLY_DYNASTIC_CUNEIFORM: typing.ClassVar[Character.UnicodeBlock] = ...
        EGYPTIAN_HIEROGLYPHS: typing.ClassVar[Character.UnicodeBlock] = ...
        EGYPTIAN_HIEROGLYPH_FORMAT_CONTROLS: typing.ClassVar[Character.UnicodeBlock] = ...
        ELBASAN: typing.ClassVar[Character.UnicodeBlock] = ...
        ELYMAIC: typing.ClassVar[Character.UnicodeBlock] = ...
        EMOTICONS: typing.ClassVar[Character.UnicodeBlock] = ...
        ENCLOSED_ALPHANUMERICS: typing.ClassVar[Character.UnicodeBlock] = ...
        ENCLOSED_ALPHANUMERIC_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        ENCLOSED_CJK_LETTERS_AND_MONTHS: typing.ClassVar[Character.UnicodeBlock] = ...
        ENCLOSED_IDEOGRAPHIC_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        ETHIOPIC: typing.ClassVar[Character.UnicodeBlock] = ...
        ETHIOPIC_EXTENDED: typing.ClassVar[Character.UnicodeBlock] = ...
        ETHIOPIC_EXTENDED_A: typing.ClassVar[Character.UnicodeBlock] = ...
        ETHIOPIC_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        GENERAL_PUNCTUATION: typing.ClassVar[Character.UnicodeBlock] = ...
        GEOMETRIC_SHAPES: typing.ClassVar[Character.UnicodeBlock] = ...
        GEOMETRIC_SHAPES_EXTENDED: typing.ClassVar[Character.UnicodeBlock] = ...
        GEORGIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        GEORGIAN_EXTENDED: typing.ClassVar[Character.UnicodeBlock] = ...
        GEORGIAN_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        GLAGOLITIC: typing.ClassVar[Character.UnicodeBlock] = ...
        GLAGOLITIC_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        GOTHIC: typing.ClassVar[Character.UnicodeBlock] = ...
        GRANTHA: typing.ClassVar[Character.UnicodeBlock] = ...
        GREEK: typing.ClassVar[Character.UnicodeBlock] = ...
        GREEK_EXTENDED: typing.ClassVar[Character.UnicodeBlock] = ...
        GUJARATI: typing.ClassVar[Character.UnicodeBlock] = ...
        GUNJALA_GONDI: typing.ClassVar[Character.UnicodeBlock] = ...
        GURMUKHI: typing.ClassVar[Character.UnicodeBlock] = ...
        HALFWIDTH_AND_FULLWIDTH_FORMS: typing.ClassVar[Character.UnicodeBlock] = ...
        HANGUL_COMPATIBILITY_JAMO: typing.ClassVar[Character.UnicodeBlock] = ...
        HANGUL_JAMO: typing.ClassVar[Character.UnicodeBlock] = ...
        HANGUL_JAMO_EXTENDED_A: typing.ClassVar[Character.UnicodeBlock] = ...
        HANGUL_JAMO_EXTENDED_B: typing.ClassVar[Character.UnicodeBlock] = ...
        HANGUL_SYLLABLES: typing.ClassVar[Character.UnicodeBlock] = ...
        HANIFI_ROHINGYA: typing.ClassVar[Character.UnicodeBlock] = ...
        HANUNOO: typing.ClassVar[Character.UnicodeBlock] = ...
        HATRAN: typing.ClassVar[Character.UnicodeBlock] = ...
        HEBREW: typing.ClassVar[Character.UnicodeBlock] = ...
        HIGH_PRIVATE_USE_SURROGATES: typing.ClassVar[Character.UnicodeBlock] = ...
        HIGH_SURROGATES: typing.ClassVar[Character.UnicodeBlock] = ...
        HIRAGANA: typing.ClassVar[Character.UnicodeBlock] = ...
        IDEOGRAPHIC_DESCRIPTION_CHARACTERS: typing.ClassVar[Character.UnicodeBlock] = ...
        IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION: typing.ClassVar[Character.UnicodeBlock] = ...
        IMPERIAL_ARAMAIC: typing.ClassVar[Character.UnicodeBlock] = ...
        INDIC_SIYAQ_NUMBERS: typing.ClassVar[Character.UnicodeBlock] = ...
        INSCRIPTIONAL_PAHLAVI: typing.ClassVar[Character.UnicodeBlock] = ...
        INSCRIPTIONAL_PARTHIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        IPA_EXTENSIONS: typing.ClassVar[Character.UnicodeBlock] = ...
        JAVANESE: typing.ClassVar[Character.UnicodeBlock] = ...
        KAITHI: typing.ClassVar[Character.UnicodeBlock] = ...
        KANA_EXTENDED_A: typing.ClassVar[Character.UnicodeBlock] = ...
        KANA_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        KANBUN: typing.ClassVar[Character.UnicodeBlock] = ...
        KANGXI_RADICALS: typing.ClassVar[Character.UnicodeBlock] = ...
        KANNADA: typing.ClassVar[Character.UnicodeBlock] = ...
        KATAKANA: typing.ClassVar[Character.UnicodeBlock] = ...
        KATAKANA_PHONETIC_EXTENSIONS: typing.ClassVar[Character.UnicodeBlock] = ...
        KAYAH_LI: typing.ClassVar[Character.UnicodeBlock] = ...
        KHAROSHTHI: typing.ClassVar[Character.UnicodeBlock] = ...
        KHITAN_SMALL_SCRIPT: typing.ClassVar[Character.UnicodeBlock] = ...
        KHMER: typing.ClassVar[Character.UnicodeBlock] = ...
        KHMER_SYMBOLS: typing.ClassVar[Character.UnicodeBlock] = ...
        KHOJKI: typing.ClassVar[Character.UnicodeBlock] = ...
        KHUDAWADI: typing.ClassVar[Character.UnicodeBlock] = ...
        LAO: typing.ClassVar[Character.UnicodeBlock] = ...
        LATIN_1_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        LATIN_EXTENDED_A: typing.ClassVar[Character.UnicodeBlock] = ...
        LATIN_EXTENDED_ADDITIONAL: typing.ClassVar[Character.UnicodeBlock] = ...
        LATIN_EXTENDED_B: typing.ClassVar[Character.UnicodeBlock] = ...
        LATIN_EXTENDED_C: typing.ClassVar[Character.UnicodeBlock] = ...
        LATIN_EXTENDED_D: typing.ClassVar[Character.UnicodeBlock] = ...
        LATIN_EXTENDED_E: typing.ClassVar[Character.UnicodeBlock] = ...
        LEPCHA: typing.ClassVar[Character.UnicodeBlock] = ...
        LETTERLIKE_SYMBOLS: typing.ClassVar[Character.UnicodeBlock] = ...
        LIMBU: typing.ClassVar[Character.UnicodeBlock] = ...
        LINEAR_A: typing.ClassVar[Character.UnicodeBlock] = ...
        LINEAR_B_IDEOGRAMS: typing.ClassVar[Character.UnicodeBlock] = ...
        LINEAR_B_SYLLABARY: typing.ClassVar[Character.UnicodeBlock] = ...
        LISU: typing.ClassVar[Character.UnicodeBlock] = ...
        LISU_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        LOW_SURROGATES: typing.ClassVar[Character.UnicodeBlock] = ...
        LYCIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        LYDIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        MAHAJANI: typing.ClassVar[Character.UnicodeBlock] = ...
        MAHJONG_TILES: typing.ClassVar[Character.UnicodeBlock] = ...
        MAKASAR: typing.ClassVar[Character.UnicodeBlock] = ...
        MALAYALAM: typing.ClassVar[Character.UnicodeBlock] = ...
        MANDAIC: typing.ClassVar[Character.UnicodeBlock] = ...
        MANICHAEAN: typing.ClassVar[Character.UnicodeBlock] = ...
        MARCHEN: typing.ClassVar[Character.UnicodeBlock] = ...
        MASARAM_GONDI: typing.ClassVar[Character.UnicodeBlock] = ...
        MATHEMATICAL_ALPHANUMERIC_SYMBOLS: typing.ClassVar[Character.UnicodeBlock] = ...
        MATHEMATICAL_OPERATORS: typing.ClassVar[Character.UnicodeBlock] = ...
        MAYAN_NUMERALS: typing.ClassVar[Character.UnicodeBlock] = ...
        MEDEFAIDRIN: typing.ClassVar[Character.UnicodeBlock] = ...
        MEETEI_MAYEK: typing.ClassVar[Character.UnicodeBlock] = ...
        MEETEI_MAYEK_EXTENSIONS: typing.ClassVar[Character.UnicodeBlock] = ...
        MENDE_KIKAKUI: typing.ClassVar[Character.UnicodeBlock] = ...
        MEROITIC_CURSIVE: typing.ClassVar[Character.UnicodeBlock] = ...
        MEROITIC_HIEROGLYPHS: typing.ClassVar[Character.UnicodeBlock] = ...
        MIAO: typing.ClassVar[Character.UnicodeBlock] = ...
        MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A: typing.ClassVar[Character.UnicodeBlock] = ...
        MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B: typing.ClassVar[Character.UnicodeBlock] = ...
        MISCELLANEOUS_SYMBOLS: typing.ClassVar[Character.UnicodeBlock] = ...
        MISCELLANEOUS_SYMBOLS_AND_ARROWS: typing.ClassVar[Character.UnicodeBlock] = ...
        MISCELLANEOUS_SYMBOLS_AND_PICTOGRAPHS: typing.ClassVar[Character.UnicodeBlock] = ...
        MISCELLANEOUS_TECHNICAL: typing.ClassVar[Character.UnicodeBlock] = ...
        MODI: typing.ClassVar[Character.UnicodeBlock] = ...
        MODIFIER_TONE_LETTERS: typing.ClassVar[Character.UnicodeBlock] = ...
        MONGOLIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        MONGOLIAN_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        MRO: typing.ClassVar[Character.UnicodeBlock] = ...
        MULTANI: typing.ClassVar[Character.UnicodeBlock] = ...
        MUSICAL_SYMBOLS: typing.ClassVar[Character.UnicodeBlock] = ...
        MYANMAR: typing.ClassVar[Character.UnicodeBlock] = ...
        MYANMAR_EXTENDED_A: typing.ClassVar[Character.UnicodeBlock] = ...
        MYANMAR_EXTENDED_B: typing.ClassVar[Character.UnicodeBlock] = ...
        NABATAEAN: typing.ClassVar[Character.UnicodeBlock] = ...
        NANDINAGARI: typing.ClassVar[Character.UnicodeBlock] = ...
        NEWA: typing.ClassVar[Character.UnicodeBlock] = ...
        NEW_TAI_LUE: typing.ClassVar[Character.UnicodeBlock] = ...
        NKO: typing.ClassVar[Character.UnicodeBlock] = ...
        NUMBER_FORMS: typing.ClassVar[Character.UnicodeBlock] = ...
        NUSHU: typing.ClassVar[Character.UnicodeBlock] = ...
        NYIAKENG_PUACHUE_HMONG: typing.ClassVar[Character.UnicodeBlock] = ...
        OGHAM: typing.ClassVar[Character.UnicodeBlock] = ...
        OLD_HUNGARIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        OLD_ITALIC: typing.ClassVar[Character.UnicodeBlock] = ...
        OLD_NORTH_ARABIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        OLD_PERMIC: typing.ClassVar[Character.UnicodeBlock] = ...
        OLD_PERSIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        OLD_SOGDIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        OLD_SOUTH_ARABIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        OLD_TURKIC: typing.ClassVar[Character.UnicodeBlock] = ...
        OL_CHIKI: typing.ClassVar[Character.UnicodeBlock] = ...
        OPTICAL_CHARACTER_RECOGNITION: typing.ClassVar[Character.UnicodeBlock] = ...
        ORIYA: typing.ClassVar[Character.UnicodeBlock] = ...
        ORNAMENTAL_DINGBATS: typing.ClassVar[Character.UnicodeBlock] = ...
        OSAGE: typing.ClassVar[Character.UnicodeBlock] = ...
        OSMANYA: typing.ClassVar[Character.UnicodeBlock] = ...
        OTTOMAN_SIYAQ_NUMBERS: typing.ClassVar[Character.UnicodeBlock] = ...
        PAHAWH_HMONG: typing.ClassVar[Character.UnicodeBlock] = ...
        PALMYRENE: typing.ClassVar[Character.UnicodeBlock] = ...
        PAU_CIN_HAU: typing.ClassVar[Character.UnicodeBlock] = ...
        PHAGS_PA: typing.ClassVar[Character.UnicodeBlock] = ...
        PHAISTOS_DISC: typing.ClassVar[Character.UnicodeBlock] = ...
        PHOENICIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        PHONETIC_EXTENSIONS: typing.ClassVar[Character.UnicodeBlock] = ...
        PHONETIC_EXTENSIONS_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        PLAYING_CARDS: typing.ClassVar[Character.UnicodeBlock] = ...
        PRIVATE_USE_AREA: typing.ClassVar[Character.UnicodeBlock] = ...
        PSALTER_PAHLAVI: typing.ClassVar[Character.UnicodeBlock] = ...
        REJANG: typing.ClassVar[Character.UnicodeBlock] = ...
        RUMI_NUMERAL_SYMBOLS: typing.ClassVar[Character.UnicodeBlock] = ...
        RUNIC: typing.ClassVar[Character.UnicodeBlock] = ...
        SAMARITAN: typing.ClassVar[Character.UnicodeBlock] = ...
        SAURASHTRA: typing.ClassVar[Character.UnicodeBlock] = ...
        SHARADA: typing.ClassVar[Character.UnicodeBlock] = ...
        SHAVIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        SHORTHAND_FORMAT_CONTROLS: typing.ClassVar[Character.UnicodeBlock] = ...
        SIDDHAM: typing.ClassVar[Character.UnicodeBlock] = ...
        SINHALA: typing.ClassVar[Character.UnicodeBlock] = ...
        SINHALA_ARCHAIC_NUMBERS: typing.ClassVar[Character.UnicodeBlock] = ...
        SMALL_FORM_VARIANTS: typing.ClassVar[Character.UnicodeBlock] = ...
        SMALL_KANA_EXTENSION: typing.ClassVar[Character.UnicodeBlock] = ...
        SOGDIAN: typing.ClassVar[Character.UnicodeBlock] = ...
        SORA_SOMPENG: typing.ClassVar[Character.UnicodeBlock] = ...
        SOYOMBO: typing.ClassVar[Character.UnicodeBlock] = ...
        SPACING_MODIFIER_LETTERS: typing.ClassVar[Character.UnicodeBlock] = ...
        SPECIALS: typing.ClassVar[Character.UnicodeBlock] = ...
        SUNDANESE: typing.ClassVar[Character.UnicodeBlock] = ...
        SUNDANESE_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        SUPERSCRIPTS_AND_SUBSCRIPTS: typing.ClassVar[Character.UnicodeBlock] = ...
        SUPPLEMENTAL_ARROWS_A: typing.ClassVar[Character.UnicodeBlock] = ...
        SUPPLEMENTAL_ARROWS_B: typing.ClassVar[Character.UnicodeBlock] = ...
        SUPPLEMENTAL_ARROWS_C: typing.ClassVar[Character.UnicodeBlock] = ...
        SUPPLEMENTAL_MATHEMATICAL_OPERATORS: typing.ClassVar[Character.UnicodeBlock] = ...
        SUPPLEMENTAL_PUNCTUATION: typing.ClassVar[Character.UnicodeBlock] = ...
        SUPPLEMENTAL_SYMBOLS_AND_PICTOGRAPHS: typing.ClassVar[Character.UnicodeBlock] = ...
        SUPPLEMENTARY_PRIVATE_USE_AREA_A: typing.ClassVar[Character.UnicodeBlock] = ...
        SUPPLEMENTARY_PRIVATE_USE_AREA_B: typing.ClassVar[Character.UnicodeBlock] = ...
        SURROGATES_AREA: typing.ClassVar[Character.UnicodeBlock] = ...
        SUTTON_SIGNWRITING: typing.ClassVar[Character.UnicodeBlock] = ...
        SYLOTI_NAGRI: typing.ClassVar[Character.UnicodeBlock] = ...
        SYMBOLS_AND_PICTOGRAPHS_EXTENDED_A: typing.ClassVar[Character.UnicodeBlock] = ...
        SYMBOLS_FOR_LEGACY_COMPUTING: typing.ClassVar[Character.UnicodeBlock] = ...
        SYRIAC: typing.ClassVar[Character.UnicodeBlock] = ...
        SYRIAC_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        TAGALOG: typing.ClassVar[Character.UnicodeBlock] = ...
        TAGBANWA: typing.ClassVar[Character.UnicodeBlock] = ...
        TAGS: typing.ClassVar[Character.UnicodeBlock] = ...
        TAI_LE: typing.ClassVar[Character.UnicodeBlock] = ...
        TAI_THAM: typing.ClassVar[Character.UnicodeBlock] = ...
        TAI_VIET: typing.ClassVar[Character.UnicodeBlock] = ...
        TAI_XUAN_JING_SYMBOLS: typing.ClassVar[Character.UnicodeBlock] = ...
        TAKRI: typing.ClassVar[Character.UnicodeBlock] = ...
        TAMIL: typing.ClassVar[Character.UnicodeBlock] = ...
        TAMIL_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        TANGUT: typing.ClassVar[Character.UnicodeBlock] = ...
        TANGUT_COMPONENTS: typing.ClassVar[Character.UnicodeBlock] = ...
        TANGUT_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        TELUGU: typing.ClassVar[Character.UnicodeBlock] = ...
        THAANA: typing.ClassVar[Character.UnicodeBlock] = ...
        THAI: typing.ClassVar[Character.UnicodeBlock] = ...
        TIBETAN: typing.ClassVar[Character.UnicodeBlock] = ...
        TIFINAGH: typing.ClassVar[Character.UnicodeBlock] = ...
        TIRHUTA: typing.ClassVar[Character.UnicodeBlock] = ...
        TRANSPORT_AND_MAP_SYMBOLS: typing.ClassVar[Character.UnicodeBlock] = ...
        UGARITIC: typing.ClassVar[Character.UnicodeBlock] = ...
        UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS: typing.ClassVar[Character.UnicodeBlock] = ...
        UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_EXTENDED: typing.ClassVar[Character.UnicodeBlock] = ...
        VAI: typing.ClassVar[Character.UnicodeBlock] = ...
        VARIATION_SELECTORS: typing.ClassVar[Character.UnicodeBlock] = ...
        VARIATION_SELECTORS_SUPPLEMENT: typing.ClassVar[Character.UnicodeBlock] = ...
        VEDIC_EXTENSIONS: typing.ClassVar[Character.UnicodeBlock] = ...
        VERTICAL_FORMS: typing.ClassVar[Character.UnicodeBlock] = ...
        WANCHO: typing.ClassVar[Character.UnicodeBlock] = ...
        WARANG_CITI: typing.ClassVar[Character.UnicodeBlock] = ...
        YEZIDI: typing.ClassVar[Character.UnicodeBlock] = ...
        YIJING_HEXAGRAM_SYMBOLS: typing.ClassVar[Character.UnicodeBlock] = ...
        YI_RADICALS: typing.ClassVar[Character.UnicodeBlock] = ...
        YI_SYLLABLES: typing.ClassVar[Character.UnicodeBlock] = ...
        ZANABAZAR_SQUARE: typing.ClassVar[Character.UnicodeBlock] = ...
        @staticmethod
        def forName(blockName: str | String, /) -> Character.UnicodeBlock: ...
        @typing.overload
        @staticmethod
        def of(c: str | java.jchar | Character, /) -> Character.UnicodeBlock: ...
        @typing.overload
        @staticmethod
        def of(codePoint: int | java.jint | Integer, /) -> Character.UnicodeBlock: ...

    class Subset(Object):
        def __init__(self, name: str | String, /) -> None: ...
        def equals(self, obj: Object | int | bool | float | str, /) -> bool: ...
        def hashCode(self) -> int: ...
        def toString(self) -> str: ...

_Class__T = typing.TypeVar('_Class__T')  # <T>
class Class(java.io.Serializable, java.lang.reflect.GenericDeclaration, java.lang.reflect.Type, java.lang.reflect.AnnotatedElement, java.lang.invoke.TypeDescriptor.OfField[typing.Type[Object]], typing.Generic[_Class__T]):
    def arrayType(self) -> typing.Type[Object]: ...
    _asSubclass__U = typing.TypeVar('_asSubclass__U')  # <U>
    def asSubclass(self, clazz: typing.Type[_asSubclass__U], /) -> typing.Type[_asSubclass__U]: ...
    def cast(self, obj: Object | int | bool | float | str, /) -> _Class__T: ...
    def componentType(self) -> typing.Type[Object]: ...
    def descriptorString(self) -> str: ...
    def desiredAssertionStatus(self) -> bool: ...
    @typing.overload
    @staticmethod
    def forName(className: str | String, /) -> typing.Type[Object]: ...
    @typing.overload
    @staticmethod
    def forName(name: str | String, initialize: bool | java.jboolean | Boolean, loader: ClassLoader, /) -> typing.Type[Object]: ...
    _getAnnotation__A = typing.TypeVar('_getAnnotation__A')  # <A>
    def getAnnotation(self, annotationClass: typing.Type[_getAnnotation__A], /) -> _getAnnotation__A | None: ...
    def getAnnotations(self) -> java.chaquopy.JavaArray[java.lang.annotation.Annotation]: ...
    _getAnnotationsByType__A = typing.TypeVar('_getAnnotationsByType__A')  # <A>
    def getAnnotationsByType(self, annotationClass: typing.Type[_getAnnotationsByType__A], /) -> java.chaquopy.JavaArray[_getAnnotationsByType__A]: ...
    def getCanonicalName(self) -> str | None: ...
    def getClassLoader(self) -> ClassLoader | None: ...
    def getClasses(self) -> java.chaquopy.JavaArray[typing.Type[Object]]: ...
    def getComponentType(self) -> typing.Type[Object] | None: ...
    def getConstructor(self, *parameterTypes: typing.Type[Object]) -> java.lang.reflect.Constructor[_Class__T]: ...
    def getConstructors(self) -> java.chaquopy.JavaArray[java.lang.reflect.Constructor[Object]]: ...
    _getDeclaredAnnotation__A = typing.TypeVar('_getDeclaredAnnotation__A')  # <A>
    def getDeclaredAnnotation(self, arg1: typing.Type[_getDeclaredAnnotation__A], /) -> _getDeclaredAnnotation__A | None: ...
    def getDeclaredAnnotations(self) -> java.chaquopy.JavaArray[java.lang.annotation.Annotation]: ...
    _getDeclaredAnnotationsByType__A = typing.TypeVar('_getDeclaredAnnotationsByType__A')  # <A>
    def getDeclaredAnnotationsByType(self, annotationClass: typing.Type[_getDeclaredAnnotationsByType__A], /) -> java.chaquopy.JavaArray[_getDeclaredAnnotationsByType__A]: ...
    def getDeclaredClasses(self) -> java.chaquopy.JavaArray[typing.Type[Object]]: ...
    def getDeclaredConstructor(self, *parameterTypes: typing.Type[Object]) -> java.lang.reflect.Constructor[_Class__T]: ...
    def getDeclaredConstructors(self) -> java.chaquopy.JavaArray[java.lang.reflect.Constructor[Object]]: ...
    def getDeclaredField(self, arg1: str | String, /) -> java.lang.reflect.Field: ...
    def getDeclaredFields(self) -> java.chaquopy.JavaArray[java.lang.reflect.Field]: ...
    def getDeclaredMethod(self, name: str | String, /, *parameterTypes: typing.Type[Object]) -> java.lang.reflect.Method: ...
    def getDeclaredMethods(self) -> java.chaquopy.JavaArray[java.lang.reflect.Method]: ...
    def getDeclaringClass(self) -> typing.Type[Object] | None: ...
    def getEnclosingClass(self) -> typing.Type[Object] | None: ...
    def getEnclosingConstructor(self) -> java.lang.reflect.Constructor[Object] | None: ...
    def getEnclosingMethod(self) -> java.lang.reflect.Method | None: ...
    def getEnumConstants(self) -> java.chaquopy.JavaArray[_Class__T] | None: ...
    def getField(self, name: str | String, /) -> java.lang.reflect.Field: ...
    def getFields(self) -> java.chaquopy.JavaArray[java.lang.reflect.Field]: ...
    def getGenericInterfaces(self) -> java.chaquopy.JavaArray[java.lang.reflect.Type]: ...
    def getGenericSuperclass(self) -> java.lang.reflect.Type: ...
    def getInterfaces(self) -> java.chaquopy.JavaArray[typing.Type[Object]]: ...
    def getMethod(self, name: str | String, /, *parameterTypes: typing.Type[Object]) -> java.lang.reflect.Method: ...
    def getMethods(self) -> java.chaquopy.JavaArray[java.lang.reflect.Method]: ...
    def getModifiers(self) -> int: ...
    def getName(self) -> str: ...
    def getNestHost(self) -> typing.Type[Object] | None: ...
    def getNestMembers(self) -> java.chaquopy.JavaArray[typing.Type[Object]]: ...
    def getPackage(self) -> Package | None: ...
    def getPackageName(self) -> str: ...
    def getPermittedSubclasses(self) -> java.chaquopy.JavaArray[typing.Type[Object]]: ...
    def getProtectionDomain(self) -> java.security.ProtectionDomain: ...
    def getRecordComponents(self) -> java.chaquopy.JavaArray[java.lang.reflect.RecordComponent]: ...
    def getResource(self, name: str | String, /) -> java.net.URL | None: ...
    def getResourceAsStream(self, name: str | String, /) -> java.io.InputStream | None: ...
    def getSigners(self) -> java.chaquopy.JavaArray[Object] | None: ...
    def getSimpleName(self) -> str: ...
    def getSuperclass(self) -> typing.Type[_Class__T] | None: ...
    def getTypeName(self) -> str: ...
    def getTypeParameters(self) -> java.chaquopy.JavaArray[java.lang.reflect.TypeVariable[typing.Type[_Class__T]]]: ...
    def isAnnotation(self) -> bool: ...
    def isAnnotationPresent(self, annotationClass: typing.Type[java.lang.annotation.Annotation], /) -> bool: ...
    def isAnonymousClass(self) -> bool: ...
    def isArray(self) -> bool: ...
    def isAssignableFrom(self, cls: typing.Type[Object], /) -> bool: ...
    def isEnum(self) -> bool: ...
    def isInstance(self, obj: Object | int | bool | float | str, /) -> bool: ...
    def isInterface(self) -> bool: ...
    def isLocalClass(self) -> bool: ...
    def isMemberClass(self) -> bool: ...
    def isNestmateOf(self, c: typing.Type[Object], /) -> bool: ...
    def isPrimitive(self) -> bool: ...
    def isRecord(self) -> bool: ...
    def isSealed(self) -> bool: ...
    def isSynthetic(self) -> bool: ...
    def newInstance(self) -> _Class__T: ...
    def toGenericString(self) -> str: ...
    def toString(self) -> str: ...

class ClassCastException(RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class ClassCircularityError(LinkageError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class ClassFormatError(LinkageError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class ClassLoader(Object):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, parent: ClassLoader, /) -> None: ...
    def clearAssertionStatus(self) -> None: ...
    @typing.overload
    def defineClass(self, name: str | String, b: java.nio.ByteBuffer, protectionDomain: java.security.ProtectionDomain, /) -> typing.Type[Object]: ...
    @typing.overload
    def defineClass(self, b: java.chaquopy.JavaArrayJByte, off: int | java.jint | Integer, len: int | java.jint | Integer, /) -> typing.Type[Object]: ...
    @typing.overload
    def defineClass(self, name: str | String, b: java.chaquopy.JavaArrayJByte, off: int | java.jint | Integer, len: int | java.jint | Integer, /) -> typing.Type[Object]: ...
    @typing.overload
    def defineClass(self, name: str | String, b: java.chaquopy.JavaArrayJByte, off: int | java.jint | Integer, len: int | java.jint | Integer, protectionDomain: java.security.ProtectionDomain, /) -> typing.Type[Object]: ...
    def definePackage(self, name: str | String, specTitle: str | String, specVersion: str | String, specVendor: str | String, implTitle: str | String, implVersion: str | String, implVendor: str | String, sealBase: java.net.URL, /) -> Package: ...
    def findClass(self, name: str | String, /) -> typing.Type[Object]: ...
    def findLibrary(self, libname: str | String, /) -> str: ...
    def findLoadedClass(self, name: str | String, /) -> typing.Type[Object]: ...
    def findResource(self, name: str | String, /) -> java.net.URL: ...
    def findResources(self, name: str | String, /) -> java.util.Enumeration[java.net.URL]: ...
    def findSystemClass(self, name: str | String, /) -> typing.Type[Object]: ...
    def getPackage(self, name: str | String, /) -> Package: ...
    def getPackages(self) -> java.chaquopy.JavaArray[Package]: ...
    def getParent(self) -> ClassLoader | None: ...
    def getResource(self, name: str | String, /) -> java.net.URL | None: ...
    def getResourceAsStream(self, name: str | String, /) -> java.io.InputStream | None: ...
    def getResources(self, name: str | String, /) -> java.util.Enumeration[java.net.URL]: ...
    @staticmethod
    def getSystemClassLoader() -> ClassLoader | None: ...
    @staticmethod
    def getSystemResource(name: str | String, /) -> java.net.URL | None: ...
    @staticmethod
    def getSystemResourceAsStream(name: str | String, /) -> java.io.InputStream | None: ...
    @staticmethod
    def getSystemResources(name: str | String, /) -> java.util.Enumeration[java.net.URL]: ...
    @typing.overload
    def loadClass(self, name: str | String, /) -> typing.Type[Object]: ...
    @typing.overload
    def loadClass(self, name: str | String, resolve: bool | java.jboolean | Boolean, /) -> typing.Type[Object]: ...
    @staticmethod
    def registerAsParallelCapable() -> bool: ...
    def resolveClass(self, c: typing.Type[Object], /) -> None: ...
    def setClassAssertionStatus(self, className: str | String, enabled: bool | java.jboolean | Boolean, /) -> None: ...
    def setDefaultAssertionStatus(self, enabled: bool | java.jboolean | Boolean, /) -> None: ...
    def setPackageAssertionStatus(self, packageName: str | String, enabled: bool | java.jboolean | Boolean, /) -> None: ...
    def setSigners(self, c: typing.Type[Object], signers: java.chaquopy.JavaArray[Object], /) -> None: ...

class ClassNotFoundException(ReflectiveOperationException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, ex: Throwable, /) -> None: ...
    def getException(self) -> Throwable: ...

_ClassValue__T = typing.TypeVar('_ClassValue__T')  # <T>
class ClassValue(Object, typing.Generic[_ClassValue__T]):
    def __init__(self) -> None: ...
    def computeValue(self, arg1: typing.Type[Object], /) -> _ClassValue__T: ...
    def get(self, type: typing.Type[Object], /) -> _ClassValue__T: ...
    def remove(self, type: typing.Type[Object], /) -> None: ...

class CloneNotSupportedException(Exception):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class Cloneable(Object): ...

_Comparable__T = typing.TypeVar('_Comparable__T')  # <T>
class Comparable(Object, typing.Generic[_Comparable__T]):
    def compareTo(self, arg1: _Comparable__T, /) -> int: ...

class Compiler(Object):
    @staticmethod
    def command(cmd: Object | int | bool | float | str, /) -> Object: ...
    @staticmethod
    def compileClass(classToCompile: typing.Type[Object], /) -> bool: ...
    @staticmethod
    def compileClasses(nameRoot: str | String, /) -> bool: ...
    @staticmethod
    def disable() -> None: ...
    @staticmethod
    def enable() -> None: ...

class Deprecated(java.lang.annotation.Annotation):
    def forRemoval(self) -> bool: ...
    def since(self) -> str: ...

class Double(Number, Comparable[Double]):
    BYTES: typing.ClassVar[int] = ...
    MAX_EXPONENT: typing.ClassVar[int] = ...
    MAX_VALUE: typing.ClassVar[float] = ...
    MIN_EXPONENT: typing.ClassVar[int] = ...
    MIN_NORMAL: typing.ClassVar[float] = ...
    MIN_VALUE: typing.ClassVar[float] = ...
    NEGATIVE_INFINITY: typing.ClassVar[float] = ...
    NaN: typing.ClassVar[float] = ...
    POSITIVE_INFINITY: typing.ClassVar[float] = ...
    PRECISION: typing.ClassVar[int] = ...
    SIZE: typing.ClassVar[int] = ...
    TYPE: typing.ClassVar[typing.Type[Double]] = ...
    @typing.overload
    def __init__(self, value: float | java.jdouble | Double, /) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...
    def byteValue(self) -> int: ...
    @staticmethod
    def compare(d1: float | java.jdouble | Double, d2: float | java.jdouble | Double, /) -> int: ...
    def compareTo(self, anotherDouble: float | java.jdouble | Double, /) -> int: ...
    @staticmethod
    def doubleToLongBits(value: float | java.jdouble | Double, /) -> int: ...
    @staticmethod
    def doubleToRawLongBits(arg1: float | java.jdouble | Double, /) -> int: ...
    def doubleValue(self) -> float: ...
    def equals(self, obj: Object | int | bool | float | str, /) -> bool: ...
    def floatValue(self) -> float: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(value: float | java.jdouble | Double, /) -> int: ...
    def intValue(self) -> int: ...
    @staticmethod
    def isFinite(d: float | java.jdouble | Double, /) -> bool: ...
    @typing.overload
    def isInfinite(self) -> bool: ...
    @typing.overload
    @staticmethod
    def isInfinite(v: float | java.jdouble | Double, /) -> bool: ...
    @typing.overload
    def isNaN(self) -> bool: ...
    @typing.overload
    @staticmethod
    def isNaN(v: float | java.jdouble | Double, /) -> bool: ...
    @staticmethod
    def longBitsToDouble(arg1: int | java.jlong | Long, /) -> float: ...
    def longValue(self) -> int: ...
    @staticmethod
    def max(a: float | java.jdouble | Double, b: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def min(a: float | java.jdouble | Double, b: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def parseDouble(s: str | String, /) -> float: ...
    def shortValue(self) -> int: ...
    @staticmethod
    def sum(a: float | java.jdouble | Double, b: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def toHexString(d: float | java.jdouble | Double, /) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def toString(d: float | java.jdouble | Double, /) -> str: ...
    @typing.overload
    @staticmethod
    def valueOf(d: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def valueOf(s: str | String, /) -> float: ...

_Enum__E = typing.TypeVar('_Enum__E', bound=Enum[E])  # <E>
class Enum(Comparable[_Enum__E], java.io.Serializable, typing.Generic[_Enum__E]):
    def __init__(self, name: str | String, ordinal: int | java.jint | Integer, /) -> None: ...
    def clone(self) -> Object: ...
    def compareTo(self, o: _Enum__E, /) -> int: ...
    def equals(self, other: Object | int | bool | float | str, /) -> bool: ...
    def finalize(self) -> None: ...
    def getDeclaringClass(self) -> typing.Type[_Enum__E]: ...
    def hashCode(self) -> int: ...
    def name(self) -> str: ...
    def ordinal(self) -> int: ...
    def toString(self) -> str: ...
    _valueOf__T = typing.TypeVar('_valueOf__T', bound=Enum[T])  # <T>
    @staticmethod
    def valueOf(enumClass: typing.Type[_valueOf__T], name: str | String, /) -> _valueOf__T: ...

class EnumConstantNotPresentException(RuntimeException):
    def __init__(self, enumType: typing.Type[Enum], constantName: str | String, /) -> None: ...
    def constantName(self) -> str: ...
    def enumType(self) -> typing.Type[Enum]: ...

class Error(Throwable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, cause: Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, cause: Throwable, enableSuppression: bool | java.jboolean | Boolean, writableStackTrace: bool | java.jboolean | Boolean, /) -> None: ...

class Exception(Throwable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, cause: Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, cause: Throwable, enableSuppression: bool | java.jboolean | Boolean, writableStackTrace: bool | java.jboolean | Boolean, /) -> None: ...

class ExceptionInInitializerError(LinkageError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, thrown: Throwable, /) -> None: ...
    def getException(self) -> Throwable: ...

class Float(Number, Comparable[Float]):
    BYTES: typing.ClassVar[int] = ...
    MAX_EXPONENT: typing.ClassVar[int] = ...
    MAX_VALUE: typing.ClassVar[float] = ...
    MIN_EXPONENT: typing.ClassVar[int] = ...
    MIN_NORMAL: typing.ClassVar[float] = ...
    MIN_VALUE: typing.ClassVar[float] = ...
    NEGATIVE_INFINITY: typing.ClassVar[float] = ...
    NaN: typing.ClassVar[float] = ...
    POSITIVE_INFINITY: typing.ClassVar[float] = ...
    PRECISION: typing.ClassVar[int] = ...
    SIZE: typing.ClassVar[int] = ...
    TYPE: typing.ClassVar[typing.Type[Float]] = ...
    @typing.overload
    def __init__(self, value: float | java.jdouble | Double, /) -> None: ...
    @typing.overload
    def __init__(self, value: float | java.jfloat | Float, /) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...
    def byteValue(self) -> int: ...
    @staticmethod
    def compare(f1: float | java.jfloat | Float, f2: float | java.jfloat | Float, /) -> int: ...
    def compareTo(self, anotherFloat: float | java.jfloat | Float, /) -> int: ...
    def doubleValue(self) -> float: ...
    def equals(self, obj: Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def floatToIntBits(value: float | java.jfloat | Float, /) -> int: ...
    @staticmethod
    def floatToRawIntBits(arg1: float | java.jfloat | Float, /) -> int: ...
    def floatValue(self) -> float: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(value: float | java.jfloat | Float, /) -> int: ...
    @staticmethod
    def intBitsToFloat(arg1: int | java.jint | Integer, /) -> float: ...
    def intValue(self) -> int: ...
    @staticmethod
    def isFinite(f: float | java.jfloat | Float, /) -> bool: ...
    @typing.overload
    def isInfinite(self) -> bool: ...
    @typing.overload
    @staticmethod
    def isInfinite(v: float | java.jfloat | Float, /) -> bool: ...
    @typing.overload
    def isNaN(self) -> bool: ...
    @typing.overload
    @staticmethod
    def isNaN(v: float | java.jfloat | Float, /) -> bool: ...
    def longValue(self) -> int: ...
    @staticmethod
    def max(a: float | java.jfloat | Float, b: float | java.jfloat | Float, /) -> float: ...
    @staticmethod
    def min(a: float | java.jfloat | Float, b: float | java.jfloat | Float, /) -> float: ...
    @staticmethod
    def parseFloat(s: str | String, /) -> float: ...
    def shortValue(self) -> int: ...
    @staticmethod
    def sum(a: float | java.jfloat | Float, b: float | java.jfloat | Float, /) -> float: ...
    @staticmethod
    def toHexString(f: float | java.jfloat | Float, /) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def toString(f: float | java.jfloat | Float, /) -> str: ...
    @typing.overload
    @staticmethod
    def valueOf(f: float | java.jfloat | Float, /) -> float: ...
    @typing.overload
    @staticmethod
    def valueOf(s: str | String, /) -> float: ...

class FunctionalInterface(java.lang.annotation.Annotation): ...

class IllegalAccessError(IncompatibleClassChangeError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class IllegalAccessException(ReflectiveOperationException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class IllegalArgumentException(RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, cause: Throwable, /) -> None: ...

class IllegalMonitorStateException(RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class IllegalStateException(RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, cause: Throwable, /) -> None: ...

class IllegalThreadStateException(IllegalArgumentException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class IncompatibleClassChangeError(LinkageError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class IndexOutOfBoundsException(RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, index: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def __init__(self, index: int | java.jlong | Long, /) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

_InheritableThreadLocal__T = typing.TypeVar('_InheritableThreadLocal__T')  # <T>
class InheritableThreadLocal(ThreadLocal[_InheritableThreadLocal__T], typing.Generic[_InheritableThreadLocal__T]):
    def __init__(self) -> None: ...
    def childValue(self, parentValue: _InheritableThreadLocal__T, /) -> _InheritableThreadLocal__T: ...

class InstantiationError(IncompatibleClassChangeError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class InstantiationException(ReflectiveOperationException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class Integer(Number, Comparable[Integer]):
    BYTES: typing.ClassVar[int] = ...
    MAX_VALUE: typing.ClassVar[int] = ...
    MIN_VALUE: typing.ClassVar[int] = ...
    SIZE: typing.ClassVar[int] = ...
    TYPE: typing.ClassVar[typing.Type[Integer]] = ...
    @typing.overload
    def __init__(self, value: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...
    @staticmethod
    def bitCount(i: int | java.jint | Integer, /) -> int: ...
    def byteValue(self) -> int: ...
    @staticmethod
    def compare(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    def compareTo(self, anotherInteger: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def compareUnsigned(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def decode(nm: str | String, /) -> int: ...
    @staticmethod
    def divideUnsigned(dividend: int | java.jint | Integer, divisor: int | java.jint | Integer, /) -> int: ...
    def doubleValue(self) -> float: ...
    def equals(self, obj: Object | int | bool | float | str, /) -> bool: ...
    def floatValue(self) -> float: ...
    @typing.overload
    @staticmethod
    def getInteger(nm: str | String, /) -> int: ...
    @typing.overload
    @staticmethod
    def getInteger(nm: str | String, val: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def getInteger(nm: str | String, val: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(value: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def highestOneBit(i: int | java.jint | Integer, /) -> int: ...
    def intValue(self) -> int: ...
    def longValue(self) -> int: ...
    @staticmethod
    def lowestOneBit(i: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def max(a: int | java.jint | Integer, b: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def min(a: int | java.jint | Integer, b: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def numberOfLeadingZeros(i: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def numberOfTrailingZeros(i: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def parseInt(s: str | String, /) -> int: ...
    @typing.overload
    @staticmethod
    def parseInt(s: str | String, radix: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def parseInt(s: CharSequence, beginIndex: int | java.jint | Integer, endIndex: int | java.jint | Integer, radix: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def parseUnsignedInt(s: str | String, /) -> int: ...
    @typing.overload
    @staticmethod
    def parseUnsignedInt(s: str | String, radix: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def parseUnsignedInt(s: CharSequence, beginIndex: int | java.jint | Integer, endIndex: int | java.jint | Integer, radix: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def remainderUnsigned(dividend: int | java.jint | Integer, divisor: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def reverse(i: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def reverseBytes(i: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def rotateLeft(i: int | java.jint | Integer, distance: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def rotateRight(i: int | java.jint | Integer, distance: int | java.jint | Integer, /) -> int: ...
    def shortValue(self) -> int: ...
    @staticmethod
    def signum(i: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def sum(a: int | java.jint | Integer, b: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def toBinaryString(i: int | java.jint | Integer, /) -> str: ...
    @staticmethod
    def toHexString(i: int | java.jint | Integer, /) -> str: ...
    @staticmethod
    def toOctalString(i: int | java.jint | Integer, /) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def toString(i: int | java.jint | Integer, /) -> str: ...
    @typing.overload
    @staticmethod
    def toString(i: int | java.jint | Integer, radix: int | java.jint | Integer, /) -> str: ...
    @staticmethod
    def toUnsignedLong(x: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def toUnsignedString(i: int | java.jint | Integer, /) -> str: ...
    @typing.overload
    @staticmethod
    def toUnsignedString(i: int | java.jint | Integer, radix: int | java.jint | Integer, /) -> str: ...
    @typing.overload
    @staticmethod
    def valueOf(i: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def valueOf(s: str | String, /) -> int: ...
    @typing.overload
    @staticmethod
    def valueOf(s: str | String, radix: int | java.jint | Integer, /) -> int: ...

class InternalError(VirtualMachineError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, cause: Throwable, /) -> None: ...

class InterruptedException(Exception):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

_Iterable__T = typing.TypeVar('_Iterable__T')  # <T>
class Iterable(Object, typing.Generic[_Iterable__T]):
    def forEach(self, action: java.util.function.Consumer[_Iterable__T], /) -> None: ...
    def iterator(self) -> java.util.Iterator[_Iterable__T]: ...
    def spliterator(self) -> java.util.Spliterator[_Iterable__T]: ...

class LinkageError(Error):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, cause: Throwable, /) -> None: ...

class Long(Number, Comparable[Long]):
    BYTES: typing.ClassVar[int] = ...
    MAX_VALUE: typing.ClassVar[int] = ...
    MIN_VALUE: typing.ClassVar[int] = ...
    SIZE: typing.ClassVar[int] = ...
    TYPE: typing.ClassVar[typing.Type[Long]] = ...
    @typing.overload
    def __init__(self, value: int | java.jlong | Long, /) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...
    @staticmethod
    def bitCount(i: int | java.jlong | Long, /) -> int: ...
    def byteValue(self) -> int: ...
    @staticmethod
    def compare(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    def compareTo(self, anotherLong: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def compareUnsigned(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def decode(nm: str | String, /) -> int: ...
    @staticmethod
    def divideUnsigned(dividend: int | java.jlong | Long, divisor: int | java.jlong | Long, /) -> int: ...
    def doubleValue(self) -> float: ...
    def equals(self, obj: Object | int | bool | float | str, /) -> bool: ...
    def floatValue(self) -> float: ...
    @typing.overload
    @staticmethod
    def getLong(nm: str | String, /) -> int: ...
    @typing.overload
    @staticmethod
    def getLong(nm: str | String, val: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def getLong(nm: str | String, val: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(value: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def highestOneBit(i: int | java.jlong | Long, /) -> int: ...
    def intValue(self) -> int: ...
    def longValue(self) -> int: ...
    @staticmethod
    def lowestOneBit(i: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def max(a: int | java.jlong | Long, b: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def min(a: int | java.jlong | Long, b: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def numberOfLeadingZeros(i: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def numberOfTrailingZeros(i: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def parseLong(s: str | String, /) -> int: ...
    @typing.overload
    @staticmethod
    def parseLong(s: str | String, radix: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def parseLong(s: CharSequence, beginIndex: int | java.jint | Integer, endIndex: int | java.jint | Integer, radix: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def parseUnsignedLong(s: str | String, /) -> int: ...
    @typing.overload
    @staticmethod
    def parseUnsignedLong(s: str | String, radix: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def parseUnsignedLong(s: CharSequence, beginIndex: int | java.jint | Integer, endIndex: int | java.jint | Integer, radix: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def remainderUnsigned(dividend: int | java.jlong | Long, divisor: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def reverse(i: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def reverseBytes(i: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def rotateLeft(i: int | java.jlong | Long, distance: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def rotateRight(i: int | java.jlong | Long, distance: int | java.jint | Integer, /) -> int: ...
    def shortValue(self) -> int: ...
    @staticmethod
    def signum(i: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def sum(a: int | java.jlong | Long, b: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def toBinaryString(i: int | java.jlong | Long, /) -> str: ...
    @staticmethod
    def toHexString(i: int | java.jlong | Long, /) -> str: ...
    @staticmethod
    def toOctalString(i: int | java.jlong | Long, /) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def toString(i: int | java.jlong | Long, /) -> str: ...
    @typing.overload
    @staticmethod
    def toString(i: int | java.jlong | Long, radix: int | java.jint | Integer, /) -> str: ...
    @typing.overload
    @staticmethod
    def toUnsignedString(i: int | java.jlong | Long, /) -> str: ...
    @typing.overload
    @staticmethod
    def toUnsignedString(i: int | java.jlong | Long, radix: int | java.jint | Integer, /) -> str: ...
    @typing.overload
    @staticmethod
    def valueOf(l: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def valueOf(s: str | String, /) -> int: ...
    @typing.overload
    @staticmethod
    def valueOf(s: str | String, radix: int | java.jint | Integer, /) -> int: ...

class Math(Object):
    E: typing.ClassVar[float] = ...
    PI: typing.ClassVar[float] = ...
    TAU: typing.ClassVar[float] = ...
    @staticmethod
    def IEEEremainder(arg1: float | java.jdouble | Double, arg2: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def abs(a: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def abs(a: float | java.jfloat | Float, /) -> float: ...
    @typing.overload
    @staticmethod
    def abs(a: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def abs(a: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def absExact(a: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def absExact(a: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def acos(arg1: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def addExact(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def addExact(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def asin(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def atan(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def atan2(arg1: float | java.jdouble | Double, arg2: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def cbrt(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def ceil(arg1: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def ceilDiv(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def ceilDiv(x: int | java.jlong | Long, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def ceilDiv(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def ceilDivExact(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def ceilDivExact(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def ceilMod(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def ceilMod(x: int | java.jlong | Long, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def ceilMod(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def clamp(value: float | java.jdouble | Double, min: float | java.jdouble | Double, max: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def clamp(value: float | java.jfloat | Float, min: float | java.jfloat | Float, max: float | java.jfloat | Float, /) -> float: ...
    @typing.overload
    @staticmethod
    def clamp(value: int | java.jlong | Long, min: int | java.jint | Integer, max: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def clamp(value: int | java.jlong | Long, min: int | java.jlong | Long, max: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def copySign(magnitude: float | java.jdouble | Double, sign: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def copySign(magnitude: float | java.jfloat | Float, sign: float | java.jfloat | Float, /) -> float: ...
    @staticmethod
    def cos(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def cosh(arg1: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def decrementExact(a: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def decrementExact(a: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def divideExact(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def divideExact(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def exp(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def expm1(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def floor(arg1: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def floorDiv(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def floorDiv(x: int | java.jlong | Long, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def floorDiv(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def floorDivExact(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def floorDivExact(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def floorMod(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def floorMod(x: int | java.jlong | Long, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def floorMod(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def fma(a: float | java.jdouble | Double, b: float | java.jdouble | Double, c: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def fma(a: float | java.jfloat | Float, b: float | java.jfloat | Float, c: float | java.jfloat | Float, /) -> float: ...
    @typing.overload
    @staticmethod
    def getExponent(d: float | java.jdouble | Double, /) -> int: ...
    @typing.overload
    @staticmethod
    def getExponent(f: float | java.jfloat | Float, /) -> int: ...
    @staticmethod
    def hypot(arg1: float | java.jdouble | Double, arg2: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def incrementExact(a: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def incrementExact(a: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def log(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def log10(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def log1p(arg1: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def max(a: float | java.jdouble | Double, b: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def max(a: float | java.jfloat | Float, b: float | java.jfloat | Float, /) -> float: ...
    @typing.overload
    @staticmethod
    def max(a: int | java.jint | Integer, b: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def max(a: int | java.jlong | Long, b: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def min(a: float | java.jdouble | Double, b: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def min(a: float | java.jfloat | Float, b: float | java.jfloat | Float, /) -> float: ...
    @typing.overload
    @staticmethod
    def min(a: int | java.jint | Integer, b: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def min(a: int | java.jlong | Long, b: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def multiplyExact(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def multiplyExact(x: int | java.jlong | Long, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def multiplyExact(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def multiplyFull(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def multiplyHigh(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def negateExact(a: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def negateExact(a: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def nextAfter(start: float | java.jdouble | Double, direction: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def nextAfter(start: float | java.jfloat | Float, direction: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def nextDown(d: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def nextDown(f: float | java.jfloat | Float, /) -> float: ...
    @typing.overload
    @staticmethod
    def nextUp(d: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def nextUp(f: float | java.jfloat | Float, /) -> float: ...
    @staticmethod
    def pow(arg1: float | java.jdouble | Double, arg2: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def random() -> float: ...
    @staticmethod
    def rint(arg1: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def round(a: float | java.jdouble | Double, /) -> int: ...
    @typing.overload
    @staticmethod
    def round(a: float | java.jfloat | Float, /) -> int: ...
    @typing.overload
    @staticmethod
    def scalb(d: float | java.jdouble | Double, scaleFactor: int | java.jint | Integer, /) -> float: ...
    @typing.overload
    @staticmethod
    def scalb(f: float | java.jfloat | Float, scaleFactor: int | java.jint | Integer, /) -> float: ...
    @typing.overload
    @staticmethod
    def signum(d: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def signum(f: float | java.jfloat | Float, /) -> float: ...
    @staticmethod
    def sin(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def sinh(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def sqrt(arg1: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def subtractExact(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def subtractExact(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def tan(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def tanh(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def toDegrees(angrad: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def toIntExact(value: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def toRadians(angdeg: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def ulp(d: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def ulp(f: float | java.jfloat | Float, /) -> float: ...
    @staticmethod
    def unsignedMultiplyHigh(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...

class NegativeArraySizeException(RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class NoClassDefFoundError(LinkageError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class NoSuchFieldError(IncompatibleClassChangeError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class NoSuchFieldException(ReflectiveOperationException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class NoSuchMethodError(IncompatibleClassChangeError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class NoSuchMethodException(ReflectiveOperationException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class NullPointerException(RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class Number(java.io.Serializable):
    def __init__(self) -> None: ...
    def byteValue(self) -> int: ...
    def doubleValue(self) -> float: ...
    def floatValue(self) -> float: ...
    def intValue(self) -> int: ...
    def longValue(self) -> int: ...
    def shortValue(self) -> int: ...

class NumberFormatException(IllegalArgumentException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class Object:
    def __init__(self) -> None: ...
    def clone(self) -> Object: ...
    def equals(self, obj: Object | int | bool | float | str, /) -> bool: ...
    def finalize(self) -> None: ...
    def getClass(self) -> typing.Type[Object]: ...
    def hashCode(self) -> int: ...
    def notify(self) -> None: ...
    def notifyAll(self) -> None: ...
    def toString(self) -> str: ...
    @typing.overload
    def wait(self) -> None: ...
    @typing.overload
    def wait(self, timeoutMillis: int | java.jlong | Long, /) -> None: ...
    @typing.overload
    def wait(self, arg1: int | java.jlong | Long, arg2: int | java.jint | Integer, /) -> None: ...

class OutOfMemoryError(VirtualMachineError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class Override(java.lang.annotation.Annotation): ...

class Package(java.lang.reflect.AnnotatedElement):
    _getAnnotation__A = typing.TypeVar('_getAnnotation__A')  # <A>
    def getAnnotation(self, annotationClass: typing.Type[_getAnnotation__A], /) -> _getAnnotation__A | None: ...
    def getAnnotations(self) -> java.chaquopy.JavaArray[java.lang.annotation.Annotation]: ...
    _getAnnotationsByType__A = typing.TypeVar('_getAnnotationsByType__A')  # <A>
    def getAnnotationsByType(self, annotationClass: typing.Type[_getAnnotationsByType__A], /) -> java.chaquopy.JavaArray[_getAnnotationsByType__A]: ...
    _getDeclaredAnnotation__A = typing.TypeVar('_getDeclaredAnnotation__A')  # <A>
    def getDeclaredAnnotation(self, annotationClass: typing.Type[_getDeclaredAnnotation__A], /) -> _getDeclaredAnnotation__A: ...
    def getDeclaredAnnotations(self) -> java.chaquopy.JavaArray[java.lang.annotation.Annotation]: ...
    _getDeclaredAnnotationsByType__A = typing.TypeVar('_getDeclaredAnnotationsByType__A')  # <A>
    def getDeclaredAnnotationsByType(self, annotationClass: typing.Type[_getDeclaredAnnotationsByType__A], /) -> java.chaquopy.JavaArray[_getDeclaredAnnotationsByType__A]: ...
    def getImplementationTitle(self) -> str | None: ...
    def getImplementationVendor(self) -> str | None: ...
    def getImplementationVersion(self) -> str | None: ...
    def getName(self) -> str: ...
    @staticmethod
    def getPackage(name: str | String, /) -> Package | None: ...
    @staticmethod
    def getPackages() -> java.chaquopy.JavaArray[Package]: ...
    def getSpecificationTitle(self) -> str | None: ...
    def getSpecificationVendor(self) -> str | None: ...
    def getSpecificationVersion(self) -> str | None: ...
    def hashCode(self) -> int: ...
    def isAnnotationPresent(self, annotationClass: typing.Type[java.lang.annotation.Annotation], /) -> bool: ...
    def isCompatibleWith(self, desired: str | String, /) -> bool: ...
    @typing.overload
    def isSealed(self) -> bool: ...
    @typing.overload
    def isSealed(self, url: java.net.URL, /) -> bool: ...
    def toString(self) -> str: ...

class Process(Object):
    def __init__(self) -> None: ...
    def destroy(self) -> None: ...
    def destroyForcibly(self) -> Process: ...
    def exitValue(self) -> int: ...
    def getErrorStream(self) -> java.io.InputStream: ...
    def getInputStream(self) -> java.io.InputStream: ...
    def getOutputStream(self) -> java.io.OutputStream: ...
    def isAlive(self) -> bool: ...
    @typing.overload
    def waitFor(self) -> int: ...
    @typing.overload
    def waitFor(self, timeout: int | java.jlong | Long, unit: java.util.concurrent.TimeUnit, /) -> bool: ...

class ProcessBuilder(Object):
    @typing.overload
    def __init__(self, command: java.util.List[String], /) -> None: ...
    @typing.overload
    def __init__(self, *command: String) -> None: ...
    @typing.overload
    def command(self) -> java.util.List[String]: ...
    @typing.overload
    def command(self, command: java.util.List[String], /) -> ProcessBuilder: ...
    @typing.overload
    def command(self, *command: String) -> ProcessBuilder: ...
    @typing.overload
    def directory(self) -> java.io.File | None: ...
    @typing.overload
    def directory(self, directory: java.io.File, /) -> ProcessBuilder: ...
    def environment(self) -> java.util.Map[String, String]: ...
    def inheritIO(self) -> ProcessBuilder: ...
    @typing.overload
    def redirectError(self) -> ProcessBuilder.Redirect: ...
    @typing.overload
    def redirectError(self, file: java.io.File, /) -> ProcessBuilder: ...
    @typing.overload
    def redirectError(self, destination: ProcessBuilder.Redirect, /) -> ProcessBuilder: ...
    @typing.overload
    def redirectErrorStream(self) -> bool: ...
    @typing.overload
    def redirectErrorStream(self, redirectErrorStream: bool | java.jboolean | Boolean, /) -> ProcessBuilder: ...
    @typing.overload
    def redirectInput(self) -> ProcessBuilder.Redirect: ...
    @typing.overload
    def redirectInput(self, file: java.io.File, /) -> ProcessBuilder: ...
    @typing.overload
    def redirectInput(self, source: ProcessBuilder.Redirect, /) -> ProcessBuilder: ...
    @typing.overload
    def redirectOutput(self) -> ProcessBuilder.Redirect: ...
    @typing.overload
    def redirectOutput(self, file: java.io.File, /) -> ProcessBuilder: ...
    @typing.overload
    def redirectOutput(self, destination: ProcessBuilder.Redirect, /) -> ProcessBuilder: ...
    def start(self) -> Process: ...

    class Redirect(Object):
        INHERIT: typing.ClassVar[ProcessBuilder.Redirect] = ...
        PIPE: typing.ClassVar[ProcessBuilder.Redirect] = ...
        @staticmethod
        def appendTo(file: java.io.File, /) -> ProcessBuilder.Redirect: ...
        def equals(self, obj: Object | int | bool | float | str, /) -> bool: ...
        def file(self) -> java.io.File: ...
        @staticmethod
        def from_(file: java.io.File, /) -> ProcessBuilder.Redirect: ...
        def hashCode(self) -> int: ...
        @staticmethod
        def to(file: java.io.File, /) -> ProcessBuilder.Redirect: ...
        def type(self) -> ProcessBuilder.Redirect.Type: ...

        class Type(Enum[ProcessBuilder.Redirect.Type]):
            PIPE: typing.ClassVar[ProcessBuilder.Redirect.Type] = ...
            INHERIT: typing.ClassVar[ProcessBuilder.Redirect.Type] = ...
            READ: typing.ClassVar[ProcessBuilder.Redirect.Type] = ...
            WRITE: typing.ClassVar[ProcessBuilder.Redirect.Type] = ...
            APPEND: typing.ClassVar[ProcessBuilder.Redirect.Type] = ...
            @staticmethod
            def valueOf(name: str | String, /) -> ProcessBuilder.Redirect.Type: ...
            @staticmethod
            def values() -> java.chaquopy.JavaArray[ProcessBuilder.Redirect.Type]: ...

class Readable(Object):
    def read(self, arg1: java.nio.CharBuffer, /) -> int: ...

class Record(Object):
    def __init__(self) -> None: ...
    def equals(self, arg1: Object | int | bool | float | str, /) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class ReflectiveOperationException(Exception):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, cause: Throwable, /) -> None: ...

class Runnable(Object):
    def run(self) -> None: ...

class Runtime(Object):
    def addShutdownHook(self, hook: Thread, /) -> None: ...
    def availableProcessors(self) -> int: ...
    @typing.overload
    def exec_(self, command: str | String, /) -> Process: ...
    @typing.overload
    def exec_(self, cmdarray: java.chaquopy.JavaArray[String], /) -> Process: ...
    @typing.overload
    def exec_(self, command: str | String, envp: java.chaquopy.JavaArray[String], /) -> Process: ...
    @typing.overload
    def exec_(self, cmdarray: java.chaquopy.JavaArray[String], envp: java.chaquopy.JavaArray[String], /) -> Process: ...
    @typing.overload
    def exec_(self, command: str | String, envp: java.chaquopy.JavaArray[String], dir: java.io.File, /) -> Process: ...
    @typing.overload
    def exec_(self, cmdarray: java.chaquopy.JavaArray[String], envp: java.chaquopy.JavaArray[String], dir: java.io.File, /) -> Process: ...
    def exit(self, status: int | java.jint | Integer, /) -> None: ...
    def freeMemory(self) -> int: ...
    def gc(self) -> None: ...
    @staticmethod
    def getRuntime() -> Runtime: ...
    def halt(self, status: int | java.jint | Integer, /) -> None: ...
    def load(self, filename: str | String, /) -> None: ...
    def loadLibrary(self, libname: str | String, /) -> None: ...
    def maxMemory(self) -> int: ...
    def removeShutdownHook(self, hook: Thread, /) -> bool: ...
    def runFinalization(self) -> None: ...
    @staticmethod
    def runFinalizersOnExit(value: bool | java.jboolean | Boolean, /) -> None: ...
    def totalMemory(self) -> int: ...
    def traceInstructions(self, on: bool | java.jboolean | Boolean, /) -> None: ...
    def traceMethodCalls(self, on: bool | java.jboolean | Boolean, /) -> None: ...

class RuntimeException(Exception):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, cause: Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, cause: Throwable, enableSuppression: bool | java.jboolean | Boolean, writableStackTrace: bool | java.jboolean | Boolean, /) -> None: ...

class RuntimePermission(java.security.BasicPermission):
    @typing.overload
    def __init__(self, name: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, name: str | String, actions: str | String, /) -> None: ...

class SafeVarargs(java.lang.annotation.Annotation): ...

class SecurityException(RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, cause: Throwable, /) -> None: ...

class SecurityManager(Object):
    inCheck: bool = ...
    def __init__(self) -> None: ...
    def checkAccept(self, host: str | String, port: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def checkAccess(self, t: Thread, /) -> None: ...
    @typing.overload
    def checkAccess(self, g: ThreadGroup, /) -> None: ...
    def checkAwtEventQueueAccess(self) -> None: ...
    @typing.overload
    def checkConnect(self, host: str | String, port: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def checkConnect(self, host: str | String, port: int | java.jint | Integer, context: Object | int | bool | float | str, /) -> None: ...
    def checkCreateClassLoader(self) -> None: ...
    def checkDelete(self, file: str | String, /) -> None: ...
    def checkExec(self, cmd: str | String, /) -> None: ...
    def checkExit(self, status: int | java.jint | Integer, /) -> None: ...
    def checkLink(self, lib: str | String, /) -> None: ...
    def checkListen(self, port: int | java.jint | Integer, /) -> None: ...
    def checkMemberAccess(self, clazz: typing.Type[Object], which: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def checkMulticast(self, maddr: java.net.InetAddress, /) -> None: ...
    @typing.overload
    def checkMulticast(self, maddr: java.net.InetAddress, ttl: int | java.jbyte | Byte, /) -> None: ...
    def checkPackageAccess(self, pkg: str | String, /) -> None: ...
    def checkPackageDefinition(self, pkg: str | String, /) -> None: ...
    @typing.overload
    def checkPermission(self, perm: java.security.Permission, /) -> None: ...
    @typing.overload
    def checkPermission(self, perm: java.security.Permission, context: Object | int | bool | float | str, /) -> None: ...
    def checkPrintJobAccess(self) -> None: ...
    def checkPropertiesAccess(self) -> None: ...
    def checkPropertyAccess(self, key: str | String, /) -> None: ...
    @typing.overload
    def checkRead(self, fd: java.io.FileDescriptor, /) -> None: ...
    @typing.overload
    def checkRead(self, file: str | String, /) -> None: ...
    @typing.overload
    def checkRead(self, file: str | String, context: Object | int | bool | float | str, /) -> None: ...
    def checkSecurityAccess(self, target: str | String, /) -> None: ...
    def checkSetFactory(self) -> None: ...
    def checkSystemClipboardAccess(self) -> None: ...
    def checkTopLevelWindow(self, window: Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def checkWrite(self, fd: java.io.FileDescriptor, /) -> None: ...
    @typing.overload
    def checkWrite(self, file: str | String, /) -> None: ...
    def classDepth(self, name: str | String, /) -> int: ...
    def classLoaderDepth(self) -> int: ...
    def currentClassLoader(self) -> ClassLoader: ...
    def currentLoadedClass(self) -> typing.Type[Object]: ...
    def getClassContext(self) -> java.chaquopy.JavaArray[typing.Type]: ...
    def getInCheck(self) -> bool: ...
    def getSecurityContext(self) -> Object: ...
    def getThreadGroup(self) -> ThreadGroup: ...
    def inClass(self, name: str | String, /) -> bool: ...
    def inClassLoader(self) -> bool: ...

class Short(Number, Comparable[Short]):
    BYTES: typing.ClassVar[int] = ...
    MAX_VALUE: typing.ClassVar[int] = ...
    MIN_VALUE: typing.ClassVar[int] = ...
    SIZE: typing.ClassVar[int] = ...
    TYPE: typing.ClassVar[typing.Type[Short]] = ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, value: int | java.jshort | Short, /) -> None: ...
    def byteValue(self) -> int: ...
    @staticmethod
    def compare(x: int | java.jshort | Short, y: int | java.jshort | Short, /) -> int: ...
    def compareTo(self, anotherShort: int | java.jshort | Short, /) -> int: ...
    @staticmethod
    def compareUnsigned(x: int | java.jshort | Short, y: int | java.jshort | Short, /) -> int: ...
    @staticmethod
    def decode(nm: str | String, /) -> int: ...
    def doubleValue(self) -> float: ...
    def equals(self, obj: Object | int | bool | float | str, /) -> bool: ...
    def floatValue(self) -> float: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(value: int | java.jshort | Short, /) -> int: ...
    def intValue(self) -> int: ...
    def longValue(self) -> int: ...
    @typing.overload
    @staticmethod
    def parseShort(s: str | String, /) -> int: ...
    @typing.overload
    @staticmethod
    def parseShort(s: str | String, radix: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def reverseBytes(i: int | java.jshort | Short, /) -> int: ...
    def shortValue(self) -> int: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def toString(s: int | java.jshort | Short, /) -> str: ...
    @staticmethod
    def toUnsignedInt(x: int | java.jshort | Short, /) -> int: ...
    @staticmethod
    def toUnsignedLong(x: int | java.jshort | Short, /) -> int: ...
    @typing.overload
    @staticmethod
    def valueOf(s: str | String, /) -> int: ...
    @typing.overload
    @staticmethod
    def valueOf(s: int | java.jshort | Short, /) -> int: ...
    @typing.overload
    @staticmethod
    def valueOf(s: str | String, radix: int | java.jint | Integer, /) -> int: ...

class StackOverflowError(VirtualMachineError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class StackTraceElement(java.io.Serializable):
    def __init__(self, declaringClass: str | String, methodName: str | String, fileName: str | String, lineNumber: int | java.jint | Integer, /) -> None: ...
    def equals(self, obj: Object | int | bool | float | str, /) -> bool: ...
    def getClassName(self) -> str: ...
    def getFileName(self) -> str: ...
    def getLineNumber(self) -> int: ...
    def getMethodName(self) -> str: ...
    def hashCode(self) -> int: ...
    def isNativeMethod(self) -> bool: ...
    def toString(self) -> str: ...

class StackWalker(Object):
    def forEach(self, action: java.util.function.Consumer[StackWalker.StackFrame], /) -> None: ...
    def getCallerClass(self) -> typing.Type[Object]: ...
    @typing.overload
    @staticmethod
    def getInstance() -> StackWalker: ...
    @typing.overload
    @staticmethod
    def getInstance(option: StackWalker.Option, /) -> StackWalker: ...
    @typing.overload
    @staticmethod
    def getInstance(options: java.util.Set[StackWalker.Option], /) -> StackWalker: ...
    @typing.overload
    @staticmethod
    def getInstance(options: java.util.Set[StackWalker.Option], estimateDepth: int | java.jint | Integer, /) -> StackWalker: ...
    _walk__T = typing.TypeVar('_walk__T')  # <T>
    def walk(self, function: java.util.function.Function[java.util.stream.Stream[StackWalker.StackFrame], _walk__T], /) -> _walk__T: ...

    class StackFrame(Object):
        def getByteCodeIndex(self) -> int: ...
        def getClassName(self) -> str: ...
        def getDeclaringClass(self) -> typing.Type[Object]: ...
        def getDescriptor(self) -> str: ...
        def getFileName(self) -> str: ...
        def getLineNumber(self) -> int: ...
        def getMethodName(self) -> str: ...
        def getMethodType(self) -> java.lang.invoke.MethodType: ...
        def isNativeMethod(self) -> bool: ...
        def toStackTraceElement(self) -> StackTraceElement: ...

    class Option(Enum[StackWalker.Option]):
        RETAIN_CLASS_REFERENCE: typing.ClassVar[StackWalker.Option] = ...
        SHOW_REFLECT_FRAMES: typing.ClassVar[StackWalker.Option] = ...
        SHOW_HIDDEN_FRAMES: typing.ClassVar[StackWalker.Option] = ...
        @staticmethod
        def valueOf(name: str | String, /) -> StackWalker.Option: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[StackWalker.Option]: ...

class StrictMath(Object):
    E: typing.ClassVar[float] = ...
    PI: typing.ClassVar[float] = ...
    TAU: typing.ClassVar[float] = ...
    @staticmethod
    def IEEEremainder(arg1: float | java.jdouble | Double, arg2: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def abs(a: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def abs(a: float | java.jfloat | Float, /) -> float: ...
    @typing.overload
    @staticmethod
    def abs(a: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def abs(a: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def absExact(a: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def absExact(a: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def acos(arg1: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def addExact(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def addExact(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def asin(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def atan(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def atan2(arg1: float | java.jdouble | Double, arg2: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def cbrt(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def ceil(a: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def ceilDiv(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def ceilDiv(x: int | java.jlong | Long, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def ceilDiv(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def ceilDivExact(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def ceilDivExact(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def ceilMod(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def ceilMod(x: int | java.jlong | Long, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def ceilMod(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def clamp(value: float | java.jdouble | Double, min: float | java.jdouble | Double, max: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def clamp(value: float | java.jfloat | Float, min: float | java.jfloat | Float, max: float | java.jfloat | Float, /) -> float: ...
    @typing.overload
    @staticmethod
    def clamp(value: int | java.jlong | Long, min: int | java.jint | Integer, max: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def clamp(value: int | java.jlong | Long, min: int | java.jlong | Long, max: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def copySign(magnitude: float | java.jdouble | Double, sign: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def copySign(magnitude: float | java.jfloat | Float, sign: float | java.jfloat | Float, /) -> float: ...
    @staticmethod
    def cos(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def cosh(arg1: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def decrementExact(a: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def decrementExact(a: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def divideExact(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def divideExact(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def exp(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def expm1(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def floor(a: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def floorDiv(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def floorDiv(x: int | java.jlong | Long, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def floorDiv(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def floorDivExact(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def floorDivExact(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def floorMod(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def floorMod(x: int | java.jlong | Long, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def floorMod(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def fma(a: float | java.jdouble | Double, b: float | java.jdouble | Double, c: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def fma(a: float | java.jfloat | Float, b: float | java.jfloat | Float, c: float | java.jfloat | Float, /) -> float: ...
    @typing.overload
    @staticmethod
    def getExponent(d: float | java.jdouble | Double, /) -> int: ...
    @typing.overload
    @staticmethod
    def getExponent(f: float | java.jfloat | Float, /) -> int: ...
    @staticmethod
    def hypot(arg1: float | java.jdouble | Double, arg2: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def incrementExact(a: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def incrementExact(a: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def log(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def log10(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def log1p(arg1: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def max(a: float | java.jdouble | Double, b: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def max(a: float | java.jfloat | Float, b: float | java.jfloat | Float, /) -> float: ...
    @typing.overload
    @staticmethod
    def max(a: int | java.jint | Integer, b: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def max(a: int | java.jlong | Long, b: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def min(a: float | java.jdouble | Double, b: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def min(a: float | java.jfloat | Float, b: float | java.jfloat | Float, /) -> float: ...
    @typing.overload
    @staticmethod
    def min(a: int | java.jint | Integer, b: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def min(a: int | java.jlong | Long, b: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def multiplyExact(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def multiplyExact(x: int | java.jlong | Long, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def multiplyExact(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def multiplyFull(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @staticmethod
    def multiplyHigh(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def negateExact(a: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def negateExact(a: int | java.jlong | Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def nextAfter(start: float | java.jdouble | Double, direction: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def nextAfter(start: float | java.jfloat | Float, direction: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def nextDown(d: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def nextDown(f: float | java.jfloat | Float, /) -> float: ...
    @typing.overload
    @staticmethod
    def nextUp(d: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def nextUp(f: float | java.jfloat | Float, /) -> float: ...
    @staticmethod
    def pow(arg1: float | java.jdouble | Double, arg2: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def random() -> float: ...
    @staticmethod
    def rint(a: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def round(a: float | java.jdouble | Double, /) -> int: ...
    @typing.overload
    @staticmethod
    def round(a: float | java.jfloat | Float, /) -> int: ...
    @typing.overload
    @staticmethod
    def scalb(d: float | java.jdouble | Double, scaleFactor: int | java.jint | Integer, /) -> float: ...
    @typing.overload
    @staticmethod
    def scalb(f: float | java.jfloat | Float, scaleFactor: int | java.jint | Integer, /) -> float: ...
    @typing.overload
    @staticmethod
    def signum(d: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def signum(f: float | java.jfloat | Float, /) -> float: ...
    @staticmethod
    def sin(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def sinh(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def sqrt(arg1: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def subtractExact(x: int | java.jint | Integer, y: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def subtractExact(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def tan(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def tanh(arg1: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def toDegrees(angrad: float | java.jdouble | Double, /) -> float: ...
    @staticmethod
    def toIntExact(value: int | java.jlong | Long, /) -> int: ...
    @staticmethod
    def toRadians(angdeg: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def ulp(d: float | java.jdouble | Double, /) -> float: ...
    @typing.overload
    @staticmethod
    def ulp(f: float | java.jfloat | Float, /) -> float: ...
    @staticmethod
    def unsignedMultiplyHigh(x: int | java.jlong | Long, y: int | java.jlong | Long, /) -> int: ...

class String(java.io.Serializable, Comparable[String], CharSequence):
    CASE_INSENSITIVE_ORDER: typing.ClassVar[java.util.Comparator[String]] = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, original: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, buffer: StringBuffer, /) -> None: ...
    @typing.overload
    def __init__(self, builder: StringBuilder, /) -> None: ...
    @typing.overload
    def __init__(self, bytes: java.chaquopy.JavaArrayJByte, /) -> None: ...
    @typing.overload
    def __init__(self, value: java.chaquopy.JavaArrayJChar, /) -> None: ...
    @typing.overload
    def __init__(self, ascii: java.chaquopy.JavaArrayJByte, hibyte: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def __init__(self, bytes: java.chaquopy.JavaArrayJByte, charsetName: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, bytes: java.chaquopy.JavaArrayJByte, charset: java.nio.charset.Charset, /) -> None: ...
    @typing.overload
    def __init__(self, bytes: java.chaquopy.JavaArrayJByte, offset: int | java.jint | Integer, length: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def __init__(self, value: java.chaquopy.JavaArrayJChar, offset: int | java.jint | Integer, count: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def __init__(self, codePoints: java.chaquopy.JavaArrayJInt, offset: int | java.jint | Integer, count: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def __init__(self, ascii: java.chaquopy.JavaArrayJByte, hibyte: int | java.jint | Integer, offset: int | java.jint | Integer, count: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def __init__(self, bytes: java.chaquopy.JavaArrayJByte, offset: int | java.jint | Integer, length: int | java.jint | Integer, charsetName: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, bytes: java.chaquopy.JavaArrayJByte, offset: int | java.jint | Integer, length: int | java.jint | Integer, charset: java.nio.charset.Charset, /) -> None: ...
    def charAt(self, arg1: int | java.jint | Integer, /) -> str: ...
    def chars(self) -> java.util.stream.IntStream: ...
    def codePointAt(self, index: int | java.jint | Integer, /) -> int: ...
    def codePointBefore(self, index: int | java.jint | Integer, /) -> int: ...
    def codePointCount(self, beginIndex: int | java.jint | Integer, endIndex: int | java.jint | Integer, /) -> int: ...
    def codePoints(self) -> java.util.stream.IntStream: ...
    def compareTo(self, arg1: str | String, /) -> int: ...
    def compareToIgnoreCase(self, str: str | String, /) -> int: ...
    def concat(self, arg1: str | String, /) -> str: ...
    def contains(self, s: CharSequence, /) -> bool: ...
    @typing.overload
    def contentEquals(self, cs: CharSequence, /) -> bool: ...
    @typing.overload
    def contentEquals(self, sb: StringBuffer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def copyValueOf(data: java.chaquopy.JavaArrayJChar, /) -> str: ...
    @typing.overload
    @staticmethod
    def copyValueOf(data: java.chaquopy.JavaArrayJChar, offset: int | java.jint | Integer, count: int | java.jint | Integer, /) -> str: ...
    def endsWith(self, suffix: str | String, /) -> bool: ...
    def equals(self, anObject: Object | int | bool | float | str, /) -> bool: ...
    def equalsIgnoreCase(self, anotherString: str | String, /) -> bool: ...
    @typing.overload
    @staticmethod
    def format(format: str | String, /, *args: Object) -> str: ...
    @typing.overload
    @staticmethod
    def format(l: java.util.Locale, format: str | String, /, *args: Object) -> str: ...
    def formatted(self, *args: Object) -> str: ...
    @typing.overload
    def getBytes(self) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def getBytes(self, charsetName: str | String, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def getBytes(self, charset: java.nio.charset.Charset, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def getBytes(self, srcBegin: int | java.jint | Integer, srcEnd: int | java.jint | Integer, dst: java.chaquopy.JavaArrayJByte, dstBegin: int | java.jint | Integer, /) -> None: ...
    def getChars(self, srcBegin: int | java.jint | Integer, srcEnd: int | java.jint | Integer, dst: java.chaquopy.JavaArrayJChar, dstBegin: int | java.jint | Integer, /) -> None: ...
    def hashCode(self) -> int: ...
    def indent(self, n: int | java.jint | Integer, /) -> str: ...
    @typing.overload
    def indexOf(self, ch: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    def indexOf(self, str: str | String, /) -> int: ...
    @typing.overload
    def indexOf(self, ch: int | java.jint | Integer, fromIndex: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    def indexOf(self, str: str | String, fromIndex: int | java.jint | Integer, /) -> int: ...
    def intern(self) -> str: ...
    def isBlank(self) -> bool: ...
    def isEmpty(self) -> bool: ...
    @typing.overload
    @staticmethod
    def join(delimiter: CharSequence, elements: Iterable[CharSequence], /) -> str: ...
    @typing.overload
    @staticmethod
    def join(delimiter: CharSequence, /, *elements: CharSequence) -> str: ...
    @typing.overload
    def lastIndexOf(self, ch: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    def lastIndexOf(self, str: str | String, /) -> int: ...
    @typing.overload
    def lastIndexOf(self, ch: int | java.jint | Integer, fromIndex: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    def lastIndexOf(self, str: str | String, fromIndex: int | java.jint | Integer, /) -> int: ...
    def length(self) -> int: ...
    def lines(self) -> java.util.stream.Stream[String]: ...
    def matches(self, regex: str | String, /) -> bool: ...
    def offsetByCodePoints(self, index: int | java.jint | Integer, codePointOffset: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    def regionMatches(self, toffset: int | java.jint | Integer, other: str | String, ooffset: int | java.jint | Integer, len: int | java.jint | Integer, /) -> bool: ...
    @typing.overload
    def regionMatches(self, ignoreCase: bool | java.jboolean | Boolean, toffset: int | java.jint | Integer, other: str | String, ooffset: int | java.jint | Integer, len: int | java.jint | Integer, /) -> bool: ...
    def repeat(self, count: int | java.jint | Integer, /) -> str: ...
    @typing.overload
    def replace(self, oldChar: str | java.jchar | Character, newChar: str | java.jchar | Character, /) -> str: ...
    @typing.overload
    def replace(self, target: CharSequence, replacement: CharSequence, /) -> str: ...
    def replaceAll(self, regex: str | String, replacement: str | String, /) -> str: ...
    def replaceFirst(self, regex: str | String, replacement: str | String, /) -> str: ...
    @typing.overload
    def split(self, regex: str | String, /) -> java.chaquopy.JavaArray[String]: ...
    @typing.overload
    def split(self, regex: str | String, limit: int | java.jint | Integer, /) -> java.chaquopy.JavaArray[String]: ...
    @typing.overload
    def startsWith(self, prefix: str | String, /) -> bool: ...
    @typing.overload
    def startsWith(self, prefix: str | String, toffset: int | java.jint | Integer, /) -> bool: ...
    def strip(self) -> str: ...
    def stripIndent(self) -> str: ...
    def stripLeading(self) -> str: ...
    def stripTrailing(self) -> str: ...
    def subSequence(self, beginIndex: int | java.jint | Integer, endIndex: int | java.jint | Integer, /) -> CharSequence: ...
    @typing.overload
    def substring(self, beginIndex: int | java.jint | Integer, /) -> str: ...
    @typing.overload
    def substring(self, beginIndex: int | java.jint | Integer, endIndex: int | java.jint | Integer, /) -> str: ...
    def toCharArray(self) -> java.chaquopy.JavaArrayJChar: ...
    @typing.overload
    def toLowerCase(self) -> str: ...
    @typing.overload
    def toLowerCase(self, locale: java.util.Locale, /) -> str: ...
    def toString(self) -> str: ...
    @typing.overload
    def toUpperCase(self) -> str: ...
    @typing.overload
    def toUpperCase(self, locale: java.util.Locale, /) -> str: ...
    _transform__R = typing.TypeVar('_transform__R')  # <R>
    def transform(self, f: java.util.function.Function[str, _transform__R], /) -> _transform__R: ...
    def translateEscapes(self) -> str: ...
    def trim(self) -> str: ...
    @typing.overload
    @staticmethod
    def valueOf(c: str | java.jchar | Character, /) -> str: ...
    @typing.overload
    @staticmethod
    def valueOf(d: float | java.jdouble | Double, /) -> str: ...
    @typing.overload
    @staticmethod
    def valueOf(f: float | java.jfloat | Float, /) -> str: ...
    @typing.overload
    @staticmethod
    def valueOf(i: int | java.jint | Integer, /) -> str: ...
    @typing.overload
    @staticmethod
    def valueOf(l: int | java.jlong | Long, /) -> str: ...
    @typing.overload
    @staticmethod
    def valueOf(obj: Object | int | bool | float | str, /) -> str: ...
    @typing.overload
    @staticmethod
    def valueOf(b: bool | java.jboolean | Boolean, /) -> str: ...
    @typing.overload
    @staticmethod
    def valueOf(data: java.chaquopy.JavaArrayJChar, /) -> str: ...
    @typing.overload
    @staticmethod
    def valueOf(data: java.chaquopy.JavaArrayJChar, offset: int | java.jint | Integer, count: int | java.jint | Integer, /) -> str: ...

class StringBuffer(Appendable, CharSequence, java.io.Serializable, Comparable[StringBuffer]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, capacity: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def __init__(self, seq: CharSequence, /) -> None: ...
    @typing.overload
    def __init__(self, str: str | String, /) -> None: ...
    @typing.overload
    def append(self, c: str | java.jchar | Character, /) -> StringBuffer: ...
    @typing.overload
    def append(self, d: float | java.jdouble | Double, /) -> StringBuffer: ...
    @typing.overload
    def append(self, f: float | java.jfloat | Float, /) -> StringBuffer: ...
    @typing.overload
    def append(self, i: int | java.jint | Integer, /) -> StringBuffer: ...
    @typing.overload
    def append(self, lng: int | java.jlong | Long, /) -> StringBuffer: ...
    @typing.overload
    def append(self, s: CharSequence, /) -> StringBuffer: ...
    @typing.overload
    def append(self, obj: Object | int | bool | float | str, /) -> StringBuffer: ...
    @typing.overload
    def append(self, str: str | String, /) -> StringBuffer: ...
    @typing.overload
    def append(self, sb: StringBuffer, /) -> StringBuffer: ...
    @typing.overload
    def append(self, b: bool | java.jboolean | Boolean, /) -> StringBuffer: ...
    @typing.overload
    def append(self, str: java.chaquopy.JavaArrayJChar, /) -> StringBuffer: ...
    @typing.overload
    def append(self, s: CharSequence, start: int | java.jint | Integer, end: int | java.jint | Integer, /) -> StringBuffer: ...
    @typing.overload
    def append(self, str: java.chaquopy.JavaArrayJChar, offset: int | java.jint | Integer, len: int | java.jint | Integer, /) -> StringBuffer: ...
    def appendCodePoint(self, codePoint: int | java.jint | Integer, /) -> StringBuffer: ...
    def capacity(self) -> int: ...
    def charAt(self, index: int | java.jint | Integer, /) -> str: ...
    def chars(self) -> java.util.stream.IntStream: ...
    def codePointAt(self, index: int | java.jint | Integer, /) -> int: ...
    def codePointBefore(self, index: int | java.jint | Integer, /) -> int: ...
    def codePointCount(self, beginIndex: int | java.jint | Integer, endIndex: int | java.jint | Integer, /) -> int: ...
    def codePoints(self) -> java.util.stream.IntStream: ...
    def compareTo(self, another: StringBuffer, /) -> int: ...
    def delete(self, start: int | java.jint | Integer, end: int | java.jint | Integer, /) -> StringBuffer: ...
    def deleteCharAt(self, index: int | java.jint | Integer, /) -> StringBuffer: ...
    def ensureCapacity(self, minimumCapacity: int | java.jint | Integer, /) -> None: ...
    def getChars(self, srcBegin: int | java.jint | Integer, srcEnd: int | java.jint | Integer, dst: java.chaquopy.JavaArrayJChar, dstBegin: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def indexOf(self, str: str | String, /) -> int: ...
    @typing.overload
    def indexOf(self, str: str | String, fromIndex: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, c: str | java.jchar | Character, /) -> StringBuffer: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, d: float | java.jdouble | Double, /) -> StringBuffer: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, f: float | java.jfloat | Float, /) -> StringBuffer: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, i: int | java.jint | Integer, /) -> StringBuffer: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, l: int | java.jlong | Long, /) -> StringBuffer: ...
    @typing.overload
    def insert(self, dstOffset: int | java.jint | Integer, s: CharSequence, /) -> StringBuffer: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, obj: Object | int | bool | float | str, /) -> StringBuffer: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, str: str | String, /) -> StringBuffer: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, b: bool | java.jboolean | Boolean, /) -> StringBuffer: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, str: java.chaquopy.JavaArrayJChar, /) -> StringBuffer: ...
    @typing.overload
    def insert(self, dstOffset: int | java.jint | Integer, s: CharSequence, start: int | java.jint | Integer, end: int | java.jint | Integer, /) -> StringBuffer: ...
    @typing.overload
    def insert(self, index: int | java.jint | Integer, str: java.chaquopy.JavaArrayJChar, offset: int | java.jint | Integer, len: int | java.jint | Integer, /) -> StringBuffer: ...
    @typing.overload
    def lastIndexOf(self, str: str | String, /) -> int: ...
    @typing.overload
    def lastIndexOf(self, str: str | String, fromIndex: int | java.jint | Integer, /) -> int: ...
    def length(self) -> int: ...
    def offsetByCodePoints(self, index: int | java.jint | Integer, codePointOffset: int | java.jint | Integer, /) -> int: ...
    def replace(self, start: int | java.jint | Integer, end: int | java.jint | Integer, str: str | String, /) -> StringBuffer: ...
    def reverse(self) -> StringBuffer: ...
    def setCharAt(self, index: int | java.jint | Integer, ch: str | java.jchar | Character, /) -> None: ...
    def setLength(self, newLength: int | java.jint | Integer, /) -> None: ...
    def subSequence(self, start: int | java.jint | Integer, end: int | java.jint | Integer, /) -> CharSequence: ...
    @typing.overload
    def substring(self, start: int | java.jint | Integer, /) -> str: ...
    @typing.overload
    def substring(self, start: int | java.jint | Integer, end: int | java.jint | Integer, /) -> str: ...
    def toString(self) -> str: ...
    def trimToSize(self) -> None: ...

class StringBuilder(Appendable, CharSequence, java.io.Serializable, Comparable[StringBuilder]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, capacity: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def __init__(self, seq: CharSequence, /) -> None: ...
    @typing.overload
    def __init__(self, str: str | String, /) -> None: ...
    @typing.overload
    def append(self, c: str | java.jchar | Character, /) -> StringBuilder: ...
    @typing.overload
    def append(self, d: float | java.jdouble | Double, /) -> StringBuilder: ...
    @typing.overload
    def append(self, f: float | java.jfloat | Float, /) -> StringBuilder: ...
    @typing.overload
    def append(self, i: int | java.jint | Integer, /) -> StringBuilder: ...
    @typing.overload
    def append(self, lng: int | java.jlong | Long, /) -> StringBuilder: ...
    @typing.overload
    def append(self, s: CharSequence, /) -> StringBuilder: ...
    @typing.overload
    def append(self, obj: Object | int | bool | float | str, /) -> StringBuilder: ...
    @typing.overload
    def append(self, str: str | String, /) -> StringBuilder: ...
    @typing.overload
    def append(self, sb: StringBuffer, /) -> StringBuilder: ...
    @typing.overload
    def append(self, b: bool | java.jboolean | Boolean, /) -> StringBuilder: ...
    @typing.overload
    def append(self, str: java.chaquopy.JavaArrayJChar, /) -> StringBuilder: ...
    @typing.overload
    def append(self, s: CharSequence, start: int | java.jint | Integer, end: int | java.jint | Integer, /) -> StringBuilder: ...
    @typing.overload
    def append(self, str: java.chaquopy.JavaArrayJChar, offset: int | java.jint | Integer, len: int | java.jint | Integer, /) -> StringBuilder: ...
    def appendCodePoint(self, codePoint: int | java.jint | Integer, /) -> StringBuilder: ...
    def capacity(self) -> int: ...
    def charAt(self, index: int | java.jint | Integer, /) -> str: ...
    def chars(self) -> java.util.stream.IntStream: ...
    def codePointAt(self, index: int | java.jint | Integer, /) -> int: ...
    def codePointBefore(self, index: int | java.jint | Integer, /) -> int: ...
    def codePointCount(self, beginIndex: int | java.jint | Integer, endIndex: int | java.jint | Integer, /) -> int: ...
    def codePoints(self) -> java.util.stream.IntStream: ...
    def compareTo(self, another: StringBuilder, /) -> int: ...
    def delete(self, start: int | java.jint | Integer, end: int | java.jint | Integer, /) -> StringBuilder: ...
    def deleteCharAt(self, index: int | java.jint | Integer, /) -> StringBuilder: ...
    def ensureCapacity(self, minimumCapacity: int | java.jint | Integer, /) -> None: ...
    def getChars(self, srcBegin: int | java.jint | Integer, srcEnd: int | java.jint | Integer, dst: java.chaquopy.JavaArrayJChar, dstBegin: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def indexOf(self, str: str | String, /) -> int: ...
    @typing.overload
    def indexOf(self, str: str | String, fromIndex: int | java.jint | Integer, /) -> int: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, c: str | java.jchar | Character, /) -> StringBuilder: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, d: float | java.jdouble | Double, /) -> StringBuilder: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, f: float | java.jfloat | Float, /) -> StringBuilder: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, i: int | java.jint | Integer, /) -> StringBuilder: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, l: int | java.jlong | Long, /) -> StringBuilder: ...
    @typing.overload
    def insert(self, dstOffset: int | java.jint | Integer, s: CharSequence, /) -> StringBuilder: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, obj: Object | int | bool | float | str, /) -> StringBuilder: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, str: str | String, /) -> StringBuilder: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, b: bool | java.jboolean | Boolean, /) -> StringBuilder: ...
    @typing.overload
    def insert(self, offset: int | java.jint | Integer, str: java.chaquopy.JavaArrayJChar, /) -> StringBuilder: ...
    @typing.overload
    def insert(self, dstOffset: int | java.jint | Integer, s: CharSequence, start: int | java.jint | Integer, end: int | java.jint | Integer, /) -> StringBuilder: ...
    @typing.overload
    def insert(self, index: int | java.jint | Integer, str: java.chaquopy.JavaArrayJChar, offset: int | java.jint | Integer, len: int | java.jint | Integer, /) -> StringBuilder: ...
    @typing.overload
    def lastIndexOf(self, str: str | String, /) -> int: ...
    @typing.overload
    def lastIndexOf(self, str: str | String, fromIndex: int | java.jint | Integer, /) -> int: ...
    def length(self) -> int: ...
    def offsetByCodePoints(self, index: int | java.jint | Integer, codePointOffset: int | java.jint | Integer, /) -> int: ...
    def replace(self, start: int | java.jint | Integer, end: int | java.jint | Integer, str: str | String, /) -> StringBuilder: ...
    def reverse(self) -> StringBuilder: ...
    def setCharAt(self, index: int | java.jint | Integer, ch: str | java.jchar | Character, /) -> None: ...
    def setLength(self, newLength: int | java.jint | Integer, /) -> None: ...
    def subSequence(self, start: int | java.jint | Integer, end: int | java.jint | Integer, /) -> CharSequence: ...
    @typing.overload
    def substring(self, start: int | java.jint | Integer, /) -> str: ...
    @typing.overload
    def substring(self, start: int | java.jint | Integer, end: int | java.jint | Integer, /) -> str: ...
    def toString(self) -> str: ...
    def trimToSize(self) -> None: ...

class StringIndexOutOfBoundsException(IndexOutOfBoundsException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, index: int | java.jint | Integer, /) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class SuppressWarnings(java.lang.annotation.Annotation):
    def value(self) -> java.chaquopy.JavaArray[String]: ...

class System(Object):
    err: typing.ClassVar[java.io.PrintStream] = ...
    in_: typing.ClassVar[java.io.InputStream] = ...
    out: typing.ClassVar[java.io.PrintStream] = ...
    @staticmethod
    def arraycopy(arg1: Object | int | bool | float | str, arg2: int | java.jint | Integer, arg3: Object | int | bool | float | str, arg4: int | java.jint | Integer, arg5: int | java.jint | Integer, /) -> None: ...
    @staticmethod
    def clearProperty(key: str | String, /) -> str: ...
    @staticmethod
    def console() -> java.io.Console | None: ...
    @staticmethod
    def currentTimeMillis() -> int: ...
    @staticmethod
    def exit(status: int | java.jint | Integer, /) -> None: ...
    @staticmethod
    def gc() -> None: ...
    @staticmethod
    def getProperties() -> java.util.Properties: ...
    @typing.overload
    @staticmethod
    def getProperty(key: str | String, /) -> str | None: ...
    @typing.overload
    @staticmethod
    def getProperty(key: str | String, def_: str | String, /) -> str: ...
    @staticmethod
    def getSecurityManager() -> SecurityManager | None: ...
    @typing.overload
    @staticmethod
    def getenv() -> java.util.Map[String, String]: ...
    @typing.overload
    @staticmethod
    def getenv(name: str | String, /) -> str | None: ...
    @staticmethod
    def identityHashCode(x: Object | int | bool | float | str, /) -> int: ...
    @staticmethod
    def inheritedChannel() -> java.nio.channels.Channel: ...
    @staticmethod
    def lineSeparator() -> str: ...
    @staticmethod
    def load(filename: str | String, /) -> None: ...
    @staticmethod
    def loadLibrary(libname: str | String, /) -> None: ...
    @staticmethod
    def mapLibraryName(arg1: str | String, /) -> str: ...
    @staticmethod
    def nanoTime() -> int: ...
    @staticmethod
    def runFinalization() -> None: ...
    @staticmethod
    def runFinalizersOnExit(value: bool | java.jboolean | Boolean, /) -> None: ...
    @staticmethod
    def setErr(err: java.io.PrintStream, /) -> None: ...
    @staticmethod
    def setIn(in_: java.io.InputStream, /) -> None: ...
    @staticmethod
    def setOut(out: java.io.PrintStream, /) -> None: ...
    @staticmethod
    def setProperties(props: java.util.Properties, /) -> None: ...
    @staticmethod
    def setProperty(key: str | String, value: str | String, /) -> str: ...
    @staticmethod
    def setSecurityManager(s: SecurityManager, /) -> None: ...

class Thread(Runnable):
    MAX_PRIORITY: typing.ClassVar[int] = ...
    MIN_PRIORITY: typing.ClassVar[int] = ...
    NORM_PRIORITY: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, target: Runnable, /) -> None: ...
    @typing.overload
    def __init__(self, name: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, target: Runnable, name: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, group: ThreadGroup, target: Runnable, /) -> None: ...
    @typing.overload
    def __init__(self, group: ThreadGroup, name: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, group: ThreadGroup, target: Runnable, name: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, group: ThreadGroup, target: Runnable, name: str | String, stackSize: int | java.jlong | Long, /) -> None: ...
    @typing.overload
    def __init__(self, group: ThreadGroup, target: Runnable, name: str | String, stackSize: int | java.jlong | Long, inheritThreadLocals: bool | java.jboolean | Boolean, /) -> None: ...
    @staticmethod
    def activeCount() -> int: ...
    def checkAccess(self) -> None: ...
    def clone(self) -> Object: ...
    def countStackFrames(self) -> int: ...
    @staticmethod
    def currentThread() -> Thread: ...
    def destroy(self) -> None: ...
    @staticmethod
    def dumpStack() -> None: ...
    @staticmethod
    def enumerate(tarray: java.chaquopy.JavaArray[Thread], /) -> int: ...
    @staticmethod
    def getAllStackTraces() -> java.util.Map[Thread, java.chaquopy.JavaArray[StackTraceElement]]: ...
    def getContextClassLoader(self) -> ClassLoader | None: ...
    @staticmethod
    def getDefaultUncaughtExceptionHandler() -> Thread.UncaughtExceptionHandler | None: ...
    def getId(self) -> int: ...
    def getName(self) -> str: ...
    def getPriority(self) -> int: ...
    def getStackTrace(self) -> java.chaquopy.JavaArray[StackTraceElement]: ...
    def getState(self) -> Thread.State: ...
    def getThreadGroup(self) -> ThreadGroup: ...
    def getUncaughtExceptionHandler(self) -> Thread.UncaughtExceptionHandler | None: ...
    @staticmethod
    def holdsLock(arg1: Object | int | bool | float | str, /) -> bool: ...
    def interrupt(self) -> None: ...
    @staticmethod
    def interrupted() -> bool: ...
    def isAlive(self) -> bool: ...
    def isDaemon(self) -> bool: ...
    def isInterrupted(self) -> bool: ...
    @typing.overload
    def join(self) -> None: ...
    @typing.overload
    def join(self, millis: int | java.jlong | Long, /) -> None: ...
    @typing.overload
    def join(self, millis: int | java.jlong | Long, nanos: int | java.jint | Integer, /) -> None: ...
    @staticmethod
    def onSpinWait() -> None: ...
    def resume(self) -> None: ...
    def run(self) -> None: ...
    def setContextClassLoader(self, cl: ClassLoader, /) -> None: ...
    def setDaemon(self, on: bool | java.jboolean | Boolean, /) -> None: ...
    @staticmethod
    def setDefaultUncaughtExceptionHandler(eh: Thread.UncaughtExceptionHandler, /) -> None: ...
    def setName(self, name: str | String, /) -> None: ...
    def setPriority(self, newPriority: int | java.jint | Integer, /) -> None: ...
    def setUncaughtExceptionHandler(self, eh: Thread.UncaughtExceptionHandler, /) -> None: ...
    @typing.overload
    @staticmethod
    def sleep(millis: int | java.jlong | Long, /) -> None: ...
    @typing.overload
    @staticmethod
    def sleep(millis: int | java.jlong | Long, nanos: int | java.jint | Integer, /) -> None: ...
    def start(self) -> None: ...
    @typing.overload
    def stop(self) -> None: ...
    @typing.overload
    def stop(self, obj: Throwable, /) -> None: ...
    def suspend(self) -> None: ...
    def toString(self) -> str: ...
    @staticmethod
    def yield_() -> None: ...

    class UncaughtExceptionHandler(Object):
        def uncaughtException(self, arg1: Thread, arg2: Throwable, /) -> None: ...

    class State(Enum[Thread.State]):
        NEW: typing.ClassVar[Thread.State] = ...
        RUNNABLE: typing.ClassVar[Thread.State] = ...
        BLOCKED: typing.ClassVar[Thread.State] = ...
        WAITING: typing.ClassVar[Thread.State] = ...
        TIMED_WAITING: typing.ClassVar[Thread.State] = ...
        TERMINATED: typing.ClassVar[Thread.State] = ...
        @staticmethod
        def valueOf(name: str | String, /) -> Thread.State: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[Thread.State]: ...

class ThreadDeath(Error):
    def __init__(self) -> None: ...

class ThreadGroup(java.lang.Thread.UncaughtExceptionHandler):
    @typing.overload
    def __init__(self, name: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, parent: ThreadGroup, name: str | String, /) -> None: ...
    def activeCount(self) -> int: ...
    def activeGroupCount(self) -> int: ...
    def allowThreadSuspension(self, b: bool | java.jboolean | Boolean, /) -> bool: ...
    def checkAccess(self) -> None: ...
    def destroy(self) -> None: ...
    @typing.overload
    def enumerate(self, list: java.chaquopy.JavaArray[Thread], /) -> int: ...
    @typing.overload
    def enumerate(self, list: java.chaquopy.JavaArray[ThreadGroup], /) -> int: ...
    @typing.overload
    def enumerate(self, list: java.chaquopy.JavaArray[Thread], recurse: bool | java.jboolean | Boolean, /) -> int: ...
    @typing.overload
    def enumerate(self, list: java.chaquopy.JavaArray[ThreadGroup], recurse: bool | java.jboolean | Boolean, /) -> int: ...
    def getMaxPriority(self) -> int: ...
    def getName(self) -> str: ...
    def getParent(self) -> ThreadGroup | None: ...
    def interrupt(self) -> None: ...
    def isDaemon(self) -> bool: ...
    def isDestroyed(self) -> bool: ...
    def list(self) -> None: ...
    def parentOf(self, g: ThreadGroup, /) -> bool: ...
    def resume(self) -> None: ...
    def setDaemon(self, daemon: bool | java.jboolean | Boolean, /) -> None: ...
    def setMaxPriority(self, pri: int | java.jint | Integer, /) -> None: ...
    def stop(self) -> None: ...
    def suspend(self) -> None: ...
    def toString(self) -> str: ...
    def uncaughtException(self, t: Thread, e: Throwable, /) -> None: ...

_ThreadLocal__T = typing.TypeVar('_ThreadLocal__T')  # <T>
class ThreadLocal(Object, typing.Generic[_ThreadLocal__T]):
    def __init__(self) -> None: ...
    def get(self) -> _ThreadLocal__T | None: ...
    def initialValue(self) -> _ThreadLocal__T: ...
    def remove(self) -> None: ...
    def set(self, value: _ThreadLocal__T, /) -> None: ...
    _withInitial__S = typing.TypeVar('_withInitial__S')  # <S>
    @staticmethod
    def withInitial(supplier: java.util.function.Supplier[_withInitial__S], /) -> ThreadLocal[_withInitial__S]: ...

class Throwable(java.io.Serializable, builtins.Exception):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, cause: Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, cause: Throwable, enableSuppression: bool | java.jboolean | Boolean, writableStackTrace: bool | java.jboolean | Boolean, /) -> None: ...
    def addSuppressed(self, exception: Throwable, /) -> None: ...
    def fillInStackTrace(self) -> Throwable: ...
    def getCause(self) -> Throwable: ...
    def getLocalizedMessage(self) -> str: ...
    def getMessage(self) -> str: ...
    def getStackTrace(self) -> java.chaquopy.JavaArray[StackTraceElement]: ...
    def getSuppressed(self) -> java.chaquopy.JavaArray[Throwable]: ...
    def initCause(self, cause: Throwable, /) -> Throwable: ...
    @typing.overload
    def printStackTrace(self) -> None: ...
    @typing.overload
    def printStackTrace(self, s: java.io.PrintStream, /) -> None: ...
    @typing.overload
    def printStackTrace(self, s: java.io.PrintWriter, /) -> None: ...
    def setStackTrace(self, stackTrace: java.chaquopy.JavaArray[StackTraceElement], /) -> None: ...
    def toString(self) -> str: ...

class TypeNotPresentException(RuntimeException):
    def __init__(self, typeName: str | String, cause: Throwable, /) -> None: ...
    def typeName(self) -> str: ...

class UnknownError(VirtualMachineError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class UnsatisfiedLinkError(LinkageError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class UnsupportedClassVersionError(ClassFormatError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class UnsupportedOperationException(RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, cause: Throwable, /) -> None: ...

class VerifyError(LinkageError):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, s: str | String, /) -> None: ...

class VirtualMachineError(Error):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, /) -> None: ...
    @typing.overload
    def __init__(self, cause: Throwable, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | String, cause: Throwable, /) -> None: ...

class Void(Object):
    TYPE: typing.ClassVar[typing.Type[Void]] = ...
