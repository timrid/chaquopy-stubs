import java
import java.chaquopy
import java.io
import java.lang
import java.nio
import java.util
import typing



class CharacterCodingException(java.io.IOException):
    def __init__(self) -> None: ...

class Charset(java.lang.Comparable[Charset]):
    def __init__(self, canonicalName: str | java.lang.String, aliases: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def aliases(self) -> java.util.Set[java.lang.String]: ...
    @staticmethod
    def availableCharsets() -> java.util.SortedMap[java.lang.String, Charset]: ...
    def canEncode(self) -> bool: ...
    def compareTo(self, that: Charset, /) -> int: ...
    def contains(self, arg1: Charset, /) -> bool: ...
    def decode(self, bb: java.nio.ByteBuffer, /) -> java.nio.CharBuffer: ...
    @staticmethod
    def defaultCharset() -> Charset: ...
    @typing.overload
    def displayName(self) -> str: ...
    @typing.overload
    def displayName(self, locale: java.util.Locale, /) -> str: ...
    @typing.overload
    def encode(self, str: str | java.lang.String, /) -> java.nio.ByteBuffer: ...
    @typing.overload
    def encode(self, cb: java.nio.CharBuffer, /) -> java.nio.ByteBuffer: ...
    def equals(self, ob: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def forName(charsetName: str | java.lang.String, /) -> Charset: ...
    def hashCode(self) -> int: ...
    def isRegistered(self) -> bool: ...
    @staticmethod
    def isSupported(charsetName: str | java.lang.String, /) -> bool: ...
    def name(self) -> str: ...
    def newDecoder(self) -> CharsetDecoder: ...
    def newEncoder(self) -> CharsetEncoder: ...
    def toString(self) -> str: ...

class CharsetDecoder(java.lang.Object):
    def __init__(self, cs: Charset, averageCharsPerByte: float | java.jfloat | java.lang.Float, maxCharsPerByte: float | java.jfloat | java.lang.Float, /) -> None: ...
    def averageCharsPerByte(self) -> float: ...
    def charset(self) -> Charset: ...
    @typing.overload
    def decode(self, in_: java.nio.ByteBuffer, /) -> java.nio.CharBuffer: ...
    @typing.overload
    def decode(self, in_: java.nio.ByteBuffer, out: java.nio.CharBuffer, endOfInput: bool | java.jboolean | java.lang.Boolean, /) -> CoderResult: ...
    def decodeLoop(self, arg1: java.nio.ByteBuffer, arg2: java.nio.CharBuffer, /) -> CoderResult: ...
    def detectedCharset(self) -> Charset: ...
    def flush(self, out: java.nio.CharBuffer, /) -> CoderResult: ...
    def implFlush(self, out: java.nio.CharBuffer, /) -> CoderResult: ...
    def implOnMalformedInput(self, newAction: CodingErrorAction, /) -> None: ...
    def implOnUnmappableCharacter(self, newAction: CodingErrorAction, /) -> None: ...
    def implReplaceWith(self, newReplacement: str | java.lang.String, /) -> None: ...
    def implReset(self) -> None: ...
    def isAutoDetecting(self) -> bool: ...
    def isCharsetDetected(self) -> bool: ...
    def malformedInputAction(self) -> CodingErrorAction: ...
    def maxCharsPerByte(self) -> float: ...
    def onMalformedInput(self, newAction: CodingErrorAction, /) -> CharsetDecoder: ...
    def onUnmappableCharacter(self, newAction: CodingErrorAction, /) -> CharsetDecoder: ...
    def replaceWith(self, newReplacement: str | java.lang.String, /) -> CharsetDecoder: ...
    def replacement(self) -> str: ...
    def reset(self) -> CharsetDecoder: ...
    def unmappableCharacterAction(self) -> CodingErrorAction: ...

class CharsetEncoder(java.lang.Object):
    @typing.overload
    def __init__(self, cs: Charset, averageBytesPerChar: float | java.jfloat | java.lang.Float, maxBytesPerChar: float | java.jfloat | java.lang.Float, /) -> None: ...
    @typing.overload
    def __init__(self, cs: Charset, averageBytesPerChar: float | java.jfloat | java.lang.Float, maxBytesPerChar: float | java.jfloat | java.lang.Float, replacement: java.chaquopy.JavaArrayJByte, /) -> None: ...
    def averageBytesPerChar(self) -> float: ...
    @typing.overload
    def canEncode(self, c: str | java.jchar | java.lang.Character, /) -> bool: ...
    @typing.overload
    def canEncode(self, cs: java.lang.CharSequence, /) -> bool: ...
    def charset(self) -> Charset: ...
    @typing.overload
    def encode(self, in_: java.nio.CharBuffer, /) -> java.nio.ByteBuffer: ...
    @typing.overload
    def encode(self, in_: java.nio.CharBuffer, out: java.nio.ByteBuffer, endOfInput: bool | java.jboolean | java.lang.Boolean, /) -> CoderResult: ...
    def encodeLoop(self, arg1: java.nio.CharBuffer, arg2: java.nio.ByteBuffer, /) -> CoderResult: ...
    def flush(self, out: java.nio.ByteBuffer, /) -> CoderResult: ...
    def implFlush(self, out: java.nio.ByteBuffer, /) -> CoderResult: ...
    def implOnMalformedInput(self, newAction: CodingErrorAction, /) -> None: ...
    def implOnUnmappableCharacter(self, newAction: CodingErrorAction, /) -> None: ...
    def implReplaceWith(self, newReplacement: java.chaquopy.JavaArrayJByte, /) -> None: ...
    def implReset(self) -> None: ...
    def isLegalReplacement(self, repl: java.chaquopy.JavaArrayJByte, /) -> bool: ...
    def malformedInputAction(self) -> CodingErrorAction: ...
    def maxBytesPerChar(self) -> float: ...
    def onMalformedInput(self, newAction: CodingErrorAction, /) -> CharsetEncoder: ...
    def onUnmappableCharacter(self, newAction: CodingErrorAction, /) -> CharsetEncoder: ...
    def replaceWith(self, newReplacement: java.chaquopy.JavaArrayJByte, /) -> CharsetEncoder: ...
    def replacement(self) -> java.chaquopy.JavaArrayJByte: ...
    def reset(self) -> CharsetEncoder: ...
    def unmappableCharacterAction(self) -> CodingErrorAction: ...

class CoderMalfunctionError(java.lang.Error):
    def __init__(self, cause: java.lang.Exception, /) -> None: ...

class CoderResult(java.lang.Object):
    OVERFLOW: typing.ClassVar[CoderResult] = ...
    UNDERFLOW: typing.ClassVar[CoderResult] = ...
    def isError(self) -> bool: ...
    def isMalformed(self) -> bool: ...
    def isOverflow(self) -> bool: ...
    def isUnderflow(self) -> bool: ...
    def isUnmappable(self) -> bool: ...
    def length(self) -> int: ...
    @staticmethod
    def malformedForLength(length: int | java.jint | java.lang.Integer, /) -> CoderResult: ...
    def throwException(self) -> None: ...
    def toString(self) -> str: ...
    @staticmethod
    def unmappableForLength(length: int | java.jint | java.lang.Integer, /) -> CoderResult: ...

class CodingErrorAction(java.lang.Object):
    IGNORE: typing.ClassVar[CodingErrorAction] = ...
    REPLACE: typing.ClassVar[CodingErrorAction] = ...
    REPORT: typing.ClassVar[CodingErrorAction] = ...
    def toString(self) -> str: ...

class IllegalCharsetNameException(java.lang.IllegalArgumentException):
    def __init__(self, charsetName: str | java.lang.String, /) -> None: ...
    def getCharsetName(self) -> str: ...

class MalformedInputException(CharacterCodingException):
    def __init__(self, inputLength: int | java.jint | java.lang.Integer, /) -> None: ...
    def getInputLength(self) -> int: ...
    def getMessage(self) -> str: ...

class StandardCharsets(java.lang.Object):
    ISO_8859_1: typing.ClassVar[Charset] = ...
    US_ASCII: typing.ClassVar[Charset] = ...
    UTF_16: typing.ClassVar[Charset] = ...
    UTF_16BE: typing.ClassVar[Charset] = ...
    UTF_16LE: typing.ClassVar[Charset] = ...
    UTF_8: typing.ClassVar[Charset] = ...

class UnmappableCharacterException(CharacterCodingException):
    def __init__(self, inputLength: int | java.jint | java.lang.Integer, /) -> None: ...
    def getInputLength(self) -> int: ...
    def getMessage(self) -> str: ...

class UnsupportedCharsetException(java.lang.IllegalArgumentException):
    def __init__(self, charsetName: str | java.lang.String, /) -> None: ...
    def getCharsetName(self) -> str: ...
