import java
import java.chaquopy
import java.io
import java.lang
import java.nio.channels
import java.nio.charset
import java.security
import java.security.cert
import java.util
import java.util.jar
import typing



class Authenticator(java.lang.Object):
    def __init__(self) -> None: ...
    def getPasswordAuthentication(self) -> PasswordAuthentication: ...
    def getRequestingHost(self) -> str: ...
    def getRequestingPort(self) -> int: ...
    def getRequestingPrompt(self) -> str: ...
    def getRequestingProtocol(self) -> str: ...
    def getRequestingScheme(self) -> str: ...
    def getRequestingSite(self) -> InetAddress: ...
    def getRequestingURL(self) -> URL: ...
    def getRequestorType(self) -> Authenticator.RequestorType: ...
    @typing.overload
    @staticmethod
    def requestPasswordAuthentication(addr: InetAddress, port: int | java.jint | java.lang.Integer, protocol: str | java.lang.String, prompt: str | java.lang.String, scheme: str | java.lang.String, /) -> PasswordAuthentication: ...
    @typing.overload
    @staticmethod
    def requestPasswordAuthentication(host: str | java.lang.String, addr: InetAddress, port: int | java.jint | java.lang.Integer, protocol: str | java.lang.String, prompt: str | java.lang.String, scheme: str | java.lang.String, /) -> PasswordAuthentication: ...
    @typing.overload
    @staticmethod
    def requestPasswordAuthentication(host: str | java.lang.String, addr: InetAddress, port: int | java.jint | java.lang.Integer, protocol: str | java.lang.String, prompt: str | java.lang.String, scheme: str | java.lang.String, url: URL, reqType: Authenticator.RequestorType, /) -> PasswordAuthentication: ...
    @staticmethod
    def setDefault(a: Authenticator, /) -> None: ...

    class RequestorType(java.lang.Enum[Authenticator.RequestorType]):
        PROXY: typing.ClassVar[Authenticator.RequestorType] = ...
        SERVER: typing.ClassVar[Authenticator.RequestorType] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> Authenticator.RequestorType: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[Authenticator.RequestorType]: ...

class BindException(SocketException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class CacheRequest(java.lang.Object):
    def __init__(self) -> None: ...
    def abort(self) -> None: ...
    def getBody(self) -> java.io.OutputStream: ...

class CacheResponse(java.lang.Object):
    def __init__(self) -> None: ...
    def getBody(self) -> java.io.InputStream: ...
    def getHeaders(self) -> java.util.Map[java.lang.String, java.util.List[java.lang.String]]: ...

class ConnectException(SocketException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class ContentHandler(java.lang.Object):
    def __init__(self) -> None: ...
    @typing.overload
    def getContent(self, arg1: URLConnection, /) -> java.lang.Object: ...
    @typing.overload
    def getContent(self, urlc: URLConnection, classes: java.chaquopy.JavaArray[typing.Type], /) -> java.lang.Object: ...

class ContentHandlerFactory(java.lang.Object):
    def createContentHandler(self, arg1: str | java.lang.String, /) -> ContentHandler: ...

class CookieHandler(java.lang.Object):
    def __init__(self) -> None: ...
    def get(self, arg1: URI, arg2: java.util.Map[java.lang.String, java.util.List[java.lang.String]], /) -> java.util.Map[java.lang.String, java.util.List[java.lang.String]]: ...
    @staticmethod
    def getDefault() -> CookieHandler: ...
    def put(self, arg1: URI, arg2: java.util.Map[java.lang.String, java.util.List[java.lang.String]], /) -> None: ...
    @staticmethod
    def setDefault(cHandler: CookieHandler, /) -> None: ...

class CookieManager(CookieHandler):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, store: CookieStore, cookiePolicy: CookiePolicy, /) -> None: ...
    def get(self, uri: URI, requestHeaders: java.util.Map[java.lang.String, java.util.List[java.lang.String]], /) -> java.util.Map[java.lang.String, java.util.List[java.lang.String]]: ...
    def getCookieStore(self) -> CookieStore: ...
    def put(self, uri: URI, responseHeaders: java.util.Map[java.lang.String, java.util.List[java.lang.String]], /) -> None: ...
    def setCookiePolicy(self, cookiePolicy: CookiePolicy, /) -> None: ...

class CookiePolicy(java.lang.Object):
    ACCEPT_ALL: typing.ClassVar[CookiePolicy] = ...
    ACCEPT_NONE: typing.ClassVar[CookiePolicy] = ...
    ACCEPT_ORIGINAL_SERVER: typing.ClassVar[CookiePolicy] = ...
    def shouldAccept(self, arg1: URI, arg2: HttpCookie, /) -> bool: ...

class CookieStore(java.lang.Object):
    def add(self, arg1: URI, arg2: HttpCookie, /) -> None: ...
    def get(self, arg1: URI, /) -> java.util.List[HttpCookie]: ...
    def getCookies(self) -> java.util.List[HttpCookie]: ...
    def getURIs(self) -> java.util.List[URI]: ...
    def remove(self, arg1: URI, arg2: HttpCookie, /) -> bool: ...
    def removeAll(self) -> bool: ...

class DatagramPacket(java.lang.Object):
    @typing.overload
    def __init__(self, buf: java.chaquopy.JavaArrayJByte, length: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, buf: java.chaquopy.JavaArrayJByte, offset: int | java.jint | java.lang.Integer, length: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, buf: java.chaquopy.JavaArrayJByte, length: int | java.jint | java.lang.Integer, address: SocketAddress, /) -> None: ...
    @typing.overload
    def __init__(self, buf: java.chaquopy.JavaArrayJByte, offset: int | java.jint | java.lang.Integer, length: int | java.jint | java.lang.Integer, address: SocketAddress, /) -> None: ...
    @typing.overload
    def __init__(self, buf: java.chaquopy.JavaArrayJByte, length: int | java.jint | java.lang.Integer, address: InetAddress, port: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, buf: java.chaquopy.JavaArrayJByte, offset: int | java.jint | java.lang.Integer, length: int | java.jint | java.lang.Integer, address: InetAddress, port: int | java.jint | java.lang.Integer, /) -> None: ...
    def getAddress(self) -> InetAddress: ...
    def getData(self) -> java.chaquopy.JavaArrayJByte: ...
    def getLength(self) -> int: ...
    def getOffset(self) -> int: ...
    def getPort(self) -> int: ...
    def getSocketAddress(self) -> SocketAddress: ...
    def setAddress(self, iaddr: InetAddress, /) -> None: ...
    @typing.overload
    def setData(self, buf: java.chaquopy.JavaArrayJByte, /) -> None: ...
    @typing.overload
    def setData(self, buf: java.chaquopy.JavaArrayJByte, offset: int | java.jint | java.lang.Integer, length: int | java.jint | java.lang.Integer, /) -> None: ...
    def setLength(self, length: int | java.jint | java.lang.Integer, /) -> None: ...
    def setPort(self, iport: int | java.jint | java.lang.Integer, /) -> None: ...
    def setSocketAddress(self, address: SocketAddress, /) -> None: ...

class DatagramSocket(java.io.Closeable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, port: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, impl: DatagramSocketImpl, /) -> None: ...
    @typing.overload
    def __init__(self, bindaddr: SocketAddress, /) -> None: ...
    @typing.overload
    def __init__(self, port: int | java.jint | java.lang.Integer, laddr: InetAddress, /) -> None: ...
    def bind(self, addr: SocketAddress, /) -> None: ...
    def close(self) -> None: ...
    @typing.overload
    def connect(self, addr: SocketAddress, /) -> None: ...
    @typing.overload
    def connect(self, address: InetAddress, port: int | java.jint | java.lang.Integer, /) -> None: ...
    def disconnect(self) -> None: ...
    def getBroadcast(self) -> bool: ...
    def getChannel(self) -> java.nio.channels.DatagramChannel: ...
    def getInetAddress(self) -> InetAddress: ...
    def getLocalAddress(self) -> InetAddress: ...
    def getLocalPort(self) -> int: ...
    def getLocalSocketAddress(self) -> SocketAddress: ...
    _getOption__T = typing.TypeVar('_getOption__T')  # <T>
    def getOption(self, name: SocketOption[_getOption__T], /) -> _getOption__T: ...
    def getPort(self) -> int: ...
    def getReceiveBufferSize(self) -> int: ...
    def getRemoteSocketAddress(self) -> SocketAddress: ...
    def getReuseAddress(self) -> bool: ...
    def getSendBufferSize(self) -> int: ...
    def getSoTimeout(self) -> int: ...
    def getTrafficClass(self) -> int: ...
    def isBound(self) -> bool: ...
    def isClosed(self) -> bool: ...
    def isConnected(self) -> bool: ...
    def receive(self, p: DatagramPacket, /) -> None: ...
    def send(self, p: DatagramPacket, /) -> None: ...
    def setBroadcast(self, on: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @staticmethod
    def setDatagramSocketImplFactory(fac: DatagramSocketImplFactory, /) -> None: ...
    _setOption__T = typing.TypeVar('_setOption__T')  # <T>
    def setOption(self, name: SocketOption[_setOption__T], value: _setOption__T, /) -> DatagramSocket: ...
    def setReceiveBufferSize(self, size: int | java.jint | java.lang.Integer, /) -> None: ...
    def setReuseAddress(self, on: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setSendBufferSize(self, size: int | java.jint | java.lang.Integer, /) -> None: ...
    def setSoTimeout(self, timeout: int | java.jint | java.lang.Integer, /) -> None: ...
    def setTrafficClass(self, tc: int | java.jint | java.lang.Integer, /) -> None: ...
    def supportedOptions(self) -> java.util.Set[SocketOption[java.lang.Object]]: ...

class DatagramSocketImpl(SocketOptions):
    fd: java.io.FileDescriptor = ...
    localPort: int = ...
    def __init__(self) -> None: ...
    def bind(self, arg1: int | java.jint | java.lang.Integer, arg2: InetAddress, /) -> None: ...
    def close(self) -> None: ...
    def connect(self, address: InetAddress, port: int | java.jint | java.lang.Integer, /) -> None: ...
    def create(self) -> None: ...
    def disconnect(self) -> None: ...
    def getFileDescriptor(self) -> java.io.FileDescriptor: ...
    def getLocalPort(self) -> int: ...
    _getOption__T = typing.TypeVar('_getOption__T')  # <T>
    def getOption(self, name: SocketOption[_getOption__T], /) -> _getOption__T: ...
    def getTTL(self) -> int: ...
    def getTimeToLive(self) -> int: ...
    def join(self, arg1: InetAddress, /) -> None: ...
    def joinGroup(self, arg1: SocketAddress, arg2: NetworkInterface, /) -> None: ...
    def leave(self, arg1: InetAddress, /) -> None: ...
    def leaveGroup(self, arg1: SocketAddress, arg2: NetworkInterface, /) -> None: ...
    def peek(self, arg1: InetAddress, /) -> int: ...
    def peekData(self, arg1: DatagramPacket, /) -> int: ...
    def receive(self, arg1: DatagramPacket, /) -> None: ...
    def send(self, arg1: DatagramPacket, /) -> None: ...
    _setOption__T = typing.TypeVar('_setOption__T')  # <T>
    def setOption(self, name: SocketOption[_setOption__T], value: _setOption__T, /) -> None: ...
    def setTTL(self, arg1: int | java.jbyte | java.lang.Byte, /) -> None: ...
    def setTimeToLive(self, arg1: int | java.jint | java.lang.Integer, /) -> None: ...
    def supportedOptions(self) -> java.util.Set[SocketOption[java.lang.Object]]: ...

class DatagramSocketImplFactory(java.lang.Object):
    def createDatagramSocketImpl(self) -> DatagramSocketImpl: ...

class FileNameMap(java.lang.Object):
    def getContentTypeFor(self, arg1: str | java.lang.String, /) -> str: ...

class HttpCookie(java.lang.Cloneable):
    def __init__(self, name: str | java.lang.String, value: str | java.lang.String, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    @staticmethod
    def domainMatches(domain: str | java.lang.String, host: str | java.lang.String, /) -> bool: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getComment(self) -> str: ...
    def getCommentURL(self) -> str: ...
    def getDiscard(self) -> bool: ...
    def getDomain(self) -> str: ...
    def getMaxAge(self) -> int: ...
    def getName(self) -> str: ...
    def getPath(self) -> str: ...
    def getPortlist(self) -> str: ...
    def getSecure(self) -> bool: ...
    def getValue(self) -> str: ...
    def getVersion(self) -> int: ...
    def hasExpired(self) -> bool: ...
    def hashCode(self) -> int: ...
    def isHttpOnly(self) -> bool: ...
    @staticmethod
    def parse(header: str | java.lang.String, /) -> java.util.List[HttpCookie]: ...
    def setComment(self, purpose: str | java.lang.String, /) -> None: ...
    def setCommentURL(self, purpose: str | java.lang.String, /) -> None: ...
    def setDiscard(self, discard: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setDomain(self, pattern: str | java.lang.String, /) -> None: ...
    def setHttpOnly(self, httpOnly: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setMaxAge(self, expiry: int | java.jlong | java.lang.Long, /) -> None: ...
    def setPath(self, uri: str | java.lang.String, /) -> None: ...
    def setPortlist(self, ports: str | java.lang.String, /) -> None: ...
    def setSecure(self, flag: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setValue(self, newValue: str | java.lang.String, /) -> None: ...
    def setVersion(self, v: int | java.jint | java.lang.Integer, /) -> None: ...
    def toString(self) -> str: ...

class HttpRetryException(java.io.IOException):
    @typing.overload
    def __init__(self, detail: str | java.lang.String, code: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, detail: str | java.lang.String, code: int | java.jint | java.lang.Integer, location: str | java.lang.String, /) -> None: ...
    def getLocation(self) -> str: ...
    def getReason(self) -> str: ...
    def responseCode(self) -> int: ...

class HttpURLConnection(URLConnection):
    HTTP_ACCEPTED: typing.ClassVar[int] = ...
    HTTP_BAD_GATEWAY: typing.ClassVar[int] = ...
    HTTP_BAD_METHOD: typing.ClassVar[int] = ...
    HTTP_BAD_REQUEST: typing.ClassVar[int] = ...
    HTTP_CLIENT_TIMEOUT: typing.ClassVar[int] = ...
    HTTP_CONFLICT: typing.ClassVar[int] = ...
    HTTP_CREATED: typing.ClassVar[int] = ...
    HTTP_ENTITY_TOO_LARGE: typing.ClassVar[int] = ...
    HTTP_FORBIDDEN: typing.ClassVar[int] = ...
    HTTP_GATEWAY_TIMEOUT: typing.ClassVar[int] = ...
    HTTP_GONE: typing.ClassVar[int] = ...
    HTTP_INTERNAL_ERROR: typing.ClassVar[int] = ...
    HTTP_LENGTH_REQUIRED: typing.ClassVar[int] = ...
    HTTP_MOVED_PERM: typing.ClassVar[int] = ...
    HTTP_MOVED_TEMP: typing.ClassVar[int] = ...
    HTTP_MULT_CHOICE: typing.ClassVar[int] = ...
    HTTP_NOT_ACCEPTABLE: typing.ClassVar[int] = ...
    HTTP_NOT_AUTHORITATIVE: typing.ClassVar[int] = ...
    HTTP_NOT_FOUND: typing.ClassVar[int] = ...
    HTTP_NOT_IMPLEMENTED: typing.ClassVar[int] = ...
    HTTP_NOT_MODIFIED: typing.ClassVar[int] = ...
    HTTP_NO_CONTENT: typing.ClassVar[int] = ...
    HTTP_OK: typing.ClassVar[int] = ...
    HTTP_PARTIAL: typing.ClassVar[int] = ...
    HTTP_PAYMENT_REQUIRED: typing.ClassVar[int] = ...
    HTTP_PRECON_FAILED: typing.ClassVar[int] = ...
    HTTP_PROXY_AUTH: typing.ClassVar[int] = ...
    HTTP_REQ_TOO_LONG: typing.ClassVar[int] = ...
    HTTP_RESET: typing.ClassVar[int] = ...
    HTTP_SEE_OTHER: typing.ClassVar[int] = ...
    HTTP_SERVER_ERROR: typing.ClassVar[int] = ...
    HTTP_UNAUTHORIZED: typing.ClassVar[int] = ...
    HTTP_UNAVAILABLE: typing.ClassVar[int] = ...
    HTTP_UNSUPPORTED_TYPE: typing.ClassVar[int] = ...
    HTTP_USE_PROXY: typing.ClassVar[int] = ...
    HTTP_VERSION: typing.ClassVar[int] = ...
    chunkLength: int = ...
    fixedContentLength: int = ...
    fixedContentLengthLong: int = ...
    instanceFollowRedirects: bool = ...
    method: str = ...
    responseCode: int = ...
    responseMessage: str = ...
    def __init__(self, u: URL, /) -> None: ...
    def disconnect(self) -> None: ...
    def getErrorStream(self) -> java.io.InputStream: ...
    @staticmethod
    def getFollowRedirects() -> bool: ...
    def getHeaderField(self, n: int | java.jint | java.lang.Integer, /) -> str: ...
    def getHeaderFieldDate(self, name: str | java.lang.String, Default: int | java.jlong | java.lang.Long, /) -> int: ...
    def getHeaderFieldKey(self, n: int | java.jint | java.lang.Integer, /) -> str: ...
    def getInstanceFollowRedirects(self) -> bool: ...
    def getPermission(self) -> java.security.Permission: ...
    def getRequestMethod(self) -> str: ...
    def getResponseCode(self) -> int: ...
    def getResponseMessage(self) -> str: ...
    def setChunkedStreamingMode(self, chunklen: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def setFixedLengthStreamingMode(self, contentLength: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def setFixedLengthStreamingMode(self, contentLength: int | java.jlong | java.lang.Long, /) -> None: ...
    @staticmethod
    def setFollowRedirects(set: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setInstanceFollowRedirects(self, followRedirects: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setRequestMethod(self, method: str | java.lang.String, /) -> None: ...
    def usingProxy(self) -> bool: ...

class IDN(java.lang.Object):
    ALLOW_UNASSIGNED: typing.ClassVar[int] = ...
    USE_STD3_ASCII_RULES: typing.ClassVar[int] = ...
    @typing.overload
    @staticmethod
    def toASCII(input: str | java.lang.String, /) -> str: ...
    @typing.overload
    @staticmethod
    def toASCII(input: str | java.lang.String, flag: int | java.jint | java.lang.Integer, /) -> str: ...
    @typing.overload
    @staticmethod
    def toUnicode(input: str | java.lang.String, /) -> str: ...
    @typing.overload
    @staticmethod
    def toUnicode(input: str | java.lang.String, flag: int | java.jint | java.lang.Integer, /) -> str: ...

class Inet4Address(InetAddress):
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getAddress(self) -> java.chaquopy.JavaArrayJByte: ...
    def getHostAddress(self) -> str: ...
    def hashCode(self) -> int: ...
    def isAnyLocalAddress(self) -> bool: ...
    def isLinkLocalAddress(self) -> bool: ...
    def isLoopbackAddress(self) -> bool: ...
    def isMCGlobal(self) -> bool: ...
    def isMCLinkLocal(self) -> bool: ...
    def isMCNodeLocal(self) -> bool: ...
    def isMCOrgLocal(self) -> bool: ...
    def isMCSiteLocal(self) -> bool: ...
    def isMulticastAddress(self) -> bool: ...
    def isSiteLocalAddress(self) -> bool: ...

class Inet6Address(InetAddress):
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getAddress(self) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    @staticmethod
    def getByAddress(host: str | java.lang.String, addr: java.chaquopy.JavaArrayJByte, scope_id: int | java.jint | java.lang.Integer, /) -> Inet6Address: ...
    @typing.overload
    @staticmethod
    def getByAddress(host: str | java.lang.String, addr: java.chaquopy.JavaArrayJByte, nif: NetworkInterface, /) -> Inet6Address: ...
    def getHostAddress(self) -> str: ...
    def getScopeId(self) -> int: ...
    def getScopedInterface(self) -> NetworkInterface: ...
    def hashCode(self) -> int: ...
    def isAnyLocalAddress(self) -> bool: ...
    def isIPv4CompatibleAddress(self) -> bool: ...
    def isLinkLocalAddress(self) -> bool: ...
    def isLoopbackAddress(self) -> bool: ...
    def isMCGlobal(self) -> bool: ...
    def isMCLinkLocal(self) -> bool: ...
    def isMCNodeLocal(self) -> bool: ...
    def isMCOrgLocal(self) -> bool: ...
    def isMCSiteLocal(self) -> bool: ...
    def isMulticastAddress(self) -> bool: ...
    def isSiteLocalAddress(self) -> bool: ...

class InetAddress(java.io.Serializable):
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getAddress(self) -> java.chaquopy.JavaArrayJByte: ...
    @staticmethod
    def getAllByName(host: str | java.lang.String, /) -> java.chaquopy.JavaArray[InetAddress]: ...
    @typing.overload
    @staticmethod
    def getByAddress(addr: java.chaquopy.JavaArrayJByte, /) -> InetAddress: ...
    @typing.overload
    @staticmethod
    def getByAddress(host: str | java.lang.String, addr: java.chaquopy.JavaArrayJByte, /) -> InetAddress: ...
    @staticmethod
    def getByName(host: str | java.lang.String, /) -> InetAddress: ...
    def getCanonicalHostName(self) -> str: ...
    def getHostAddress(self) -> str: ...
    def getHostName(self) -> str: ...
    @staticmethod
    def getLocalHost() -> InetAddress: ...
    @staticmethod
    def getLoopbackAddress() -> InetAddress: ...
    def hashCode(self) -> int: ...
    def isAnyLocalAddress(self) -> bool: ...
    def isLinkLocalAddress(self) -> bool: ...
    def isLoopbackAddress(self) -> bool: ...
    def isMCGlobal(self) -> bool: ...
    def isMCLinkLocal(self) -> bool: ...
    def isMCNodeLocal(self) -> bool: ...
    def isMCOrgLocal(self) -> bool: ...
    def isMCSiteLocal(self) -> bool: ...
    def isMulticastAddress(self) -> bool: ...
    @typing.overload
    def isReachable(self, timeout: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    def isReachable(self, netif: NetworkInterface, ttl: int | java.jint | java.lang.Integer, timeout: int | java.jint | java.lang.Integer, /) -> bool: ...
    def isSiteLocalAddress(self) -> bool: ...
    def toString(self) -> str: ...

class InetSocketAddress(SocketAddress):
    @typing.overload
    def __init__(self, port: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, hostname: str | java.lang.String, port: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, addr: InetAddress, port: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def createUnresolved(host: str | java.lang.String, port: int | java.jint | java.lang.Integer, /) -> InetSocketAddress: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getAddress(self) -> InetAddress: ...
    def getHostName(self) -> str: ...
    def getHostString(self) -> str: ...
    def getPort(self) -> int: ...
    def hashCode(self) -> int: ...
    def isUnresolved(self) -> bool: ...
    def toString(self) -> str: ...

class InterfaceAddress(java.lang.Object):
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getAddress(self) -> InetAddress: ...
    def getBroadcast(self) -> InetAddress: ...
    def getNetworkPrefixLength(self) -> int: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class JarURLConnection(URLConnection):
    jarFileURLConnection: URLConnection = ...
    def __init__(self, url: URL, /) -> None: ...
    def getAttributes(self) -> java.util.jar.Attributes: ...
    def getCertificates(self) -> java.chaquopy.JavaArray[java.security.cert.Certificate]: ...
    def getEntryName(self) -> str: ...
    def getJarEntry(self) -> java.util.jar.JarEntry: ...
    def getJarFile(self) -> java.util.jar.JarFile: ...
    def getJarFileURL(self) -> URL: ...
    def getMainAttributes(self) -> java.util.jar.Attributes: ...
    def getManifest(self) -> java.util.jar.Manifest: ...

class MalformedURLException(java.io.IOException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class MulticastSocket(DatagramSocket):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, port: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, bindaddr: SocketAddress, /) -> None: ...
    def getInterface(self) -> InetAddress: ...
    def getLoopbackMode(self) -> bool: ...
    def getNetworkInterface(self) -> NetworkInterface: ...
    def getTTL(self) -> int: ...
    def getTimeToLive(self) -> int: ...
    @typing.overload
    def joinGroup(self, mcastaddr: InetAddress, /) -> None: ...
    @typing.overload
    def joinGroup(self, mcastaddr: SocketAddress, netIf: NetworkInterface, /) -> None: ...
    @typing.overload
    def leaveGroup(self, mcastaddr: InetAddress, /) -> None: ...
    @typing.overload
    def leaveGroup(self, mcastaddr: SocketAddress, netIf: NetworkInterface, /) -> None: ...
    def send(self, p: DatagramPacket, ttl: int | java.jbyte | java.lang.Byte, /) -> None: ...
    def setInterface(self, inf: InetAddress, /) -> None: ...
    def setLoopbackMode(self, disable: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setNetworkInterface(self, netIf: NetworkInterface, /) -> None: ...
    def setTTL(self, ttl: int | java.jbyte | java.lang.Byte, /) -> None: ...
    def setTimeToLive(self, ttl: int | java.jint | java.lang.Integer, /) -> None: ...
    def supportedOptions(self) -> java.util.Set[SocketOption[java.lang.Object]]: ...

class NetPermission(java.security.BasicPermission):
    @typing.overload
    def __init__(self, name: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, name: str | java.lang.String, actions: str | java.lang.String, /) -> None: ...

class NetworkInterface(java.lang.Object):
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def getByIndex(index: int | java.jint | java.lang.Integer, /) -> NetworkInterface: ...
    @staticmethod
    def getByInetAddress(addr: InetAddress, /) -> NetworkInterface: ...
    @staticmethod
    def getByName(name: str | java.lang.String, /) -> NetworkInterface: ...
    def getDisplayName(self) -> str: ...
    def getHardwareAddress(self) -> java.chaquopy.JavaArrayJByte: ...
    def getIndex(self) -> int: ...
    def getInetAddresses(self) -> java.util.Enumeration[InetAddress]: ...
    def getInterfaceAddresses(self) -> java.util.List[InterfaceAddress]: ...
    def getMTU(self) -> int: ...
    def getName(self) -> str: ...
    @staticmethod
    def getNetworkInterfaces() -> java.util.Enumeration[NetworkInterface]: ...
    def getParent(self) -> NetworkInterface: ...
    def getSubInterfaces(self) -> java.util.Enumeration[NetworkInterface]: ...
    def hashCode(self) -> int: ...
    def isLoopback(self) -> bool: ...
    def isPointToPoint(self) -> bool: ...
    def isUp(self) -> bool: ...
    def isVirtual(self) -> bool: ...
    def supportsMulticast(self) -> bool: ...
    def toString(self) -> str: ...

class NoRouteToHostException(SocketException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class PasswordAuthentication(java.lang.Object):
    def __init__(self, userName: str | java.lang.String, password: java.chaquopy.JavaArrayJChar, /) -> None: ...
    def getPassword(self) -> java.chaquopy.JavaArrayJChar: ...
    def getUserName(self) -> str: ...

class PortUnreachableException(SocketException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class ProtocolException(java.io.IOException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...

class ProtocolFamily(java.lang.Object):
    def name(self) -> str: ...

class Proxy(java.lang.Object):
    NO_PROXY: typing.ClassVar[Proxy] = ...
    def __init__(self, type: Proxy.Type, sa: SocketAddress, /) -> None: ...
    def address(self) -> SocketAddress: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...
    def type(self) -> Proxy.Type: ...

    class Type(java.lang.Enum[Proxy.Type]):
        DIRECT: typing.ClassVar[Proxy.Type] = ...
        HTTP: typing.ClassVar[Proxy.Type] = ...
        SOCKS: typing.ClassVar[Proxy.Type] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> Proxy.Type: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[Proxy.Type]: ...

class ProxySelector(java.lang.Object):
    def __init__(self) -> None: ...
    def connectFailed(self, arg1: URI, arg2: SocketAddress, arg3: java.io.IOException, /) -> None: ...
    @staticmethod
    def getDefault() -> ProxySelector: ...
    def select(self, arg1: URI, /) -> java.util.List[Proxy]: ...
    @staticmethod
    def setDefault(ps: ProxySelector, /) -> None: ...

class ResponseCache(java.lang.Object):
    def __init__(self) -> None: ...
    def get(self, arg1: URI, arg2: str | java.lang.String, arg3: java.util.Map[java.lang.String, java.util.List[java.lang.String]], /) -> CacheResponse: ...
    @staticmethod
    def getDefault() -> ResponseCache: ...
    def put(self, arg1: URI, arg2: URLConnection, /) -> CacheRequest: ...
    @staticmethod
    def setDefault(responseCache: ResponseCache, /) -> None: ...

class SecureCacheResponse(CacheResponse):
    def __init__(self) -> None: ...
    def getCipherSuite(self) -> str: ...
    def getLocalCertificateChain(self) -> java.util.List[java.security.cert.Certificate]: ...
    def getLocalPrincipal(self) -> java.security.Principal: ...
    def getPeerPrincipal(self) -> java.security.Principal: ...
    def getServerCertificateChain(self) -> java.util.List[java.security.cert.Certificate]: ...

class ServerSocket(java.io.Closeable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, port: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, port: int | java.jint | java.lang.Integer, backlog: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, port: int | java.jint | java.lang.Integer, backlog: int | java.jint | java.lang.Integer, bindAddr: InetAddress, /) -> None: ...
    def accept(self) -> Socket: ...
    @typing.overload
    def bind(self, endpoint: SocketAddress, /) -> None: ...
    @typing.overload
    def bind(self, endpoint: SocketAddress, backlog: int | java.jint | java.lang.Integer, /) -> None: ...
    def close(self) -> None: ...
    def getChannel(self) -> java.nio.channels.ServerSocketChannel: ...
    def getInetAddress(self) -> InetAddress: ...
    def getLocalPort(self) -> int: ...
    def getLocalSocketAddress(self) -> SocketAddress: ...
    _getOption__T = typing.TypeVar('_getOption__T')  # <T>
    def getOption(self, name: SocketOption[_getOption__T], /) -> _getOption__T: ...
    def getReceiveBufferSize(self) -> int: ...
    def getReuseAddress(self) -> bool: ...
    def getSoTimeout(self) -> int: ...
    def implAccept(self, s: Socket, /) -> None: ...
    def isBound(self) -> bool: ...
    def isClosed(self) -> bool: ...
    _setOption__T = typing.TypeVar('_setOption__T')  # <T>
    def setOption(self, name: SocketOption[_setOption__T], value: _setOption__T, /) -> ServerSocket: ...
    def setPerformancePreferences(self, connectionTime: int | java.jint | java.lang.Integer, latency: int | java.jint | java.lang.Integer, bandwidth: int | java.jint | java.lang.Integer, /) -> None: ...
    def setReceiveBufferSize(self, size: int | java.jint | java.lang.Integer, /) -> None: ...
    def setReuseAddress(self, on: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setSoTimeout(self, timeout: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def setSocketFactory(fac: SocketImplFactory, /) -> None: ...
    def supportedOptions(self) -> java.util.Set[SocketOption[java.lang.Object]]: ...
    def toString(self) -> str: ...

class Socket(java.io.Closeable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, proxy: Proxy, /) -> None: ...
    @typing.overload
    def __init__(self, impl: SocketImpl, /) -> None: ...
    @typing.overload
    def __init__(self, host: str | java.lang.String, port: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, address: InetAddress, port: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, host: str | java.lang.String, port: int | java.jint | java.lang.Integer, stream: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def __init__(self, host: InetAddress, port: int | java.jint | java.lang.Integer, stream: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def __init__(self, host: str | java.lang.String, port: int | java.jint | java.lang.Integer, localAddr: InetAddress, localPort: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, address: InetAddress, port: int | java.jint | java.lang.Integer, localAddr: InetAddress, localPort: int | java.jint | java.lang.Integer, /) -> None: ...
    def bind(self, bindpoint: SocketAddress, /) -> None: ...
    def close(self) -> None: ...
    @typing.overload
    def connect(self, endpoint: SocketAddress, /) -> None: ...
    @typing.overload
    def connect(self, endpoint: SocketAddress, timeout: int | java.jint | java.lang.Integer, /) -> None: ...
    def getChannel(self) -> java.nio.channels.SocketChannel: ...
    def getInetAddress(self) -> InetAddress: ...
    def getInputStream(self) -> java.io.InputStream: ...
    def getKeepAlive(self) -> bool: ...
    def getLocalAddress(self) -> InetAddress: ...
    def getLocalPort(self) -> int: ...
    def getLocalSocketAddress(self) -> SocketAddress: ...
    def getOOBInline(self) -> bool: ...
    _getOption__T = typing.TypeVar('_getOption__T')  # <T>
    def getOption(self, name: SocketOption[_getOption__T], /) -> _getOption__T: ...
    def getOutputStream(self) -> java.io.OutputStream: ...
    def getPort(self) -> int: ...
    def getReceiveBufferSize(self) -> int: ...
    def getRemoteSocketAddress(self) -> SocketAddress: ...
    def getReuseAddress(self) -> bool: ...
    def getSendBufferSize(self) -> int: ...
    def getSoLinger(self) -> int: ...
    def getSoTimeout(self) -> int: ...
    def getTcpNoDelay(self) -> bool: ...
    def getTrafficClass(self) -> int: ...
    def isBound(self) -> bool: ...
    def isClosed(self) -> bool: ...
    def isConnected(self) -> bool: ...
    def isInputShutdown(self) -> bool: ...
    def isOutputShutdown(self) -> bool: ...
    def sendUrgentData(self, data: int | java.jint | java.lang.Integer, /) -> None: ...
    def setKeepAlive(self, on: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setOOBInline(self, on: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    _setOption__T = typing.TypeVar('_setOption__T')  # <T>
    def setOption(self, name: SocketOption[_setOption__T], value: _setOption__T, /) -> Socket: ...
    def setPerformancePreferences(self, connectionTime: int | java.jint | java.lang.Integer, latency: int | java.jint | java.lang.Integer, bandwidth: int | java.jint | java.lang.Integer, /) -> None: ...
    def setReceiveBufferSize(self, size: int | java.jint | java.lang.Integer, /) -> None: ...
    def setReuseAddress(self, on: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setSendBufferSize(self, size: int | java.jint | java.lang.Integer, /) -> None: ...
    def setSoLinger(self, on: bool | java.jboolean | java.lang.Boolean, linger: int | java.jint | java.lang.Integer, /) -> None: ...
    def setSoTimeout(self, timeout: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def setSocketImplFactory(fac: SocketImplFactory, /) -> None: ...
    def setTcpNoDelay(self, on: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setTrafficClass(self, tc: int | java.jint | java.lang.Integer, /) -> None: ...
    def shutdownInput(self) -> None: ...
    def shutdownOutput(self) -> None: ...
    def supportedOptions(self) -> java.util.Set[SocketOption[java.lang.Object]]: ...
    def toString(self) -> str: ...

class SocketAddress(java.io.Serializable):
    def __init__(self) -> None: ...

class SocketException(java.io.IOException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class SocketImpl(SocketOptions):
    address: InetAddress = ...
    fd: java.io.FileDescriptor = ...
    localport: int = ...
    port: int = ...
    def __init__(self) -> None: ...
    def accept(self, arg1: SocketImpl, /) -> None: ...
    def available(self) -> int: ...
    def bind(self, arg1: InetAddress, arg2: int | java.jint | java.lang.Integer, /) -> None: ...
    def close(self) -> None: ...
    @typing.overload
    def connect(self, arg1: str | java.lang.String, arg2: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def connect(self, arg1: InetAddress, arg2: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def connect(self, arg1: SocketAddress, arg2: int | java.jint | java.lang.Integer, /) -> None: ...
    def create(self, arg1: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def getFileDescriptor(self) -> java.io.FileDescriptor: ...
    def getInetAddress(self) -> InetAddress: ...
    def getInputStream(self) -> java.io.InputStream: ...
    def getLocalPort(self) -> int: ...
    _getOption__T = typing.TypeVar('_getOption__T')  # <T>
    def getOption(self, name: SocketOption[_getOption__T], /) -> _getOption__T: ...
    def getOutputStream(self) -> java.io.OutputStream: ...
    def getPort(self) -> int: ...
    def listen(self, arg1: int | java.jint | java.lang.Integer, /) -> None: ...
    def sendUrgentData(self, arg1: int | java.jint | java.lang.Integer, /) -> None: ...
    _setOption__T = typing.TypeVar('_setOption__T')  # <T>
    def setOption(self, name: SocketOption[_setOption__T], value: _setOption__T, /) -> None: ...
    def setPerformancePreferences(self, connectionTime: int | java.jint | java.lang.Integer, latency: int | java.jint | java.lang.Integer, bandwidth: int | java.jint | java.lang.Integer, /) -> None: ...
    def shutdownInput(self) -> None: ...
    def shutdownOutput(self) -> None: ...
    def supportedOptions(self) -> java.util.Set[SocketOption[java.lang.Object]]: ...
    def supportsUrgentData(self) -> bool: ...
    def toString(self) -> str: ...

class SocketImplFactory(java.lang.Object):
    def createSocketImpl(self) -> SocketImpl: ...

_SocketOption__T = typing.TypeVar('_SocketOption__T')  # <T>
class SocketOption(java.lang.Object, typing.Generic[_SocketOption__T]):
    def name(self) -> str: ...
    def type(self) -> typing.Type[_SocketOption__T]: ...

class SocketOptions(java.lang.Object):
    IP_MULTICAST_IF: typing.ClassVar[int] = ...
    IP_MULTICAST_IF2: typing.ClassVar[int] = ...
    IP_MULTICAST_LOOP: typing.ClassVar[int] = ...
    IP_TOS: typing.ClassVar[int] = ...
    SO_BINDADDR: typing.ClassVar[int] = ...
    SO_BROADCAST: typing.ClassVar[int] = ...
    SO_KEEPALIVE: typing.ClassVar[int] = ...
    SO_LINGER: typing.ClassVar[int] = ...
    SO_OOBINLINE: typing.ClassVar[int] = ...
    SO_RCVBUF: typing.ClassVar[int] = ...
    SO_REUSEADDR: typing.ClassVar[int] = ...
    SO_REUSEPORT: typing.ClassVar[int] = ...
    SO_SNDBUF: typing.ClassVar[int] = ...
    SO_TIMEOUT: typing.ClassVar[int] = ...
    TCP_NODELAY: typing.ClassVar[int] = ...
    def getOption(self, arg1: int | java.jint | java.lang.Integer, /) -> java.lang.Object: ...
    def setOption(self, arg1: int | java.jint | java.lang.Integer, arg2: java.lang.Object | int | bool | float | str, /) -> None: ...

class SocketPermission(java.security.Permission, java.io.Serializable):
    def __init__(self, host: str | java.lang.String, action: str | java.lang.String, /) -> None: ...
    def getActions(self) -> str: ...
    def implies(self, p: java.security.Permission, /) -> bool: ...

class SocketTimeoutException(java.io.InterruptedIOException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class StandardProtocolFamily(java.lang.Enum[StandardProtocolFamily], ProtocolFamily):
    INET: typing.ClassVar[StandardProtocolFamily] = ...
    INET6: typing.ClassVar[StandardProtocolFamily] = ...
    UNIX: typing.ClassVar[StandardProtocolFamily] = ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> StandardProtocolFamily: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[StandardProtocolFamily]: ...

class StandardSocketOptions(java.lang.Object):
    IP_MULTICAST_IF: typing.ClassVar[SocketOption[NetworkInterface]] = ...
    IP_MULTICAST_LOOP: typing.ClassVar[SocketOption[java.lang.Boolean]] = ...
    IP_MULTICAST_TTL: typing.ClassVar[SocketOption[java.lang.Integer]] = ...
    IP_TOS: typing.ClassVar[SocketOption[java.lang.Integer]] = ...
    SO_BROADCAST: typing.ClassVar[SocketOption[java.lang.Boolean]] = ...
    SO_KEEPALIVE: typing.ClassVar[SocketOption[java.lang.Boolean]] = ...
    SO_LINGER: typing.ClassVar[SocketOption[java.lang.Integer]] = ...
    SO_RCVBUF: typing.ClassVar[SocketOption[java.lang.Integer]] = ...
    SO_REUSEADDR: typing.ClassVar[SocketOption[java.lang.Boolean]] = ...
    SO_REUSEPORT: typing.ClassVar[SocketOption[java.lang.Boolean]] = ...
    SO_SNDBUF: typing.ClassVar[SocketOption[java.lang.Integer]] = ...
    TCP_NODELAY: typing.ClassVar[SocketOption[java.lang.Boolean]] = ...

class URI(java.lang.Comparable[URI], java.io.Serializable):
    @typing.overload
    def __init__(self, str: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, scheme: str | java.lang.String, ssp: str | java.lang.String, fragment: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, scheme: str | java.lang.String, host: str | java.lang.String, path: str | java.lang.String, fragment: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, scheme: str | java.lang.String, authority: str | java.lang.String, path: str | java.lang.String, query: str | java.lang.String, fragment: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, scheme: str | java.lang.String, userInfo: str | java.lang.String, host: str | java.lang.String, port: int | java.jint | java.lang.Integer, path: str | java.lang.String, query: str | java.lang.String, fragment: str | java.lang.String, /) -> None: ...
    def compareTo(self, that: URI, /) -> int: ...
    @staticmethod
    def create(str: str | java.lang.String, /) -> URI: ...
    def equals(self, ob: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getAuthority(self) -> str | None: ...
    def getFragment(self) -> str | None: ...
    def getHost(self) -> str | None: ...
    def getPath(self) -> str | None: ...
    def getPort(self) -> int: ...
    def getQuery(self) -> str | None: ...
    def getRawAuthority(self) -> str | None: ...
    def getRawFragment(self) -> str | None: ...
    def getRawPath(self) -> str | None: ...
    def getRawQuery(self) -> str | None: ...
    def getRawSchemeSpecificPart(self) -> str | None: ...
    def getRawUserInfo(self) -> str | None: ...
    def getScheme(self) -> str | None: ...
    def getSchemeSpecificPart(self) -> str: ...
    def getUserInfo(self) -> str | None: ...
    def hashCode(self) -> int: ...
    def isAbsolute(self) -> bool: ...
    def isOpaque(self) -> bool: ...
    def normalize(self) -> URI: ...
    def parseServerAuthority(self) -> URI: ...
    def relativize(self, uri: URI, /) -> URI: ...
    @typing.overload
    def resolve(self, str: str | java.lang.String, /) -> URI: ...
    @typing.overload
    def resolve(self, uri: URI, /) -> URI: ...
    def toASCIIString(self) -> str: ...
    def toString(self) -> str: ...
    def toURL(self) -> URL: ...

class URISyntaxException(java.lang.Exception):
    @typing.overload
    def __init__(self, input: str | java.lang.String, reason: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, input: str | java.lang.String, reason: str | java.lang.String, index: int | java.jint | java.lang.Integer, /) -> None: ...
    def getIndex(self) -> int: ...
    def getInput(self) -> str: ...
    def getMessage(self) -> str: ...
    def getReason(self) -> str: ...

class URL(java.io.Serializable):
    @typing.overload
    def __init__(self, spec: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, context: URL, spec: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, protocol: str | java.lang.String, host: str | java.lang.String, file: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, context: URL, spec: str | java.lang.String, handler: URLStreamHandler, /) -> None: ...
    @typing.overload
    def __init__(self, protocol: str | java.lang.String, host: str | java.lang.String, port: int | java.jint | java.lang.Integer, file: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, protocol: str | java.lang.String, host: str | java.lang.String, port: int | java.jint | java.lang.Integer, file: str | java.lang.String, handler: URLStreamHandler, /) -> None: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getAuthority(self) -> str | None: ...
    @typing.overload
    def getContent(self) -> java.lang.Object: ...
    @typing.overload
    def getContent(self, classes: java.chaquopy.JavaArray[typing.Type], /) -> java.lang.Object: ...
    def getDefaultPort(self) -> int: ...
    def getFile(self) -> str: ...
    def getHost(self) -> str: ...
    def getPath(self) -> str: ...
    def getPort(self) -> int: ...
    def getProtocol(self) -> str: ...
    def getQuery(self) -> str | None: ...
    def getRef(self) -> str | None: ...
    def getUserInfo(self) -> str | None: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def openConnection(self) -> URLConnection | None: ...
    @typing.overload
    def openConnection(self, proxy: Proxy, /) -> URLConnection | None: ...
    def openStream(self) -> java.io.InputStream: ...
    def sameFile(self, other: URL, /) -> bool: ...
    @staticmethod
    def setURLStreamHandlerFactory(fac: URLStreamHandlerFactory, /) -> None: ...
    def toExternalForm(self) -> str: ...
    def toString(self) -> str: ...
    def toURI(self) -> URI: ...

class URLClassLoader(java.security.SecureClassLoader, java.io.Closeable):
    @typing.overload
    def __init__(self, urls: java.chaquopy.JavaArray[URL], /) -> None: ...
    @typing.overload
    def __init__(self, urls: java.chaquopy.JavaArray[URL], parent: java.lang.ClassLoader, /) -> None: ...
    @typing.overload
    def __init__(self, urls: java.chaquopy.JavaArray[URL], parent: java.lang.ClassLoader, factory: URLStreamHandlerFactory, /) -> None: ...
    def addURL(self, url: URL, /) -> None: ...
    def close(self) -> None: ...
    def definePackage(self, name: str | java.lang.String, man: java.util.jar.Manifest, url: URL, /) -> java.lang.Package: ...
    def findClass(self, name: str | java.lang.String, /) -> typing.Type[java.lang.Object]: ...
    def findResource(self, name: str | java.lang.String, /) -> URL: ...
    def findResources(self, name: str | java.lang.String, /) -> java.util.Enumeration[URL]: ...
    def getPermissions(self, codesource: java.security.CodeSource, /) -> java.security.PermissionCollection: ...
    def getResourceAsStream(self, name: str | java.lang.String, /) -> java.io.InputStream: ...
    def getURLs(self) -> java.chaquopy.JavaArray[URL]: ...
    @typing.overload
    @staticmethod
    def newInstance(urls: java.chaquopy.JavaArray[URL], /) -> URLClassLoader: ...
    @typing.overload
    @staticmethod
    def newInstance(urls: java.chaquopy.JavaArray[URL], parent: java.lang.ClassLoader, /) -> URLClassLoader: ...

class URLConnection(java.lang.Object):
    allowUserInteraction: bool = ...
    connected: bool = ...
    doInput: bool = ...
    doOutput: bool = ...
    ifModifiedSince: int = ...
    url: URL = ...
    useCaches: bool = ...
    def __init__(self, url: URL, /) -> None: ...
    def addRequestProperty(self, key: str | java.lang.String, value: str | java.lang.String, /) -> None: ...
    def connect(self) -> None: ...
    def getAllowUserInteraction(self) -> bool: ...
    def getConnectTimeout(self) -> int: ...
    @typing.overload
    def getContent(self) -> java.lang.Object: ...
    @typing.overload
    def getContent(self, classes: java.chaquopy.JavaArray[typing.Type], /) -> java.lang.Object: ...
    def getContentEncoding(self) -> str: ...
    def getContentLength(self) -> int: ...
    def getContentLengthLong(self) -> int: ...
    def getContentType(self) -> str: ...
    def getDate(self) -> int: ...
    @staticmethod
    def getDefaultAllowUserInteraction() -> bool: ...
    @staticmethod
    def getDefaultRequestProperty(key: str | java.lang.String, /) -> str: ...
    def getDefaultUseCaches(self) -> bool: ...
    def getDoInput(self) -> bool: ...
    def getDoOutput(self) -> bool: ...
    def getExpiration(self) -> int: ...
    @staticmethod
    def getFileNameMap() -> FileNameMap: ...
    @typing.overload
    def getHeaderField(self, n: int | java.jint | java.lang.Integer, /) -> str: ...
    @typing.overload
    def getHeaderField(self, name: str | java.lang.String, /) -> str: ...
    def getHeaderFieldDate(self, name: str | java.lang.String, Default: int | java.jlong | java.lang.Long, /) -> int: ...
    def getHeaderFieldInt(self, name: str | java.lang.String, Default: int | java.jint | java.lang.Integer, /) -> int: ...
    def getHeaderFieldKey(self, n: int | java.jint | java.lang.Integer, /) -> str: ...
    def getHeaderFieldLong(self, name: str | java.lang.String, Default: int | java.jlong | java.lang.Long, /) -> int: ...
    def getHeaderFields(self) -> java.util.Map[java.lang.String, java.util.List[java.lang.String]]: ...
    def getIfModifiedSince(self) -> int: ...
    def getInputStream(self) -> java.io.InputStream: ...
    def getLastModified(self) -> int: ...
    def getOutputStream(self) -> java.io.OutputStream: ...
    def getPermission(self) -> java.security.Permission: ...
    def getReadTimeout(self) -> int: ...
    def getRequestProperties(self) -> java.util.Map[java.lang.String, java.util.List[java.lang.String]]: ...
    def getRequestProperty(self, key: str | java.lang.String, /) -> str: ...
    def getURL(self) -> URL: ...
    def getUseCaches(self) -> bool: ...
    @staticmethod
    def guessContentTypeFromName(fname: str | java.lang.String, /) -> str: ...
    @staticmethod
    def guessContentTypeFromStream(is_: java.io.InputStream, /) -> str: ...
    def setAllowUserInteraction(self, allowuserinteraction: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setConnectTimeout(self, timeout: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def setContentHandlerFactory(fac: ContentHandlerFactory, /) -> None: ...
    @staticmethod
    def setDefaultAllowUserInteraction(defaultallowuserinteraction: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @staticmethod
    def setDefaultRequestProperty(key: str | java.lang.String, value: str | java.lang.String, /) -> None: ...
    def setDefaultUseCaches(self, defaultusecaches: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setDoInput(self, doinput: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setDoOutput(self, dooutput: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @staticmethod
    def setFileNameMap(map: FileNameMap, /) -> None: ...
    def setIfModifiedSince(self, ifmodifiedsince: int | java.jlong | java.lang.Long, /) -> None: ...
    def setReadTimeout(self, timeout: int | java.jint | java.lang.Integer, /) -> None: ...
    def setRequestProperty(self, key: str | java.lang.String, value: str | java.lang.String, /) -> None: ...
    def setUseCaches(self, usecaches: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def toString(self) -> str: ...

class URLDecoder(java.lang.Object):
    def __init__(self) -> None: ...
    @typing.overload
    @staticmethod
    def decode(s: str | java.lang.String, /) -> str: ...
    @typing.overload
    @staticmethod
    def decode(s: str | java.lang.String, enc: str | java.lang.String, /) -> str: ...
    @typing.overload
    @staticmethod
    def decode(s: str | java.lang.String, charset: java.nio.charset.Charset, /) -> str: ...

class URLEncoder(java.lang.Object):
    @typing.overload
    @staticmethod
    def encode(s: str | java.lang.String, /) -> str: ...
    @typing.overload
    @staticmethod
    def encode(s: str | java.lang.String, enc: str | java.lang.String, /) -> str: ...
    @typing.overload
    @staticmethod
    def encode(s: str | java.lang.String, charset: java.nio.charset.Charset, /) -> str: ...

class URLStreamHandler(java.lang.Object):
    def __init__(self) -> None: ...
    def equals(self, u1: URL, u2: URL, /) -> bool: ...
    def getDefaultPort(self) -> int: ...
    def getHostAddress(self, u: URL, /) -> InetAddress: ...
    def hashCode(self, u: URL, /) -> int: ...
    def hostsEqual(self, u1: URL, u2: URL, /) -> bool: ...
    @typing.overload
    def openConnection(self, arg1: URL, /) -> URLConnection: ...
    @typing.overload
    def openConnection(self, u: URL, p: Proxy, /) -> URLConnection: ...
    def parseURL(self, u: URL, spec: str | java.lang.String, start: int | java.jint | java.lang.Integer, limit: int | java.jint | java.lang.Integer, /) -> None: ...
    def sameFile(self, u1: URL, u2: URL, /) -> bool: ...
    @typing.overload
    def setURL(self, u: URL, protocol: str | java.lang.String, host: str | java.lang.String, port: int | java.jint | java.lang.Integer, file: str | java.lang.String, ref: str | java.lang.String, /) -> None: ...
    @typing.overload
    def setURL(self, u: URL, protocol: str | java.lang.String, host: str | java.lang.String, port: int | java.jint | java.lang.Integer, authority: str | java.lang.String, userInfo: str | java.lang.String, path: str | java.lang.String, query: str | java.lang.String, ref: str | java.lang.String, /) -> None: ...
    def toExternalForm(self, u: URL, /) -> str: ...

class URLStreamHandlerFactory(java.lang.Object):
    def createURLStreamHandler(self, arg1: str | java.lang.String, /) -> URLStreamHandler: ...

class UnknownHostException(java.io.IOException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...

class UnknownServiceException(java.io.IOException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...
