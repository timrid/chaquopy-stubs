import java
import java.chaquopy
import java.io
import java.lang
import java.nio
import java.security
import java.security.cert
import java.security.spec
import javax.security.auth
import typing



class AEADBadTagException(BadPaddingException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class BadPaddingException(java.security.GeneralSecurityException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class Cipher(java.lang.Object):
    DECRYPT_MODE: typing.ClassVar[int] = ...
    ENCRYPT_MODE: typing.ClassVar[int] = ...
    PRIVATE_KEY: typing.ClassVar[int] = ...
    PUBLIC_KEY: typing.ClassVar[int] = ...
    SECRET_KEY: typing.ClassVar[int] = ...
    UNWRAP_MODE: typing.ClassVar[int] = ...
    WRAP_MODE: typing.ClassVar[int] = ...
    def __init__(self, cipherSpi: CipherSpi, provider: java.security.Provider, transformation: str | java.lang.String, /) -> None: ...
    @typing.overload
    def doFinal(self) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def doFinal(self, input: java.chaquopy.JavaArrayJByte, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def doFinal(self, input: java.nio.ByteBuffer, output: java.nio.ByteBuffer, /) -> int: ...
    @typing.overload
    def doFinal(self, output: java.chaquopy.JavaArrayJByte, outputOffset: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def doFinal(self, input: java.chaquopy.JavaArrayJByte, inputOffset: int | java.jint | java.lang.Integer, inputLen: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def doFinal(self, input: java.chaquopy.JavaArrayJByte, inputOffset: int | java.jint | java.lang.Integer, inputLen: int | java.jint | java.lang.Integer, output: java.chaquopy.JavaArrayJByte, /) -> int: ...
    @typing.overload
    def doFinal(self, input: java.chaquopy.JavaArrayJByte, inputOffset: int | java.jint | java.lang.Integer, inputLen: int | java.jint | java.lang.Integer, output: java.chaquopy.JavaArrayJByte, outputOffset: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAlgorithm(self) -> str: ...
    def getBlockSize(self) -> int: ...
    def getExemptionMechanism(self) -> ExemptionMechanism: ...
    def getIV(self) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    @staticmethod
    def getInstance(transformation: str | java.lang.String, /) -> Cipher: ...
    @typing.overload
    @staticmethod
    def getInstance(transformation: str | java.lang.String, provider: str | java.lang.String, /) -> Cipher: ...
    @typing.overload
    @staticmethod
    def getInstance(transformation: str | java.lang.String, provider: java.security.Provider, /) -> Cipher: ...
    @staticmethod
    def getMaxAllowedKeyLength(transformation: str | java.lang.String, /) -> int: ...
    @staticmethod
    def getMaxAllowedParameterSpec(transformation: str | java.lang.String, /) -> java.security.spec.AlgorithmParameterSpec: ...
    def getOutputSize(self, inputLen: int | java.jint | java.lang.Integer, /) -> int: ...
    def getParameters(self) -> java.security.AlgorithmParameters: ...
    def getProvider(self) -> java.security.Provider: ...
    @typing.overload
    def init(self, opmode: int | java.jint | java.lang.Integer, key: java.security.Key, /) -> None: ...
    @typing.overload
    def init(self, opmode: int | java.jint | java.lang.Integer, certificate: java.security.cert.Certificate, /) -> None: ...
    @typing.overload
    def init(self, opmode: int | java.jint | java.lang.Integer, key: java.security.Key, params: java.security.AlgorithmParameters, /) -> None: ...
    @typing.overload
    def init(self, opmode: int | java.jint | java.lang.Integer, key: java.security.Key, random: java.security.SecureRandom, /) -> None: ...
    @typing.overload
    def init(self, opmode: int | java.jint | java.lang.Integer, key: java.security.Key, params: java.security.spec.AlgorithmParameterSpec, /) -> None: ...
    @typing.overload
    def init(self, opmode: int | java.jint | java.lang.Integer, certificate: java.security.cert.Certificate, random: java.security.SecureRandom, /) -> None: ...
    @typing.overload
    def init(self, opmode: int | java.jint | java.lang.Integer, key: java.security.Key, params: java.security.AlgorithmParameters, random: java.security.SecureRandom, /) -> None: ...
    @typing.overload
    def init(self, opmode: int | java.jint | java.lang.Integer, key: java.security.Key, params: java.security.spec.AlgorithmParameterSpec, random: java.security.SecureRandom, /) -> None: ...
    def unwrap(self, wrappedKey: java.chaquopy.JavaArrayJByte, wrappedKeyAlgorithm: str | java.lang.String, wrappedKeyType: int | java.jint | java.lang.Integer, /) -> java.security.Key: ...
    @typing.overload
    def update(self, input: java.chaquopy.JavaArrayJByte, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def update(self, input: java.nio.ByteBuffer, output: java.nio.ByteBuffer, /) -> int: ...
    @typing.overload
    def update(self, input: java.chaquopy.JavaArrayJByte, inputOffset: int | java.jint | java.lang.Integer, inputLen: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def update(self, input: java.chaquopy.JavaArrayJByte, inputOffset: int | java.jint | java.lang.Integer, inputLen: int | java.jint | java.lang.Integer, output: java.chaquopy.JavaArrayJByte, /) -> int: ...
    @typing.overload
    def update(self, input: java.chaquopy.JavaArrayJByte, inputOffset: int | java.jint | java.lang.Integer, inputLen: int | java.jint | java.lang.Integer, output: java.chaquopy.JavaArrayJByte, outputOffset: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def updateAAD(self, src: java.nio.ByteBuffer, /) -> None: ...
    @typing.overload
    def updateAAD(self, src: java.chaquopy.JavaArrayJByte, /) -> None: ...
    @typing.overload
    def updateAAD(self, src: java.chaquopy.JavaArrayJByte, offset: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, /) -> None: ...
    def wrap(self, key: java.security.Key, /) -> java.chaquopy.JavaArrayJByte: ...

class CipherInputStream(java.io.FilterInputStream):
    @typing.overload
    def __init__(self, is_: java.io.InputStream, /) -> None: ...
    @typing.overload
    def __init__(self, is_: java.io.InputStream, c: Cipher, /) -> None: ...
    def available(self) -> int: ...
    def close(self) -> None: ...
    def markSupported(self) -> bool: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, b: java.chaquopy.JavaArrayJByte, /) -> int: ...
    @typing.overload
    def read(self, b: java.chaquopy.JavaArrayJByte, off: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, /) -> int: ...
    def skip(self, n: int | java.jlong | java.lang.Long, /) -> int: ...

class CipherOutputStream(java.io.FilterOutputStream):
    @typing.overload
    def __init__(self, os: java.io.OutputStream, /) -> None: ...
    @typing.overload
    def __init__(self, os: java.io.OutputStream, c: Cipher, /) -> None: ...
    def close(self) -> None: ...
    def flush(self) -> None: ...
    @typing.overload
    def write(self, b: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def write(self, b: java.chaquopy.JavaArrayJByte, /) -> None: ...
    @typing.overload
    def write(self, b: java.chaquopy.JavaArrayJByte, off: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, /) -> None: ...

class CipherSpi(java.lang.Object):
    def __init__(self) -> None: ...
    @typing.overload
    def engineDoFinal(self, input: java.nio.ByteBuffer, output: java.nio.ByteBuffer, /) -> int: ...
    @typing.overload
    def engineDoFinal(self, arg1: java.chaquopy.JavaArrayJByte, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def engineDoFinal(self, arg1: java.chaquopy.JavaArrayJByte, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, arg4: java.chaquopy.JavaArrayJByte, arg5: int | java.jint | java.lang.Integer, /) -> int: ...
    def engineGetBlockSize(self) -> int: ...
    def engineGetIV(self) -> java.chaquopy.JavaArrayJByte: ...
    def engineGetKeySize(self, key: java.security.Key, /) -> int: ...
    def engineGetOutputSize(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def engineGetParameters(self) -> java.security.AlgorithmParameters: ...
    @typing.overload
    def engineInit(self, arg1: int | java.jint | java.lang.Integer, arg2: java.security.Key, arg3: java.security.SecureRandom, /) -> None: ...
    @typing.overload
    def engineInit(self, arg1: int | java.jint | java.lang.Integer, arg2: java.security.Key, arg3: java.security.AlgorithmParameters, arg4: java.security.SecureRandom, /) -> None: ...
    @typing.overload
    def engineInit(self, arg1: int | java.jint | java.lang.Integer, arg2: java.security.Key, arg3: java.security.spec.AlgorithmParameterSpec, arg4: java.security.SecureRandom, /) -> None: ...
    def engineSetMode(self, arg1: str | java.lang.String, /) -> None: ...
    def engineSetPadding(self, arg1: str | java.lang.String, /) -> None: ...
    def engineUnwrap(self, wrappedKey: java.chaquopy.JavaArrayJByte, wrappedKeyAlgorithm: str | java.lang.String, wrappedKeyType: int | java.jint | java.lang.Integer, /) -> java.security.Key: ...
    @typing.overload
    def engineUpdate(self, input: java.nio.ByteBuffer, output: java.nio.ByteBuffer, /) -> int: ...
    @typing.overload
    def engineUpdate(self, arg1: java.chaquopy.JavaArrayJByte, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def engineUpdate(self, arg1: java.chaquopy.JavaArrayJByte, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, arg4: java.chaquopy.JavaArrayJByte, arg5: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def engineUpdateAAD(self, src: java.nio.ByteBuffer, /) -> None: ...
    @typing.overload
    def engineUpdateAAD(self, src: java.chaquopy.JavaArrayJByte, offset: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, /) -> None: ...
    def engineWrap(self, key: java.security.Key, /) -> java.chaquopy.JavaArrayJByte: ...

class EncryptedPrivateKeyInfo(java.lang.Object):
    @typing.overload
    def __init__(self, encoded: java.chaquopy.JavaArrayJByte, /) -> None: ...
    @typing.overload
    def __init__(self, algName: str | java.lang.String, encryptedData: java.chaquopy.JavaArrayJByte, /) -> None: ...
    @typing.overload
    def __init__(self, algParams: java.security.AlgorithmParameters, encryptedData: java.chaquopy.JavaArrayJByte, /) -> None: ...
    def getAlgName(self) -> str: ...
    def getAlgParameters(self) -> java.security.AlgorithmParameters: ...
    def getEncoded(self) -> java.chaquopy.JavaArrayJByte: ...
    def getEncryptedData(self) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def getKeySpec(self, decryptKey: java.security.Key, /) -> java.security.spec.PKCS8EncodedKeySpec: ...
    @typing.overload
    def getKeySpec(self, cipher: Cipher, /) -> java.security.spec.PKCS8EncodedKeySpec: ...
    @typing.overload
    def getKeySpec(self, decryptKey: java.security.Key, providerName: str | java.lang.String, /) -> java.security.spec.PKCS8EncodedKeySpec: ...
    @typing.overload
    def getKeySpec(self, decryptKey: java.security.Key, provider: java.security.Provider, /) -> java.security.spec.PKCS8EncodedKeySpec: ...

class ExemptionMechanism(java.lang.Object):
    def __init__(self, exmechSpi: ExemptionMechanismSpi, provider: java.security.Provider, mechanism: str | java.lang.String, /) -> None: ...
    @typing.overload
    def genExemptionBlob(self) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def genExemptionBlob(self, output: java.chaquopy.JavaArrayJByte, /) -> int: ...
    @typing.overload
    def genExemptionBlob(self, output: java.chaquopy.JavaArrayJByte, outputOffset: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def getInstance(algorithm: str | java.lang.String, /) -> ExemptionMechanism: ...
    @typing.overload
    @staticmethod
    def getInstance(algorithm: str | java.lang.String, provider: str | java.lang.String, /) -> ExemptionMechanism: ...
    @typing.overload
    @staticmethod
    def getInstance(algorithm: str | java.lang.String, provider: java.security.Provider, /) -> ExemptionMechanism: ...
    def getName(self) -> str: ...
    def getOutputSize(self, inputLen: int | java.jint | java.lang.Integer, /) -> int: ...
    def getProvider(self) -> java.security.Provider: ...
    @typing.overload
    def init(self, key: java.security.Key, /) -> None: ...
    @typing.overload
    def init(self, key: java.security.Key, params: java.security.AlgorithmParameters, /) -> None: ...
    @typing.overload
    def init(self, key: java.security.Key, params: java.security.spec.AlgorithmParameterSpec, /) -> None: ...
    def isCryptoAllowed(self, key: java.security.Key, /) -> bool: ...

class ExemptionMechanismException(java.security.GeneralSecurityException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class ExemptionMechanismSpi(java.lang.Object):
    def __init__(self) -> None: ...
    @typing.overload
    def engineGenExemptionBlob(self) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def engineGenExemptionBlob(self, arg1: java.chaquopy.JavaArrayJByte, arg2: int | java.jint | java.lang.Integer, /) -> int: ...
    def engineGetOutputSize(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def engineInit(self, arg1: java.security.Key, /) -> None: ...
    @typing.overload
    def engineInit(self, arg1: java.security.Key, arg2: java.security.AlgorithmParameters, /) -> None: ...
    @typing.overload
    def engineInit(self, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, /) -> None: ...

class IllegalBlockSizeException(java.security.GeneralSecurityException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class KeyAgreement(java.lang.Object):
    def __init__(self, keyAgreeSpi: KeyAgreementSpi, provider: java.security.Provider, algorithm: str | java.lang.String, /) -> None: ...
    def doPhase(self, key: java.security.Key, lastPhase: bool | java.jboolean | java.lang.Boolean, /) -> java.security.Key: ...
    @typing.overload
    def generateSecret(self) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def generateSecret(self, algorithm: str | java.lang.String, /) -> SecretKey: ...
    @typing.overload
    def generateSecret(self, sharedSecret: java.chaquopy.JavaArrayJByte, offset: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAlgorithm(self) -> str: ...
    @typing.overload
    @staticmethod
    def getInstance(algorithm: str | java.lang.String, /) -> KeyAgreement: ...
    @typing.overload
    @staticmethod
    def getInstance(algorithm: str | java.lang.String, provider: str | java.lang.String, /) -> KeyAgreement: ...
    @typing.overload
    @staticmethod
    def getInstance(algorithm: str | java.lang.String, provider: java.security.Provider, /) -> KeyAgreement: ...
    def getProvider(self) -> java.security.Provider: ...
    @typing.overload
    def init(self, key: java.security.Key, /) -> None: ...
    @typing.overload
    def init(self, key: java.security.Key, random: java.security.SecureRandom, /) -> None: ...
    @typing.overload
    def init(self, key: java.security.Key, params: java.security.spec.AlgorithmParameterSpec, /) -> None: ...
    @typing.overload
    def init(self, key: java.security.Key, params: java.security.spec.AlgorithmParameterSpec, random: java.security.SecureRandom, /) -> None: ...

class KeyAgreementSpi(java.lang.Object):
    def __init__(self) -> None: ...
    def engineDoPhase(self, arg1: java.security.Key, arg2: bool | java.jboolean | java.lang.Boolean, /) -> java.security.Key: ...
    @typing.overload
    def engineGenerateSecret(self) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def engineGenerateSecret(self, arg1: str | java.lang.String, /) -> SecretKey: ...
    @typing.overload
    def engineGenerateSecret(self, arg1: java.chaquopy.JavaArrayJByte, arg2: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def engineInit(self, arg1: java.security.Key, arg2: java.security.SecureRandom, /) -> None: ...
    @typing.overload
    def engineInit(self, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, arg3: java.security.SecureRandom, /) -> None: ...

class KeyGenerator(java.lang.Object):
    def __init__(self, keyGenSpi: KeyGeneratorSpi, provider: java.security.Provider, algorithm: str | java.lang.String, /) -> None: ...
    def generateKey(self) -> SecretKey: ...
    def getAlgorithm(self) -> str: ...
    @typing.overload
    @staticmethod
    def getInstance(algorithm: str | java.lang.String, /) -> KeyGenerator: ...
    @typing.overload
    @staticmethod
    def getInstance(algorithm: str | java.lang.String, provider: str | java.lang.String, /) -> KeyGenerator: ...
    @typing.overload
    @staticmethod
    def getInstance(algorithm: str | java.lang.String, provider: java.security.Provider, /) -> KeyGenerator: ...
    def getProvider(self) -> java.security.Provider: ...
    @typing.overload
    def init(self, keysize: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def init(self, random: java.security.SecureRandom, /) -> None: ...
    @typing.overload
    def init(self, params: java.security.spec.AlgorithmParameterSpec, /) -> None: ...
    @typing.overload
    def init(self, keysize: int | java.jint | java.lang.Integer, random: java.security.SecureRandom, /) -> None: ...
    @typing.overload
    def init(self, params: java.security.spec.AlgorithmParameterSpec, random: java.security.SecureRandom, /) -> None: ...

class KeyGeneratorSpi(java.lang.Object):
    def __init__(self) -> None: ...
    def engineGenerateKey(self) -> SecretKey: ...
    @typing.overload
    def engineInit(self, arg1: java.security.SecureRandom, /) -> None: ...
    @typing.overload
    def engineInit(self, arg1: int | java.jint | java.lang.Integer, arg2: java.security.SecureRandom, /) -> None: ...
    @typing.overload
    def engineInit(self, arg1: java.security.spec.AlgorithmParameterSpec, arg2: java.security.SecureRandom, /) -> None: ...

class Mac(java.lang.Cloneable):
    def __init__(self, macSpi: MacSpi, provider: java.security.Provider, algorithm: str | java.lang.String, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    @typing.overload
    def doFinal(self) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def doFinal(self, input: java.chaquopy.JavaArrayJByte, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    def doFinal(self, output: java.chaquopy.JavaArrayJByte, outOffset: int | java.jint | java.lang.Integer, /) -> None: ...
    def getAlgorithm(self) -> str: ...
    @typing.overload
    @staticmethod
    def getInstance(algorithm: str | java.lang.String, /) -> Mac: ...
    @typing.overload
    @staticmethod
    def getInstance(algorithm: str | java.lang.String, provider: str | java.lang.String, /) -> Mac: ...
    @typing.overload
    @staticmethod
    def getInstance(algorithm: str | java.lang.String, provider: java.security.Provider, /) -> Mac: ...
    def getMacLength(self) -> int: ...
    def getProvider(self) -> java.security.Provider: ...
    @typing.overload
    def init(self, key: java.security.Key, /) -> None: ...
    @typing.overload
    def init(self, key: java.security.Key, params: java.security.spec.AlgorithmParameterSpec, /) -> None: ...
    def reset(self) -> None: ...
    @typing.overload
    def update(self, input: int | java.jbyte | java.lang.Byte, /) -> None: ...
    @typing.overload
    def update(self, input: java.nio.ByteBuffer, /) -> None: ...
    @typing.overload
    def update(self, input: java.chaquopy.JavaArrayJByte, /) -> None: ...
    @typing.overload
    def update(self, input: java.chaquopy.JavaArrayJByte, offset: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, /) -> None: ...

class MacSpi(java.lang.Object):
    def __init__(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def engineDoFinal(self) -> java.chaquopy.JavaArrayJByte: ...
    def engineGetMacLength(self) -> int: ...
    def engineInit(self, arg1: java.security.Key, arg2: java.security.spec.AlgorithmParameterSpec, /) -> None: ...
    def engineReset(self) -> None: ...
    @typing.overload
    def engineUpdate(self, arg1: int | java.jbyte | java.lang.Byte, /) -> None: ...
    @typing.overload
    def engineUpdate(self, input: java.nio.ByteBuffer, /) -> None: ...
    @typing.overload
    def engineUpdate(self, arg1: java.chaquopy.JavaArrayJByte, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> None: ...

class NoSuchPaddingException(java.security.GeneralSecurityException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class NullCipher(Cipher):
    def __init__(self) -> None: ...

class SealedObject(java.io.Serializable):
    encodedParams: java.chaquopy.JavaArrayJByte = ...
    @typing.overload
    def __init__(self, so: SealedObject, /) -> None: ...
    @typing.overload
    def __init__(self, object: java.io.Serializable, c: Cipher, /) -> None: ...
    def getAlgorithm(self) -> str: ...
    @typing.overload
    def getObject(self, key: java.security.Key, /) -> java.lang.Object: ...
    @typing.overload
    def getObject(self, c: Cipher, /) -> java.lang.Object: ...
    @typing.overload
    def getObject(self, key: java.security.Key, provider: str | java.lang.String, /) -> java.lang.Object: ...

class SecretKey(java.security.Key, javax.security.auth.Destroyable):
    serialVersionUID: typing.ClassVar[int] = ...

class SecretKeyFactory(java.lang.Object):
    def __init__(self, keyFacSpi: SecretKeyFactorySpi, provider: java.security.Provider, algorithm: str | java.lang.String, /) -> None: ...
    def generateSecret(self, keySpec: java.security.spec.KeySpec, /) -> SecretKey: ...
    def getAlgorithm(self) -> str: ...
    @typing.overload
    @staticmethod
    def getInstance(algorithm: str | java.lang.String, /) -> SecretKeyFactory: ...
    @typing.overload
    @staticmethod
    def getInstance(algorithm: str | java.lang.String, provider: str | java.lang.String, /) -> SecretKeyFactory: ...
    @typing.overload
    @staticmethod
    def getInstance(algorithm: str | java.lang.String, provider: java.security.Provider, /) -> SecretKeyFactory: ...
    def getKeySpec(self, key: SecretKey, keySpec: typing.Type[java.lang.Object], /) -> java.security.spec.KeySpec: ...
    def getProvider(self) -> java.security.Provider: ...
    def translateKey(self, key: SecretKey, /) -> SecretKey: ...

class SecretKeyFactorySpi(java.lang.Object):
    def __init__(self) -> None: ...
    def engineGenerateSecret(self, arg1: java.security.spec.KeySpec, /) -> SecretKey: ...
    def engineGetKeySpec(self, arg1: SecretKey, arg2: typing.Type[java.lang.Object], /) -> java.security.spec.KeySpec: ...
    def engineTranslateKey(self, arg1: SecretKey, /) -> SecretKey: ...

class ShortBufferException(java.security.GeneralSecurityException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...
