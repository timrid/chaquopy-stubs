import android.icu.math
import android.icu.number
import android.icu.util
import java
import java.chaquopy
import java.io
import java.lang
import java.math
import java.text
import java.util
import typing



_AlphabeticIndex__V = typing.TypeVar('_AlphabeticIndex__V')  # <V>

_AlphabeticIndex__Record__V = typing.TypeVar('_AlphabeticIndex__Record__V')  # <V>

_AlphabeticIndex__ImmutableIndex__V = typing.TypeVar('_AlphabeticIndex__ImmutableIndex__V')  # <V>

_AlphabeticIndex__Bucket__V = typing.TypeVar('_AlphabeticIndex__Bucket__V')  # <V>
class AlphabeticIndex(java.lang.Iterable[AlphabeticIndex.Bucket[_AlphabeticIndex__V]], typing.Generic[_AlphabeticIndex__V]):
    @typing.overload
    def __init__(self, collator: RuleBasedCollator, /) -> None: ...
    @typing.overload
    def __init__(self, locale: android.icu.util.ULocale, /) -> None: ...
    @typing.overload
    def __init__(self, locale: java.util.Locale, /) -> None: ...
    @typing.overload
    def addLabels(self, additions: UnicodeSet, /) -> AlphabeticIndex[_AlphabeticIndex__V]: ...
    @typing.overload
    def addLabels(self, *additions: android.icu.util.ULocale) -> AlphabeticIndex[_AlphabeticIndex__V]: ...
    @typing.overload
    def addLabels(self, *additions: java.util.Locale) -> AlphabeticIndex[_AlphabeticIndex__V]: ...
    def addRecord(self, name: java.lang.CharSequence, data: _AlphabeticIndex__V, /) -> AlphabeticIndex[_AlphabeticIndex__V]: ...
    def buildImmutableIndex(self) -> AlphabeticIndex.ImmutableIndex[_AlphabeticIndex__V]: ...
    def clearRecords(self) -> AlphabeticIndex[_AlphabeticIndex__V]: ...
    def getBucketCount(self) -> int: ...
    def getBucketIndex(self, name: java.lang.CharSequence, /) -> int: ...
    def getBucketLabels(self) -> java.util.List[java.lang.String]: ...
    def getCollator(self) -> RuleBasedCollator: ...
    def getInflowLabel(self) -> str: ...
    def getMaxLabelCount(self) -> int: ...
    def getOverflowLabel(self) -> str: ...
    def getRecordCount(self) -> int: ...
    def getUnderflowLabel(self) -> str: ...
    def iterator(self) -> java.util.Iterator[AlphabeticIndex.Bucket[_AlphabeticIndex__V]]: ...
    def setInflowLabel(self, inflowLabel: str | java.lang.String, /) -> AlphabeticIndex[_AlphabeticIndex__V]: ...
    def setMaxLabelCount(self, maxLabelCount: int | java.jint | java.lang.Integer, /) -> AlphabeticIndex[_AlphabeticIndex__V]: ...
    def setOverflowLabel(self, overflowLabel: str | java.lang.String, /) -> AlphabeticIndex[_AlphabeticIndex__V]: ...
    def setUnderflowLabel(self, underflowLabel: str | java.lang.String, /) -> AlphabeticIndex[_AlphabeticIndex__V]: ...
    class Record(java.lang.Object, typing.Generic[_AlphabeticIndex__Record__V]):
        def getData(self) -> _AlphabeticIndex__Record__V: ...
        def getName(self) -> java.lang.CharSequence: ...
        def toString(self) -> str: ...
    class ImmutableIndex(java.lang.Iterable[AlphabeticIndex.Bucket[_AlphabeticIndex__ImmutableIndex__V]], typing.Generic[_AlphabeticIndex__ImmutableIndex__V]):
        def getBucket(self, index: int | java.jint | java.lang.Integer, /) -> AlphabeticIndex.Bucket[_AlphabeticIndex__ImmutableIndex__V]: ...
        def getBucketCount(self) -> int: ...
        def getBucketIndex(self, name: java.lang.CharSequence, /) -> int: ...
        def iterator(self) -> java.util.Iterator[AlphabeticIndex.Bucket[_AlphabeticIndex__ImmutableIndex__V]]: ...
    class Bucket(java.lang.Iterable[AlphabeticIndex.Record[_AlphabeticIndex__Bucket__V]], typing.Generic[_AlphabeticIndex__Bucket__V]):
        def getLabel(self) -> str: ...
        def getLabelType(self) -> AlphabeticIndex.Bucket.LabelType: ...
        def iterator(self) -> java.util.Iterator[AlphabeticIndex.Record[_AlphabeticIndex__Bucket__V]]: ...
        def size(self) -> int: ...
        def toString(self) -> str: ...

        class LabelType(java.lang.Enum[AlphabeticIndex.Bucket.LabelType]):
            NORMAL: typing.ClassVar[AlphabeticIndex.Bucket.LabelType] = ...
            UNDERFLOW: typing.ClassVar[AlphabeticIndex.Bucket.LabelType] = ...
            INFLOW: typing.ClassVar[AlphabeticIndex.Bucket.LabelType] = ...
            OVERFLOW: typing.ClassVar[AlphabeticIndex.Bucket.LabelType] = ...
            @staticmethod
            def valueOf(name: str | java.lang.String, /) -> AlphabeticIndex.Bucket.LabelType: ...
            @staticmethod
            def values() -> java.chaquopy.JavaArray[AlphabeticIndex.Bucket.LabelType]: ...

class Bidi(java.lang.Object):
    DIRECTION_DEFAULT_LEFT_TO_RIGHT: typing.ClassVar[int] = ...
    DIRECTION_DEFAULT_RIGHT_TO_LEFT: typing.ClassVar[int] = ...
    DIRECTION_LEFT_TO_RIGHT: typing.ClassVar[int] = ...
    DIRECTION_RIGHT_TO_LEFT: typing.ClassVar[int] = ...
    DO_MIRRORING: typing.ClassVar[int] = ...
    INSERT_LRM_FOR_NUMERIC: typing.ClassVar[int] = ...
    KEEP_BASE_COMBINING: typing.ClassVar[int] = ...
    LEVEL_DEFAULT_LTR: typing.ClassVar[int] = ...
    LEVEL_DEFAULT_RTL: typing.ClassVar[int] = ...
    LEVEL_OVERRIDE: typing.ClassVar[int] = ...
    LTR: typing.ClassVar[int] = ...
    MAP_NOWHERE: typing.ClassVar[int] = ...
    MAX_EXPLICIT_LEVEL: typing.ClassVar[int] = ...
    MIXED: typing.ClassVar[int] = ...
    NEUTRAL: typing.ClassVar[int] = ...
    OPTION_DEFAULT: typing.ClassVar[int] = ...
    OPTION_INSERT_MARKS: typing.ClassVar[int] = ...
    OPTION_REMOVE_CONTROLS: typing.ClassVar[int] = ...
    OPTION_STREAMING: typing.ClassVar[int] = ...
    OUTPUT_REVERSE: typing.ClassVar[int] = ...
    REMOVE_BIDI_CONTROLS: typing.ClassVar[int] = ...
    REORDER_DEFAULT: typing.ClassVar[int] = ...
    REORDER_GROUP_NUMBERS_WITH_R: typing.ClassVar[int] = ...
    REORDER_INVERSE_FOR_NUMBERS_SPECIAL: typing.ClassVar[int] = ...
    REORDER_INVERSE_LIKE_DIRECT: typing.ClassVar[int] = ...
    REORDER_INVERSE_NUMBERS_AS_L: typing.ClassVar[int] = ...
    REORDER_NUMBERS_SPECIAL: typing.ClassVar[int] = ...
    REORDER_RUNS_ONLY: typing.ClassVar[int] = ...
    RTL: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, paragraph: java.text.AttributedCharacterIterator, /) -> None: ...
    @typing.overload
    def __init__(self, maxLength: int | java.jint | java.lang.Integer, maxRunCount: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, paragraph: str | java.lang.String, flags: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, text: java.chaquopy.JavaArrayJChar, textStart: int | java.jint | java.lang.Integer, embeddings: java.chaquopy.JavaArrayJByte, embStart: int | java.jint | java.lang.Integer, paragraphLength: int | java.jint | java.lang.Integer, flags: int | java.jint | java.lang.Integer, /) -> None: ...
    def baseIsLeftToRight(self) -> bool: ...
    def countParagraphs(self) -> int: ...
    def countRuns(self) -> int: ...
    def createLineBidi(self, lineStart: int | java.jint | java.lang.Integer, lineLimit: int | java.jint | java.lang.Integer, /) -> Bidi: ...
    @staticmethod
    def getBaseDirection(paragraph: java.lang.CharSequence, /) -> int: ...
    def getBaseLevel(self) -> int: ...
    def getCustomClassifier(self) -> BidiClassifier: ...
    def getCustomizedClass(self, c: int | java.jint | java.lang.Integer, /) -> int: ...
    def getDirection(self) -> int: ...
    def getLength(self) -> int: ...
    def getLevelAt(self, charIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLevels(self) -> java.chaquopy.JavaArrayJByte: ...
    def getLogicalIndex(self, visualIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLogicalMap(self) -> java.chaquopy.JavaArrayJInt: ...
    def getLogicalRun(self, logicalPosition: int | java.jint | java.lang.Integer, /) -> BidiRun: ...
    def getParaLevel(self) -> int: ...
    def getParagraph(self, charIndex: int | java.jint | java.lang.Integer, /) -> BidiRun: ...
    def getParagraphByIndex(self, paraIndex: int | java.jint | java.lang.Integer, /) -> BidiRun: ...
    def getParagraphIndex(self, charIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    def getProcessedLength(self) -> int: ...
    def getReorderingMode(self) -> int: ...
    def getReorderingOptions(self) -> int: ...
    def getResultLength(self) -> int: ...
    def getRunCount(self) -> int: ...
    def getRunLevel(self, run: int | java.jint | java.lang.Integer, /) -> int: ...
    def getRunLimit(self, run: int | java.jint | java.lang.Integer, /) -> int: ...
    def getRunStart(self, run: int | java.jint | java.lang.Integer, /) -> int: ...
    def getText(self) -> java.chaquopy.JavaArrayJChar: ...
    def getTextAsString(self) -> str: ...
    def getVisualIndex(self, logicalIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    def getVisualMap(self) -> java.chaquopy.JavaArrayJInt: ...
    def getVisualRun(self, runIndex: int | java.jint | java.lang.Integer, /) -> BidiRun: ...
    @staticmethod
    def invertMap(srcMap: java.chaquopy.JavaArrayJInt, /) -> java.chaquopy.JavaArrayJInt: ...
    def isInverse(self) -> bool: ...
    def isLeftToRight(self) -> bool: ...
    def isMixed(self) -> bool: ...
    def isOrderParagraphsLTR(self) -> bool: ...
    def isRightToLeft(self) -> bool: ...
    def orderParagraphsLTR(self, ordarParaLTR: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @staticmethod
    def reorderLogical(levels: java.chaquopy.JavaArrayJByte, /) -> java.chaquopy.JavaArrayJInt: ...
    @staticmethod
    def reorderVisual(levels: java.chaquopy.JavaArrayJByte, /) -> java.chaquopy.JavaArrayJInt: ...
    @staticmethod
    def reorderVisually(levels: java.chaquopy.JavaArrayJByte, levelStart: int | java.jint | java.lang.Integer, objects: java.chaquopy.JavaArray[java.lang.Object], objectStart: int | java.jint | java.lang.Integer, count: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def requiresBidi(text: java.chaquopy.JavaArrayJChar, start: int | java.jint | java.lang.Integer, limit: int | java.jint | java.lang.Integer, /) -> bool: ...
    def setContext(self, prologue: str | java.lang.String, epilogue: str | java.lang.String, /) -> None: ...
    def setCustomClassifier(self, classifier: BidiClassifier, /) -> None: ...
    def setInverse(self, isInverse: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setLine(self, start: int | java.jint | java.lang.Integer, limit: int | java.jint | java.lang.Integer, /) -> Bidi: ...
    @typing.overload
    def setPara(self, paragraph: java.text.AttributedCharacterIterator, /) -> None: ...
    @typing.overload
    def setPara(self, text: str | java.lang.String, paraLevel: int | java.jbyte | java.lang.Byte, embeddingLevels: java.chaquopy.JavaArrayJByte, /) -> None: ...
    @typing.overload
    def setPara(self, chars: java.chaquopy.JavaArrayJChar, paraLevel: int | java.jbyte | java.lang.Byte, embeddingLevels: java.chaquopy.JavaArrayJByte, /) -> None: ...
    def setReorderingMode(self, reorderingMode: int | java.jint | java.lang.Integer, /) -> None: ...
    def setReorderingOptions(self, options: int | java.jint | java.lang.Integer, /) -> None: ...
    def writeReordered(self, options: int | java.jint | java.lang.Integer, /) -> str: ...
    @staticmethod
    def writeReverse(src: str | java.lang.String, options: int | java.jint | java.lang.Integer, /) -> str: ...

class BidiClassifier(java.lang.Object):
    def __init__(self, context: java.lang.Object | int | bool | float | str, /) -> None: ...
    def classify(self, c: int | java.jint | java.lang.Integer, /) -> int: ...
    def getContext(self) -> java.lang.Object: ...
    def setContext(self, context: java.lang.Object | int | bool | float | str, /) -> None: ...

class BidiRun(java.lang.Object):
    def getDirection(self) -> int: ...
    def getEmbeddingLevel(self) -> int: ...
    def getLength(self) -> int: ...
    def getLimit(self) -> int: ...
    def getStart(self) -> int: ...
    def isEvenRun(self) -> bool: ...
    def isOddRun(self) -> bool: ...
    def toString(self) -> str: ...

class BreakIterator(java.lang.Cloneable):
    DONE: typing.ClassVar[int] = ...
    KIND_CHARACTER: typing.ClassVar[int] = ...
    KIND_LINE: typing.ClassVar[int] = ...
    KIND_SENTENCE: typing.ClassVar[int] = ...
    KIND_TITLE: typing.ClassVar[int] = ...
    KIND_WORD: typing.ClassVar[int] = ...
    WORD_IDEO: typing.ClassVar[int] = ...
    WORD_IDEO_LIMIT: typing.ClassVar[int] = ...
    WORD_KANA: typing.ClassVar[int] = ...
    WORD_KANA_LIMIT: typing.ClassVar[int] = ...
    WORD_LETTER: typing.ClassVar[int] = ...
    WORD_LETTER_LIMIT: typing.ClassVar[int] = ...
    WORD_NONE: typing.ClassVar[int] = ...
    WORD_NONE_LIMIT: typing.ClassVar[int] = ...
    WORD_NUMBER: typing.ClassVar[int] = ...
    WORD_NUMBER_LIMIT: typing.ClassVar[int] = ...
    def __init__(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def current(self) -> int: ...
    def first(self) -> int: ...
    def following(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def getAvailableLocales() -> java.chaquopy.JavaArray[java.util.Locale]: ...
    @typing.overload
    @staticmethod
    def getCharacterInstance() -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getCharacterInstance(where: android.icu.util.ULocale, /) -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getCharacterInstance(where: java.util.Locale, /) -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getLineInstance() -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getLineInstance(where: android.icu.util.ULocale, /) -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getLineInstance(where: java.util.Locale, /) -> BreakIterator: ...
    def getRuleStatus(self) -> int: ...
    def getRuleStatusVec(self, fillInArray: java.chaquopy.JavaArrayJInt, /) -> int: ...
    @typing.overload
    @staticmethod
    def getSentenceInstance() -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getSentenceInstance(where: android.icu.util.ULocale, /) -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getSentenceInstance(where: java.util.Locale, /) -> BreakIterator: ...
    def getText(self) -> java.text.CharacterIterator: ...
    @typing.overload
    @staticmethod
    def getTitleInstance() -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getTitleInstance(where: android.icu.util.ULocale, /) -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getTitleInstance(where: java.util.Locale, /) -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getWordInstance() -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getWordInstance(where: android.icu.util.ULocale, /) -> BreakIterator: ...
    @typing.overload
    @staticmethod
    def getWordInstance(where: java.util.Locale, /) -> BreakIterator: ...
    def isBoundary(self, offset: int | java.jint | java.lang.Integer, /) -> bool: ...
    def last(self) -> int: ...
    @typing.overload
    def next(self) -> int: ...
    @typing.overload
    def next(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def preceding(self, offset: int | java.jint | java.lang.Integer, /) -> int: ...
    def previous(self) -> int: ...
    @typing.overload
    def setText(self, newText: java.lang.CharSequence, /) -> None: ...
    @typing.overload
    def setText(self, newText: str | java.lang.String, /) -> None: ...
    @typing.overload
    def setText(self, arg1: java.text.CharacterIterator, /) -> None: ...

class CaseMap(java.lang.Object):
    @staticmethod
    def fold() -> CaseMap.Fold: ...
    def omitUnchangedText(self) -> CaseMap: ...
    @staticmethod
    def toLower() -> CaseMap.Lower: ...
    @staticmethod
    def toTitle() -> CaseMap.Title: ...
    @staticmethod
    def toUpper() -> CaseMap.Upper: ...

    class Upper(CaseMap):
        _apply_1__A = typing.TypeVar('_apply_1__A')  # <A>
        @typing.overload
        def apply(self, locale: java.util.Locale, src: java.lang.CharSequence, /) -> str: ...
        @typing.overload
        def apply(self, locale: java.util.Locale, src: java.lang.CharSequence, dest: _apply_1__A, edits: Edits, /) -> _apply_1__A: ...
        def omitUnchangedText(self) -> CaseMap.Upper: ...

    class Title(CaseMap):
        def adjustToCased(self) -> CaseMap.Title: ...
        _apply_1__A = typing.TypeVar('_apply_1__A')  # <A>
        @typing.overload
        def apply(self, locale: java.util.Locale, iter: BreakIterator, src: java.lang.CharSequence, /) -> str: ...
        @typing.overload
        def apply(self, locale: java.util.Locale, iter: BreakIterator, src: java.lang.CharSequence, dest: _apply_1__A, edits: Edits, /) -> _apply_1__A: ...
        def noBreakAdjustment(self) -> CaseMap.Title: ...
        def noLowercase(self) -> CaseMap.Title: ...
        def omitUnchangedText(self) -> CaseMap.Title: ...
        def sentences(self) -> CaseMap.Title: ...
        def wholeString(self) -> CaseMap.Title: ...

    class Lower(CaseMap):
        _apply_1__A = typing.TypeVar('_apply_1__A')  # <A>
        @typing.overload
        def apply(self, locale: java.util.Locale, src: java.lang.CharSequence, /) -> str: ...
        @typing.overload
        def apply(self, locale: java.util.Locale, src: java.lang.CharSequence, dest: _apply_1__A, edits: Edits, /) -> _apply_1__A: ...
        def omitUnchangedText(self) -> CaseMap.Lower: ...

    class Fold(CaseMap):
        _apply_1__A = typing.TypeVar('_apply_1__A')  # <A>
        @typing.overload
        def apply(self, src: java.lang.CharSequence, /) -> str: ...
        @typing.overload
        def apply(self, src: java.lang.CharSequence, dest: _apply_1__A, edits: Edits, /) -> _apply_1__A: ...
        def omitUnchangedText(self) -> CaseMap.Fold: ...
        def turkic(self) -> CaseMap.Fold: ...

class CollationElementIterator(java.lang.Object):
    IGNORABLE: typing.ClassVar[int] = ...
    NULLORDER: typing.ClassVar[int] = ...
    def equals(self, that: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getMaxExpansion(self, ce: int | java.jint | java.lang.Integer, /) -> int: ...
    def getOffset(self) -> int: ...
    def hashCode(self) -> int: ...
    def next(self) -> int: ...
    def previous(self) -> int: ...
    @staticmethod
    def primaryOrder(ce: int | java.jint | java.lang.Integer, /) -> int: ...
    def reset(self) -> None: ...
    @staticmethod
    def secondaryOrder(ce: int | java.jint | java.lang.Integer, /) -> int: ...
    def setOffset(self, newOffset: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def setText(self, source: UCharacterIterator, /) -> None: ...
    @typing.overload
    def setText(self, source: str | java.lang.String, /) -> None: ...
    @typing.overload
    def setText(self, source: java.text.CharacterIterator, /) -> None: ...
    @staticmethod
    def tertiaryOrder(ce: int | java.jint | java.lang.Integer, /) -> int: ...

class CollationKey(java.lang.Comparable[CollationKey]):
    def __init__(self, source: str | java.lang.String, key: java.chaquopy.JavaArrayJByte, /) -> None: ...
    def compareTo(self, target: CollationKey, /) -> int: ...
    @typing.overload
    def equals(self, target: CollationKey, /) -> bool: ...
    @typing.overload
    def equals(self, target: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getBound(self, boundType: int | java.jint | java.lang.Integer, noOfLevels: int | java.jint | java.lang.Integer, /) -> CollationKey: ...
    def getSourceString(self) -> str: ...
    def hashCode(self) -> int: ...
    def merge(self, source: CollationKey, /) -> CollationKey: ...
    def toByteArray(self) -> java.chaquopy.JavaArrayJByte: ...

    class BoundMode(java.lang.Object):
        LOWER: typing.ClassVar[int] = ...
        UPPER: typing.ClassVar[int] = ...
        UPPER_LONG: typing.ClassVar[int] = ...

class Collator(java.util.Comparator[java.lang.Object], android.icu.util.Freezable[Collator], java.lang.Cloneable):
    CANONICAL_DECOMPOSITION: typing.ClassVar[int] = ...
    FULL_DECOMPOSITION: typing.ClassVar[int] = ...
    IDENTICAL: typing.ClassVar[int] = ...
    NO_DECOMPOSITION: typing.ClassVar[int] = ...
    PRIMARY: typing.ClassVar[int] = ...
    QUATERNARY: typing.ClassVar[int] = ...
    SECONDARY: typing.ClassVar[int] = ...
    TERTIARY: typing.ClassVar[int] = ...
    def __init__(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def cloneAsThawed(self) -> Collator: ...
    @typing.overload
    def compare(self, source: java.lang.Object | int | bool | float | str, target: java.lang.Object | int | bool | float | str, /) -> int: ...
    @typing.overload
    def compare(self, arg1: str | java.lang.String, arg2: str | java.lang.String, /) -> int: ...
    @typing.overload
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def equals(self, source: str | java.lang.String, target: str | java.lang.String, /) -> bool: ...
    def freeze(self) -> Collator: ...
    @staticmethod
    def getAvailableLocales() -> java.chaquopy.JavaArray[java.util.Locale]: ...
    @staticmethod
    def getAvailableULocales() -> java.chaquopy.JavaArray[android.icu.util.ULocale]: ...
    def getCollationKey(self, arg1: str | java.lang.String, /) -> CollationKey: ...
    def getDecomposition(self) -> int: ...
    @typing.overload
    @staticmethod
    def getDisplayName(objectLocale: android.icu.util.ULocale, /) -> str: ...
    @typing.overload
    @staticmethod
    def getDisplayName(objectLocale: java.util.Locale, /) -> str: ...
    @typing.overload
    @staticmethod
    def getDisplayName(objectLocale: android.icu.util.ULocale, displayLocale: android.icu.util.ULocale, /) -> str: ...
    @typing.overload
    @staticmethod
    def getDisplayName(objectLocale: java.util.Locale, displayLocale: java.util.Locale, /) -> str: ...
    @staticmethod
    def getEquivalentReorderCodes(reorderCode: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJInt: ...
    @typing.overload
    @staticmethod
    def getFunctionalEquivalent(keyword: str | java.lang.String, locID: android.icu.util.ULocale, /) -> android.icu.util.ULocale: ...
    @typing.overload
    @staticmethod
    def getFunctionalEquivalent(keyword: str | java.lang.String, locID: android.icu.util.ULocale, isAvailable: java.chaquopy.JavaArrayJBoolean, /) -> android.icu.util.ULocale: ...
    @typing.overload
    @staticmethod
    def getInstance() -> Collator: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, /) -> Collator: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, /) -> Collator: ...
    @staticmethod
    def getKeywordValues(keyword: str | java.lang.String, /) -> java.chaquopy.JavaArray[java.lang.String]: ...
    @staticmethod
    def getKeywordValuesForLocale(key: str | java.lang.String, locale: android.icu.util.ULocale, commonlyUsed: bool | java.jboolean | java.lang.Boolean, /) -> java.chaquopy.JavaArray[java.lang.String]: ...
    @staticmethod
    def getKeywords() -> java.chaquopy.JavaArray[java.lang.String]: ...
    def getMaxVariable(self) -> int: ...
    def getReorderCodes(self) -> java.chaquopy.JavaArrayJInt: ...
    def getStrength(self) -> int: ...
    def getTailoredSet(self) -> UnicodeSet: ...
    def getUCAVersion(self) -> android.icu.util.VersionInfo: ...
    def getVariableTop(self) -> int: ...
    def getVersion(self) -> android.icu.util.VersionInfo: ...
    def hashCode(self) -> int: ...
    def isFrozen(self) -> bool: ...
    def setDecomposition(self, decomposition: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMaxVariable(self, group: int | java.jint | java.lang.Integer, /) -> Collator: ...
    def setReorderCodes(self, *order: java.chaquopy.JavaArrayJInt) -> None: ...
    def setStrength(self, newStrength: int | java.jint | java.lang.Integer, /) -> None: ...

    class ReorderCodes(java.lang.Object):
        CURRENCY: typing.ClassVar[int] = ...
        DEFAULT: typing.ClassVar[int] = ...
        DIGIT: typing.ClassVar[int] = ...
        FIRST: typing.ClassVar[int] = ...
        NONE: typing.ClassVar[int] = ...
        OTHERS: typing.ClassVar[int] = ...
        PUNCTUATION: typing.ClassVar[int] = ...
        SPACE: typing.ClassVar[int] = ...
        SYMBOL: typing.ClassVar[int] = ...

class CompactDecimalFormat(DecimalFormat):
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, style: CompactDecimalFormat.CompactStyle, /) -> CompactDecimalFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, style: CompactDecimalFormat.CompactStyle, /) -> CompactDecimalFormat: ...
    def parse(self, text: str | java.lang.String, parsePosition: java.text.ParsePosition, /) -> java.lang.Number: ...
    def parseCurrency(self, text: java.lang.CharSequence, parsePosition: java.text.ParsePosition, /) -> android.icu.util.CurrencyAmount: ...

    class CompactStyle(java.lang.Enum[CompactDecimalFormat.CompactStyle]):
        SHORT: typing.ClassVar[CompactDecimalFormat.CompactStyle] = ...
        LONG: typing.ClassVar[CompactDecimalFormat.CompactStyle] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> CompactDecimalFormat.CompactStyle: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[CompactDecimalFormat.CompactStyle]: ...

class ConstrainedFieldPosition(java.lang.Object):
    def __init__(self) -> None: ...
    def constrainClass(self, classConstraint: typing.Type[java.lang.Object], /) -> None: ...
    def constrainField(self, field: java.text.Format.Field, /) -> None: ...
    def getField(self) -> java.text.Format.Field | None: ...
    def getFieldValue(self) -> java.lang.Object | None: ...
    def getInt64IterationContext(self) -> int: ...
    def getLimit(self) -> int: ...
    def getStart(self) -> int: ...
    def matchesField(self, field: java.text.Format.Field, fieldValue: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def reset(self) -> None: ...
    def setInt64IterationContext(self, context: int | java.jlong | java.lang.Long, /) -> None: ...
    def setState(self, field: java.text.Format.Field, value: java.lang.Object | int | bool | float | str, start: int | java.jint | java.lang.Integer, limit: int | java.jint | java.lang.Integer, /) -> None: ...
    def toString(self) -> str: ...

class CurrencyPluralInfo(java.lang.Cloneable, java.io.Serializable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, locale: android.icu.util.ULocale, /) -> None: ...
    @typing.overload
    def __init__(self, locale: java.util.Locale, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, a: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getCurrencyPluralPattern(self, pluralCount: str | java.lang.String, /) -> str: ...
    @typing.overload
    @staticmethod
    def getInstance() -> CurrencyPluralInfo: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, /) -> CurrencyPluralInfo: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, /) -> CurrencyPluralInfo: ...
    def getLocale(self) -> android.icu.util.ULocale: ...
    def getPluralRules(self) -> PluralRules: ...
    def hashCode(self) -> int: ...
    def setCurrencyPluralPattern(self, pluralCount: str | java.lang.String, pattern: str | java.lang.String, /) -> None: ...
    def setLocale(self, loc: android.icu.util.ULocale, /) -> None: ...
    def setPluralRules(self, ruleDescription: str | java.lang.String, /) -> None: ...

class DateFormat(UFormat):
    ABBR_GENERIC_TZ: typing.ClassVar[str] = ...
    ABBR_MONTH: typing.ClassVar[str] = ...
    ABBR_MONTH_DAY: typing.ClassVar[str] = ...
    ABBR_MONTH_WEEKDAY_DAY: typing.ClassVar[str] = ...
    ABBR_QUARTER: typing.ClassVar[str] = ...
    ABBR_SPECIFIC_TZ: typing.ClassVar[str] = ...
    ABBR_UTC_TZ: typing.ClassVar[str] = ...
    ABBR_WEEKDAY: typing.ClassVar[str] = ...
    AM_PM_FIELD: typing.ClassVar[int] = ...
    AM_PM_MIDNIGHT_NOON_FIELD: typing.ClassVar[int] = ...
    DATE_FIELD: typing.ClassVar[int] = ...
    DAY: typing.ClassVar[str] = ...
    DAY_OF_WEEK_FIELD: typing.ClassVar[int] = ...
    DAY_OF_WEEK_IN_MONTH_FIELD: typing.ClassVar[int] = ...
    DAY_OF_YEAR_FIELD: typing.ClassVar[int] = ...
    DEFAULT: typing.ClassVar[int] = ...
    DOW_LOCAL_FIELD: typing.ClassVar[int] = ...
    ERA_FIELD: typing.ClassVar[int] = ...
    EXTENDED_YEAR_FIELD: typing.ClassVar[int] = ...
    FLEXIBLE_DAY_PERIOD_FIELD: typing.ClassVar[int] = ...
    FRACTIONAL_SECOND_FIELD: typing.ClassVar[int] = ...
    FULL: typing.ClassVar[int] = ...
    GENERIC_TZ: typing.ClassVar[str] = ...
    HOUR: typing.ClassVar[str] = ...
    HOUR0_FIELD: typing.ClassVar[int] = ...
    HOUR1_FIELD: typing.ClassVar[int] = ...
    HOUR24: typing.ClassVar[str] = ...
    HOUR24_MINUTE: typing.ClassVar[str] = ...
    HOUR24_MINUTE_SECOND: typing.ClassVar[str] = ...
    HOUR_MINUTE: typing.ClassVar[str] = ...
    HOUR_MINUTE_SECOND: typing.ClassVar[str] = ...
    HOUR_OF_DAY0_FIELD: typing.ClassVar[int] = ...
    HOUR_OF_DAY1_FIELD: typing.ClassVar[int] = ...
    JULIAN_DAY_FIELD: typing.ClassVar[int] = ...
    LOCATION_TZ: typing.ClassVar[str] = ...
    LONG: typing.ClassVar[int] = ...
    MEDIUM: typing.ClassVar[int] = ...
    MILLISECONDS_IN_DAY_FIELD: typing.ClassVar[int] = ...
    MILLISECOND_FIELD: typing.ClassVar[int] = ...
    MINUTE: typing.ClassVar[str] = ...
    MINUTE_FIELD: typing.ClassVar[int] = ...
    MINUTE_SECOND: typing.ClassVar[str] = ...
    MONTH: typing.ClassVar[str] = ...
    MONTH_DAY: typing.ClassVar[str] = ...
    MONTH_FIELD: typing.ClassVar[int] = ...
    MONTH_WEEKDAY_DAY: typing.ClassVar[str] = ...
    NONE: typing.ClassVar[int] = ...
    NUM_MONTH: typing.ClassVar[str] = ...
    NUM_MONTH_DAY: typing.ClassVar[str] = ...
    NUM_MONTH_WEEKDAY_DAY: typing.ClassVar[str] = ...
    QUARTER: typing.ClassVar[str] = ...
    QUARTER_FIELD: typing.ClassVar[int] = ...
    RELATIVE: typing.ClassVar[int] = ...
    RELATIVE_DEFAULT: typing.ClassVar[int] = ...
    RELATIVE_FULL: typing.ClassVar[int] = ...
    RELATIVE_LONG: typing.ClassVar[int] = ...
    RELATIVE_MEDIUM: typing.ClassVar[int] = ...
    RELATIVE_SHORT: typing.ClassVar[int] = ...
    SECOND: typing.ClassVar[str] = ...
    SECOND_FIELD: typing.ClassVar[int] = ...
    SHORT: typing.ClassVar[int] = ...
    SPECIFIC_TZ: typing.ClassVar[str] = ...
    STANDALONE_DAY_FIELD: typing.ClassVar[int] = ...
    STANDALONE_MONTH_FIELD: typing.ClassVar[int] = ...
    STANDALONE_QUARTER_FIELD: typing.ClassVar[int] = ...
    TIMEZONE_FIELD: typing.ClassVar[int] = ...
    TIMEZONE_GENERIC_FIELD: typing.ClassVar[int] = ...
    TIMEZONE_ISO_FIELD: typing.ClassVar[int] = ...
    TIMEZONE_ISO_LOCAL_FIELD: typing.ClassVar[int] = ...
    TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD: typing.ClassVar[int] = ...
    TIMEZONE_RFC_FIELD: typing.ClassVar[int] = ...
    TIMEZONE_SPECIAL_FIELD: typing.ClassVar[int] = ...
    WEEKDAY: typing.ClassVar[str] = ...
    WEEK_OF_MONTH_FIELD: typing.ClassVar[int] = ...
    WEEK_OF_YEAR_FIELD: typing.ClassVar[int] = ...
    YEAR: typing.ClassVar[str] = ...
    YEAR_ABBR_MONTH: typing.ClassVar[str] = ...
    YEAR_ABBR_MONTH_DAY: typing.ClassVar[str] = ...
    YEAR_ABBR_MONTH_WEEKDAY_DAY: typing.ClassVar[str] = ...
    YEAR_ABBR_QUARTER: typing.ClassVar[str] = ...
    YEAR_FIELD: typing.ClassVar[int] = ...
    YEAR_MONTH: typing.ClassVar[str] = ...
    YEAR_MONTH_DAY: typing.ClassVar[str] = ...
    YEAR_MONTH_WEEKDAY_DAY: typing.ClassVar[str] = ...
    YEAR_NAME_FIELD: typing.ClassVar[int] = ...
    YEAR_NUM_MONTH: typing.ClassVar[str] = ...
    YEAR_NUM_MONTH_DAY: typing.ClassVar[str] = ...
    YEAR_NUM_MONTH_WEEKDAY_DAY: typing.ClassVar[str] = ...
    YEAR_QUARTER: typing.ClassVar[str] = ...
    YEAR_WOY_FIELD: typing.ClassVar[int] = ...
    calendar: android.icu.util.Calendar = ...
    numberFormat: NumberFormat = ...
    def __init__(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def format(self, date: java.util.Date, /) -> str: ...
    @typing.overload
    def format(self, arg1: android.icu.util.Calendar, arg2: java.lang.StringBuffer, arg3: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, obj: java.lang.Object | int | bool | float | str, toAppendTo: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, date: java.util.Date, toAppendTo: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @staticmethod
    def getAvailableLocales() -> java.chaquopy.JavaArray[java.util.Locale]: ...
    def getBooleanAttribute(self, key: DateFormat.BooleanAttribute, /) -> bool: ...
    def getCalendar(self) -> android.icu.util.Calendar: ...
    def getContext(self, type: DisplayContext.Type, /) -> DisplayContext: ...
    @typing.overload
    @staticmethod
    def getDateInstance() -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateInstance(style: int | java.jint | java.lang.Integer, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateInstance(style: int | java.jint | java.lang.Integer, locale: android.icu.util.ULocale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateInstance(style: int | java.jint | java.lang.Integer, aLocale: java.util.Locale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateInstance(cal: android.icu.util.Calendar, dateStyle: int | java.jint | java.lang.Integer, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateInstance(cal: android.icu.util.Calendar, dateStyle: int | java.jint | java.lang.Integer, locale: android.icu.util.ULocale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateInstance(cal: android.icu.util.Calendar, dateStyle: int | java.jint | java.lang.Integer, locale: java.util.Locale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateTimeInstance() -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateTimeInstance(dateStyle: int | java.jint | java.lang.Integer, timeStyle: int | java.jint | java.lang.Integer, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateTimeInstance(dateStyle: int | java.jint | java.lang.Integer, timeStyle: int | java.jint | java.lang.Integer, locale: android.icu.util.ULocale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateTimeInstance(dateStyle: int | java.jint | java.lang.Integer, timeStyle: int | java.jint | java.lang.Integer, aLocale: java.util.Locale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateTimeInstance(cal: android.icu.util.Calendar, dateStyle: int | java.jint | java.lang.Integer, timeStyle: int | java.jint | java.lang.Integer, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateTimeInstance(cal: android.icu.util.Calendar, dateStyle: int | java.jint | java.lang.Integer, timeStyle: int | java.jint | java.lang.Integer, locale: android.icu.util.ULocale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getDateTimeInstance(cal: android.icu.util.Calendar, dateStyle: int | java.jint | java.lang.Integer, timeStyle: int | java.jint | java.lang.Integer, locale: java.util.Locale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getInstance() -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(cal: android.icu.util.Calendar, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(cal: android.icu.util.Calendar, locale: android.icu.util.ULocale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(cal: android.icu.util.Calendar, locale: java.util.Locale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getInstanceForSkeleton(skeleton: str | java.lang.String, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getInstanceForSkeleton(skeleton: str | java.lang.String, locale: android.icu.util.ULocale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getInstanceForSkeleton(skeleton: str | java.lang.String, locale: java.util.Locale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getInstanceForSkeleton(cal: android.icu.util.Calendar, skeleton: str | java.lang.String, locale: android.icu.util.ULocale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getInstanceForSkeleton(cal: android.icu.util.Calendar, skeleton: str | java.lang.String, locale: java.util.Locale, /) -> DateFormat: ...
    def getNumberFormat(self) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getPatternInstance(skeleton: str | java.lang.String, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getPatternInstance(skeleton: str | java.lang.String, locale: android.icu.util.ULocale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getPatternInstance(skeleton: str | java.lang.String, locale: java.util.Locale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getPatternInstance(cal: android.icu.util.Calendar, skeleton: str | java.lang.String, locale: android.icu.util.ULocale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getPatternInstance(cal: android.icu.util.Calendar, skeleton: str | java.lang.String, locale: java.util.Locale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getTimeInstance() -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getTimeInstance(style: int | java.jint | java.lang.Integer, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getTimeInstance(style: int | java.jint | java.lang.Integer, locale: android.icu.util.ULocale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getTimeInstance(style: int | java.jint | java.lang.Integer, aLocale: java.util.Locale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getTimeInstance(cal: android.icu.util.Calendar, timeStyle: int | java.jint | java.lang.Integer, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getTimeInstance(cal: android.icu.util.Calendar, timeStyle: int | java.jint | java.lang.Integer, locale: android.icu.util.ULocale, /) -> DateFormat: ...
    @typing.overload
    @staticmethod
    def getTimeInstance(cal: android.icu.util.Calendar, timeStyle: int | java.jint | java.lang.Integer, locale: java.util.Locale, /) -> DateFormat: ...
    def getTimeZone(self) -> android.icu.util.TimeZone: ...
    def hashCode(self) -> int: ...
    def isCalendarLenient(self) -> bool: ...
    def isLenient(self) -> bool: ...
    @typing.overload
    def parse(self, text: str | java.lang.String, /) -> java.util.Date | None: ...
    @typing.overload
    def parse(self, text: str | java.lang.String, pos: java.text.ParsePosition, /) -> java.util.Date | None: ...
    @typing.overload
    def parse(self, arg1: str | java.lang.String, arg2: android.icu.util.Calendar, arg3: java.text.ParsePosition, /) -> None: ...
    def parseObject(self, source: str | java.lang.String, pos: java.text.ParsePosition, /) -> java.lang.Object: ...
    def setBooleanAttribute(self, key: DateFormat.BooleanAttribute, value: bool | java.jboolean | java.lang.Boolean, /) -> DateFormat: ...
    def setCalendar(self, newCalendar: android.icu.util.Calendar, /) -> None: ...
    def setCalendarLenient(self, lenient: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setContext(self, context: DisplayContext, /) -> None: ...
    def setLenient(self, lenient: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setNumberFormat(self, newNumberFormat: NumberFormat, /) -> None: ...
    def setTimeZone(self, zone: android.icu.util.TimeZone, /) -> None: ...

    class HourCycle(java.lang.Enum[DateFormat.HourCycle]):
        HOUR_CYCLE_11: typing.ClassVar[DateFormat.HourCycle] = ...
        HOUR_CYCLE_12: typing.ClassVar[DateFormat.HourCycle] = ...
        HOUR_CYCLE_23: typing.ClassVar[DateFormat.HourCycle] = ...
        HOUR_CYCLE_24: typing.ClassVar[DateFormat.HourCycle] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> DateFormat.HourCycle: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[DateFormat.HourCycle]: ...

    class Field(java.text.Format.Field):
        AM_PM: typing.ClassVar[DateFormat.Field] = ...
        AM_PM_MIDNIGHT_NOON: typing.ClassVar[DateFormat.Field] = ...
        DAY_OF_MONTH: typing.ClassVar[DateFormat.Field] = ...
        DAY_OF_WEEK: typing.ClassVar[DateFormat.Field] = ...
        DAY_OF_WEEK_IN_MONTH: typing.ClassVar[DateFormat.Field] = ...
        DAY_OF_YEAR: typing.ClassVar[DateFormat.Field] = ...
        DOW_LOCAL: typing.ClassVar[DateFormat.Field] = ...
        ERA: typing.ClassVar[DateFormat.Field] = ...
        EXTENDED_YEAR: typing.ClassVar[DateFormat.Field] = ...
        FLEXIBLE_DAY_PERIOD: typing.ClassVar[DateFormat.Field] = ...
        HOUR0: typing.ClassVar[DateFormat.Field] = ...
        HOUR1: typing.ClassVar[DateFormat.Field] = ...
        HOUR_OF_DAY0: typing.ClassVar[DateFormat.Field] = ...
        HOUR_OF_DAY1: typing.ClassVar[DateFormat.Field] = ...
        JULIAN_DAY: typing.ClassVar[DateFormat.Field] = ...
        MILLISECOND: typing.ClassVar[DateFormat.Field] = ...
        MILLISECONDS_IN_DAY: typing.ClassVar[DateFormat.Field] = ...
        MINUTE: typing.ClassVar[DateFormat.Field] = ...
        MONTH: typing.ClassVar[DateFormat.Field] = ...
        QUARTER: typing.ClassVar[DateFormat.Field] = ...
        SECOND: typing.ClassVar[DateFormat.Field] = ...
        TIME_ZONE: typing.ClassVar[DateFormat.Field] = ...
        WEEK_OF_MONTH: typing.ClassVar[DateFormat.Field] = ...
        WEEK_OF_YEAR: typing.ClassVar[DateFormat.Field] = ...
        YEAR: typing.ClassVar[DateFormat.Field] = ...
        YEAR_WOY: typing.ClassVar[DateFormat.Field] = ...
        def __init__(self, name: str | java.lang.String, calendarField: int | java.jint | java.lang.Integer, /) -> None: ...
        def getCalendarField(self) -> int: ...
        @staticmethod
        def ofCalendarField(calendarField: int | java.jint | java.lang.Integer, /) -> DateFormat.Field: ...
        def readResolve(self) -> java.lang.Object: ...

    class BooleanAttribute(java.lang.Enum[DateFormat.BooleanAttribute]):
        PARSE_ALLOW_WHITESPACE: typing.ClassVar[DateFormat.BooleanAttribute] = ...
        PARSE_ALLOW_NUMERIC: typing.ClassVar[DateFormat.BooleanAttribute] = ...
        PARSE_MULTIPLE_PATTERNS_FOR_MATCH: typing.ClassVar[DateFormat.BooleanAttribute] = ...
        PARSE_PARTIAL_LITERAL_MATCH: typing.ClassVar[DateFormat.BooleanAttribute] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> DateFormat.BooleanAttribute: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[DateFormat.BooleanAttribute]: ...

class DateFormatSymbols(java.io.Serializable, java.lang.Cloneable):
    ABBREVIATED: typing.ClassVar[int] = ...
    FORMAT: typing.ClassVar[int] = ...
    NARROW: typing.ClassVar[int] = ...
    SHORT: typing.ClassVar[int] = ...
    STANDALONE: typing.ClassVar[int] = ...
    WIDE: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, locale: android.icu.util.ULocale, /) -> None: ...
    @typing.overload
    def __init__(self, locale: java.util.Locale, /) -> None: ...
    @typing.overload
    def __init__(self, cal: android.icu.util.Calendar, locale: android.icu.util.ULocale, /) -> None: ...
    @typing.overload
    def __init__(self, cal: android.icu.util.Calendar, locale: java.util.Locale, /) -> None: ...
    @typing.overload
    def __init__(self, calendarClass: typing.Type[android.icu.util.Calendar], locale: android.icu.util.ULocale, /) -> None: ...
    @typing.overload
    def __init__(self, calendarClass: typing.Type[android.icu.util.Calendar], locale: java.util.Locale, /) -> None: ...
    @typing.overload
    def __init__(self, bundle: java.util.ResourceBundle, locale: android.icu.util.ULocale, /) -> None: ...
    @typing.overload
    def __init__(self, bundle: java.util.ResourceBundle, locale: java.util.Locale, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getAmPmStrings(self) -> java.chaquopy.JavaArray[java.lang.String]: ...
    @staticmethod
    def getAvailableLocales() -> java.chaquopy.JavaArray[java.util.Locale]: ...
    def getEraNames(self) -> java.chaquopy.JavaArray[java.lang.String]: ...
    def getEras(self) -> java.chaquopy.JavaArray[java.lang.String]: ...
    @typing.overload
    @staticmethod
    def getInstance() -> DateFormatSymbols: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, /) -> DateFormatSymbols: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, /) -> DateFormatSymbols: ...
    def getLocalPatternChars(self) -> str: ...
    @typing.overload
    def getMonths(self) -> java.chaquopy.JavaArray[java.lang.String]: ...
    @typing.overload
    def getMonths(self, context: int | java.jint | java.lang.Integer, width: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArray[java.lang.String]: ...
    def getNarrowEras(self) -> java.chaquopy.JavaArray[java.lang.String]: ...
    def getQuarters(self, context: int | java.jint | java.lang.Integer, width: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArray[java.lang.String]: ...
    def getShortMonths(self) -> java.chaquopy.JavaArray[java.lang.String]: ...
    def getShortWeekdays(self) -> java.chaquopy.JavaArray[java.lang.String]: ...
    @typing.overload
    def getWeekdays(self) -> java.chaquopy.JavaArray[java.lang.String]: ...
    @typing.overload
    def getWeekdays(self, context: int | java.jint | java.lang.Integer, width: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArray[java.lang.String]: ...
    def getYearNames(self, context: int | java.jint | java.lang.Integer, width: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArray[java.lang.String] | None: ...
    def getZodiacNames(self, context: int | java.jint | java.lang.Integer, width: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArray[java.lang.String] | None: ...
    def getZoneStrings(self) -> java.chaquopy.JavaArray[java.chaquopy.JavaArray[java.lang.String]]: ...
    def hashCode(self) -> int: ...
    def initializeData(self, desiredLocale: android.icu.util.ULocale, type: str | java.lang.String, /) -> None: ...
    def setAmPmStrings(self, newAmpms: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def setEraNames(self, newEraNames: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def setEras(self, newEras: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def setLocalPatternChars(self, newLocalPatternChars: str | java.lang.String, /) -> None: ...
    @typing.overload
    def setMonths(self, newMonths: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    @typing.overload
    def setMonths(self, newMonths: java.chaquopy.JavaArray[java.lang.String], context: int | java.jint | java.lang.Integer, width: int | java.jint | java.lang.Integer, /) -> None: ...
    def setNarrowEras(self, newNarrowEras: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def setQuarters(self, newQuarters: java.chaquopy.JavaArray[java.lang.String], context: int | java.jint | java.lang.Integer, width: int | java.jint | java.lang.Integer, /) -> None: ...
    def setShortMonths(self, newShortMonths: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def setShortWeekdays(self, newAbbrevWeekdays: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    @typing.overload
    def setWeekdays(self, newWeekdays: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    @typing.overload
    def setWeekdays(self, newWeekdays: java.chaquopy.JavaArray[java.lang.String], context: int | java.jint | java.lang.Integer, width: int | java.jint | java.lang.Integer, /) -> None: ...
    def setYearNames(self, yearNames: java.chaquopy.JavaArray[java.lang.String], context: int | java.jint | java.lang.Integer, width: int | java.jint | java.lang.Integer, /) -> None: ...
    def setZodiacNames(self, zodiacNames: java.chaquopy.JavaArray[java.lang.String], context: int | java.jint | java.lang.Integer, width: int | java.jint | java.lang.Integer, /) -> None: ...
    def setZoneStrings(self, newZoneStrings: java.chaquopy.JavaArray[java.chaquopy.JavaArray[java.lang.String]], /) -> None: ...

class DateIntervalFormat(UFormat):
    def clone(self) -> java.lang.Object: ...
    @typing.overload
    def format(self, dtInterval: android.icu.util.DateInterval, appendTo: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, obj: java.lang.Object | int | bool | float | str, appendTo: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, fromCalendar: android.icu.util.Calendar, toCalendar: android.icu.util.Calendar, appendTo: java.lang.StringBuffer, pos: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def formatToValue(self, dtInterval: android.icu.util.DateInterval, /) -> DateIntervalFormat.FormattedDateInterval: ...
    @typing.overload
    def formatToValue(self, fromCalendar: android.icu.util.Calendar, toCalendar: android.icu.util.Calendar, /) -> DateIntervalFormat.FormattedDateInterval: ...
    def getContext(self, type: DisplayContext.Type, /) -> DisplayContext: ...
    def getDateFormat(self) -> DateFormat: ...
    def getDateIntervalInfo(self) -> DateIntervalInfo: ...
    @typing.overload
    @staticmethod
    def getInstance(skeleton: str | java.lang.String, /) -> DateIntervalFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(skeleton: str | java.lang.String, dtitvinf: DateIntervalInfo, /) -> DateIntervalFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(skeleton: str | java.lang.String, locale: android.icu.util.ULocale, /) -> DateIntervalFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(skeleton: str | java.lang.String, locale: java.util.Locale, /) -> DateIntervalFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(skeleton: str | java.lang.String, locale: android.icu.util.ULocale, dtitvinf: DateIntervalInfo, /) -> DateIntervalFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(skeleton: str | java.lang.String, locale: java.util.Locale, dtitvinf: DateIntervalInfo, /) -> DateIntervalFormat: ...
    def getTimeZone(self) -> android.icu.util.TimeZone: ...
    def parseObject(self, source: str | java.lang.String, parse_pos: java.text.ParsePosition, /) -> java.lang.Object: ...
    def setContext(self, context: DisplayContext, /) -> None: ...
    def setDateIntervalInfo(self, newItvPattern: DateIntervalInfo, /) -> None: ...
    def setTimeZone(self, zone: android.icu.util.TimeZone, /) -> None: ...

    class FormattedDateInterval(FormattedValue):
        _appendTo__A = typing.TypeVar('_appendTo__A')  # <A>
        def appendTo(self, appendable: _appendTo__A, /) -> _appendTo__A: ...
        def charAt(self, index: int | java.jint | java.lang.Integer, /) -> str: ...
        def length(self) -> int: ...
        def nextPosition(self, cfpos: ConstrainedFieldPosition, /) -> bool: ...
        def subSequence(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> java.lang.CharSequence: ...
        def toCharacterIterator(self) -> java.text.AttributedCharacterIterator: ...
        def toString(self) -> str: ...

class DateIntervalInfo(java.lang.Cloneable, android.icu.util.Freezable[DateIntervalInfo], java.io.Serializable):
    @typing.overload
    def __init__(self, locale: android.icu.util.ULocale, /) -> None: ...
    @typing.overload
    def __init__(self, locale: java.util.Locale, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def cloneAsThawed(self) -> DateIntervalInfo: ...
    def equals(self, a: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def freeze(self) -> DateIntervalInfo: ...
    def getDefaultOrder(self) -> bool: ...
    def getFallbackIntervalPattern(self) -> str: ...
    def getIntervalPattern(self, skeleton: str | java.lang.String, field: int | java.jint | java.lang.Integer, /) -> DateIntervalInfo.PatternInfo | None: ...
    def hashCode(self) -> int: ...
    def isFrozen(self) -> bool: ...
    def setFallbackIntervalPattern(self, fallbackPattern: str | java.lang.String, /) -> None: ...
    def setIntervalPattern(self, skeleton: str | java.lang.String, lrgDiffCalUnit: int | java.jint | java.lang.Integer, intervalPattern: str | java.lang.String, /) -> None: ...

    class PatternInfo(java.lang.Cloneable, java.io.Serializable):
        def __init__(self, firstPart: str | java.lang.String, secondPart: str | java.lang.String, firstDateInPtnIsLaterDate: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
        def equals(self, a: java.lang.Object | int | bool | float | str, /) -> bool: ...
        def firstDateInPtnIsLaterDate(self) -> bool: ...
        def getFirstPart(self) -> str: ...
        def getSecondPart(self) -> str: ...
        def hashCode(self) -> int: ...
        def toString(self) -> str: ...

class DateTimePatternGenerator(android.icu.util.Freezable[DateTimePatternGenerator], java.lang.Cloneable):
    DAY: typing.ClassVar[int] = ...
    DAYPERIOD: typing.ClassVar[int] = ...
    DAY_OF_WEEK_IN_MONTH: typing.ClassVar[int] = ...
    DAY_OF_YEAR: typing.ClassVar[int] = ...
    ERA: typing.ClassVar[int] = ...
    FRACTIONAL_SECOND: typing.ClassVar[int] = ...
    HOUR: typing.ClassVar[int] = ...
    MATCH_ALL_FIELDS_LENGTH: typing.ClassVar[int] = ...
    MATCH_HOUR_FIELD_LENGTH: typing.ClassVar[int] = ...
    MATCH_NO_OPTIONS: typing.ClassVar[int] = ...
    MINUTE: typing.ClassVar[int] = ...
    MONTH: typing.ClassVar[int] = ...
    QUARTER: typing.ClassVar[int] = ...
    SECOND: typing.ClassVar[int] = ...
    WEEKDAY: typing.ClassVar[int] = ...
    WEEK_OF_MONTH: typing.ClassVar[int] = ...
    WEEK_OF_YEAR: typing.ClassVar[int] = ...
    YEAR: typing.ClassVar[int] = ...
    ZONE: typing.ClassVar[int] = ...
    def __init__(self) -> None: ...
    def addPattern(self, pattern: str | java.lang.String, override: bool | java.jboolean | java.lang.Boolean, returnInfo: DateTimePatternGenerator.PatternInfo, /) -> DateTimePatternGenerator: ...
    def clone(self) -> java.lang.Object: ...
    def cloneAsThawed(self) -> DateTimePatternGenerator: ...
    def freeze(self) -> DateTimePatternGenerator: ...
    def getAppendItemFormat(self, field: int | java.jint | java.lang.Integer, /) -> str: ...
    def getAppendItemName(self, field: int | java.jint | java.lang.Integer, /) -> str: ...
    def getBaseSkeleton(self, pattern: str | java.lang.String, /) -> str: ...
    def getBaseSkeletons(self, result: java.util.Set[java.lang.String], /) -> java.util.Set[java.lang.String]: ...
    @typing.overload
    def getBestPattern(self, skeleton: str | java.lang.String, /) -> str: ...
    @typing.overload
    def getBestPattern(self, skeleton: str | java.lang.String, options: int | java.jint | java.lang.Integer, /) -> str: ...
    @typing.overload
    def getDateTimeFormat(self) -> str: ...
    @typing.overload
    def getDateTimeFormat(self, style: int | java.jint | java.lang.Integer, /) -> str: ...
    def getDecimal(self) -> str: ...
    def getDefaultHourCycle(self) -> DateFormat.HourCycle: ...
    @staticmethod
    def getEmptyInstance() -> DateTimePatternGenerator: ...
    def getFieldDisplayName(self, field: int | java.jint | java.lang.Integer, width: DateTimePatternGenerator.DisplayWidth, /) -> str: ...
    @typing.overload
    @staticmethod
    def getInstance() -> DateTimePatternGenerator: ...
    @typing.overload
    @staticmethod
    def getInstance(uLocale: android.icu.util.ULocale, /) -> DateTimePatternGenerator: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, /) -> DateTimePatternGenerator: ...
    def getSkeleton(self, pattern: str | java.lang.String, /) -> str: ...
    def getSkeletons(self, result: java.util.Map[java.lang.String, java.lang.String], /) -> java.util.Map[java.lang.String, java.lang.String]: ...
    def isFrozen(self) -> bool: ...
    @typing.overload
    def replaceFieldTypes(self, pattern: str | java.lang.String, skeleton: str | java.lang.String, /) -> str: ...
    @typing.overload
    def replaceFieldTypes(self, pattern: str | java.lang.String, skeleton: str | java.lang.String, options: int | java.jint | java.lang.Integer, /) -> str: ...
    def setAppendItemFormat(self, field: int | java.jint | java.lang.Integer, value: str | java.lang.String, /) -> None: ...
    def setAppendItemName(self, field: int | java.jint | java.lang.Integer, value: str | java.lang.String, /) -> None: ...
    @typing.overload
    def setDateTimeFormat(self, dateTimeFormat: str | java.lang.String, /) -> None: ...
    @typing.overload
    def setDateTimeFormat(self, style: int | java.jint | java.lang.Integer, dateTimeFormat: str | java.lang.String, /) -> None: ...
    def setDecimal(self, decimal: str | java.lang.String, /) -> None: ...

    class PatternInfo(java.lang.Object):
        BASE_CONFLICT: typing.ClassVar[int] = ...
        CONFLICT: typing.ClassVar[int] = ...
        OK: typing.ClassVar[int] = ...
        conflictingPattern: str = ...
        status: int = ...
        def __init__(self) -> None: ...

    class DisplayWidth(java.lang.Enum[DateTimePatternGenerator.DisplayWidth]):
        WIDE: typing.ClassVar[DateTimePatternGenerator.DisplayWidth] = ...
        ABBREVIATED: typing.ClassVar[DateTimePatternGenerator.DisplayWidth] = ...
        NARROW: typing.ClassVar[DateTimePatternGenerator.DisplayWidth] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> DateTimePatternGenerator.DisplayWidth: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[DateTimePatternGenerator.DisplayWidth]: ...

class DecimalFormat(NumberFormat):
    MINIMUM_GROUPING_DIGITS_AUTO: typing.ClassVar[int] = ...
    MINIMUM_GROUPING_DIGITS_MIN2: typing.ClassVar[int] = ...
    PAD_AFTER_PREFIX: typing.ClassVar[int] = ...
    PAD_AFTER_SUFFIX: typing.ClassVar[int] = ...
    PAD_BEFORE_PREFIX: typing.ClassVar[int] = ...
    PAD_BEFORE_SUFFIX: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, symbols: DecimalFormatSymbols, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, symbols: DecimalFormatSymbols, infoInput: CurrencyPluralInfo, style: int | java.jint | java.lang.Integer, /) -> None: ...
    def applyLocalizedPattern(self, localizedPattern: str | java.lang.String, /) -> None: ...
    def applyPattern(self, pattern: str | java.lang.String, /) -> None: ...
    def areSignificantDigitsUsed(self) -> bool: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def format(self, number: float | java.jdouble | java.lang.Double, result: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, number: int | java.jlong | java.lang.Long, result: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, number: android.icu.math.BigDecimal, result: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, currAmt: android.icu.util.CurrencyAmount, result: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, number: java.math.BigDecimal, result: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, number: java.math.BigInteger, result: java.lang.StringBuffer, fieldPosition: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    def formatToCharacterIterator(self, obj: java.lang.Object | int | bool | float | str, /) -> java.text.AttributedCharacterIterator: ...
    def getCurrency(self) -> android.icu.util.Currency: ...
    def getCurrencyPluralInfo(self) -> CurrencyPluralInfo: ...
    def getCurrencyUsage(self) -> android.icu.util.Currency.CurrencyUsage: ...
    def getDecimalFormatSymbols(self) -> DecimalFormatSymbols: ...
    def getFormatWidth(self) -> int: ...
    def getGroupingSize(self) -> int: ...
    def getMathContext(self) -> java.math.MathContext: ...
    def getMathContextICU(self) -> android.icu.math.MathContext: ...
    def getMaximumFractionDigits(self) -> int: ...
    def getMaximumIntegerDigits(self) -> int: ...
    def getMaximumSignificantDigits(self) -> int: ...
    def getMinimumExponentDigits(self) -> int: ...
    def getMinimumFractionDigits(self) -> int: ...
    def getMinimumGroupingDigits(self) -> int: ...
    def getMinimumIntegerDigits(self) -> int: ...
    def getMinimumSignificantDigits(self) -> int: ...
    def getMultiplier(self) -> int: ...
    def getNegativePrefix(self) -> str: ...
    def getNegativeSuffix(self) -> str: ...
    def getPadCharacter(self) -> str: ...
    def getPadPosition(self) -> int: ...
    def getParseMaxDigits(self) -> int: ...
    def getPositivePrefix(self) -> str: ...
    def getPositiveSuffix(self) -> str: ...
    def getRoundingIncrement(self) -> java.math.BigDecimal: ...
    def getRoundingMode(self) -> int: ...
    def getSecondaryGroupingSize(self) -> int: ...
    def hashCode(self) -> int: ...
    def isDecimalPatternMatchRequired(self) -> bool: ...
    def isDecimalSeparatorAlwaysShown(self) -> bool: ...
    def isExponentSignAlwaysShown(self) -> bool: ...
    def isGroupingUsed(self) -> bool: ...
    def isParseBigDecimal(self) -> bool: ...
    def isParseCaseSensitive(self) -> bool: ...
    def isParseIntegerOnly(self) -> bool: ...
    def isParseNoExponent(self) -> bool: ...
    def isParseStrict(self) -> bool: ...
    def isScientificNotation(self) -> bool: ...
    def isSignAlwaysShown(self) -> bool: ...
    def parse(self, text: str | java.lang.String, parsePosition: java.text.ParsePosition, /) -> java.lang.Number: ...
    def parseCurrency(self, text: java.lang.CharSequence, parsePosition: java.text.ParsePosition, /) -> android.icu.util.CurrencyAmount: ...
    def setCurrency(self, currency: android.icu.util.Currency, /) -> None: ...
    def setCurrencyPluralInfo(self, newInfo: CurrencyPluralInfo, /) -> None: ...
    def setCurrencyUsage(self, usage: android.icu.util.Currency.CurrencyUsage, /) -> None: ...
    def setDecimalFormatSymbols(self, newSymbols: DecimalFormatSymbols, /) -> None: ...
    def setDecimalPatternMatchRequired(self, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setDecimalSeparatorAlwaysShown(self, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setExponentSignAlwaysShown(self, expSignAlways: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setFormatWidth(self, width: int | java.jint | java.lang.Integer, /) -> None: ...
    def setGroupingSize(self, width: int | java.jint | java.lang.Integer, /) -> None: ...
    def setGroupingUsed(self, enabled: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setMathContext(self, mathContext: java.math.MathContext, /) -> None: ...
    def setMathContextICU(self, mathContextICU: android.icu.math.MathContext, /) -> None: ...
    def setMaximumFractionDigits(self, value: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMaximumIntegerDigits(self, value: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMaximumSignificantDigits(self, value: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMinimumExponentDigits(self, minExpDig: int | java.jbyte | java.lang.Byte, /) -> None: ...
    def setMinimumFractionDigits(self, value: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMinimumGroupingDigits(self, number: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMinimumIntegerDigits(self, value: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMinimumSignificantDigits(self, value: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMultiplier(self, multiplier: int | java.jint | java.lang.Integer, /) -> None: ...
    def setNegativePrefix(self, prefix: str | java.lang.String, /) -> None: ...
    def setNegativeSuffix(self, suffix: str | java.lang.String, /) -> None: ...
    def setPadCharacter(self, padChar: str | java.jchar | java.lang.Character, /) -> None: ...
    def setPadPosition(self, padPos: int | java.jint | java.lang.Integer, /) -> None: ...
    def setParseBigDecimal(self, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setParseCaseSensitive(self, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setParseIntegerOnly(self, parseIntegerOnly: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setParseMaxDigits(self, maxDigits: int | java.jint | java.lang.Integer, /) -> None: ...
    def setParseNoExponent(self, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setParseStrict(self, parseStrict: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setPositivePrefix(self, prefix: str | java.lang.String, /) -> None: ...
    def setPositiveSuffix(self, suffix: str | java.lang.String, /) -> None: ...
    @typing.overload
    def setRoundingIncrement(self, increment: float | java.jdouble | java.lang.Double, /) -> None: ...
    @typing.overload
    def setRoundingIncrement(self, increment: android.icu.math.BigDecimal, /) -> None: ...
    @typing.overload
    def setRoundingIncrement(self, increment: java.math.BigDecimal, /) -> None: ...
    def setRoundingMode(self, roundingMode: int | java.jint | java.lang.Integer, /) -> None: ...
    def setScientificNotation(self, useScientific: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setSecondaryGroupingSize(self, width: int | java.jint | java.lang.Integer, /) -> None: ...
    def setSignAlwaysShown(self, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setSignificantDigitsUsed(self, useSignificantDigits: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def toLocalizedPattern(self) -> str: ...
    def toPattern(self) -> str: ...
    def toString(self) -> str: ...

class DecimalFormatSymbols(java.lang.Cloneable, java.io.Serializable):
    CURRENCY_SPC_CURRENCY_MATCH: typing.ClassVar[int] = ...
    CURRENCY_SPC_INSERT: typing.ClassVar[int] = ...
    CURRENCY_SPC_SURROUNDING_MATCH: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, locale: android.icu.util.ULocale, /) -> None: ...
    @typing.overload
    def __init__(self, locale: java.util.Locale, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    @staticmethod
    def forNumberingSystem(locale: android.icu.util.ULocale, ns: NumberingSystem, /) -> DecimalFormatSymbols: ...
    @typing.overload
    @staticmethod
    def forNumberingSystem(locale: java.util.Locale, ns: NumberingSystem, /) -> DecimalFormatSymbols: ...
    @staticmethod
    def getAvailableLocales() -> java.chaquopy.JavaArray[java.util.Locale]: ...
    @staticmethod
    def getAvailableULocales() -> java.chaquopy.JavaArray[android.icu.util.ULocale]: ...
    def getCurrency(self) -> android.icu.util.Currency | None: ...
    def getCurrencySymbol(self) -> str: ...
    def getDecimalSeparator(self) -> str: ...
    def getDecimalSeparatorString(self) -> str: ...
    def getDigit(self) -> str: ...
    def getDigitStrings(self) -> java.chaquopy.JavaArray[java.lang.String]: ...
    def getDigits(self) -> java.chaquopy.JavaArrayJChar: ...
    def getExponentMultiplicationSign(self) -> str: ...
    def getExponentSeparator(self) -> str: ...
    def getGroupingSeparator(self) -> str: ...
    def getGroupingSeparatorString(self) -> str: ...
    def getInfinity(self) -> str: ...
    @typing.overload
    @staticmethod
    def getInstance() -> DecimalFormatSymbols: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, /) -> DecimalFormatSymbols: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, /) -> DecimalFormatSymbols: ...
    def getInternationalCurrencySymbol(self) -> str: ...
    def getLocale(self) -> java.util.Locale | None: ...
    def getMinusSign(self) -> str: ...
    def getMinusSignString(self) -> str: ...
    def getMonetaryDecimalSeparator(self) -> str: ...
    def getMonetaryDecimalSeparatorString(self) -> str: ...
    def getMonetaryGroupingSeparator(self) -> str: ...
    def getMonetaryGroupingSeparatorString(self) -> str: ...
    def getNaN(self) -> str: ...
    def getPadEscape(self) -> str: ...
    def getPatternForCurrencySpacing(self, itemType: int | java.jint | java.lang.Integer, beforeCurrency: bool | java.jboolean | java.lang.Boolean, /) -> str | None: ...
    def getPatternSeparator(self) -> str: ...
    def getPerMill(self) -> str: ...
    def getPerMillString(self) -> str: ...
    def getPercent(self) -> str: ...
    def getPercentString(self) -> str: ...
    def getPlusSign(self) -> str: ...
    def getPlusSignString(self) -> str: ...
    def getSignificantDigit(self) -> str: ...
    def getULocale(self) -> android.icu.util.ULocale: ...
    def getZeroDigit(self) -> str: ...
    def hashCode(self) -> int: ...
    def setCurrency(self, currency: android.icu.util.Currency, /) -> None: ...
    def setCurrencySymbol(self, currency: str | java.lang.String, /) -> None: ...
    def setDecimalSeparator(self, decimalSeparator: str | java.jchar | java.lang.Character, /) -> None: ...
    def setDecimalSeparatorString(self, decimalSeparatorString: str | java.lang.String, /) -> None: ...
    def setDigit(self, digit: str | java.jchar | java.lang.Character, /) -> None: ...
    def setDigitStrings(self, digitStrings: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def setExponentMultiplicationSign(self, exponentMultiplicationSign: str | java.lang.String, /) -> None: ...
    def setExponentSeparator(self, exp: str | java.lang.String, /) -> None: ...
    def setGroupingSeparator(self, groupingSeparator: str | java.jchar | java.lang.Character, /) -> None: ...
    def setGroupingSeparatorString(self, groupingSeparatorString: str | java.lang.String, /) -> None: ...
    def setInfinity(self, infinity: str | java.lang.String, /) -> None: ...
    def setInternationalCurrencySymbol(self, currency: str | java.lang.String, /) -> None: ...
    def setMinusSign(self, minusSign: str | java.jchar | java.lang.Character, /) -> None: ...
    def setMinusSignString(self, minusSignString: str | java.lang.String, /) -> None: ...
    def setMonetaryDecimalSeparator(self, sep: str | java.jchar | java.lang.Character, /) -> None: ...
    def setMonetaryDecimalSeparatorString(self, sep: str | java.lang.String, /) -> None: ...
    def setMonetaryGroupingSeparator(self, sep: str | java.jchar | java.lang.Character, /) -> None: ...
    def setMonetaryGroupingSeparatorString(self, sep: str | java.lang.String, /) -> None: ...
    def setNaN(self, NaN: str | java.lang.String, /) -> None: ...
    def setPadEscape(self, c: str | java.jchar | java.lang.Character, /) -> None: ...
    def setPatternForCurrencySpacing(self, itemType: int | java.jint | java.lang.Integer, beforeCurrency: bool | java.jboolean | java.lang.Boolean, pattern: str | java.lang.String, /) -> None: ...
    def setPatternSeparator(self, patternSeparator: str | java.jchar | java.lang.Character, /) -> None: ...
    def setPerMill(self, perMill: str | java.jchar | java.lang.Character, /) -> None: ...
    def setPerMillString(self, perMillString: str | java.lang.String, /) -> None: ...
    def setPercent(self, percent: str | java.jchar | java.lang.Character, /) -> None: ...
    def setPercentString(self, percentString: str | java.lang.String, /) -> None: ...
    def setPlusSign(self, plus: str | java.jchar | java.lang.Character, /) -> None: ...
    def setPlusSignString(self, plusSignString: str | java.lang.String, /) -> None: ...
    def setSignificantDigit(self, sigDigit: str | java.jchar | java.lang.Character, /) -> None: ...
    def setZeroDigit(self, zeroDigit: str | java.jchar | java.lang.Character, /) -> None: ...

class DisplayContext(java.lang.Enum[DisplayContext]):
    STANDARD_NAMES: typing.ClassVar[DisplayContext] = ...
    DIALECT_NAMES: typing.ClassVar[DisplayContext] = ...
    CAPITALIZATION_NONE: typing.ClassVar[DisplayContext] = ...
    CAPITALIZATION_FOR_MIDDLE_OF_SENTENCE: typing.ClassVar[DisplayContext] = ...
    CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE: typing.ClassVar[DisplayContext] = ...
    CAPITALIZATION_FOR_UI_LIST_OR_MENU: typing.ClassVar[DisplayContext] = ...
    CAPITALIZATION_FOR_STANDALONE: typing.ClassVar[DisplayContext] = ...
    LENGTH_FULL: typing.ClassVar[DisplayContext] = ...
    LENGTH_SHORT: typing.ClassVar[DisplayContext] = ...
    SUBSTITUTE: typing.ClassVar[DisplayContext] = ...
    NO_SUBSTITUTE: typing.ClassVar[DisplayContext] = ...
    def type(self) -> DisplayContext.Type: ...
    def value(self) -> int: ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> DisplayContext: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[DisplayContext]: ...

    class Type(java.lang.Enum[DisplayContext.Type]):
        DIALECT_HANDLING: typing.ClassVar[DisplayContext.Type] = ...
        CAPITALIZATION: typing.ClassVar[DisplayContext.Type] = ...
        DISPLAY_LENGTH: typing.ClassVar[DisplayContext.Type] = ...
        SUBSTITUTE_HANDLING: typing.ClassVar[DisplayContext.Type] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> DisplayContext.Type: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[DisplayContext.Type]: ...

class DisplayOptions(java.lang.Object):
    @staticmethod
    def builder() -> DisplayOptions.Builder: ...
    def copyToBuilder(self) -> DisplayOptions.Builder: ...
    def getCapitalization(self) -> DisplayOptions.Capitalization: ...
    def getDisplayLength(self) -> DisplayOptions.DisplayLength: ...
    def getGrammaticalCase(self) -> DisplayOptions.GrammaticalCase: ...
    def getNameStyle(self) -> DisplayOptions.NameStyle: ...
    def getNounClass(self) -> DisplayOptions.NounClass: ...
    def getPluralCategory(self) -> DisplayOptions.PluralCategory: ...
    def getSubstituteHandling(self) -> DisplayOptions.SubstituteHandling: ...

    class SubstituteHandling(java.lang.Enum[DisplayOptions.SubstituteHandling]):
        UNDEFINED: typing.ClassVar[DisplayOptions.SubstituteHandling] = ...
        SUBSTITUTE: typing.ClassVar[DisplayOptions.SubstituteHandling] = ...
        NO_SUBSTITUTE: typing.ClassVar[DisplayOptions.SubstituteHandling] = ...
        VALUES: typing.ClassVar[java.util.List[DisplayOptions.SubstituteHandling]] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> DisplayOptions.SubstituteHandling: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[DisplayOptions.SubstituteHandling]: ...

    class PluralCategory(java.lang.Enum[DisplayOptions.PluralCategory]):
        UNDEFINED: typing.ClassVar[DisplayOptions.PluralCategory] = ...
        ZERO: typing.ClassVar[DisplayOptions.PluralCategory] = ...
        ONE: typing.ClassVar[DisplayOptions.PluralCategory] = ...
        TWO: typing.ClassVar[DisplayOptions.PluralCategory] = ...
        FEW: typing.ClassVar[DisplayOptions.PluralCategory] = ...
        MANY: typing.ClassVar[DisplayOptions.PluralCategory] = ...
        OTHER: typing.ClassVar[DisplayOptions.PluralCategory] = ...
        VALUES: typing.ClassVar[java.util.List[DisplayOptions.PluralCategory]] = ...
        @staticmethod
        def fromIdentifier(identifier: str | java.lang.String, /) -> DisplayOptions.PluralCategory: ...
        def getIdentifier(self) -> str: ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> DisplayOptions.PluralCategory: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[DisplayOptions.PluralCategory]: ...

    class NounClass(java.lang.Enum[DisplayOptions.NounClass]):
        UNDEFINED: typing.ClassVar[DisplayOptions.NounClass] = ...
        OTHER: typing.ClassVar[DisplayOptions.NounClass] = ...
        NEUTER: typing.ClassVar[DisplayOptions.NounClass] = ...
        FEMININE: typing.ClassVar[DisplayOptions.NounClass] = ...
        MASCULINE: typing.ClassVar[DisplayOptions.NounClass] = ...
        ANIMATE: typing.ClassVar[DisplayOptions.NounClass] = ...
        INANIMATE: typing.ClassVar[DisplayOptions.NounClass] = ...
        PERSONAL: typing.ClassVar[DisplayOptions.NounClass] = ...
        COMMON: typing.ClassVar[DisplayOptions.NounClass] = ...
        VALUES: typing.ClassVar[java.util.List[DisplayOptions.NounClass]] = ...
        @staticmethod
        def fromIdentifier(identifier: str | java.lang.String, /) -> DisplayOptions.NounClass: ...
        def getIdentifier(self) -> str: ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> DisplayOptions.NounClass: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[DisplayOptions.NounClass]: ...

    class NameStyle(java.lang.Enum[DisplayOptions.NameStyle]):
        UNDEFINED: typing.ClassVar[DisplayOptions.NameStyle] = ...
        STANDARD_NAMES: typing.ClassVar[DisplayOptions.NameStyle] = ...
        DIALECT_NAMES: typing.ClassVar[DisplayOptions.NameStyle] = ...
        VALUES: typing.ClassVar[java.util.List[DisplayOptions.NameStyle]] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> DisplayOptions.NameStyle: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[DisplayOptions.NameStyle]: ...

    class GrammaticalCase(java.lang.Enum[DisplayOptions.GrammaticalCase]):
        UNDEFINED: typing.ClassVar[DisplayOptions.GrammaticalCase] = ...
        ABLATIVE: typing.ClassVar[DisplayOptions.GrammaticalCase] = ...
        ACCUSATIVE: typing.ClassVar[DisplayOptions.GrammaticalCase] = ...
        COMITATIVE: typing.ClassVar[DisplayOptions.GrammaticalCase] = ...
        DATIVE: typing.ClassVar[DisplayOptions.GrammaticalCase] = ...
        ERGATIVE: typing.ClassVar[DisplayOptions.GrammaticalCase] = ...
        GENITIVE: typing.ClassVar[DisplayOptions.GrammaticalCase] = ...
        INSTRUMENTAL: typing.ClassVar[DisplayOptions.GrammaticalCase] = ...
        LOCATIVE: typing.ClassVar[DisplayOptions.GrammaticalCase] = ...
        LOCATIVE_COPULATIVE: typing.ClassVar[DisplayOptions.GrammaticalCase] = ...
        NOMINATIVE: typing.ClassVar[DisplayOptions.GrammaticalCase] = ...
        OBLIQUE: typing.ClassVar[DisplayOptions.GrammaticalCase] = ...
        PREPOSITIONAL: typing.ClassVar[DisplayOptions.GrammaticalCase] = ...
        SOCIATIVE: typing.ClassVar[DisplayOptions.GrammaticalCase] = ...
        VOCATIVE: typing.ClassVar[DisplayOptions.GrammaticalCase] = ...
        VALUES: typing.ClassVar[java.util.List[DisplayOptions.GrammaticalCase]] = ...
        @staticmethod
        def fromIdentifier(identifier: str | java.lang.String, /) -> DisplayOptions.GrammaticalCase: ...
        def getIdentifier(self) -> str: ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> DisplayOptions.GrammaticalCase: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[DisplayOptions.GrammaticalCase]: ...

    class DisplayLength(java.lang.Enum[DisplayOptions.DisplayLength]):
        UNDEFINED: typing.ClassVar[DisplayOptions.DisplayLength] = ...
        LENGTH_FULL: typing.ClassVar[DisplayOptions.DisplayLength] = ...
        LENGTH_SHORT: typing.ClassVar[DisplayOptions.DisplayLength] = ...
        VALUES: typing.ClassVar[java.util.List[DisplayOptions.DisplayLength]] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> DisplayOptions.DisplayLength: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[DisplayOptions.DisplayLength]: ...

    class Capitalization(java.lang.Enum[DisplayOptions.Capitalization]):
        UNDEFINED: typing.ClassVar[DisplayOptions.Capitalization] = ...
        BEGINNING_OF_SENTENCE: typing.ClassVar[DisplayOptions.Capitalization] = ...
        MIDDLE_OF_SENTENCE: typing.ClassVar[DisplayOptions.Capitalization] = ...
        STANDALONE: typing.ClassVar[DisplayOptions.Capitalization] = ...
        UI_LIST_OR_MENU: typing.ClassVar[DisplayOptions.Capitalization] = ...
        VALUES: typing.ClassVar[java.util.List[DisplayOptions.Capitalization]] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> DisplayOptions.Capitalization: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[DisplayOptions.Capitalization]: ...

    class Builder(java.lang.Object):
        def build(self) -> DisplayOptions: ...
        def setCapitalization(self, capitalization: DisplayOptions.Capitalization, /) -> DisplayOptions.Builder: ...
        def setDisplayLength(self, displayLength: DisplayOptions.DisplayLength, /) -> DisplayOptions.Builder: ...
        def setGrammaticalCase(self, grammaticalCase: DisplayOptions.GrammaticalCase, /) -> DisplayOptions.Builder: ...
        def setNameStyle(self, nameStyle: DisplayOptions.NameStyle, /) -> DisplayOptions.Builder: ...
        def setNounClass(self, nounClass: DisplayOptions.NounClass, /) -> DisplayOptions.Builder: ...
        def setPluralCategory(self, pluralCategory: DisplayOptions.PluralCategory, /) -> DisplayOptions.Builder: ...
        def setSubstituteHandling(self, substituteHandling: DisplayOptions.SubstituteHandling, /) -> DisplayOptions.Builder: ...

class Edits(java.lang.Object):
    def __init__(self) -> None: ...
    def addReplace(self, oldLength: int | java.jint | java.lang.Integer, newLength: int | java.jint | java.lang.Integer, /) -> None: ...
    def addUnchanged(self, unchangedLength: int | java.jint | java.lang.Integer, /) -> None: ...
    def getCoarseChangesIterator(self) -> Edits.Iterator: ...
    def getCoarseIterator(self) -> Edits.Iterator: ...
    def getFineChangesIterator(self) -> Edits.Iterator: ...
    def getFineIterator(self) -> Edits.Iterator: ...
    def hasChanges(self) -> bool: ...
    def lengthDelta(self) -> int: ...
    def mergeAndAppend(self, ab: Edits, bc: Edits, /) -> Edits: ...
    def numberOfChanges(self) -> int: ...
    def reset(self) -> None: ...

    class Iterator(java.lang.Object):
        def destinationIndex(self) -> int: ...
        def destinationIndexFromSourceIndex(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
        def findDestinationIndex(self, i: int | java.jint | java.lang.Integer, /) -> bool: ...
        def findSourceIndex(self, i: int | java.jint | java.lang.Integer, /) -> bool: ...
        def hasChange(self) -> bool: ...
        def newLength(self) -> int: ...
        def next(self) -> bool: ...
        def oldLength(self) -> int: ...
        def replacementIndex(self) -> int: ...
        def sourceIndex(self) -> int: ...
        def sourceIndexFromDestinationIndex(self, i: int | java.jint | java.lang.Integer, /) -> int: ...
        def toString(self) -> str: ...

class FormattedValue(java.lang.CharSequence):
    _appendTo__A = typing.TypeVar('_appendTo__A')  # <A>
    def appendTo(self, arg1: _appendTo__A, /) -> _appendTo__A: ...
    def nextPosition(self, arg1: ConstrainedFieldPosition, /) -> bool: ...
    def toCharacterIterator(self) -> java.text.AttributedCharacterIterator: ...
    def toString(self) -> str: ...

class IDNA(java.lang.Object):
    CHECK_BIDI: typing.ClassVar[int] = ...
    CHECK_CONTEXTJ: typing.ClassVar[int] = ...
    CHECK_CONTEXTO: typing.ClassVar[int] = ...
    DEFAULT: typing.ClassVar[int] = ...
    NONTRANSITIONAL_TO_ASCII: typing.ClassVar[int] = ...
    NONTRANSITIONAL_TO_UNICODE: typing.ClassVar[int] = ...
    USE_STD3_RULES: typing.ClassVar[int] = ...
    @staticmethod
    def getUTS46Instance(options: int | java.jint | java.lang.Integer, /) -> IDNA: ...
    def labelToASCII(self, arg1: java.lang.CharSequence, arg2: java.lang.StringBuilder, arg3: IDNA.Info, /) -> java.lang.StringBuilder: ...
    def labelToUnicode(self, arg1: java.lang.CharSequence, arg2: java.lang.StringBuilder, arg3: IDNA.Info, /) -> java.lang.StringBuilder: ...
    def nameToASCII(self, arg1: java.lang.CharSequence, arg2: java.lang.StringBuilder, arg3: IDNA.Info, /) -> java.lang.StringBuilder: ...
    def nameToUnicode(self, arg1: java.lang.CharSequence, arg2: java.lang.StringBuilder, arg3: IDNA.Info, /) -> java.lang.StringBuilder: ...

    class Info(java.lang.Object):
        def __init__(self) -> None: ...
        def getErrors(self) -> java.util.Set[IDNA.Error]: ...
        def hasErrors(self) -> bool: ...
        def isTransitionalDifferent(self) -> bool: ...

    class Error(java.lang.Enum[IDNA.Error]):
        EMPTY_LABEL: typing.ClassVar[IDNA.Error] = ...
        LABEL_TOO_LONG: typing.ClassVar[IDNA.Error] = ...
        DOMAIN_NAME_TOO_LONG: typing.ClassVar[IDNA.Error] = ...
        LEADING_HYPHEN: typing.ClassVar[IDNA.Error] = ...
        TRAILING_HYPHEN: typing.ClassVar[IDNA.Error] = ...
        HYPHEN_3_4: typing.ClassVar[IDNA.Error] = ...
        LEADING_COMBINING_MARK: typing.ClassVar[IDNA.Error] = ...
        DISALLOWED: typing.ClassVar[IDNA.Error] = ...
        PUNYCODE: typing.ClassVar[IDNA.Error] = ...
        LABEL_HAS_DOT: typing.ClassVar[IDNA.Error] = ...
        INVALID_ACE_LABEL: typing.ClassVar[IDNA.Error] = ...
        BIDI: typing.ClassVar[IDNA.Error] = ...
        CONTEXTJ: typing.ClassVar[IDNA.Error] = ...
        CONTEXTO_PUNCTUATION: typing.ClassVar[IDNA.Error] = ...
        CONTEXTO_DIGITS: typing.ClassVar[IDNA.Error] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> IDNA.Error: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[IDNA.Error]: ...

class ListFormatter(java.lang.Object):
    @typing.overload
    def format(self, items: java.util.Collection[java.lang.Object], /) -> str: ...
    @typing.overload
    def format(self, *items: java.lang.Object) -> str: ...
    @typing.overload
    def formatToValue(self, items: java.util.Collection[java.lang.Object], /) -> ListFormatter.FormattedList: ...
    @typing.overload
    def formatToValue(self, *items: java.lang.Object) -> ListFormatter.FormattedList: ...
    @typing.overload
    @staticmethod
    def getInstance() -> ListFormatter: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, /) -> ListFormatter: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, /) -> ListFormatter: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, type: ListFormatter.Type, width: ListFormatter.Width, /) -> ListFormatter: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, type: ListFormatter.Type, width: ListFormatter.Width, /) -> ListFormatter: ...
    def getPatternForNumItems(self, count: int | java.jint | java.lang.Integer, /) -> str: ...

    class Width(java.lang.Enum[ListFormatter.Width]):
        WIDE: typing.ClassVar[ListFormatter.Width] = ...
        SHORT: typing.ClassVar[ListFormatter.Width] = ...
        NARROW: typing.ClassVar[ListFormatter.Width] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> ListFormatter.Width: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[ListFormatter.Width]: ...

    class Type(java.lang.Enum[ListFormatter.Type]):
        AND: typing.ClassVar[ListFormatter.Type] = ...
        OR: typing.ClassVar[ListFormatter.Type] = ...
        UNITS: typing.ClassVar[ListFormatter.Type] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> ListFormatter.Type: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[ListFormatter.Type]: ...

    class FormattedList(FormattedValue):
        _appendTo__A = typing.TypeVar('_appendTo__A')  # <A>
        def appendTo(self, appendable: _appendTo__A, /) -> _appendTo__A: ...
        def charAt(self, index: int | java.jint | java.lang.Integer, /) -> str: ...
        def length(self) -> int: ...
        def nextPosition(self, cfpos: ConstrainedFieldPosition, /) -> bool: ...
        def subSequence(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> java.lang.CharSequence: ...
        def toCharacterIterator(self) -> java.text.AttributedCharacterIterator: ...
        def toString(self) -> str: ...

class LocaleDisplayNames(java.lang.Object):
    def getContext(self, arg1: DisplayContext.Type, /) -> DisplayContext: ...
    def getDialectHandling(self) -> LocaleDisplayNames.DialectHandling: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, /) -> LocaleDisplayNames: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, /) -> LocaleDisplayNames: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, dialectHandling: LocaleDisplayNames.DialectHandling, /) -> LocaleDisplayNames: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, /, *contexts: DisplayContext) -> LocaleDisplayNames: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, /, *contexts: DisplayContext) -> LocaleDisplayNames: ...
    def getLocale(self) -> android.icu.util.ULocale: ...
    def getUiList(self, localeSet: java.util.Set[android.icu.util.ULocale], inSelf: bool | java.jboolean | java.lang.Boolean, collator: java.util.Comparator[java.lang.Object], /) -> java.util.List[LocaleDisplayNames.UiListItem]: ...
    def getUiListCompareWholeItems(self, arg1: java.util.Set[android.icu.util.ULocale], arg2: java.util.Comparator[LocaleDisplayNames.UiListItem], /) -> java.util.List[LocaleDisplayNames.UiListItem]: ...
    def keyDisplayName(self, arg1: str | java.lang.String, /) -> str: ...
    def keyValueDisplayName(self, arg1: str | java.lang.String, arg2: str | java.lang.String, /) -> str: ...
    def languageDisplayName(self, arg1: str | java.lang.String, /) -> str: ...
    @typing.overload
    def localeDisplayName(self, arg1: android.icu.util.ULocale, /) -> str: ...
    @typing.overload
    def localeDisplayName(self, arg1: str | java.lang.String, /) -> str: ...
    @typing.overload
    def localeDisplayName(self, arg1: java.util.Locale, /) -> str: ...
    def regionDisplayName(self, arg1: str | java.lang.String, /) -> str: ...
    @typing.overload
    def scriptDisplayName(self, arg1: int | java.jint | java.lang.Integer, /) -> str: ...
    @typing.overload
    def scriptDisplayName(self, arg1: str | java.lang.String, /) -> str: ...
    def variantDisplayName(self, arg1: str | java.lang.String, /) -> str: ...

    class UiListItem(java.lang.Object):
        minimized: android.icu.util.ULocale = ...
        modified: android.icu.util.ULocale = ...
        nameInDisplayLocale: str = ...
        nameInSelf: str = ...
        def __init__(self, minimized: android.icu.util.ULocale, modified: android.icu.util.ULocale, nameInDisplayLocale: str | java.lang.String, nameInSelf: str | java.lang.String, /) -> None: ...
        def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
        @staticmethod
        def getComparator(comparator: java.util.Comparator[java.lang.Object], inSelf: bool | java.jboolean | java.lang.Boolean, /) -> java.util.Comparator[LocaleDisplayNames.UiListItem]: ...
        def hashCode(self) -> int: ...
        def toString(self) -> str: ...

    class DialectHandling(java.lang.Enum[LocaleDisplayNames.DialectHandling]):
        STANDARD_NAMES: typing.ClassVar[LocaleDisplayNames.DialectHandling] = ...
        DIALECT_NAMES: typing.ClassVar[LocaleDisplayNames.DialectHandling] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> LocaleDisplayNames.DialectHandling: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[LocaleDisplayNames.DialectHandling]: ...

class MeasureFormat(UFormat):
    def equals(self, other: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def format(self, obj: java.lang.Object | int | bool | float | str, toAppendTo: java.lang.StringBuffer, fpos: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    def formatMeasurePerUnit(self, measure: android.icu.util.Measure, perUnit: android.icu.util.MeasureUnit, appendTo: java.lang.StringBuilder, pos: java.text.FieldPosition, /) -> java.lang.StringBuilder: ...
    @typing.overload
    def formatMeasures(self, *measures: android.icu.util.Measure) -> str: ...
    @typing.overload
    def formatMeasures(self, appendTo: java.lang.StringBuilder, fpos: java.text.FieldPosition, /, *measures: android.icu.util.Measure) -> java.lang.StringBuilder: ...
    @typing.overload
    @staticmethod
    def getCurrencyFormat() -> MeasureFormat: ...
    @typing.overload
    @staticmethod
    def getCurrencyFormat(locale: android.icu.util.ULocale, /) -> MeasureFormat: ...
    @typing.overload
    @staticmethod
    def getCurrencyFormat(locale: java.util.Locale, /) -> MeasureFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, formatWidth: MeasureFormat.FormatWidth, /) -> MeasureFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, formatWidth: MeasureFormat.FormatWidth, /) -> MeasureFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, formatWidth: MeasureFormat.FormatWidth, format: NumberFormat, /) -> MeasureFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, formatWidth: MeasureFormat.FormatWidth, format: NumberFormat, /) -> MeasureFormat: ...
    def getLocale(self) -> android.icu.util.ULocale: ...
    def getNumberFormat(self) -> NumberFormat: ...
    def getUnitDisplayName(self, unit: android.icu.util.MeasureUnit, /) -> str: ...
    def getWidth(self) -> MeasureFormat.FormatWidth: ...
    def hashCode(self) -> int: ...
    def parseObject(self, source: str | java.lang.String, pos: java.text.ParsePosition, /) -> android.icu.util.Measure: ...

    class FormatWidth(java.lang.Enum[MeasureFormat.FormatWidth]):
        WIDE: typing.ClassVar[MeasureFormat.FormatWidth] = ...
        SHORT: typing.ClassVar[MeasureFormat.FormatWidth] = ...
        NARROW: typing.ClassVar[MeasureFormat.FormatWidth] = ...
        NUMERIC: typing.ClassVar[MeasureFormat.FormatWidth] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> MeasureFormat.FormatWidth: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[MeasureFormat.FormatWidth]: ...

class MessageFormat(UFormat):
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, locale: android.icu.util.ULocale, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, locale: java.util.Locale, /) -> None: ...
    @typing.overload
    def applyPattern(self, pttrn: str | java.lang.String, /) -> None: ...
    @typing.overload
    def applyPattern(self, pattern: str | java.lang.String, aposMode: MessagePattern.ApostropheMode, /) -> None: ...
    @staticmethod
    def autoQuoteApostrophe(pattern: str | java.lang.String, /) -> str: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    @staticmethod
    def format(pattern: str | java.lang.String, arguments: java.util.Map[java.lang.String, java.lang.Object], /) -> str: ...
    @typing.overload
    @staticmethod
    def format(pattern: str | java.lang.String, /, *arguments: java.lang.Object) -> str: ...
    @typing.overload
    def format(self, arguments: java.lang.Object | int | bool | float | str, result: java.lang.StringBuffer, pos: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, arguments: java.util.Map[java.lang.String, java.lang.Object], result: java.lang.StringBuffer, pos: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, arguments: java.chaquopy.JavaArray[java.lang.Object], result: java.lang.StringBuffer, pos: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    def formatToCharacterIterator(self, arguments: java.lang.Object | int | bool | float | str, /) -> java.text.AttributedCharacterIterator: ...
    def getApostropheMode(self) -> MessagePattern.ApostropheMode: ...
    def getArgumentNames(self) -> java.util.Set[java.lang.String]: ...
    def getFormatByArgumentName(self, argumentName: str | java.lang.String, /) -> java.text.Format | None: ...
    def getFormats(self) -> java.chaquopy.JavaArray[java.text.Format]: ...
    def getFormatsByArgumentIndex(self) -> java.chaquopy.JavaArray[java.text.Format]: ...
    def getLocale(self) -> java.util.Locale: ...
    def getULocale(self) -> android.icu.util.ULocale: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def parse(self, source: str | java.lang.String, /) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def parse(self, source: str | java.lang.String, pos: java.text.ParsePosition, /) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    def parseObject(self, source: str | java.lang.String, pos: java.text.ParsePosition, /) -> java.lang.Object | None: ...
    @typing.overload
    def parseToMap(self, source: str | java.lang.String, /) -> java.util.Map[java.lang.String, java.lang.Object]: ...
    @typing.overload
    def parseToMap(self, source: str | java.lang.String, pos: java.text.ParsePosition, /) -> java.util.Map[java.lang.String, java.lang.Object]: ...
    def setFormat(self, formatElementIndex: int | java.jint | java.lang.Integer, newFormat: java.text.Format, /) -> None: ...
    def setFormatByArgumentIndex(self, argumentIndex: int | java.jint | java.lang.Integer, newFormat: java.text.Format, /) -> None: ...
    def setFormatByArgumentName(self, argumentName: str | java.lang.String, newFormat: java.text.Format, /) -> None: ...
    def setFormats(self, newFormats: java.chaquopy.JavaArray[java.text.Format], /) -> None: ...
    def setFormatsByArgumentIndex(self, newFormats: java.chaquopy.JavaArray[java.text.Format], /) -> None: ...
    def setFormatsByArgumentName(self, newFormats: java.util.Map[java.lang.String, java.text.Format], /) -> None: ...
    @typing.overload
    def setLocale(self, locale: android.icu.util.ULocale, /) -> None: ...
    @typing.overload
    def setLocale(self, locale: java.util.Locale, /) -> None: ...
    def toPattern(self) -> str: ...
    def usesNamedArguments(self) -> bool: ...

    class Field(java.text.Format.Field):
        ARGUMENT: typing.ClassVar[MessageFormat.Field] = ...
        def __init__(self, name: str | java.lang.String, /) -> None: ...
        def readResolve(self) -> java.lang.Object: ...

class MessagePattern(java.lang.Cloneable, android.icu.util.Freezable[MessagePattern]):
    ARG_NAME_NOT_NUMBER: typing.ClassVar[int] = ...
    ARG_NAME_NOT_VALID: typing.ClassVar[int] = ...
    NO_NUMERIC_VALUE: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, mode: MessagePattern.ApostropheMode, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, /) -> None: ...
    def autoQuoteApostropheDeep(self) -> str: ...
    def clear(self) -> None: ...
    def clearPatternAndSetApostropheMode(self, mode: MessagePattern.ApostropheMode, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def cloneAsThawed(self) -> MessagePattern: ...
    def countParts(self) -> int: ...
    def equals(self, other: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def freeze(self) -> MessagePattern: ...
    def getApostropheMode(self) -> MessagePattern.ApostropheMode: ...
    def getLimitPartIndex(self, start: int | java.jint | java.lang.Integer, /) -> int: ...
    def getNumericValue(self, part: MessagePattern.Part, /) -> float: ...
    def getPart(self, i: int | java.jint | java.lang.Integer, /) -> MessagePattern.Part: ...
    def getPartType(self, i: int | java.jint | java.lang.Integer, /) -> MessagePattern.Part.Type: ...
    def getPatternIndex(self, partIndex: int | java.jint | java.lang.Integer, /) -> int: ...
    def getPatternString(self) -> str | None: ...
    def getPluralOffset(self, pluralStart: int | java.jint | java.lang.Integer, /) -> float: ...
    def getSubstring(self, part: MessagePattern.Part, /) -> str: ...
    def hasNamedArguments(self) -> bool: ...
    def hasNumberedArguments(self) -> bool: ...
    def hashCode(self) -> int: ...
    def isFrozen(self) -> bool: ...
    def parse(self, pattern: str | java.lang.String, /) -> MessagePattern: ...
    def parseChoiceStyle(self, pattern: str | java.lang.String, /) -> MessagePattern: ...
    def parsePluralStyle(self, pattern: str | java.lang.String, /) -> MessagePattern: ...
    def parseSelectStyle(self, pattern: str | java.lang.String, /) -> MessagePattern: ...
    def partSubstringMatches(self, part: MessagePattern.Part, s: str | java.lang.String, /) -> bool: ...
    def toString(self) -> str: ...
    @staticmethod
    def validateArgumentName(name: str | java.lang.String, /) -> int: ...

    class Part(java.lang.Object):
        def equals(self, other: java.lang.Object | int | bool | float | str, /) -> bool: ...
        def getArgType(self) -> MessagePattern.ArgType: ...
        def getIndex(self) -> int: ...
        def getLength(self) -> int: ...
        def getLimit(self) -> int: ...
        def getType(self) -> MessagePattern.Part.Type: ...
        def getValue(self) -> int: ...
        def hashCode(self) -> int: ...
        def toString(self) -> str: ...

        class Type(java.lang.Enum[MessagePattern.Part.Type]):
            MSG_START: typing.ClassVar[MessagePattern.Part.Type] = ...
            MSG_LIMIT: typing.ClassVar[MessagePattern.Part.Type] = ...
            SKIP_SYNTAX: typing.ClassVar[MessagePattern.Part.Type] = ...
            INSERT_CHAR: typing.ClassVar[MessagePattern.Part.Type] = ...
            REPLACE_NUMBER: typing.ClassVar[MessagePattern.Part.Type] = ...
            ARG_START: typing.ClassVar[MessagePattern.Part.Type] = ...
            ARG_LIMIT: typing.ClassVar[MessagePattern.Part.Type] = ...
            ARG_NUMBER: typing.ClassVar[MessagePattern.Part.Type] = ...
            ARG_NAME: typing.ClassVar[MessagePattern.Part.Type] = ...
            ARG_TYPE: typing.ClassVar[MessagePattern.Part.Type] = ...
            ARG_STYLE: typing.ClassVar[MessagePattern.Part.Type] = ...
            ARG_SELECTOR: typing.ClassVar[MessagePattern.Part.Type] = ...
            ARG_INT: typing.ClassVar[MessagePattern.Part.Type] = ...
            ARG_DOUBLE: typing.ClassVar[MessagePattern.Part.Type] = ...
            def hasNumericValue(self) -> bool: ...
            @staticmethod
            def valueOf(name: str | java.lang.String, /) -> MessagePattern.Part.Type: ...
            @staticmethod
            def values() -> java.chaquopy.JavaArray[MessagePattern.Part.Type]: ...

    class ArgType(java.lang.Enum[MessagePattern.ArgType]):
        NONE: typing.ClassVar[MessagePattern.ArgType] = ...
        SIMPLE: typing.ClassVar[MessagePattern.ArgType] = ...
        CHOICE: typing.ClassVar[MessagePattern.ArgType] = ...
        PLURAL: typing.ClassVar[MessagePattern.ArgType] = ...
        SELECT: typing.ClassVar[MessagePattern.ArgType] = ...
        SELECTORDINAL: typing.ClassVar[MessagePattern.ArgType] = ...
        def hasPluralStyle(self) -> bool: ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> MessagePattern.ArgType: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[MessagePattern.ArgType]: ...

    class ApostropheMode(java.lang.Enum[MessagePattern.ApostropheMode]):
        DOUBLE_OPTIONAL: typing.ClassVar[MessagePattern.ApostropheMode] = ...
        DOUBLE_REQUIRED: typing.ClassVar[MessagePattern.ApostropheMode] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> MessagePattern.ApostropheMode: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[MessagePattern.ApostropheMode]: ...

class Normalizer(java.lang.Cloneable):
    COMPARE_CODE_POINT_ORDER: typing.ClassVar[int] = ...
    COMPARE_IGNORE_CASE: typing.ClassVar[int] = ...
    FOLD_CASE_DEFAULT: typing.ClassVar[int] = ...
    FOLD_CASE_EXCLUDE_SPECIAL_I: typing.ClassVar[int] = ...
    INPUT_IS_FCD: typing.ClassVar[int] = ...
    MAYBE: typing.ClassVar[Normalizer.QuickCheckResult] = ...
    NO: typing.ClassVar[Normalizer.QuickCheckResult] = ...
    YES: typing.ClassVar[Normalizer.QuickCheckResult] = ...
    def clone(self) -> java.lang.Object: ...
    @typing.overload
    @staticmethod
    def compare(char32a: int | java.jint | java.lang.Integer, char32b: int | java.jint | java.lang.Integer, options: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(char32a: int | java.jint | java.lang.Integer, str2: str | java.lang.String, options: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(s1: str | java.lang.String, s2: str | java.lang.String, options: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(s1: java.chaquopy.JavaArrayJChar, s2: java.chaquopy.JavaArrayJChar, options: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def compare(s1: java.chaquopy.JavaArrayJChar, s1Start: int | java.jint | java.lang.Integer, s1Limit: int | java.jint | java.lang.Integer, s2: java.chaquopy.JavaArrayJChar, s2Start: int | java.jint | java.lang.Integer, s2Limit: int | java.jint | java.lang.Integer, options: int | java.jint | java.lang.Integer, /) -> int: ...

    class QuickCheckResult(java.lang.Object): ...

class Normalizer2(java.lang.Object):
    def append(self, arg1: java.lang.StringBuilder, arg2: java.lang.CharSequence, /) -> java.lang.StringBuilder: ...
    def composePair(self, a: int | java.jint | java.lang.Integer, b: int | java.jint | java.lang.Integer, /) -> int: ...
    def getCombiningClass(self, c: int | java.jint | java.lang.Integer, /) -> int: ...
    def getDecomposition(self, arg1: int | java.jint | java.lang.Integer, /) -> str | None: ...
    @staticmethod
    def getInstance(data: java.io.InputStream, name: str | java.lang.String, mode: Normalizer2.Mode, /) -> Normalizer2: ...
    @staticmethod
    def getNFCInstance() -> Normalizer2: ...
    @staticmethod
    def getNFDInstance() -> Normalizer2: ...
    @staticmethod
    def getNFKCCasefoldInstance() -> Normalizer2: ...
    @staticmethod
    def getNFKCInstance() -> Normalizer2: ...
    @staticmethod
    def getNFKDInstance() -> Normalizer2: ...
    def getRawDecomposition(self, c: int | java.jint | java.lang.Integer, /) -> str | None: ...
    def hasBoundaryAfter(self, arg1: int | java.jint | java.lang.Integer, /) -> bool: ...
    def hasBoundaryBefore(self, arg1: int | java.jint | java.lang.Integer, /) -> bool: ...
    def isInert(self, arg1: int | java.jint | java.lang.Integer, /) -> bool: ...
    def isNormalized(self, arg1: java.lang.CharSequence, /) -> bool: ...
    @typing.overload
    def normalize(self, src: java.lang.CharSequence, /) -> str: ...
    @typing.overload
    def normalize(self, arg1: java.lang.CharSequence, arg2: java.lang.Appendable, /) -> java.lang.Appendable: ...
    @typing.overload
    def normalize(self, arg1: java.lang.CharSequence, arg2: java.lang.StringBuilder, /) -> java.lang.StringBuilder: ...
    def normalizeSecondAndAppend(self, arg1: java.lang.StringBuilder, arg2: java.lang.CharSequence, /) -> java.lang.StringBuilder: ...
    def quickCheck(self, arg1: java.lang.CharSequence, /) -> Normalizer.QuickCheckResult: ...
    def spanQuickCheckYes(self, arg1: java.lang.CharSequence, /) -> int: ...

    class Mode(java.lang.Enum[Normalizer2.Mode]):
        COMPOSE: typing.ClassVar[Normalizer2.Mode] = ...
        DECOMPOSE: typing.ClassVar[Normalizer2.Mode] = ...
        FCD: typing.ClassVar[Normalizer2.Mode] = ...
        COMPOSE_CONTIGUOUS: typing.ClassVar[Normalizer2.Mode] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> Normalizer2.Mode: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[Normalizer2.Mode]: ...

class NumberFormat(UFormat):
    ACCOUNTINGCURRENCYSTYLE: typing.ClassVar[int] = ...
    CASHCURRENCYSTYLE: typing.ClassVar[int] = ...
    CURRENCYSTYLE: typing.ClassVar[int] = ...
    FRACTION_FIELD: typing.ClassVar[int] = ...
    INTEGERSTYLE: typing.ClassVar[int] = ...
    INTEGER_FIELD: typing.ClassVar[int] = ...
    ISOCURRENCYSTYLE: typing.ClassVar[int] = ...
    NUMBERSTYLE: typing.ClassVar[int] = ...
    PERCENTSTYLE: typing.ClassVar[int] = ...
    PLURALCURRENCYSTYLE: typing.ClassVar[int] = ...
    SCIENTIFICSTYLE: typing.ClassVar[int] = ...
    STANDARDCURRENCYSTYLE: typing.ClassVar[int] = ...
    def __init__(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def format(self, number: float | java.jdouble | java.lang.Double, /) -> str: ...
    @typing.overload
    def format(self, number: int | java.jlong | java.lang.Long, /) -> str: ...
    @typing.overload
    def format(self, number: android.icu.math.BigDecimal, /) -> str: ...
    @typing.overload
    def format(self, currAmt: android.icu.util.CurrencyAmount, /) -> str: ...
    @typing.overload
    def format(self, number: java.math.BigDecimal, /) -> str: ...
    @typing.overload
    def format(self, number: java.math.BigInteger, /) -> str: ...
    @typing.overload
    def format(self, arg1: float | java.jdouble | java.lang.Double, arg2: java.lang.StringBuffer, arg3: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, arg1: int | java.jlong | java.lang.Long, arg2: java.lang.StringBuffer, arg3: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, arg1: android.icu.math.BigDecimal, arg2: java.lang.StringBuffer, arg3: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, currAmt: android.icu.util.CurrencyAmount, toAppendTo: java.lang.StringBuffer, pos: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, number: java.lang.Object | int | bool | float | str, toAppendTo: java.lang.StringBuffer, pos: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, arg1: java.math.BigDecimal, arg2: java.lang.StringBuffer, arg3: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, arg1: java.math.BigInteger, arg2: java.lang.StringBuffer, arg3: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @staticmethod
    def getAvailableLocales() -> java.chaquopy.JavaArray[java.util.Locale]: ...
    def getContext(self, type: DisplayContext.Type, /) -> DisplayContext: ...
    def getCurrency(self) -> android.icu.util.Currency: ...
    @typing.overload
    @staticmethod
    def getCurrencyInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getCurrencyInstance(inLocale: android.icu.util.ULocale, /) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getCurrencyInstance(inLocale: java.util.Locale, /) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(style: int | java.jint | java.lang.Integer, /) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(inLocale: android.icu.util.ULocale, /) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(inLocale: java.util.Locale, /) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(desiredLocale: android.icu.util.ULocale, choice: int | java.jint | java.lang.Integer, /) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(inLocale: java.util.Locale, style: int | java.jint | java.lang.Integer, /) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getIntegerInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getIntegerInstance(inLocale: android.icu.util.ULocale, /) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getIntegerInstance(inLocale: java.util.Locale, /) -> NumberFormat: ...
    def getMaximumFractionDigits(self) -> int: ...
    def getMaximumIntegerDigits(self) -> int: ...
    def getMinimumFractionDigits(self) -> int: ...
    def getMinimumIntegerDigits(self) -> int: ...
    @typing.overload
    @staticmethod
    def getNumberInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getNumberInstance(inLocale: android.icu.util.ULocale, /) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getNumberInstance(inLocale: java.util.Locale, /) -> NumberFormat: ...
    @staticmethod
    def getPattern(forLocale: android.icu.util.ULocale, choice: int | java.jint | java.lang.Integer, /) -> str: ...
    @typing.overload
    @staticmethod
    def getPercentInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getPercentInstance(inLocale: android.icu.util.ULocale, /) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getPercentInstance(inLocale: java.util.Locale, /) -> NumberFormat: ...
    def getRoundingMode(self) -> int: ...
    @typing.overload
    @staticmethod
    def getScientificInstance() -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getScientificInstance(inLocale: android.icu.util.ULocale, /) -> NumberFormat: ...
    @typing.overload
    @staticmethod
    def getScientificInstance(inLocale: java.util.Locale, /) -> NumberFormat: ...
    def hashCode(self) -> int: ...
    def isGroupingUsed(self) -> bool: ...
    def isParseIntegerOnly(self) -> bool: ...
    def isParseStrict(self) -> bool: ...
    @typing.overload
    def parse(self, text: str | java.lang.String, /) -> java.lang.Number: ...
    @typing.overload
    def parse(self, arg1: str | java.lang.String, arg2: java.text.ParsePosition, /) -> java.lang.Number: ...
    def parseCurrency(self, text: java.lang.CharSequence, pos: java.text.ParsePosition, /) -> android.icu.util.CurrencyAmount | None: ...
    def parseObject(self, source: str | java.lang.String, parsePosition: java.text.ParsePosition, /) -> java.lang.Object | None: ...
    def setContext(self, context: DisplayContext, /) -> None: ...
    def setCurrency(self, theCurrency: android.icu.util.Currency, /) -> None: ...
    def setGroupingUsed(self, newValue: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setMaximumFractionDigits(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMaximumIntegerDigits(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMinimumFractionDigits(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMinimumIntegerDigits(self, newValue: int | java.jint | java.lang.Integer, /) -> None: ...
    def setParseIntegerOnly(self, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setParseStrict(self, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setRoundingMode(self, roundingMode: int | java.jint | java.lang.Integer, /) -> None: ...

    class Field(java.text.Format.Field):
        APPROXIMATELY_SIGN: typing.ClassVar[NumberFormat.Field] = ...
        COMPACT: typing.ClassVar[NumberFormat.Field] = ...
        CURRENCY: typing.ClassVar[NumberFormat.Field] = ...
        DECIMAL_SEPARATOR: typing.ClassVar[NumberFormat.Field] = ...
        EXPONENT: typing.ClassVar[NumberFormat.Field] = ...
        EXPONENT_SIGN: typing.ClassVar[NumberFormat.Field] = ...
        EXPONENT_SYMBOL: typing.ClassVar[NumberFormat.Field] = ...
        FRACTION: typing.ClassVar[NumberFormat.Field] = ...
        GROUPING_SEPARATOR: typing.ClassVar[NumberFormat.Field] = ...
        INTEGER: typing.ClassVar[NumberFormat.Field] = ...
        MEASURE_UNIT: typing.ClassVar[NumberFormat.Field] = ...
        PERCENT: typing.ClassVar[NumberFormat.Field] = ...
        PERMILLE: typing.ClassVar[NumberFormat.Field] = ...
        SIGN: typing.ClassVar[NumberFormat.Field] = ...
        def __init__(self, fieldName: str | java.lang.String, /) -> None: ...
        def readResolve(self) -> java.lang.Object: ...

class NumberingSystem(java.lang.Object):
    LATIN: typing.ClassVar[NumberingSystem] = ...
    def __init__(self) -> None: ...
    @staticmethod
    def getAvailableNames() -> java.chaquopy.JavaArray[java.lang.String]: ...
    def getDescription(self) -> str: ...
    @typing.overload
    @staticmethod
    def getInstance() -> NumberingSystem: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, /) -> NumberingSystem: ...
    @typing.overload
    @staticmethod
    def getInstance(inLocale: java.util.Locale, /) -> NumberingSystem: ...
    @typing.overload
    @staticmethod
    def getInstance(radix_in: int | java.jint | java.lang.Integer, isAlgorithmic_in: bool | java.jboolean | java.lang.Boolean, desc_in: str | java.lang.String, /) -> NumberingSystem: ...
    @staticmethod
    def getInstanceByName(name: str | java.lang.String, /) -> NumberingSystem | None: ...
    def getName(self) -> str: ...
    def getRadix(self) -> int: ...
    def isAlgorithmic(self) -> bool: ...
    @staticmethod
    def isValidDigitString(str: str | java.lang.String, /) -> bool: ...

class PluralFormat(UFormat):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, rules: PluralRules, /) -> None: ...
    @typing.overload
    def __init__(self, ulocale: android.icu.util.ULocale, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, locale: java.util.Locale, /) -> None: ...
    @typing.overload
    def __init__(self, rules: PluralRules, pattern: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, ulocale: android.icu.util.ULocale, type: PluralRules.PluralType, /) -> None: ...
    @typing.overload
    def __init__(self, ulocale: android.icu.util.ULocale, rules: PluralRules, /) -> None: ...
    @typing.overload
    def __init__(self, ulocale: android.icu.util.ULocale, pattern: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, locale: java.util.Locale, type: PluralRules.PluralType, /) -> None: ...
    @typing.overload
    def __init__(self, locale: java.util.Locale, rules: PluralRules, /) -> None: ...
    @typing.overload
    def __init__(self, ulocale: android.icu.util.ULocale, type: PluralRules.PluralType, pattern: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, ulocale: android.icu.util.ULocale, rules: PluralRules, pattern: str | java.lang.String, /) -> None: ...
    def applyPattern(self, pattern: str | java.lang.String, /) -> None: ...
    @typing.overload
    def equals(self, rhs: PluralFormat, /) -> bool: ...
    @typing.overload
    def equals(self, rhs: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def format(self, number: float | java.jdouble | java.lang.Double, /) -> str: ...
    @typing.overload
    def format(self, number: java.lang.Object | int | bool | float | str, toAppendTo: java.lang.StringBuffer, pos: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    def hashCode(self) -> int: ...
    def parse(self, text: str | java.lang.String, parsePosition: java.text.ParsePosition, /) -> java.lang.Number: ...
    def parseObject(self, source: str | java.lang.String, pos: java.text.ParsePosition, /) -> java.lang.Object: ...
    def setNumberFormat(self, format: NumberFormat, /) -> None: ...
    def toPattern(self) -> str: ...
    def toString(self) -> str: ...

class PluralRules(java.io.Serializable):
    DEFAULT: typing.ClassVar[PluralRules] = ...
    KEYWORD_FEW: typing.ClassVar[str] = ...
    KEYWORD_MANY: typing.ClassVar[str] = ...
    KEYWORD_ONE: typing.ClassVar[str] = ...
    KEYWORD_OTHER: typing.ClassVar[str] = ...
    KEYWORD_TWO: typing.ClassVar[str] = ...
    KEYWORD_ZERO: typing.ClassVar[str] = ...
    NO_UNIQUE_VALUE: typing.ClassVar[float] = ...
    @staticmethod
    def createRules(description: str | java.lang.String, /) -> PluralRules: ...
    @typing.overload
    def equals(self, rhs: PluralRules, /) -> bool: ...
    @typing.overload
    def equals(self, rhs: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    @staticmethod
    def forLocale(locale: android.icu.util.ULocale, /) -> PluralRules: ...
    @typing.overload
    @staticmethod
    def forLocale(locale: java.util.Locale, /) -> PluralRules: ...
    @typing.overload
    @staticmethod
    def forLocale(locale: android.icu.util.ULocale, type: PluralRules.PluralType, /) -> PluralRules: ...
    @typing.overload
    @staticmethod
    def forLocale(locale: java.util.Locale, type: PluralRules.PluralType, /) -> PluralRules: ...
    def getAllKeywordValues(self, keyword: str | java.lang.String, /) -> java.util.Collection[java.lang.Double] | None: ...
    def getKeywords(self) -> java.util.Set[java.lang.String]: ...
    def getSamples(self, keyword: str | java.lang.String, /) -> java.util.Collection[java.lang.Double]: ...
    def getUniqueKeywordValue(self, keyword: str | java.lang.String, /) -> float: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def parseDescription(description: str | java.lang.String, /) -> PluralRules: ...
    @typing.overload
    def select(self, number: float | java.jdouble | java.lang.Double, /) -> str: ...
    @typing.overload
    def select(self, number: android.icu.number.FormattedNumber, /) -> str: ...
    @typing.overload
    def select(self, range: android.icu.number.FormattedNumberRange, /) -> str: ...
    def toString(self) -> str: ...

    class PluralType(java.lang.Enum[PluralRules.PluralType]):
        CARDINAL: typing.ClassVar[PluralRules.PluralType] = ...
        ORDINAL: typing.ClassVar[PluralRules.PluralType] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> PluralRules.PluralType: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[PluralRules.PluralType]: ...

class RelativeDateTimeFormatter(java.lang.Object):
    def combineDateAndTime(self, relativeDateString: str | java.lang.String, timeString: str | java.lang.String, /) -> str: ...
    @typing.overload
    def format(self, offset: float | java.jdouble | java.lang.Double, unit: RelativeDateTimeFormatter.RelativeDateTimeUnit, /) -> str | None: ...
    @typing.overload
    def format(self, direction: RelativeDateTimeFormatter.Direction, unit: RelativeDateTimeFormatter.AbsoluteUnit, /) -> str | None: ...
    @typing.overload
    def format(self, quantity: float | java.jdouble | java.lang.Double, direction: RelativeDateTimeFormatter.Direction, unit: RelativeDateTimeFormatter.RelativeUnit, /) -> str | None: ...
    def formatNumeric(self, offset: float | java.jdouble | java.lang.Double, unit: RelativeDateTimeFormatter.RelativeDateTimeUnit, /) -> str: ...
    def formatNumericToValue(self, offset: float | java.jdouble | java.lang.Double, unit: RelativeDateTimeFormatter.RelativeDateTimeUnit, /) -> RelativeDateTimeFormatter.FormattedRelativeDateTime: ...
    @typing.overload
    def formatToValue(self, offset: float | java.jdouble | java.lang.Double, unit: RelativeDateTimeFormatter.RelativeDateTimeUnit, /) -> RelativeDateTimeFormatter.FormattedRelativeDateTime | None: ...
    @typing.overload
    def formatToValue(self, direction: RelativeDateTimeFormatter.Direction, unit: RelativeDateTimeFormatter.AbsoluteUnit, /) -> RelativeDateTimeFormatter.FormattedRelativeDateTime | None: ...
    @typing.overload
    def formatToValue(self, quantity: float | java.jdouble | java.lang.Double, direction: RelativeDateTimeFormatter.Direction, unit: RelativeDateTimeFormatter.RelativeUnit, /) -> RelativeDateTimeFormatter.FormattedRelativeDateTime | None: ...
    def getCapitalizationContext(self) -> DisplayContext: ...
    def getFormatStyle(self) -> RelativeDateTimeFormatter.Style: ...
    @typing.overload
    @staticmethod
    def getInstance() -> RelativeDateTimeFormatter: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, /) -> RelativeDateTimeFormatter: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, /) -> RelativeDateTimeFormatter: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, nf: NumberFormat, /) -> RelativeDateTimeFormatter: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, nf: NumberFormat, /) -> RelativeDateTimeFormatter: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, nf: NumberFormat, style: RelativeDateTimeFormatter.Style, capitalizationContext: DisplayContext, /) -> RelativeDateTimeFormatter: ...
    def getNumberFormat(self) -> NumberFormat: ...

    class Style(java.lang.Enum[RelativeDateTimeFormatter.Style]):
        LONG: typing.ClassVar[RelativeDateTimeFormatter.Style] = ...
        SHORT: typing.ClassVar[RelativeDateTimeFormatter.Style] = ...
        NARROW: typing.ClassVar[RelativeDateTimeFormatter.Style] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> RelativeDateTimeFormatter.Style: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[RelativeDateTimeFormatter.Style]: ...

    class RelativeUnit(java.lang.Enum[RelativeDateTimeFormatter.RelativeUnit]):
        SECONDS: typing.ClassVar[RelativeDateTimeFormatter.RelativeUnit] = ...
        MINUTES: typing.ClassVar[RelativeDateTimeFormatter.RelativeUnit] = ...
        HOURS: typing.ClassVar[RelativeDateTimeFormatter.RelativeUnit] = ...
        DAYS: typing.ClassVar[RelativeDateTimeFormatter.RelativeUnit] = ...
        WEEKS: typing.ClassVar[RelativeDateTimeFormatter.RelativeUnit] = ...
        MONTHS: typing.ClassVar[RelativeDateTimeFormatter.RelativeUnit] = ...
        YEARS: typing.ClassVar[RelativeDateTimeFormatter.RelativeUnit] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> RelativeDateTimeFormatter.RelativeUnit: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[RelativeDateTimeFormatter.RelativeUnit]: ...

    class RelativeDateTimeUnit(java.lang.Enum[RelativeDateTimeFormatter.RelativeDateTimeUnit]):
        YEAR: typing.ClassVar[RelativeDateTimeFormatter.RelativeDateTimeUnit] = ...
        QUARTER: typing.ClassVar[RelativeDateTimeFormatter.RelativeDateTimeUnit] = ...
        MONTH: typing.ClassVar[RelativeDateTimeFormatter.RelativeDateTimeUnit] = ...
        WEEK: typing.ClassVar[RelativeDateTimeFormatter.RelativeDateTimeUnit] = ...
        DAY: typing.ClassVar[RelativeDateTimeFormatter.RelativeDateTimeUnit] = ...
        HOUR: typing.ClassVar[RelativeDateTimeFormatter.RelativeDateTimeUnit] = ...
        MINUTE: typing.ClassVar[RelativeDateTimeFormatter.RelativeDateTimeUnit] = ...
        SECOND: typing.ClassVar[RelativeDateTimeFormatter.RelativeDateTimeUnit] = ...
        SUNDAY: typing.ClassVar[RelativeDateTimeFormatter.RelativeDateTimeUnit] = ...
        MONDAY: typing.ClassVar[RelativeDateTimeFormatter.RelativeDateTimeUnit] = ...
        TUESDAY: typing.ClassVar[RelativeDateTimeFormatter.RelativeDateTimeUnit] = ...
        WEDNESDAY: typing.ClassVar[RelativeDateTimeFormatter.RelativeDateTimeUnit] = ...
        THURSDAY: typing.ClassVar[RelativeDateTimeFormatter.RelativeDateTimeUnit] = ...
        FRIDAY: typing.ClassVar[RelativeDateTimeFormatter.RelativeDateTimeUnit] = ...
        SATURDAY: typing.ClassVar[RelativeDateTimeFormatter.RelativeDateTimeUnit] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> RelativeDateTimeFormatter.RelativeDateTimeUnit: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[RelativeDateTimeFormatter.RelativeDateTimeUnit]: ...

    class FormattedRelativeDateTime(FormattedValue):
        _appendTo__A = typing.TypeVar('_appendTo__A')  # <A>
        def appendTo(self, appendable: _appendTo__A, /) -> _appendTo__A: ...
        def charAt(self, index: int | java.jint | java.lang.Integer, /) -> str: ...
        def length(self) -> int: ...
        def nextPosition(self, cfpos: ConstrainedFieldPosition, /) -> bool: ...
        def subSequence(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> java.lang.CharSequence: ...
        def toCharacterIterator(self) -> java.text.AttributedCharacterIterator: ...
        def toString(self) -> str: ...

    class Direction(java.lang.Enum[RelativeDateTimeFormatter.Direction]):
        LAST_2: typing.ClassVar[RelativeDateTimeFormatter.Direction] = ...
        LAST: typing.ClassVar[RelativeDateTimeFormatter.Direction] = ...
        THIS: typing.ClassVar[RelativeDateTimeFormatter.Direction] = ...
        NEXT: typing.ClassVar[RelativeDateTimeFormatter.Direction] = ...
        NEXT_2: typing.ClassVar[RelativeDateTimeFormatter.Direction] = ...
        PLAIN: typing.ClassVar[RelativeDateTimeFormatter.Direction] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> RelativeDateTimeFormatter.Direction: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[RelativeDateTimeFormatter.Direction]: ...

    class AbsoluteUnit(java.lang.Enum[RelativeDateTimeFormatter.AbsoluteUnit]):
        SUNDAY: typing.ClassVar[RelativeDateTimeFormatter.AbsoluteUnit] = ...
        MONDAY: typing.ClassVar[RelativeDateTimeFormatter.AbsoluteUnit] = ...
        TUESDAY: typing.ClassVar[RelativeDateTimeFormatter.AbsoluteUnit] = ...
        WEDNESDAY: typing.ClassVar[RelativeDateTimeFormatter.AbsoluteUnit] = ...
        THURSDAY: typing.ClassVar[RelativeDateTimeFormatter.AbsoluteUnit] = ...
        FRIDAY: typing.ClassVar[RelativeDateTimeFormatter.AbsoluteUnit] = ...
        SATURDAY: typing.ClassVar[RelativeDateTimeFormatter.AbsoluteUnit] = ...
        DAY: typing.ClassVar[RelativeDateTimeFormatter.AbsoluteUnit] = ...
        WEEK: typing.ClassVar[RelativeDateTimeFormatter.AbsoluteUnit] = ...
        MONTH: typing.ClassVar[RelativeDateTimeFormatter.AbsoluteUnit] = ...
        YEAR: typing.ClassVar[RelativeDateTimeFormatter.AbsoluteUnit] = ...
        NOW: typing.ClassVar[RelativeDateTimeFormatter.AbsoluteUnit] = ...
        QUARTER: typing.ClassVar[RelativeDateTimeFormatter.AbsoluteUnit] = ...
        HOUR: typing.ClassVar[RelativeDateTimeFormatter.AbsoluteUnit] = ...
        MINUTE: typing.ClassVar[RelativeDateTimeFormatter.AbsoluteUnit] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> RelativeDateTimeFormatter.AbsoluteUnit: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[RelativeDateTimeFormatter.AbsoluteUnit]: ...

class Replaceable(java.lang.Object):
    def char32At(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def charAt(self, arg1: int | java.jint | java.lang.Integer, /) -> str: ...
    def copy(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, arg3: int | java.jint | java.lang.Integer, /) -> None: ...
    def getChars(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, arg3: java.chaquopy.JavaArrayJChar, arg4: int | java.jint | java.lang.Integer, /) -> None: ...
    def hasMetaData(self) -> bool: ...
    def length(self) -> int: ...
    @typing.overload
    def replace(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, arg3: str | java.lang.String, /) -> None: ...
    @typing.overload
    def replace(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, arg3: java.chaquopy.JavaArrayJChar, arg4: int | java.jint | java.lang.Integer, arg5: int | java.jint | java.lang.Integer, /) -> None: ...

class RuleBasedCollator(Collator):
    def __init__(self, rules: str | java.lang.String, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def cloneAsThawed(self) -> RuleBasedCollator: ...
    def compare(self, source: str | java.lang.String, target: str | java.lang.String, /) -> int: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def freeze(self) -> Collator: ...
    @typing.overload
    def getCollationElementIterator(self, source: UCharacterIterator, /) -> CollationElementIterator: ...
    @typing.overload
    def getCollationElementIterator(self, source: str | java.lang.String, /) -> CollationElementIterator: ...
    @typing.overload
    def getCollationElementIterator(self, source: java.text.CharacterIterator, /) -> CollationElementIterator: ...
    def getCollationKey(self, source: str | java.lang.String, /) -> CollationKey: ...
    def getContractionsAndExpansions(self, contractions: UnicodeSet, expansions: UnicodeSet, addPrefixes: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def getDecomposition(self) -> int: ...
    def getMaxVariable(self) -> int: ...
    def getNumericCollation(self) -> bool: ...
    def getReorderCodes(self) -> java.chaquopy.JavaArrayJInt: ...
    @typing.overload
    def getRules(self) -> str: ...
    @typing.overload
    def getRules(self, fullrules: bool | java.jboolean | java.lang.Boolean, /) -> str: ...
    def getStrength(self) -> int: ...
    def getTailoredSet(self) -> UnicodeSet: ...
    def getUCAVersion(self) -> android.icu.util.VersionInfo: ...
    def getVariableTop(self) -> int: ...
    def getVersion(self) -> android.icu.util.VersionInfo: ...
    def hashCode(self) -> int: ...
    def isAlternateHandlingShifted(self) -> bool: ...
    def isCaseLevel(self) -> bool: ...
    def isFrenchCollation(self) -> bool: ...
    def isFrozen(self) -> bool: ...
    def isLowerCaseFirst(self) -> bool: ...
    def isUpperCaseFirst(self) -> bool: ...
    def setAlternateHandlingDefault(self) -> None: ...
    def setAlternateHandlingShifted(self, shifted: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setCaseFirstDefault(self) -> None: ...
    def setCaseLevel(self, flag: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setCaseLevelDefault(self) -> None: ...
    def setDecomposition(self, decomposition: int | java.jint | java.lang.Integer, /) -> None: ...
    def setDecompositionDefault(self) -> None: ...
    def setFrenchCollation(self, flag: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setFrenchCollationDefault(self) -> None: ...
    def setLowerCaseFirst(self, lowerfirst: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setMaxVariable(self, group: int | java.jint | java.lang.Integer, /) -> RuleBasedCollator: ...
    def setNumericCollation(self, flag: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setNumericCollationDefault(self) -> None: ...
    def setReorderCodes(self, *order: java.chaquopy.JavaArrayJInt) -> None: ...
    def setStrength(self, newStrength: int | java.jint | java.lang.Integer, /) -> None: ...
    def setStrengthDefault(self) -> None: ...
    def setUpperCaseFirst(self, upperfirst: bool | java.jboolean | java.lang.Boolean, /) -> None: ...

class ScientificNumberFormatter(java.lang.Object):
    def format(self, number: java.lang.Object | int | bool | float | str, /) -> str: ...
    @typing.overload
    @staticmethod
    def getMarkupInstance(df: DecimalFormat, beginMarkup: str | java.lang.String, endMarkup: str | java.lang.String, /) -> ScientificNumberFormatter: ...
    @typing.overload
    @staticmethod
    def getMarkupInstance(locale: android.icu.util.ULocale, beginMarkup: str | java.lang.String, endMarkup: str | java.lang.String, /) -> ScientificNumberFormatter: ...
    @typing.overload
    @staticmethod
    def getSuperscriptInstance(df: DecimalFormat, /) -> ScientificNumberFormatter: ...
    @typing.overload
    @staticmethod
    def getSuperscriptInstance(locale: android.icu.util.ULocale, /) -> ScientificNumberFormatter: ...

class SearchIterator(java.lang.Object):
    DONE: typing.ClassVar[int] = ...
    breakIterator: BreakIterator = ...
    matchLength: int = ...
    targetText: java.text.CharacterIterator = ...
    def __init__(self, target: java.text.CharacterIterator, breaker: BreakIterator, /) -> None: ...
    def first(self) -> int: ...
    def following(self, position: int | java.jint | java.lang.Integer, /) -> int: ...
    def getBreakIterator(self) -> BreakIterator: ...
    def getElementComparisonType(self) -> SearchIterator.ElementComparisonType: ...
    def getIndex(self) -> int: ...
    def getMatchLength(self) -> int: ...
    def getMatchStart(self) -> int: ...
    def getMatchedText(self) -> str | None: ...
    def getTarget(self) -> java.text.CharacterIterator: ...
    def handleNext(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def handlePrevious(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def isOverlapping(self) -> bool: ...
    def last(self) -> int: ...
    def next(self) -> int: ...
    def preceding(self, position: int | java.jint | java.lang.Integer, /) -> int: ...
    def previous(self) -> int: ...
    def reset(self) -> None: ...
    def setBreakIterator(self, breakiter: BreakIterator, /) -> None: ...
    def setElementComparisonType(self, type: SearchIterator.ElementComparisonType, /) -> None: ...
    def setIndex(self, position: int | java.jint | java.lang.Integer, /) -> None: ...
    def setMatchLength(self, length: int | java.jint | java.lang.Integer, /) -> None: ...
    def setOverlapping(self, allowOverlap: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setTarget(self, text: java.text.CharacterIterator, /) -> None: ...

    class ElementComparisonType(java.lang.Enum[SearchIterator.ElementComparisonType]):
        STANDARD_ELEMENT_COMPARISON: typing.ClassVar[SearchIterator.ElementComparisonType] = ...
        PATTERN_BASE_WEIGHT_IS_WILDCARD: typing.ClassVar[SearchIterator.ElementComparisonType] = ...
        ANY_BASE_WEIGHT_IS_WILDCARD: typing.ClassVar[SearchIterator.ElementComparisonType] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> SearchIterator.ElementComparisonType: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[SearchIterator.ElementComparisonType]: ...

class SelectFormat(java.text.Format):
    def __init__(self, pattern: str | java.lang.String, /) -> None: ...
    def applyPattern(self, pattern: str | java.lang.String, /) -> None: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def format(self, keyword: str | java.lang.String, /) -> str: ...
    @typing.overload
    def format(self, keyword: java.lang.Object | int | bool | float | str, toAppendTo: java.lang.StringBuffer, pos: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    def hashCode(self) -> int: ...
    def parseObject(self, source: str | java.lang.String, pos: java.text.ParsePosition, /) -> java.lang.Object: ...
    def toPattern(self) -> str: ...
    def toString(self) -> str: ...

class SimpleDateFormat(DateFormat):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, formatData: DateFormatSymbols, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, loc: android.icu.util.ULocale, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, loc: java.util.Locale, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, override: str | java.lang.String, loc: android.icu.util.ULocale, /) -> None: ...
    def applyLocalizedPattern(self, pat: str | java.lang.String, /) -> None: ...
    def applyPattern(self, pat: str | java.lang.String, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def format(self, cal: android.icu.util.Calendar, toAppendTo: java.lang.StringBuffer, pos: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    def formatToCharacterIterator(self, obj: java.lang.Object | int | bool | float | str, /) -> java.text.AttributedCharacterIterator: ...
    def get2DigitYearStart(self) -> java.util.Date: ...
    def getDateFormatSymbols(self) -> DateFormatSymbols: ...
    def getNumberFormat(self, field: str | java.jchar | java.lang.Character, /) -> NumberFormat: ...
    def getSymbols(self) -> DateFormatSymbols: ...
    def getTimeZoneFormat(self) -> TimeZoneFormat: ...
    def hashCode(self) -> int: ...
    def matchQuarterString(self, text: str | java.lang.String, start: int | java.jint | java.lang.Integer, field: int | java.jint | java.lang.Integer, data: java.chaquopy.JavaArray[java.lang.String], cal: android.icu.util.Calendar, /) -> int: ...
    def matchString(self, text: str | java.lang.String, start: int | java.jint | java.lang.Integer, field: int | java.jint | java.lang.Integer, data: java.chaquopy.JavaArray[java.lang.String], cal: android.icu.util.Calendar, /) -> int: ...
    def parse(self, text: str | java.lang.String, cal: android.icu.util.Calendar, parsePos: java.text.ParsePosition, /) -> None: ...
    def patternCharToDateFormatField(self, ch: str | java.jchar | java.lang.Character, /) -> DateFormat.Field: ...
    def set2DigitYearStart(self, startDate: java.util.Date, /) -> None: ...
    def setContext(self, context: DisplayContext, /) -> None: ...
    def setDateFormatSymbols(self, newFormatSymbols: DateFormatSymbols, /) -> None: ...
    @typing.overload
    def setNumberFormat(self, newNumberFormat: NumberFormat, /) -> None: ...
    @typing.overload
    def setNumberFormat(self, fields: str | java.lang.String, overrideNF: NumberFormat, /) -> None: ...
    def setTimeZoneFormat(self, tzfmt: TimeZoneFormat, /) -> None: ...
    def subFormat(self, ch: str | java.jchar | java.lang.Character, count: int | java.jint | java.lang.Integer, beginOffset: int | java.jint | java.lang.Integer, pos: java.text.FieldPosition, fmtData: DateFormatSymbols, cal: android.icu.util.Calendar, /) -> str: ...
    def subParse(self, text: str | java.lang.String, start: int | java.jint | java.lang.Integer, ch: str | java.jchar | java.lang.Character, count: int | java.jint | java.lang.Integer, obeyCount: bool | java.jboolean | java.lang.Boolean, allowNegative: bool | java.jboolean | java.lang.Boolean, ambiguousYear: java.chaquopy.JavaArrayJBoolean, cal: android.icu.util.Calendar, /) -> int: ...
    def toLocalizedPattern(self) -> str: ...
    def toPattern(self) -> str: ...
    def zeroPaddingNumber(self, value: int | java.jlong | java.lang.Long, minDigits: int | java.jint | java.lang.Integer, maxDigits: int | java.jint | java.lang.Integer, /) -> str: ...

class StringPrepParseException(java.text.ParseException):
    ACE_PREFIX_ERROR: typing.ClassVar[int] = ...
    BUFFER_OVERFLOW_ERROR: typing.ClassVar[int] = ...
    CHECK_BIDI_ERROR: typing.ClassVar[int] = ...
    DOMAIN_NAME_TOO_LONG_ERROR: typing.ClassVar[int] = ...
    ILLEGAL_CHAR_FOUND: typing.ClassVar[int] = ...
    INVALID_CHAR_FOUND: typing.ClassVar[int] = ...
    LABEL_TOO_LONG_ERROR: typing.ClassVar[int] = ...
    PROHIBITED_ERROR: typing.ClassVar[int] = ...
    STD3_ASCII_RULES_ERROR: typing.ClassVar[int] = ...
    UNASSIGNED_ERROR: typing.ClassVar[int] = ...
    VERIFICATION_ERROR: typing.ClassVar[int] = ...
    ZERO_LENGTH_LABEL: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, error: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, error: int | java.jint | java.lang.Integer, rules: str | java.lang.String, pos: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, error: int | java.jint | java.lang.Integer, rules: str | java.lang.String, pos: int | java.jint | java.lang.Integer, lineNumber: int | java.jint | java.lang.Integer, /) -> None: ...
    def equals(self, other: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getError(self) -> int: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class StringSearch(SearchIterator):
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, target: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, target: java.text.CharacterIterator, collator: RuleBasedCollator, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, target: java.text.CharacterIterator, locale: android.icu.util.ULocale, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, target: java.text.CharacterIterator, locale: java.util.Locale, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, target: java.text.CharacterIterator, collator: RuleBasedCollator, breakiter: BreakIterator, /) -> None: ...
    def getCollator(self) -> RuleBasedCollator: ...
    def getIndex(self) -> int: ...
    def getPattern(self) -> str: ...
    def handleNext(self, position: int | java.jint | java.lang.Integer, /) -> int: ...
    def handlePrevious(self, position: int | java.jint | java.lang.Integer, /) -> int: ...
    def isCanonical(self) -> bool: ...
    def reset(self) -> None: ...
    def setCanonical(self, allowCanonical: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setCollator(self, collator: RuleBasedCollator, /) -> None: ...
    def setIndex(self, position: int | java.jint | java.lang.Integer, /) -> None: ...
    def setPattern(self, pattern: str | java.lang.String, /) -> None: ...
    def setTarget(self, text: java.text.CharacterIterator, /) -> None: ...

class SymbolTable(java.lang.Object):
    SYMBOL_REF: typing.ClassVar[str] = ...
    def lookup(self, arg1: str | java.lang.String, /) -> java.chaquopy.JavaArrayJChar | None: ...
    def lookupMatcher(self, arg1: int | java.jint | java.lang.Integer, /) -> UnicodeMatcher | None: ...
    def parseReference(self, arg1: str | java.lang.String, arg2: java.text.ParsePosition, arg3: int | java.jint | java.lang.Integer, /) -> str | None: ...

class TimeZoneFormat(UFormat, android.icu.util.Freezable[TimeZoneFormat], java.io.Serializable):
    def __init__(self, locale: android.icu.util.ULocale, /) -> None: ...
    def cloneAsThawed(self) -> TimeZoneFormat: ...
    @typing.overload
    def format(self, style: TimeZoneFormat.Style, tz: android.icu.util.TimeZone, date: int | java.jlong | java.lang.Long, /) -> str: ...
    @typing.overload
    def format(self, obj: java.lang.Object | int | bool | float | str, toAppendTo: java.lang.StringBuffer, pos: java.text.FieldPosition, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def format(self, style: TimeZoneFormat.Style, tz: android.icu.util.TimeZone, date: int | java.jlong | java.lang.Long, timeType: android.icu.util.Output[TimeZoneFormat.TimeType], /) -> str: ...
    def formatOffsetISO8601Basic(self, offset: int | java.jint | java.lang.Integer, useUtcIndicator: bool | java.jboolean | java.lang.Boolean, isShort: bool | java.jboolean | java.lang.Boolean, ignoreSeconds: bool | java.jboolean | java.lang.Boolean, /) -> str: ...
    def formatOffsetISO8601Extended(self, offset: int | java.jint | java.lang.Integer, useUtcIndicator: bool | java.jboolean | java.lang.Boolean, isShort: bool | java.jboolean | java.lang.Boolean, ignoreSeconds: bool | java.jboolean | java.lang.Boolean, /) -> str: ...
    def formatOffsetLocalizedGMT(self, offset: int | java.jint | java.lang.Integer, /) -> str: ...
    def formatOffsetShortLocalizedGMT(self, offset: int | java.jint | java.lang.Integer, /) -> str: ...
    def formatToCharacterIterator(self, obj: java.lang.Object | int | bool | float | str, /) -> java.text.AttributedCharacterIterator: ...
    def freeze(self) -> TimeZoneFormat: ...
    def getDefaultParseOptions(self) -> java.util.EnumSet[TimeZoneFormat.ParseOption]: ...
    def getGMTOffsetDigits(self) -> str: ...
    def getGMTOffsetPattern(self, type: TimeZoneFormat.GMTOffsetPatternType, /) -> str: ...
    def getGMTPattern(self) -> str: ...
    def getGMTZeroFormat(self) -> str: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, /) -> TimeZoneFormat: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, /) -> TimeZoneFormat: ...
    def getTimeZoneNames(self) -> TimeZoneNames: ...
    def isFrozen(self) -> bool: ...
    @typing.overload
    def parse(self, text: str | java.lang.String, /) -> android.icu.util.TimeZone | None: ...
    @typing.overload
    def parse(self, text: str | java.lang.String, pos: java.text.ParsePosition, /) -> android.icu.util.TimeZone | None: ...
    @typing.overload
    def parse(self, style: TimeZoneFormat.Style, text: str | java.lang.String, pos: java.text.ParsePosition, timeType: android.icu.util.Output[TimeZoneFormat.TimeType], /) -> android.icu.util.TimeZone | None: ...
    @typing.overload
    def parse(self, style: TimeZoneFormat.Style, text: str | java.lang.String, pos: java.text.ParsePosition, options: java.util.EnumSet[TimeZoneFormat.ParseOption], timeType: android.icu.util.Output[TimeZoneFormat.TimeType], /) -> android.icu.util.TimeZone | None: ...
    def parseObject(self, source: str | java.lang.String, pos: java.text.ParsePosition, /) -> java.lang.Object: ...
    def parseOffsetISO8601(self, text: str | java.lang.String, pos: java.text.ParsePosition, /) -> int: ...
    def parseOffsetLocalizedGMT(self, text: str | java.lang.String, pos: java.text.ParsePosition, /) -> int: ...
    def parseOffsetShortLocalizedGMT(self, text: str | java.lang.String, pos: java.text.ParsePosition, /) -> int: ...
    def setDefaultParseOptions(self, options: java.util.EnumSet[TimeZoneFormat.ParseOption], /) -> TimeZoneFormat: ...
    def setGMTOffsetDigits(self, digits: str | java.lang.String, /) -> TimeZoneFormat: ...
    def setGMTOffsetPattern(self, type: TimeZoneFormat.GMTOffsetPatternType, pattern: str | java.lang.String, /) -> TimeZoneFormat: ...
    def setGMTPattern(self, pattern: str | java.lang.String, /) -> TimeZoneFormat: ...
    def setGMTZeroFormat(self, gmtZeroFormat: str | java.lang.String, /) -> TimeZoneFormat: ...
    def setTimeZoneNames(self, tznames: TimeZoneNames, /) -> TimeZoneFormat: ...

    class TimeType(java.lang.Enum[TimeZoneFormat.TimeType]):
        UNKNOWN: typing.ClassVar[TimeZoneFormat.TimeType] = ...
        STANDARD: typing.ClassVar[TimeZoneFormat.TimeType] = ...
        DAYLIGHT: typing.ClassVar[TimeZoneFormat.TimeType] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> TimeZoneFormat.TimeType: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[TimeZoneFormat.TimeType]: ...

    class Style(java.lang.Enum[TimeZoneFormat.Style]):
        GENERIC_LOCATION: typing.ClassVar[TimeZoneFormat.Style] = ...
        GENERIC_LONG: typing.ClassVar[TimeZoneFormat.Style] = ...
        GENERIC_SHORT: typing.ClassVar[TimeZoneFormat.Style] = ...
        SPECIFIC_LONG: typing.ClassVar[TimeZoneFormat.Style] = ...
        SPECIFIC_SHORT: typing.ClassVar[TimeZoneFormat.Style] = ...
        LOCALIZED_GMT: typing.ClassVar[TimeZoneFormat.Style] = ...
        LOCALIZED_GMT_SHORT: typing.ClassVar[TimeZoneFormat.Style] = ...
        ISO_BASIC_SHORT: typing.ClassVar[TimeZoneFormat.Style] = ...
        ISO_BASIC_LOCAL_SHORT: typing.ClassVar[TimeZoneFormat.Style] = ...
        ISO_BASIC_FIXED: typing.ClassVar[TimeZoneFormat.Style] = ...
        ISO_BASIC_LOCAL_FIXED: typing.ClassVar[TimeZoneFormat.Style] = ...
        ISO_BASIC_FULL: typing.ClassVar[TimeZoneFormat.Style] = ...
        ISO_BASIC_LOCAL_FULL: typing.ClassVar[TimeZoneFormat.Style] = ...
        ISO_EXTENDED_FIXED: typing.ClassVar[TimeZoneFormat.Style] = ...
        ISO_EXTENDED_LOCAL_FIXED: typing.ClassVar[TimeZoneFormat.Style] = ...
        ISO_EXTENDED_FULL: typing.ClassVar[TimeZoneFormat.Style] = ...
        ISO_EXTENDED_LOCAL_FULL: typing.ClassVar[TimeZoneFormat.Style] = ...
        ZONE_ID: typing.ClassVar[TimeZoneFormat.Style] = ...
        ZONE_ID_SHORT: typing.ClassVar[TimeZoneFormat.Style] = ...
        EXEMPLAR_LOCATION: typing.ClassVar[TimeZoneFormat.Style] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> TimeZoneFormat.Style: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[TimeZoneFormat.Style]: ...

    class ParseOption(java.lang.Enum[TimeZoneFormat.ParseOption]):
        ALL_STYLES: typing.ClassVar[TimeZoneFormat.ParseOption] = ...
        TZ_DATABASE_ABBREVIATIONS: typing.ClassVar[TimeZoneFormat.ParseOption] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> TimeZoneFormat.ParseOption: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[TimeZoneFormat.ParseOption]: ...

    class GMTOffsetPatternType(java.lang.Enum[TimeZoneFormat.GMTOffsetPatternType]):
        POSITIVE_HM: typing.ClassVar[TimeZoneFormat.GMTOffsetPatternType] = ...
        POSITIVE_HMS: typing.ClassVar[TimeZoneFormat.GMTOffsetPatternType] = ...
        NEGATIVE_HM: typing.ClassVar[TimeZoneFormat.GMTOffsetPatternType] = ...
        NEGATIVE_HMS: typing.ClassVar[TimeZoneFormat.GMTOffsetPatternType] = ...
        POSITIVE_H: typing.ClassVar[TimeZoneFormat.GMTOffsetPatternType] = ...
        NEGATIVE_H: typing.ClassVar[TimeZoneFormat.GMTOffsetPatternType] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> TimeZoneFormat.GMTOffsetPatternType: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[TimeZoneFormat.GMTOffsetPatternType]: ...

class TimeZoneNames(java.io.Serializable):
    @typing.overload
    def getAvailableMetaZoneIDs(self) -> java.util.Set[java.lang.String]: ...
    @typing.overload
    def getAvailableMetaZoneIDs(self, arg1: str | java.lang.String, /) -> java.util.Set[java.lang.String]: ...
    def getDisplayName(self, tzID: str | java.lang.String, type: TimeZoneNames.NameType, date: int | java.jlong | java.lang.Long, /) -> str | None: ...
    def getExemplarLocationName(self, tzID: str | java.lang.String, /) -> str | None: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: android.icu.util.ULocale, /) -> TimeZoneNames: ...
    @typing.overload
    @staticmethod
    def getInstance(locale: java.util.Locale, /) -> TimeZoneNames: ...
    def getMetaZoneDisplayName(self, arg1: str | java.lang.String, arg2: TimeZoneNames.NameType, /) -> str | None: ...
    def getMetaZoneID(self, arg1: str | java.lang.String, arg2: int | java.jlong | java.lang.Long, /) -> str | None: ...
    def getReferenceZoneID(self, arg1: str | java.lang.String, arg2: str | java.lang.String, /) -> str | None: ...
    @staticmethod
    def getTZDBInstance(locale: android.icu.util.ULocale, /) -> TimeZoneNames: ...
    def getTimeZoneDisplayName(self, arg1: str | java.lang.String, arg2: TimeZoneNames.NameType, /) -> str | None: ...

    class NameType(java.lang.Enum[TimeZoneNames.NameType]):
        LONG_GENERIC: typing.ClassVar[TimeZoneNames.NameType] = ...
        LONG_STANDARD: typing.ClassVar[TimeZoneNames.NameType] = ...
        LONG_DAYLIGHT: typing.ClassVar[TimeZoneNames.NameType] = ...
        SHORT_GENERIC: typing.ClassVar[TimeZoneNames.NameType] = ...
        SHORT_STANDARD: typing.ClassVar[TimeZoneNames.NameType] = ...
        SHORT_DAYLIGHT: typing.ClassVar[TimeZoneNames.NameType] = ...
        EXEMPLAR_LOCATION: typing.ClassVar[TimeZoneNames.NameType] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> TimeZoneNames.NameType: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[TimeZoneNames.NameType]: ...

class Transliterator(java.lang.Object):
    FORWARD: typing.ClassVar[int] = ...
    REVERSE: typing.ClassVar[int] = ...
    @staticmethod
    def createFromRules(ID: str | java.lang.String, rules: str | java.lang.String, dir: int | java.jint | java.lang.Integer, /) -> Transliterator: ...
    def filteredTransliterate(self, text: Replaceable, index: Transliterator.Position, incremental: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def finishTransliteration(self, text: Replaceable, index: Transliterator.Position, /) -> None: ...
    @staticmethod
    def getAvailableIDs() -> java.util.Enumeration[java.lang.String]: ...
    @staticmethod
    def getAvailableSources() -> java.util.Enumeration[java.lang.String]: ...
    @staticmethod
    def getAvailableTargets(source: str | java.lang.String, /) -> java.util.Enumeration[java.lang.String]: ...
    @staticmethod
    def getAvailableVariants(source: str | java.lang.String, target: str | java.lang.String, /) -> java.util.Enumeration[java.lang.String]: ...
    @typing.overload
    @staticmethod
    def getDisplayName(ID: str | java.lang.String, /) -> str: ...
    @typing.overload
    @staticmethod
    def getDisplayName(id: str | java.lang.String, inLocale: android.icu.util.ULocale, /) -> str: ...
    @typing.overload
    @staticmethod
    def getDisplayName(id: str | java.lang.String, inLocale: java.util.Locale, /) -> str: ...
    def getElements(self) -> java.chaquopy.JavaArray[Transliterator]: ...
    def getFilter(self) -> UnicodeFilter: ...
    def getID(self) -> str: ...
    @typing.overload
    @staticmethod
    def getInstance(ID: str | java.lang.String, /) -> Transliterator: ...
    @typing.overload
    @staticmethod
    def getInstance(ID: str | java.lang.String, dir: int | java.jint | java.lang.Integer, /) -> Transliterator: ...
    def getInverse(self) -> Transliterator: ...
    def getMaximumContextLength(self) -> int: ...
    def getSourceSet(self) -> UnicodeSet: ...
    def getTargetSet(self) -> UnicodeSet: ...
    def setFilter(self, filter: UnicodeFilter, /) -> None: ...
    def toRules(self, escapeUnprintable: bool | java.jboolean | java.lang.Boolean, /) -> str: ...
    @typing.overload
    def transliterate(self, text: Replaceable, /) -> None: ...
    @typing.overload
    def transliterate(self, text: str | java.lang.String, /) -> str: ...
    @typing.overload
    def transliterate(self, text: Replaceable, index: Transliterator.Position, /) -> None: ...
    @typing.overload
    def transliterate(self, text: Replaceable, start: int | java.jint | java.lang.Integer, limit: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def transliterate(self, text: Replaceable, index: Transliterator.Position, insertion: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def transliterate(self, text: Replaceable, index: Transliterator.Position, insertion: str | java.lang.String, /) -> None: ...

    class Position(java.lang.Object):
        contextLimit: int = ...
        contextStart: int = ...
        limit: int = ...
        start: int = ...
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, pos: Transliterator.Position, /) -> None: ...
        @typing.overload
        def __init__(self, contextStart: int | java.jint | java.lang.Integer, contextLimit: int | java.jint | java.lang.Integer, start: int | java.jint | java.lang.Integer, /) -> None: ...
        @typing.overload
        def __init__(self, contextStart: int | java.jint | java.lang.Integer, contextLimit: int | java.jint | java.lang.Integer, start: int | java.jint | java.lang.Integer, limit: int | java.jint | java.lang.Integer, /) -> None: ...
        def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
        def hashCode(self) -> int: ...
        def set(self, pos: Transliterator.Position, /) -> None: ...
        def toString(self) -> str: ...
        def validate(self, length: int | java.jint | java.lang.Integer, /) -> None: ...

class UCharacterIterator(java.lang.Cloneable):
    DONE: typing.ClassVar[int] = ...
    def __init__(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def current(self) -> int: ...
    def currentCodePoint(self) -> int: ...
    def getCharacterIterator(self) -> java.text.CharacterIterator: ...
    def getIndex(self) -> int: ...
    @typing.overload
    @staticmethod
    def getInstance(source: Replaceable, /) -> UCharacterIterator: ...
    @typing.overload
    @staticmethod
    def getInstance(source: str | java.lang.String, /) -> UCharacterIterator: ...
    @typing.overload
    @staticmethod
    def getInstance(source: java.lang.StringBuffer, /) -> UCharacterIterator: ...
    @typing.overload
    @staticmethod
    def getInstance(source: java.text.CharacterIterator, /) -> UCharacterIterator: ...
    @typing.overload
    @staticmethod
    def getInstance(source: java.chaquopy.JavaArrayJChar, /) -> UCharacterIterator: ...
    @typing.overload
    @staticmethod
    def getInstance(source: java.chaquopy.JavaArrayJChar, start: int | java.jint | java.lang.Integer, limit: int | java.jint | java.lang.Integer, /) -> UCharacterIterator: ...
    def getLength(self) -> int: ...
    @typing.overload
    def getText(self) -> str: ...
    @typing.overload
    def getText(self, fillIn: java.chaquopy.JavaArrayJChar, /) -> int: ...
    @typing.overload
    def getText(self, arg1: java.chaquopy.JavaArrayJChar, arg2: int | java.jint | java.lang.Integer, /) -> int: ...
    def moveCodePointIndex(self, delta: int | java.jint | java.lang.Integer, /) -> int: ...
    def moveIndex(self, delta: int | java.jint | java.lang.Integer, /) -> int: ...
    def next(self) -> int: ...
    def nextCodePoint(self) -> int: ...
    def previous(self) -> int: ...
    def previousCodePoint(self) -> int: ...
    def setIndex(self, arg1: int | java.jint | java.lang.Integer, /) -> None: ...
    def setToLimit(self) -> None: ...
    def setToStart(self) -> None: ...

class UFormat(java.text.Format):
    def __init__(self) -> None: ...

class UnicodeFilter(UnicodeMatcher):
    def contains(self, arg1: int | java.jint | java.lang.Integer, /) -> bool: ...
    def matches(self, text: Replaceable, offset: java.chaquopy.JavaArrayJInt, limit: int | java.jint | java.lang.Integer, incremental: bool | java.jboolean | java.lang.Boolean, /) -> int: ...

class UnicodeMatcher(java.lang.Object):
    ETHER: typing.ClassVar[str] = ...
    U_MATCH: typing.ClassVar[int] = ...
    U_MISMATCH: typing.ClassVar[int] = ...
    U_PARTIAL_MATCH: typing.ClassVar[int] = ...
    def addMatchSetTo(self, arg1: UnicodeSet, /) -> None: ...
    def matches(self, arg1: Replaceable, arg2: java.chaquopy.JavaArrayJInt, arg3: int | java.jint | java.lang.Integer, arg4: bool | java.jboolean | java.lang.Boolean, /) -> int: ...
    def matchesIndexValue(self, arg1: int | java.jint | java.lang.Integer, /) -> bool: ...
    def toPattern(self, arg1: bool | java.jboolean | java.lang.Boolean, /) -> str: ...

class UnicodeSet(UnicodeFilter, java.lang.Iterable[java.lang.String], java.lang.Comparable[UnicodeSet], android.icu.util.Freezable[UnicodeSet]):
    ADD_CASE_MAPPINGS: typing.ClassVar[int] = ...
    ALL_CODE_POINTS: typing.ClassVar[UnicodeSet] = ...
    CASE: typing.ClassVar[int] = ...
    CASE_INSENSITIVE: typing.ClassVar[int] = ...
    EMPTY: typing.ClassVar[UnicodeSet] = ...
    IGNORE_SPACE: typing.ClassVar[int] = ...
    MAX_VALUE: typing.ClassVar[int] = ...
    MIN_VALUE: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, other: UnicodeSet, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, *pairs: java.chaquopy.JavaArrayJInt) -> None: ...
    @typing.overload
    def __init__(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, options: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, ignoreWhitespace: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, pos: java.text.ParsePosition, symbols: SymbolTable, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, pos: java.text.ParsePosition, symbols: SymbolTable, options: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def _generatePattern(self, result: java.lang.StringBuffer, escapeUnprintable: bool | java.jboolean | java.lang.Boolean, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def _generatePattern(self, result: java.lang.StringBuffer, escapeUnprintable: bool | java.jboolean | java.lang.Boolean, includeStrings: bool | java.jboolean | java.lang.Boolean, /) -> java.lang.StringBuffer: ...
    @typing.overload
    def add(self, c: int | java.jint | java.lang.Integer, /) -> UnicodeSet: ...
    @typing.overload
    def add(self, s: java.lang.CharSequence, /) -> UnicodeSet: ...
    @typing.overload
    def add(self, source: java.lang.Iterable[java.lang.Object], /) -> UnicodeSet: ...
    @typing.overload
    def add(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> UnicodeSet: ...
    @typing.overload
    def addAll(self, c: UnicodeSet, /) -> UnicodeSet: ...
    @typing.overload
    def addAll(self, s: java.lang.CharSequence, /) -> UnicodeSet: ...
    @typing.overload
    def addAll(self, source: java.lang.Iterable[java.lang.Object], /) -> UnicodeSet: ...
    @typing.overload
    def addAll(self, *collection: java.lang.Object) -> UnicodeSet: ...
    @typing.overload
    def addAll(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> UnicodeSet: ...
    _addAllTo__T = typing.TypeVar('_addAllTo__T')  # <T>
    def addAllTo(self, target: _addAllTo__T, /) -> _addAllTo__T: ...
    def addMatchSetTo(self, toUnionTo: UnicodeSet, /) -> None: ...
    def applyIntPropertyValue(self, prop: int | java.jint | java.lang.Integer, value: int | java.jint | java.lang.Integer, /) -> UnicodeSet: ...
    @typing.overload
    def applyPattern(self, pattern: str | java.lang.String, /) -> UnicodeSet: ...
    @typing.overload
    def applyPattern(self, pattern: str | java.lang.String, options: int | java.jint | java.lang.Integer, /) -> UnicodeSet: ...
    @typing.overload
    def applyPattern(self, pattern: str | java.lang.String, ignoreWhitespace: bool | java.jboolean | java.lang.Boolean, /) -> UnicodeSet: ...
    @typing.overload
    def applyPropertyAlias(self, propertyAlias: str | java.lang.String, valueAlias: str | java.lang.String, /) -> UnicodeSet: ...
    @typing.overload
    def applyPropertyAlias(self, propertyAlias: str | java.lang.String, valueAlias: str | java.lang.String, symbols: SymbolTable, /) -> UnicodeSet: ...
    def charAt(self, index: int | java.jint | java.lang.Integer, /) -> int: ...
    def clear(self) -> UnicodeSet: ...
    def clone(self) -> java.lang.Object: ...
    def cloneAsThawed(self) -> UnicodeSet: ...
    def closeOver(self, attribute: int | java.jint | java.lang.Integer, /) -> UnicodeSet: ...
    def compact(self) -> UnicodeSet: ...
    @typing.overload
    def compareTo(self, o: UnicodeSet, /) -> int: ...
    @typing.overload
    def compareTo(self, other: java.lang.Iterable[java.lang.String], /) -> int: ...
    @typing.overload
    def compareTo(self, o: UnicodeSet, style: UnicodeSet.ComparisonStyle, /) -> int: ...
    @typing.overload
    def complement(self) -> UnicodeSet: ...
    @typing.overload
    def complement(self, c: int | java.jint | java.lang.Integer, /) -> UnicodeSet: ...
    @typing.overload
    def complement(self, s: java.lang.CharSequence, /) -> UnicodeSet: ...
    @typing.overload
    def complement(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> UnicodeSet: ...
    @typing.overload
    def complementAll(self, c: UnicodeSet, /) -> UnicodeSet: ...
    @typing.overload
    def complementAll(self, s: java.lang.CharSequence, /) -> UnicodeSet: ...
    @typing.overload
    def contains(self, c: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    def contains(self, s: java.lang.CharSequence, /) -> bool: ...
    @typing.overload
    def contains(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    def containsAll(self, b: UnicodeSet, /) -> bool: ...
    @typing.overload
    def containsAll(self, collection: java.lang.Iterable[java.lang.Object], /) -> bool: ...
    @typing.overload
    def containsAll(self, s: str | java.lang.String, /) -> bool: ...
    @typing.overload
    def containsNone(self, b: UnicodeSet, /) -> bool: ...
    @typing.overload
    def containsNone(self, s: java.lang.CharSequence, /) -> bool: ...
    @typing.overload
    def containsNone(self, collection: java.lang.Iterable[java.lang.Object], /) -> bool: ...
    @typing.overload
    def containsNone(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    def containsSome(self, s: UnicodeSet, /) -> bool: ...
    @typing.overload
    def containsSome(self, s: java.lang.CharSequence, /) -> bool: ...
    @typing.overload
    def containsSome(self, collection: java.lang.Iterable[java.lang.Object], /) -> bool: ...
    @typing.overload
    def containsSome(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> bool: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def freeze(self) -> UnicodeSet: ...
    @staticmethod
    def fromAll(s: java.lang.CharSequence, /) -> UnicodeSet: ...
    @staticmethod
    def from_(s: java.lang.CharSequence, /) -> UnicodeSet: ...
    def getRangeCount(self) -> int: ...
    def getRangeEnd(self, index: int | java.jint | java.lang.Integer, /) -> int: ...
    def getRangeStart(self, index: int | java.jint | java.lang.Integer, /) -> int: ...
    def hasStrings(self) -> bool: ...
    def hashCode(self) -> int: ...
    def indexOf(self, c: int | java.jint | java.lang.Integer, /) -> int: ...
    def isEmpty(self) -> bool: ...
    def isFrozen(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[java.lang.String]: ...
    def matches(self, text: Replaceable, offset: java.chaquopy.JavaArrayJInt, limit: int | java.jint | java.lang.Integer, incremental: bool | java.jboolean | java.lang.Boolean, /) -> int: ...
    def matchesIndexValue(self, v: int | java.jint | java.lang.Integer, /) -> bool: ...
    def ranges(self) -> java.lang.Iterable[UnicodeSet.EntryRange]: ...
    @typing.overload
    def remove(self, c: int | java.jint | java.lang.Integer, /) -> UnicodeSet: ...
    @typing.overload
    def remove(self, s: java.lang.CharSequence, /) -> UnicodeSet: ...
    @typing.overload
    def remove(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> UnicodeSet: ...
    @typing.overload
    def removeAll(self, c: UnicodeSet, /) -> UnicodeSet: ...
    @typing.overload
    def removeAll(self, s: java.lang.CharSequence, /) -> UnicodeSet: ...
    @typing.overload
    def removeAll(self, collection: java.lang.Iterable[java.lang.Object], /) -> UnicodeSet: ...
    def removeAllStrings(self) -> UnicodeSet: ...
    @typing.overload
    def retain(self, c: int | java.jint | java.lang.Integer, /) -> UnicodeSet: ...
    @typing.overload
    def retain(self, cs: java.lang.CharSequence, /) -> UnicodeSet: ...
    @typing.overload
    def retain(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> UnicodeSet: ...
    @typing.overload
    def retainAll(self, c: UnicodeSet, /) -> UnicodeSet: ...
    @typing.overload
    def retainAll(self, s: java.lang.CharSequence, /) -> UnicodeSet: ...
    @typing.overload
    def retainAll(self, collection: java.lang.Iterable[java.lang.Object], /) -> UnicodeSet: ...
    @typing.overload
    def set(self, other: UnicodeSet, /) -> UnicodeSet: ...
    @typing.overload
    def set(self, start: int | java.jint | java.lang.Integer, end: int | java.jint | java.lang.Integer, /) -> UnicodeSet: ...
    def size(self) -> int: ...
    @typing.overload
    def span(self, s: java.lang.CharSequence, spanCondition: UnicodeSet.SpanCondition, /) -> int: ...
    @typing.overload
    def span(self, s: java.lang.CharSequence, start: int | java.jint | java.lang.Integer, spanCondition: UnicodeSet.SpanCondition, /) -> int: ...
    @typing.overload
    def spanBack(self, s: java.lang.CharSequence, spanCondition: UnicodeSet.SpanCondition, /) -> int: ...
    @typing.overload
    def spanBack(self, s: java.lang.CharSequence, fromIndex: int | java.jint | java.lang.Integer, spanCondition: UnicodeSet.SpanCondition, /) -> int: ...
    def strings(self) -> java.util.Collection[java.lang.String]: ...
    def toPattern(self, escapeUnprintable: bool | java.jboolean | java.lang.Boolean, /) -> str: ...
    def toString(self) -> str: ...

    class SpanCondition(java.lang.Enum[UnicodeSet.SpanCondition]):
        NOT_CONTAINED: typing.ClassVar[UnicodeSet.SpanCondition] = ...
        CONTAINED: typing.ClassVar[UnicodeSet.SpanCondition] = ...
        SIMPLE: typing.ClassVar[UnicodeSet.SpanCondition] = ...
        CONDITION_COUNT: typing.ClassVar[UnicodeSet.SpanCondition] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> UnicodeSet.SpanCondition: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[UnicodeSet.SpanCondition]: ...

    class EntryRange(java.lang.Object):
        codepoint: int = ...
        codepointEnd: int = ...
        def toString(self) -> str: ...

    class ComparisonStyle(java.lang.Enum[UnicodeSet.ComparisonStyle]):
        SHORTER_FIRST: typing.ClassVar[UnicodeSet.ComparisonStyle] = ...
        LEXICOGRAPHIC: typing.ClassVar[UnicodeSet.ComparisonStyle] = ...
        LONGER_FIRST: typing.ClassVar[UnicodeSet.ComparisonStyle] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> UnicodeSet.ComparisonStyle: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[UnicodeSet.ComparisonStyle]: ...

class UnicodeSetIterator(java.lang.Object):
    IS_STRING: typing.ClassVar[int] = ...
    codepoint: int = ...
    codepointEnd: int = ...
    string: str = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, set: UnicodeSet, /) -> None: ...
    def getString(self) -> str: ...
    def next(self) -> bool: ...
    def nextRange(self) -> bool: ...
    @typing.overload
    def reset(self) -> None: ...
    @typing.overload
    def reset(self, uset: UnicodeSet, /) -> None: ...
    def skipToStrings(self) -> UnicodeSetIterator: ...

class UnicodeSetSpanner(java.lang.Object):
    def __init__(self, source: UnicodeSet, /) -> None: ...
    @typing.overload
    def countIn(self, sequence: java.lang.CharSequence, /) -> int: ...
    @typing.overload
    def countIn(self, sequence: java.lang.CharSequence, countMethod: UnicodeSetSpanner.CountMethod, /) -> int: ...
    @typing.overload
    def countIn(self, sequence: java.lang.CharSequence, countMethod: UnicodeSetSpanner.CountMethod, spanCondition: UnicodeSet.SpanCondition, /) -> int: ...
    @typing.overload
    def deleteFrom(self, sequence: java.lang.CharSequence, /) -> str: ...
    @typing.overload
    def deleteFrom(self, sequence: java.lang.CharSequence, spanCondition: UnicodeSet.SpanCondition, /) -> str: ...
    def equals(self, other: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getUnicodeSet(self) -> UnicodeSet: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def replaceFrom(self, sequence: java.lang.CharSequence, replacement: java.lang.CharSequence, /) -> str: ...
    @typing.overload
    def replaceFrom(self, sequence: java.lang.CharSequence, replacement: java.lang.CharSequence, countMethod: UnicodeSetSpanner.CountMethod, /) -> str: ...
    @typing.overload
    def replaceFrom(self, sequence: java.lang.CharSequence, replacement: java.lang.CharSequence, countMethod: UnicodeSetSpanner.CountMethod, spanCondition: UnicodeSet.SpanCondition, /) -> str: ...
    @typing.overload
    def trim(self, sequence: java.lang.CharSequence, /) -> java.lang.CharSequence: ...
    @typing.overload
    def trim(self, sequence: java.lang.CharSequence, trimOption: UnicodeSetSpanner.TrimOption, /) -> java.lang.CharSequence: ...
    @typing.overload
    def trim(self, sequence: java.lang.CharSequence, trimOption: UnicodeSetSpanner.TrimOption, spanCondition: UnicodeSet.SpanCondition, /) -> java.lang.CharSequence: ...

    class TrimOption(java.lang.Enum[UnicodeSetSpanner.TrimOption]):
        LEADING: typing.ClassVar[UnicodeSetSpanner.TrimOption] = ...
        BOTH: typing.ClassVar[UnicodeSetSpanner.TrimOption] = ...
        TRAILING: typing.ClassVar[UnicodeSetSpanner.TrimOption] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> UnicodeSetSpanner.TrimOption: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[UnicodeSetSpanner.TrimOption]: ...

    class CountMethod(java.lang.Enum[UnicodeSetSpanner.CountMethod]):
        WHOLE_SPAN: typing.ClassVar[UnicodeSetSpanner.CountMethod] = ...
        MIN_ELEMENTS: typing.ClassVar[UnicodeSetSpanner.CountMethod] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> UnicodeSetSpanner.CountMethod: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[UnicodeSetSpanner.CountMethod]: ...
