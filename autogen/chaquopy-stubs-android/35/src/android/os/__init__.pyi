import android
import android.content
import android.icu.util
import android.media
import android.os.strictmode
import android.util
import java
import java.chaquopy
import java.io
import java.lang
import java.net
import java.nio
import java.time
import java.util
import java.util.concurrent
import java.util.function
import typing



_AsyncTask__Params = typing.TypeVar('_AsyncTask__Params')  # <Params>
_AsyncTask__Progress = typing.TypeVar('_AsyncTask__Progress')  # <Progress>
_AsyncTask__Result = typing.TypeVar('_AsyncTask__Result')  # <Result>
class AsyncTask(java.lang.Object, typing.Generic[_AsyncTask__Params, _AsyncTask__Progress, _AsyncTask__Result]):
    SERIAL_EXECUTOR: typing.ClassVar[java.util.concurrent.Executor] = ...
    THREAD_POOL_EXECUTOR: typing.ClassVar[java.util.concurrent.Executor] = ...
    def __init__(self) -> None: ...
    def cancel(self, mayInterruptIfRunning: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def doInBackground(self, *arg1: _AsyncTask__Params) -> _AsyncTask__Result: ...
    @typing.overload
    @staticmethod
    def execute(runnable: java.lang.Runnable, /) -> None: ...
    @typing.overload
    def execute(self, *params: _AsyncTask__Params) -> AsyncTask[_AsyncTask__Params, _AsyncTask__Progress, _AsyncTask__Result]: ...
    def executeOnExecutor(self, exec_: java.util.concurrent.Executor, /, *params: _AsyncTask__Params) -> AsyncTask[_AsyncTask__Params, _AsyncTask__Progress, _AsyncTask__Result]: ...
    @typing.overload
    def get(self) -> _AsyncTask__Result: ...
    @typing.overload
    def get(self, timeout: int | java.jlong | java.lang.Long, unit: java.util.concurrent.TimeUnit, /) -> _AsyncTask__Result: ...
    def getStatus(self) -> AsyncTask.Status: ...
    def isCancelled(self) -> bool: ...
    @typing.overload
    def onCancelled(self) -> None: ...
    @typing.overload
    def onCancelled(self, result: _AsyncTask__Result, /) -> None: ...
    def onPostExecute(self, result: _AsyncTask__Result, /) -> None: ...
    def onPreExecute(self) -> None: ...
    def onProgressUpdate(self, *values: _AsyncTask__Progress) -> None: ...
    def publishProgress(self, *values: _AsyncTask__Progress) -> None: ...

    class Status(java.lang.Enum[AsyncTask.Status]):
        PENDING: typing.ClassVar[AsyncTask.Status] = ...
        RUNNING: typing.ClassVar[AsyncTask.Status] = ...
        FINISHED: typing.ClassVar[AsyncTask.Status] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> AsyncTask.Status: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[AsyncTask.Status]: ...

class BadParcelableException(android.util.AndroidRuntimeException):
    @typing.overload
    def __init__(self, cause: java.lang.Exception, /) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class BaseBundle(java.lang.Object):
    def clear(self) -> None: ...
    def containsKey(self, key: str | java.lang.String, /) -> bool: ...
    def get(self, key: str | java.lang.String, /) -> java.lang.Object | None: ...
    @typing.overload
    def getBoolean(self, key: str | java.lang.String, /) -> bool: ...
    @typing.overload
    def getBoolean(self, key: str | java.lang.String, defaultValue: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def getBooleanArray(self, key: str | java.lang.String, /) -> java.chaquopy.JavaArrayJBoolean | None: ...
    @typing.overload
    def getDouble(self, key: str | java.lang.String, /) -> float: ...
    @typing.overload
    def getDouble(self, key: str | java.lang.String, defaultValue: float | java.jdouble | java.lang.Double, /) -> float: ...
    def getDoubleArray(self, key: str | java.lang.String, /) -> java.chaquopy.JavaArrayJDouble | None: ...
    @typing.overload
    def getInt(self, key: str | java.lang.String, /) -> int: ...
    @typing.overload
    def getInt(self, key: str | java.lang.String, defaultValue: int | java.jint | java.lang.Integer, /) -> int: ...
    def getIntArray(self, key: str | java.lang.String, /) -> java.chaquopy.JavaArrayJInt | None: ...
    @typing.overload
    def getLong(self, key: str | java.lang.String, /) -> int: ...
    @typing.overload
    def getLong(self, key: str | java.lang.String, defaultValue: int | java.jlong | java.lang.Long, /) -> int: ...
    def getLongArray(self, key: str | java.lang.String, /) -> java.chaquopy.JavaArrayJLong | None: ...
    @typing.overload
    def getString(self, key: str | java.lang.String, /) -> str | None: ...
    @typing.overload
    def getString(self, key: str | java.lang.String, defaultValue: str | java.lang.String, /) -> str | None: ...
    def getStringArray(self, key: str | java.lang.String, /) -> java.chaquopy.JavaArray[java.lang.String] | None: ...
    def isEmpty(self) -> bool: ...
    def keySet(self) -> java.util.Set[java.lang.String]: ...
    def putAll(self, bundle: PersistableBundle, /) -> None: ...
    def putBoolean(self, key: str | java.lang.String, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def putBooleanArray(self, key: str | java.lang.String, value: java.chaquopy.JavaArrayJBoolean, /) -> None: ...
    def putDouble(self, key: str | java.lang.String, value: float | java.jdouble | java.lang.Double, /) -> None: ...
    def putDoubleArray(self, key: str | java.lang.String, value: java.chaquopy.JavaArrayJDouble, /) -> None: ...
    def putInt(self, key: str | java.lang.String, value: int | java.jint | java.lang.Integer, /) -> None: ...
    def putIntArray(self, key: str | java.lang.String, value: java.chaquopy.JavaArrayJInt, /) -> None: ...
    def putLong(self, key: str | java.lang.String, value: int | java.jlong | java.lang.Long, /) -> None: ...
    def putLongArray(self, key: str | java.lang.String, value: java.chaquopy.JavaArrayJLong, /) -> None: ...
    def putString(self, key: str | java.lang.String, value: str | java.lang.String, /) -> None: ...
    def putStringArray(self, key: str | java.lang.String, value: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def remove(self, key: str | java.lang.String, /) -> None: ...
    def size(self) -> int: ...

class BatteryManager(java.lang.Object):
    ACTION_CHARGING: typing.ClassVar[str] = ...
    ACTION_DISCHARGING: typing.ClassVar[str] = ...
    BATTERY_HEALTH_COLD: typing.ClassVar[int] = ...
    BATTERY_HEALTH_DEAD: typing.ClassVar[int] = ...
    BATTERY_HEALTH_GOOD: typing.ClassVar[int] = ...
    BATTERY_HEALTH_OVERHEAT: typing.ClassVar[int] = ...
    BATTERY_HEALTH_OVER_VOLTAGE: typing.ClassVar[int] = ...
    BATTERY_HEALTH_UNKNOWN: typing.ClassVar[int] = ...
    BATTERY_HEALTH_UNSPECIFIED_FAILURE: typing.ClassVar[int] = ...
    BATTERY_PLUGGED_AC: typing.ClassVar[int] = ...
    BATTERY_PLUGGED_DOCK: typing.ClassVar[int] = ...
    BATTERY_PLUGGED_USB: typing.ClassVar[int] = ...
    BATTERY_PLUGGED_WIRELESS: typing.ClassVar[int] = ...
    BATTERY_PROPERTY_CAPACITY: typing.ClassVar[int] = ...
    BATTERY_PROPERTY_CHARGE_COUNTER: typing.ClassVar[int] = ...
    BATTERY_PROPERTY_CURRENT_AVERAGE: typing.ClassVar[int] = ...
    BATTERY_PROPERTY_CURRENT_NOW: typing.ClassVar[int] = ...
    BATTERY_PROPERTY_ENERGY_COUNTER: typing.ClassVar[int] = ...
    BATTERY_PROPERTY_STATUS: typing.ClassVar[int] = ...
    BATTERY_STATUS_CHARGING: typing.ClassVar[int] = ...
    BATTERY_STATUS_DISCHARGING: typing.ClassVar[int] = ...
    BATTERY_STATUS_FULL: typing.ClassVar[int] = ...
    BATTERY_STATUS_NOT_CHARGING: typing.ClassVar[int] = ...
    BATTERY_STATUS_UNKNOWN: typing.ClassVar[int] = ...
    EXTRA_BATTERY_LOW: typing.ClassVar[str] = ...
    EXTRA_CHARGING_STATUS: typing.ClassVar[str] = ...
    EXTRA_CYCLE_COUNT: typing.ClassVar[str] = ...
    EXTRA_HEALTH: typing.ClassVar[str] = ...
    EXTRA_ICON_SMALL: typing.ClassVar[str] = ...
    EXTRA_LEVEL: typing.ClassVar[str] = ...
    EXTRA_PLUGGED: typing.ClassVar[str] = ...
    EXTRA_PRESENT: typing.ClassVar[str] = ...
    EXTRA_SCALE: typing.ClassVar[str] = ...
    EXTRA_STATUS: typing.ClassVar[str] = ...
    EXTRA_TECHNOLOGY: typing.ClassVar[str] = ...
    EXTRA_TEMPERATURE: typing.ClassVar[str] = ...
    EXTRA_VOLTAGE: typing.ClassVar[str] = ...
    def computeChargeTimeRemaining(self) -> int: ...
    def getIntProperty(self, id: int | java.jint | java.lang.Integer, /) -> int: ...
    def getLongProperty(self, id: int | java.jint | java.lang.Integer, /) -> int: ...
    def getStringProperty(self, id: int | java.jint | java.lang.Integer, /) -> str | None: ...
    def isCharging(self) -> bool: ...

class Binder(IBinder):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, descriptor: str | java.lang.String, /) -> None: ...
    def attachInterface(self, owner: IInterface, descriptor: str | java.lang.String, /) -> None: ...
    @staticmethod
    def clearCallingIdentity() -> int: ...
    @staticmethod
    def clearCallingWorkSource() -> int: ...
    @typing.overload
    def dump(self, fd: java.io.FileDescriptor, args: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    @typing.overload
    def dump(self, fd: java.io.FileDescriptor, fout: java.io.PrintWriter, args: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def dumpAsync(self, fd: java.io.FileDescriptor, args: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    @staticmethod
    def flushPendingCommands() -> None: ...
    @staticmethod
    def getCallingPid() -> int: ...
    @staticmethod
    def getCallingUid() -> int: ...
    @staticmethod
    def getCallingUidOrThrow() -> int: ...
    @staticmethod
    def getCallingUserHandle() -> UserHandle: ...
    @staticmethod
    def getCallingWorkSourceUid() -> int: ...
    def getInterfaceDescriptor(self) -> str | None: ...
    def isBinderAlive(self) -> bool: ...
    @staticmethod
    def joinThreadPool() -> None: ...
    def linkToDeath(self, recipient: IBinder.DeathRecipient, flags: int | java.jint | java.lang.Integer, /) -> None: ...
    def onTransact(self, code: int | java.jint | java.lang.Integer, data: Parcel, reply: Parcel, flags: int | java.jint | java.lang.Integer, /) -> bool: ...
    def pingBinder(self) -> bool: ...
    def queryLocalInterface(self, descriptor: str | java.lang.String, /) -> IInterface | None: ...
    @staticmethod
    def restoreCallingIdentity(arg1: int | java.jlong | java.lang.Long, /) -> None: ...
    @staticmethod
    def restoreCallingWorkSource(arg1: int | java.jlong | java.lang.Long, /) -> None: ...
    @staticmethod
    def setCallingWorkSourceUid(arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def transact(self, code: int | java.jint | java.lang.Integer, data: Parcel, reply: Parcel, flags: int | java.jint | java.lang.Integer, /) -> bool: ...
    def unlinkToDeath(self, recipient: IBinder.DeathRecipient, flags: int | java.jint | java.lang.Integer, /) -> bool: ...

class BugreportManager(java.lang.Object):
    def cancelBugreport(self) -> None: ...
    def startConnectivityBugreport(self, bugreportFd: ParcelFileDescriptor, executor: java.util.concurrent.Executor, callback: BugreportManager.BugreportCallback, /) -> None: ...

    class BugreportCallback(java.lang.Object):
        BUGREPORT_ERROR_ANOTHER_REPORT_IN_PROGRESS: typing.ClassVar[int] = ...
        BUGREPORT_ERROR_INVALID_INPUT: typing.ClassVar[int] = ...
        BUGREPORT_ERROR_NO_BUGREPORT_TO_RETRIEVE: typing.ClassVar[int] = ...
        BUGREPORT_ERROR_RUNTIME: typing.ClassVar[int] = ...
        BUGREPORT_ERROR_USER_CONSENT_TIMED_OUT: typing.ClassVar[int] = ...
        BUGREPORT_ERROR_USER_DENIED_CONSENT: typing.ClassVar[int] = ...
        def __init__(self) -> None: ...
        def onEarlyReportFinished(self) -> None: ...
        def onError(self, errorCode: int | java.jint | java.lang.Integer, /) -> None: ...
        def onFinished(self) -> None: ...
        def onProgress(self, progress: float | java.jfloat | java.lang.Float, /) -> None: ...

class Build(java.lang.Object):
    BOARD: typing.ClassVar[str] = ...
    BOOTLOADER: typing.ClassVar[str] = ...
    BRAND: typing.ClassVar[str] = ...
    CPU_ABI: typing.ClassVar[str] = ...
    CPU_ABI2: typing.ClassVar[str] = ...
    DEVICE: typing.ClassVar[str] = ...
    DISPLAY: typing.ClassVar[str] = ...
    FINGERPRINT: typing.ClassVar[str] = ...
    HARDWARE: typing.ClassVar[str] = ...
    HOST: typing.ClassVar[str] = ...
    ID: typing.ClassVar[str] = ...
    MANUFACTURER: typing.ClassVar[str] = ...
    MODEL: typing.ClassVar[str] = ...
    ODM_SKU: typing.ClassVar[str] = ...
    PRODUCT: typing.ClassVar[str] = ...
    RADIO: typing.ClassVar[str] = ...
    SERIAL: typing.ClassVar[str] = ...
    SKU: typing.ClassVar[str] = ...
    SOC_MANUFACTURER: typing.ClassVar[str] = ...
    SOC_MODEL: typing.ClassVar[str] = ...
    SUPPORTED_32_BIT_ABIS: typing.ClassVar[java.chaquopy.JavaArray[java.lang.String]] = ...
    SUPPORTED_64_BIT_ABIS: typing.ClassVar[java.chaquopy.JavaArray[java.lang.String]] = ...
    SUPPORTED_ABIS: typing.ClassVar[java.chaquopy.JavaArray[java.lang.String]] = ...
    TAGS: typing.ClassVar[str] = ...
    TIME: typing.ClassVar[int] = ...
    TYPE: typing.ClassVar[str] = ...
    UNKNOWN: typing.ClassVar[str] = ...
    USER: typing.ClassVar[str] = ...
    def __init__(self) -> None: ...
    @staticmethod
    def getFingerprintedPartitions() -> java.util.List[Build.Partition]: ...
    @staticmethod
    def getRadioVersion() -> str: ...
    @staticmethod
    def getSerial() -> str: ...

    class VERSION_CODES(java.lang.Object):
        BASE: typing.ClassVar[int] = ...
        BASE_1_1: typing.ClassVar[int] = ...
        CUPCAKE: typing.ClassVar[int] = ...
        CUR_DEVELOPMENT: typing.ClassVar[int] = ...
        DONUT: typing.ClassVar[int] = ...
        ECLAIR: typing.ClassVar[int] = ...
        ECLAIR_0_1: typing.ClassVar[int] = ...
        ECLAIR_MR1: typing.ClassVar[int] = ...
        FROYO: typing.ClassVar[int] = ...
        GINGERBREAD: typing.ClassVar[int] = ...
        GINGERBREAD_MR1: typing.ClassVar[int] = ...
        HONEYCOMB: typing.ClassVar[int] = ...
        HONEYCOMB_MR1: typing.ClassVar[int] = ...
        HONEYCOMB_MR2: typing.ClassVar[int] = ...
        ICE_CREAM_SANDWICH: typing.ClassVar[int] = ...
        ICE_CREAM_SANDWICH_MR1: typing.ClassVar[int] = ...
        JELLY_BEAN: typing.ClassVar[int] = ...
        JELLY_BEAN_MR1: typing.ClassVar[int] = ...
        JELLY_BEAN_MR2: typing.ClassVar[int] = ...
        KITKAT: typing.ClassVar[int] = ...
        KITKAT_WATCH: typing.ClassVar[int] = ...
        LOLLIPOP: typing.ClassVar[int] = ...
        LOLLIPOP_MR1: typing.ClassVar[int] = ...
        M: typing.ClassVar[int] = ...
        N: typing.ClassVar[int] = ...
        N_MR1: typing.ClassVar[int] = ...
        O: typing.ClassVar[int] = ...
        O_MR1: typing.ClassVar[int] = ...
        P: typing.ClassVar[int] = ...
        Q: typing.ClassVar[int] = ...
        R: typing.ClassVar[int] = ...
        S: typing.ClassVar[int] = ...
        S_V2: typing.ClassVar[int] = ...
        TIRAMISU: typing.ClassVar[int] = ...
        UPSIDE_DOWN_CAKE: typing.ClassVar[int] = ...
        VANILLA_ICE_CREAM: typing.ClassVar[int] = ...
        def __init__(self) -> None: ...

    class VERSION(java.lang.Object):
        BASE_OS: typing.ClassVar[str] = ...
        CODENAME: typing.ClassVar[str] = ...
        INCREMENTAL: typing.ClassVar[str] = ...
        MEDIA_PERFORMANCE_CLASS: typing.ClassVar[int] = ...
        PREVIEW_SDK_INT: typing.ClassVar[int] = ...
        RELEASE: typing.ClassVar[str] = ...
        RELEASE_OR_CODENAME: typing.ClassVar[str] = ...
        RELEASE_OR_PREVIEW_DISPLAY: typing.ClassVar[str] = ...
        SDK: typing.ClassVar[str] = ...
        SDK_INT: typing.ClassVar[int] = ...
        SECURITY_PATCH: typing.ClassVar[str] = ...
        def __init__(self) -> None: ...

    class Partition(java.lang.Object):
        PARTITION_NAME_SYSTEM: typing.ClassVar[str] = ...
        def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
        def getBuildTimeMillis(self) -> int: ...
        def getFingerprint(self) -> str: ...
        def getName(self) -> str: ...
        def hashCode(self) -> int: ...

class Bundle(BaseBundle, java.lang.Cloneable, Parcelable):
    CREATOR: typing.ClassVar[Parcelable.Creator[Bundle]] = ...
    EMPTY: typing.ClassVar[Bundle] = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, capacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, b: Bundle, /) -> None: ...
    @typing.overload
    def __init__(self, b: PersistableBundle, /) -> None: ...
    @typing.overload
    def __init__(self, loader: java.lang.ClassLoader, /) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def deepCopy(self) -> Bundle: ...
    def describeContents(self) -> int: ...
    def getBinder(self, key: str | java.lang.String, /) -> IBinder | None: ...
    def getBundle(self, key: str | java.lang.String, /) -> Bundle | None: ...
    @typing.overload
    def getByte(self, key: str | java.lang.String, /) -> int: ...
    @typing.overload
    def getByte(self, key: str | java.lang.String, defaultValue: int | java.jbyte | java.lang.Byte, /) -> int: ...
    def getByteArray(self, key: str | java.lang.String, /) -> java.chaquopy.JavaArrayJByte | None: ...
    @typing.overload
    def getChar(self, key: str | java.lang.String, /) -> str: ...
    @typing.overload
    def getChar(self, key: str | java.lang.String, defaultValue: str | java.jchar | java.lang.Character, /) -> str: ...
    def getCharArray(self, key: str | java.lang.String, /) -> java.chaquopy.JavaArrayJChar | None: ...
    @typing.overload
    def getCharSequence(self, key: str | java.lang.String, /) -> java.lang.CharSequence | None: ...
    @typing.overload
    def getCharSequence(self, key: str | java.lang.String, defaultValue: java.lang.CharSequence, /) -> java.lang.CharSequence | None: ...
    def getCharSequenceArray(self, key: str | java.lang.String, /) -> java.chaquopy.JavaArray[java.lang.CharSequence] | None: ...
    def getCharSequenceArrayList(self, key: str | java.lang.String, /) -> java.util.ArrayList[java.lang.CharSequence] | None: ...
    def getClassLoader(self) -> java.lang.ClassLoader: ...
    @typing.overload
    def getFloat(self, key: str | java.lang.String, /) -> float: ...
    @typing.overload
    def getFloat(self, key: str | java.lang.String, defaultValue: float | java.jfloat | java.lang.Float, /) -> float: ...
    def getFloatArray(self, key: str | java.lang.String, /) -> java.chaquopy.JavaArrayJFloat | None: ...
    def getIntegerArrayList(self, key: str | java.lang.String, /) -> java.util.ArrayList[java.lang.Integer] | None: ...
    _getParcelable_1__T = typing.TypeVar('_getParcelable_1__T')  # <T>
    @typing.overload
    def getParcelable(self, key: str | java.lang.String, /) -> java.lang.Object | None: ...
    @typing.overload
    def getParcelable(self, key: str | java.lang.String, clazz: typing.Type[_getParcelable_1__T], /) -> _getParcelable_1__T | None: ...
    _getParcelableArray_1__T = typing.TypeVar('_getParcelableArray_1__T')  # <T>
    @typing.overload
    def getParcelableArray(self, key: str | java.lang.String, /) -> java.chaquopy.JavaArray[Parcelable] | None: ...
    @typing.overload
    def getParcelableArray(self, key: str | java.lang.String, clazz: typing.Type[_getParcelableArray_1__T], /) -> java.chaquopy.JavaArray[_getParcelableArray_1__T] | None: ...
    _getParcelableArrayList_1__T = typing.TypeVar('_getParcelableArrayList_1__T')  # <T>
    @typing.overload
    def getParcelableArrayList(self, key: str | java.lang.String, /) -> java.util.ArrayList[java.lang.Object] | None: ...
    @typing.overload
    def getParcelableArrayList(self, key: str | java.lang.String, clazz: typing.Type[_getParcelableArrayList_1__T], /) -> java.util.ArrayList[_getParcelableArrayList_1__T] | None: ...
    _getSerializable_1__T = typing.TypeVar('_getSerializable_1__T')  # <T>
    @typing.overload
    def getSerializable(self, key: str | java.lang.String, /) -> java.io.Serializable | None: ...
    @typing.overload
    def getSerializable(self, key: str | java.lang.String, clazz: typing.Type[_getSerializable_1__T], /) -> _getSerializable_1__T | None: ...
    @typing.overload
    def getShort(self, key: str | java.lang.String, /) -> int: ...
    @typing.overload
    def getShort(self, key: str | java.lang.String, defaultValue: int | java.jshort | java.lang.Short, /) -> int: ...
    def getShortArray(self, key: str | java.lang.String, /) -> java.chaquopy.JavaArrayJShort | None: ...
    def getSize(self, key: str | java.lang.String, /) -> android.util.Size | None: ...
    def getSizeF(self, key: str | java.lang.String, /) -> android.util.SizeF | None: ...
    _getSparseParcelableArray_1__T = typing.TypeVar('_getSparseParcelableArray_1__T')  # <T>
    @typing.overload
    def getSparseParcelableArray(self, key: str | java.lang.String, /) -> android.util.SparseArray[java.lang.Object] | None: ...
    @typing.overload
    def getSparseParcelableArray(self, key: str | java.lang.String, clazz: typing.Type[_getSparseParcelableArray_1__T], /) -> android.util.SparseArray[_getSparseParcelableArray_1__T] | None: ...
    def getStringArrayList(self, key: str | java.lang.String, /) -> java.util.ArrayList[java.lang.String] | None: ...
    def hasFileDescriptors(self) -> bool: ...
    def putAll(self, bundle: Bundle, /) -> None: ...
    def putBinder(self, key: str | java.lang.String, value: IBinder, /) -> None: ...
    def putBundle(self, key: str | java.lang.String, value: Bundle, /) -> None: ...
    def putByte(self, key: str | java.lang.String, value: int | java.jbyte | java.lang.Byte, /) -> None: ...
    def putByteArray(self, key: str | java.lang.String, value: java.chaquopy.JavaArrayJByte, /) -> None: ...
    def putChar(self, key: str | java.lang.String, value: str | java.jchar | java.lang.Character, /) -> None: ...
    def putCharArray(self, key: str | java.lang.String, value: java.chaquopy.JavaArrayJChar, /) -> None: ...
    def putCharSequence(self, key: str | java.lang.String, value: java.lang.CharSequence, /) -> None: ...
    def putCharSequenceArray(self, key: str | java.lang.String, value: java.chaquopy.JavaArray[java.lang.CharSequence], /) -> None: ...
    def putCharSequenceArrayList(self, key: str | java.lang.String, value: java.util.ArrayList[java.lang.CharSequence], /) -> None: ...
    def putFloat(self, key: str | java.lang.String, value: float | java.jfloat | java.lang.Float, /) -> None: ...
    def putFloatArray(self, key: str | java.lang.String, value: java.chaquopy.JavaArrayJFloat, /) -> None: ...
    def putIntegerArrayList(self, key: str | java.lang.String, value: java.util.ArrayList[java.lang.Integer], /) -> None: ...
    def putParcelable(self, key: str | java.lang.String, value: Parcelable, /) -> None: ...
    def putParcelableArray(self, key: str | java.lang.String, value: java.chaquopy.JavaArray[Parcelable], /) -> None: ...
    def putParcelableArrayList(self, key: str | java.lang.String, value: java.util.ArrayList[Parcelable], /) -> None: ...
    def putSerializable(self, key: str | java.lang.String, value: java.io.Serializable, /) -> None: ...
    def putShort(self, key: str | java.lang.String, value: int | java.jshort | java.lang.Short, /) -> None: ...
    def putShortArray(self, key: str | java.lang.String, value: java.chaquopy.JavaArrayJShort, /) -> None: ...
    def putSize(self, key: str | java.lang.String, value: android.util.Size, /) -> None: ...
    def putSizeF(self, key: str | java.lang.String, value: android.util.SizeF, /) -> None: ...
    def putSparseParcelableArray(self, key: str | java.lang.String, value: android.util.SparseArray[Parcelable], /) -> None: ...
    def putStringArrayList(self, key: str | java.lang.String, value: java.util.ArrayList[java.lang.String], /) -> None: ...
    def readFromParcel(self, parcel: Parcel, /) -> None: ...
    def remove(self, key: str | java.lang.String, /) -> None: ...
    def setClassLoader(self, loader: java.lang.ClassLoader, /) -> None: ...
    def toString(self) -> str: ...
    def writeToParcel(self, parcel: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...

class CancellationSignal(java.lang.Object):
    def __init__(self) -> None: ...
    def cancel(self) -> None: ...
    def isCanceled(self) -> bool: ...
    def setOnCancelListener(self, listener: CancellationSignal.OnCancelListener, /) -> None: ...
    def throwIfCanceled(self) -> None: ...

    class OnCancelListener(java.lang.Object):
        def onCancel(self) -> None: ...

class CombinedVibration(Parcelable):
    CREATOR: typing.ClassVar[Parcelable.Creator[CombinedVibration]] = ...
    @staticmethod
    def createParallel(effect: VibrationEffect, /) -> CombinedVibration: ...
    def describeContents(self) -> int: ...
    @staticmethod
    def startParallel() -> CombinedVibration.ParallelCombination: ...

    class ParallelCombination(java.lang.Object):
        def addVibrator(self, vibratorId: int | java.jint | java.lang.Integer, effect: VibrationEffect, /) -> CombinedVibration.ParallelCombination: ...
        def combine(self) -> CombinedVibration: ...

class ConditionVariable(java.lang.Object):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, state: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def block(self) -> None: ...
    @typing.overload
    def block(self, timeoutMs: int | java.jlong | java.lang.Long, /) -> bool: ...
    def close(self) -> None: ...
    def open(self) -> None: ...

class CountDownTimer(java.lang.Object):
    def __init__(self, millisInFuture: int | java.jlong | java.lang.Long, countDownInterval: int | java.jlong | java.lang.Long, /) -> None: ...
    def cancel(self) -> None: ...
    def onFinish(self) -> None: ...
    def onTick(self, arg1: int | java.jlong | java.lang.Long, /) -> None: ...
    def start(self) -> CountDownTimer: ...

class CpuUsageInfo(Parcelable):
    CREATOR: typing.ClassVar[Parcelable.Creator[CpuUsageInfo]] = ...
    def describeContents(self) -> int: ...
    def getActive(self) -> int: ...
    def getTotal(self) -> int: ...
    def writeToParcel(self, out: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...

class DeadObjectException(RemoteException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...

class DeadSystemException(DeadObjectException):
    def __init__(self) -> None: ...

class Debug(java.lang.Object):
    SHOW_CLASSLOADER: typing.ClassVar[int] = ...
    SHOW_FULL_DETAIL: typing.ClassVar[int] = ...
    SHOW_INITIALIZED: typing.ClassVar[int] = ...
    TRACE_COUNT_ALLOCS: typing.ClassVar[int] = ...
    @staticmethod
    def attachJvmtiAgent(library: str | java.lang.String, options: str | java.lang.String, classLoader: java.lang.ClassLoader, /) -> None: ...
    @staticmethod
    def changeDebugPort(port: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def dumpHprofData(fileName: str | java.lang.String, /) -> None: ...
    @staticmethod
    def dumpService(name: str | java.lang.String, fd: java.io.FileDescriptor, args: java.chaquopy.JavaArray[java.lang.String], /) -> bool: ...
    @staticmethod
    def enableEmulatorTraceOutput() -> None: ...
    @staticmethod
    def getBinderDeathObjectCount() -> int: ...
    @staticmethod
    def getBinderLocalObjectCount() -> int: ...
    @staticmethod
    def getBinderProxyObjectCount() -> int: ...
    @staticmethod
    def getBinderReceivedTransactions() -> int: ...
    @staticmethod
    def getBinderSentTransactions() -> int: ...
    @staticmethod
    def getGlobalAllocCount() -> int: ...
    @staticmethod
    def getGlobalAllocSize() -> int: ...
    @staticmethod
    def getGlobalClassInitCount() -> int: ...
    @staticmethod
    def getGlobalClassInitTime() -> int: ...
    @staticmethod
    def getGlobalExternalAllocCount() -> int: ...
    @staticmethod
    def getGlobalExternalAllocSize() -> int: ...
    @staticmethod
    def getGlobalExternalFreedCount() -> int: ...
    @staticmethod
    def getGlobalExternalFreedSize() -> int: ...
    @staticmethod
    def getGlobalFreedCount() -> int: ...
    @staticmethod
    def getGlobalFreedSize() -> int: ...
    @staticmethod
    def getGlobalGcInvocationCount() -> int: ...
    @staticmethod
    def getLoadedClassCount() -> int: ...
    @staticmethod
    def getMemoryInfo(arg1: Debug.MemoryInfo, /) -> None: ...
    @staticmethod
    def getNativeHeapAllocatedSize() -> int: ...
    @staticmethod
    def getNativeHeapFreeSize() -> int: ...
    @staticmethod
    def getNativeHeapSize() -> int: ...
    @staticmethod
    def getPss() -> int: ...
    @staticmethod
    def getRss() -> int: ...
    @staticmethod
    def getRuntimeStat(statName: str | java.lang.String, /) -> str: ...
    @staticmethod
    def getRuntimeStats() -> java.util.Map[java.lang.String, java.lang.String]: ...
    @staticmethod
    def getThreadAllocCount() -> int: ...
    @staticmethod
    def getThreadAllocSize() -> int: ...
    @staticmethod
    def getThreadExternalAllocCount() -> int: ...
    @staticmethod
    def getThreadExternalAllocSize() -> int: ...
    @staticmethod
    def getThreadGcInvocationCount() -> int: ...
    @staticmethod
    def isDebuggerConnected() -> bool: ...
    @staticmethod
    def printLoadedClasses(flags: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def resetAllCounts() -> None: ...
    @staticmethod
    def resetGlobalAllocCount() -> None: ...
    @staticmethod
    def resetGlobalAllocSize() -> None: ...
    @staticmethod
    def resetGlobalClassInitCount() -> None: ...
    @staticmethod
    def resetGlobalClassInitTime() -> None: ...
    @staticmethod
    def resetGlobalExternalAllocCount() -> None: ...
    @staticmethod
    def resetGlobalExternalAllocSize() -> None: ...
    @staticmethod
    def resetGlobalExternalFreedCount() -> None: ...
    @staticmethod
    def resetGlobalExternalFreedSize() -> None: ...
    @staticmethod
    def resetGlobalFreedCount() -> None: ...
    @staticmethod
    def resetGlobalFreedSize() -> None: ...
    @staticmethod
    def resetGlobalGcInvocationCount() -> None: ...
    @staticmethod
    def resetThreadAllocCount() -> None: ...
    @staticmethod
    def resetThreadAllocSize() -> None: ...
    @staticmethod
    def resetThreadExternalAllocCount() -> None: ...
    @staticmethod
    def resetThreadExternalAllocSize() -> None: ...
    @staticmethod
    def resetThreadGcInvocationCount() -> None: ...
    @staticmethod
    def setAllocationLimit(limit: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def setGlobalAllocationLimit(limit: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def startAllocCounting() -> None: ...
    @typing.overload
    @staticmethod
    def startMethodTracing() -> None: ...
    @typing.overload
    @staticmethod
    def startMethodTracing(tracePath: str | java.lang.String, /) -> None: ...
    @typing.overload
    @staticmethod
    def startMethodTracing(tracePath: str | java.lang.String, bufferSize: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def startMethodTracing(tracePath: str | java.lang.String, bufferSize: int | java.jint | java.lang.Integer, flags: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def startMethodTracingSampling(tracePath: str | java.lang.String, bufferSize: int | java.jint | java.lang.Integer, intervalUs: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def startNativeTracing() -> None: ...
    @staticmethod
    def stopAllocCounting() -> None: ...
    @staticmethod
    def stopMethodTracing() -> None: ...
    @staticmethod
    def stopNativeTracing() -> None: ...
    @staticmethod
    def threadCpuTimeNanos() -> int: ...
    @staticmethod
    def waitForDebugger() -> None: ...
    @staticmethod
    def waitingForDebugger() -> bool: ...

    class MemoryInfo(Parcelable):
        CREATOR: typing.ClassVar[Parcelable.Creator[Debug.MemoryInfo]] = ...
        dalvikPrivateDirty: int = ...
        dalvikPss: int = ...
        dalvikSharedDirty: int = ...
        nativePrivateDirty: int = ...
        nativePss: int = ...
        nativeSharedDirty: int = ...
        otherPrivateDirty: int = ...
        otherPss: int = ...
        otherSharedDirty: int = ...
        def __init__(self) -> None: ...
        def describeContents(self) -> int: ...
        def getMemoryStat(self, statName: str | java.lang.String, /) -> str: ...
        def getMemoryStats(self) -> java.util.Map[java.lang.String, java.lang.String]: ...
        def getTotalPrivateClean(self) -> int: ...
        def getTotalPrivateDirty(self) -> int: ...
        def getTotalPss(self) -> int: ...
        def getTotalSharedClean(self) -> int: ...
        def getTotalSharedDirty(self) -> int: ...
        def getTotalSwappablePss(self) -> int: ...
        def readFromParcel(self, source: Parcel, /) -> None: ...
        def writeToParcel(self, dest: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...

    class InstructionCount(java.lang.Object):
        def __init__(self) -> None: ...
        def collect(self) -> bool: ...
        def globalMethodInvocations(self) -> int: ...
        def globalTotal(self) -> int: ...
        def resetAndStart(self) -> bool: ...

class DropBoxManager(java.lang.Object):
    ACTION_DROPBOX_ENTRY_ADDED: typing.ClassVar[str] = ...
    EXTRA_DROPPED_COUNT: typing.ClassVar[str] = ...
    EXTRA_TAG: typing.ClassVar[str] = ...
    EXTRA_TIME: typing.ClassVar[str] = ...
    IS_EMPTY: typing.ClassVar[int] = ...
    IS_GZIPPED: typing.ClassVar[int] = ...
    IS_TEXT: typing.ClassVar[int] = ...
    def __init__(self) -> None: ...
    def addData(self, tag: str | java.lang.String, data: java.chaquopy.JavaArrayJByte, flags: int | java.jint | java.lang.Integer, /) -> None: ...
    def addFile(self, tag: str | java.lang.String, file: java.io.File, flags: int | java.jint | java.lang.Integer, /) -> None: ...
    def addText(self, tag: str | java.lang.String, data: str | java.lang.String, /) -> None: ...
    def getNextEntry(self, tag: str | java.lang.String, msec: int | java.jlong | java.lang.Long, /) -> DropBoxManager.Entry | None: ...
    def isTagEnabled(self, tag: str | java.lang.String, /) -> bool: ...

    class Entry(Parcelable, java.io.Closeable):
        CREATOR: typing.ClassVar[Parcelable.Creator[DropBoxManager.Entry]] = ...
        @typing.overload
        def __init__(self, tag: str | java.lang.String, millis: int | java.jlong | java.lang.Long, /) -> None: ...
        @typing.overload
        def __init__(self, tag: str | java.lang.String, millis: int | java.jlong | java.lang.Long, text: str | java.lang.String, /) -> None: ...
        @typing.overload
        def __init__(self, tag: str | java.lang.String, millis: int | java.jlong | java.lang.Long, data: ParcelFileDescriptor, flags: int | java.jint | java.lang.Integer, /) -> None: ...
        @typing.overload
        def __init__(self, tag: str | java.lang.String, millis: int | java.jlong | java.lang.Long, data: java.io.File, flags: int | java.jint | java.lang.Integer, /) -> None: ...
        @typing.overload
        def __init__(self, tag: str | java.lang.String, millis: int | java.jlong | java.lang.Long, data: java.chaquopy.JavaArrayJByte, flags: int | java.jint | java.lang.Integer, /) -> None: ...
        def close(self) -> None: ...
        def describeContents(self) -> int: ...
        def getFlags(self) -> int: ...
        def getInputStream(self) -> java.io.InputStream: ...
        def getTag(self) -> str: ...
        def getText(self, maxBytes: int | java.jint | java.lang.Integer, /) -> str: ...
        def getTimeMillis(self) -> int: ...
        def writeToParcel(self, out: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...

class Environment(java.lang.Object):
    DIRECTORY_ALARMS: typing.ClassVar[str] = ...
    DIRECTORY_AUDIOBOOKS: typing.ClassVar[str] = ...
    DIRECTORY_DCIM: typing.ClassVar[str] = ...
    DIRECTORY_DOCUMENTS: typing.ClassVar[str] = ...
    DIRECTORY_DOWNLOADS: typing.ClassVar[str] = ...
    DIRECTORY_MOVIES: typing.ClassVar[str] = ...
    DIRECTORY_MUSIC: typing.ClassVar[str] = ...
    DIRECTORY_NOTIFICATIONS: typing.ClassVar[str] = ...
    DIRECTORY_PICTURES: typing.ClassVar[str] = ...
    DIRECTORY_PODCASTS: typing.ClassVar[str] = ...
    DIRECTORY_RECORDINGS: typing.ClassVar[str] = ...
    DIRECTORY_RINGTONES: typing.ClassVar[str] = ...
    DIRECTORY_SCREENSHOTS: typing.ClassVar[str] = ...
    MEDIA_BAD_REMOVAL: typing.ClassVar[str] = ...
    MEDIA_CHECKING: typing.ClassVar[str] = ...
    MEDIA_EJECTING: typing.ClassVar[str] = ...
    MEDIA_MOUNTED: typing.ClassVar[str] = ...
    MEDIA_MOUNTED_READ_ONLY: typing.ClassVar[str] = ...
    MEDIA_NOFS: typing.ClassVar[str] = ...
    MEDIA_REMOVED: typing.ClassVar[str] = ...
    MEDIA_SHARED: typing.ClassVar[str] = ...
    MEDIA_UNKNOWN: typing.ClassVar[str] = ...
    MEDIA_UNMOUNTABLE: typing.ClassVar[str] = ...
    MEDIA_UNMOUNTED: typing.ClassVar[str] = ...
    def __init__(self) -> None: ...
    @staticmethod
    def getDataDirectory() -> java.io.File: ...
    @staticmethod
    def getDownloadCacheDirectory() -> java.io.File: ...
    @staticmethod
    def getExternalStorageDirectory() -> java.io.File: ...
    @staticmethod
    def getExternalStoragePublicDirectory(type: str | java.lang.String, /) -> java.io.File: ...
    @typing.overload
    @staticmethod
    def getExternalStorageState() -> str: ...
    @typing.overload
    @staticmethod
    def getExternalStorageState(path: java.io.File, /) -> str: ...
    @staticmethod
    def getRootDirectory() -> java.io.File: ...
    @staticmethod
    def getStorageDirectory() -> java.io.File: ...
    @staticmethod
    def getStorageState(path: java.io.File, /) -> str: ...
    @typing.overload
    @staticmethod
    def isExternalStorageEmulated() -> bool: ...
    @typing.overload
    @staticmethod
    def isExternalStorageEmulated(path: java.io.File, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isExternalStorageLegacy() -> bool: ...
    @typing.overload
    @staticmethod
    def isExternalStorageLegacy(path: java.io.File, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isExternalStorageManager() -> bool: ...
    @typing.overload
    @staticmethod
    def isExternalStorageManager(path: java.io.File, /) -> bool: ...
    @typing.overload
    @staticmethod
    def isExternalStorageRemovable() -> bool: ...
    @typing.overload
    @staticmethod
    def isExternalStorageRemovable(path: java.io.File, /) -> bool: ...

class FileObserver(java.lang.Object):
    ACCESS: typing.ClassVar[int] = ...
    ALL_EVENTS: typing.ClassVar[int] = ...
    ATTRIB: typing.ClassVar[int] = ...
    CLOSE_NOWRITE: typing.ClassVar[int] = ...
    CLOSE_WRITE: typing.ClassVar[int] = ...
    CREATE: typing.ClassVar[int] = ...
    DELETE: typing.ClassVar[int] = ...
    DELETE_SELF: typing.ClassVar[int] = ...
    MODIFY: typing.ClassVar[int] = ...
    MOVED_FROM: typing.ClassVar[int] = ...
    MOVED_TO: typing.ClassVar[int] = ...
    MOVE_SELF: typing.ClassVar[int] = ...
    OPEN: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, file: java.io.File, /) -> None: ...
    @typing.overload
    def __init__(self, path: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, files: java.util.List[java.io.File], /) -> None: ...
    @typing.overload
    def __init__(self, file: java.io.File, mask: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, path: str | java.lang.String, mask: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, files: java.util.List[java.io.File], mask: int | java.jint | java.lang.Integer, /) -> None: ...
    def finalize(self) -> None: ...
    def onEvent(self, arg1: int | java.jint | java.lang.Integer, arg2: str | java.lang.String, /) -> None: ...
    def startWatching(self) -> None: ...
    def stopWatching(self) -> None: ...

class FileUriExposedException(java.lang.RuntimeException):
    def __init__(self, message: str | java.lang.String, /) -> None: ...

class FileUtils(java.lang.Object):
    @typing.overload
    @staticmethod
    def closeQuietly(fd: java.io.FileDescriptor, /) -> None: ...
    @typing.overload
    @staticmethod
    def closeQuietly(closeable: java.lang.AutoCloseable, /) -> None: ...
    @typing.overload
    @staticmethod
    def copy(in_: java.io.FileDescriptor, out: java.io.FileDescriptor, /) -> int: ...
    @typing.overload
    @staticmethod
    def copy(in_: java.io.InputStream, out: java.io.OutputStream, /) -> int: ...
    @typing.overload
    @staticmethod
    def copy(in_: java.io.FileDescriptor, out: java.io.FileDescriptor, signal: CancellationSignal, executor: java.util.concurrent.Executor, listener: FileUtils.ProgressListener, /) -> int: ...
    @typing.overload
    @staticmethod
    def copy(in_: java.io.InputStream, out: java.io.OutputStream, signal: CancellationSignal, executor: java.util.concurrent.Executor, listener: FileUtils.ProgressListener, /) -> int: ...

    class ProgressListener(java.lang.Object):
        def onProgress(self, arg1: int | java.jlong | java.lang.Long, /) -> None: ...

class Handler(java.lang.Object):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, callback: Handler.Callback, /) -> None: ...
    @typing.overload
    def __init__(self, looper: Looper, /) -> None: ...
    @typing.overload
    def __init__(self, looper: Looper, callback: Handler.Callback, /) -> None: ...
    @typing.overload
    @staticmethod
    def createAsync(looper: Looper, /) -> Handler: ...
    @typing.overload
    @staticmethod
    def createAsync(looper: Looper, callback: Handler.Callback, /) -> Handler: ...
    def dispatchMessage(self, msg: Message, /) -> None: ...
    def dump(self, pw: android.util.Printer, prefix: str | java.lang.String, /) -> None: ...
    def getLooper(self) -> Looper: ...
    def getMessageName(self, message: Message, /) -> str: ...
    def handleMessage(self, msg: Message, /) -> None: ...
    def hasCallbacks(self, r: java.lang.Runnable, /) -> bool: ...
    @typing.overload
    def hasMessages(self, what: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    def hasMessages(self, what: int | java.jint | java.lang.Integer, object: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def obtainMessage(self) -> Message: ...
    @typing.overload
    def obtainMessage(self, what: int | java.jint | java.lang.Integer, /) -> Message: ...
    @typing.overload
    def obtainMessage(self, what: int | java.jint | java.lang.Integer, obj: java.lang.Object | int | bool | float | str, /) -> Message: ...
    @typing.overload
    def obtainMessage(self, what: int | java.jint | java.lang.Integer, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, /) -> Message: ...
    @typing.overload
    def obtainMessage(self, what: int | java.jint | java.lang.Integer, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, obj: java.lang.Object | int | bool | float | str, /) -> Message: ...
    def post(self, r: java.lang.Runnable, /) -> bool: ...
    def postAtFrontOfQueue(self, r: java.lang.Runnable, /) -> bool: ...
    @typing.overload
    def postAtTime(self, r: java.lang.Runnable, uptimeMillis: int | java.jlong | java.lang.Long, /) -> bool: ...
    @typing.overload
    def postAtTime(self, r: java.lang.Runnable, token: java.lang.Object | int | bool | float | str, uptimeMillis: int | java.jlong | java.lang.Long, /) -> bool: ...
    @typing.overload
    def postDelayed(self, r: java.lang.Runnable, delayMillis: int | java.jlong | java.lang.Long, /) -> bool: ...
    @typing.overload
    def postDelayed(self, r: java.lang.Runnable, token: java.lang.Object | int | bool | float | str, delayMillis: int | java.jlong | java.lang.Long, /) -> bool: ...
    @typing.overload
    def removeCallbacks(self, r: java.lang.Runnable, /) -> None: ...
    @typing.overload
    def removeCallbacks(self, r: java.lang.Runnable, token: java.lang.Object | int | bool | float | str, /) -> None: ...
    def removeCallbacksAndMessages(self, token: java.lang.Object | int | bool | float | str, /) -> None: ...
    @typing.overload
    def removeMessages(self, what: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def removeMessages(self, what: int | java.jint | java.lang.Integer, object: java.lang.Object | int | bool | float | str, /) -> None: ...
    def sendEmptyMessage(self, what: int | java.jint | java.lang.Integer, /) -> bool: ...
    def sendEmptyMessageAtTime(self, what: int | java.jint | java.lang.Integer, uptimeMillis: int | java.jlong | java.lang.Long, /) -> bool: ...
    def sendEmptyMessageDelayed(self, what: int | java.jint | java.lang.Integer, delayMillis: int | java.jlong | java.lang.Long, /) -> bool: ...
    def sendMessage(self, msg: Message, /) -> bool: ...
    def sendMessageAtFrontOfQueue(self, msg: Message, /) -> bool: ...
    def sendMessageAtTime(self, msg: Message, uptimeMillis: int | java.jlong | java.lang.Long, /) -> bool: ...
    def sendMessageDelayed(self, msg: Message, delayMillis: int | java.jlong | java.lang.Long, /) -> bool: ...
    def toString(self) -> str: ...

    class Callback(java.lang.Object):
        def handleMessage(self, arg1: Message, /) -> bool: ...

class HandlerThread(java.lang.Thread):
    @typing.overload
    def __init__(self, name: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, name: str | java.lang.String, priority: int | java.jint | java.lang.Integer, /) -> None: ...
    def getLooper(self) -> Looper: ...
    def getThreadId(self) -> int: ...
    def onLooperPrepared(self) -> None: ...
    def quit(self) -> bool: ...
    def quitSafely(self) -> bool: ...
    def run(self) -> None: ...

class HardwarePropertiesManager(java.lang.Object):
    DEVICE_TEMPERATURE_BATTERY: typing.ClassVar[int] = ...
    DEVICE_TEMPERATURE_CPU: typing.ClassVar[int] = ...
    DEVICE_TEMPERATURE_GPU: typing.ClassVar[int] = ...
    DEVICE_TEMPERATURE_SKIN: typing.ClassVar[int] = ...
    TEMPERATURE_CURRENT: typing.ClassVar[int] = ...
    TEMPERATURE_SHUTDOWN: typing.ClassVar[int] = ...
    TEMPERATURE_THROTTLING: typing.ClassVar[int] = ...
    TEMPERATURE_THROTTLING_BELOW_VR_MIN: typing.ClassVar[int] = ...
    UNDEFINED_TEMPERATURE: typing.ClassVar[float] = ...
    def getCpuUsages(self) -> java.chaquopy.JavaArray[CpuUsageInfo]: ...
    def getDeviceTemperatures(self, type: int | java.jint | java.lang.Integer, source: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJFloat: ...
    def getFanSpeeds(self) -> java.chaquopy.JavaArrayJFloat: ...

class IBinder(java.lang.Object):
    DUMP_TRANSACTION: typing.ClassVar[int] = ...
    FIRST_CALL_TRANSACTION: typing.ClassVar[int] = ...
    FLAG_ONEWAY: typing.ClassVar[int] = ...
    INTERFACE_TRANSACTION: typing.ClassVar[int] = ...
    LAST_CALL_TRANSACTION: typing.ClassVar[int] = ...
    LIKE_TRANSACTION: typing.ClassVar[int] = ...
    PING_TRANSACTION: typing.ClassVar[int] = ...
    TWEET_TRANSACTION: typing.ClassVar[int] = ...
    def dump(self, arg1: java.io.FileDescriptor, arg2: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def dumpAsync(self, arg1: java.io.FileDescriptor, arg2: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def getInterfaceDescriptor(self) -> str | None: ...
    @staticmethod
    def getSuggestedMaxIpcSizeBytes() -> int: ...
    def isBinderAlive(self) -> bool: ...
    def linkToDeath(self, arg1: IBinder.DeathRecipient, arg2: int | java.jint | java.lang.Integer, /) -> None: ...
    def pingBinder(self) -> bool: ...
    def queryLocalInterface(self, arg1: str | java.lang.String, /) -> IInterface | None: ...
    def transact(self, arg1: int | java.jint | java.lang.Integer, arg2: Parcel, arg3: Parcel, arg4: int | java.jint | java.lang.Integer, /) -> bool: ...
    def unlinkToDeath(self, arg1: IBinder.DeathRecipient, arg2: int | java.jint | java.lang.Integer, /) -> bool: ...

    class DeathRecipient(java.lang.Object):
        @typing.overload
        def binderDied(self) -> None: ...
        @typing.overload
        def binderDied(self, who: IBinder, /) -> None: ...

class IInterface(java.lang.Object):
    def asBinder(self) -> IBinder: ...

class LimitExceededException(java.lang.IllegalStateException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...

class LocaleList(Parcelable):
    CREATOR: typing.ClassVar[Parcelable.Creator[LocaleList]] = ...
    def __init__(self, *list: java.util.Locale) -> None: ...
    def describeContents(self) -> int: ...
    def equals(self, other: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def forLanguageTags(list: str | java.lang.String, /) -> LocaleList: ...
    def get(self, index: int | java.jint | java.lang.Integer, /) -> java.util.Locale: ...
    @staticmethod
    def getAdjustedDefault() -> LocaleList: ...
    @staticmethod
    def getDefault() -> LocaleList: ...
    @staticmethod
    def getEmptyLocaleList() -> LocaleList: ...
    def getFirstMatch(self, supportedLocales: java.chaquopy.JavaArray[java.lang.String], /) -> java.util.Locale | None: ...
    def hashCode(self) -> int: ...
    def indexOf(self, locale: java.util.Locale, /) -> int: ...
    def isEmpty(self) -> bool: ...
    @staticmethod
    def isPseudoLocale(locale: android.icu.util.ULocale, /) -> bool: ...
    @staticmethod
    def matchesLanguageAndScript(supported: java.util.Locale, desired: java.util.Locale, /) -> bool: ...
    @staticmethod
    def setDefault(locales: LocaleList, /) -> None: ...
    def size(self) -> int: ...
    def toLanguageTags(self) -> str: ...
    def toString(self) -> str: ...
    def writeToParcel(self, dest: Parcel, parcelableFlags: int | java.jint | java.lang.Integer, /) -> None: ...

class Looper(java.lang.Object):
    def dump(self, pw: android.util.Printer, prefix: str | java.lang.String, /) -> None: ...
    @staticmethod
    def getMainLooper() -> Looper: ...
    def getQueue(self) -> MessageQueue: ...
    def getThread(self) -> java.lang.Thread: ...
    def isCurrentThread(self) -> bool: ...
    @staticmethod
    def loop() -> None: ...
    @staticmethod
    def myLooper() -> Looper | None: ...
    @staticmethod
    def myQueue() -> MessageQueue: ...
    @staticmethod
    def prepare() -> None: ...
    @staticmethod
    def prepareMainLooper() -> None: ...
    def quit(self) -> None: ...
    def quitSafely(self) -> None: ...
    def setMessageLogging(self, printer: android.util.Printer, /) -> None: ...
    def toString(self) -> str: ...

class MemoryFile(java.lang.Object):
    def __init__(self, name: str | java.lang.String, length: int | java.jint | java.lang.Integer, /) -> None: ...
    def allowPurging(self, allowPurging: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def close(self) -> None: ...
    def getInputStream(self) -> java.io.InputStream: ...
    def getOutputStream(self) -> java.io.OutputStream: ...
    def isPurgingAllowed(self) -> bool: ...
    def length(self) -> int: ...
    def readBytes(self, buffer: java.chaquopy.JavaArrayJByte, srcOffset: int | java.jint | java.lang.Integer, destOffset: int | java.jint | java.lang.Integer, count: int | java.jint | java.lang.Integer, /) -> int: ...
    def writeBytes(self, buffer: java.chaquopy.JavaArrayJByte, srcOffset: int | java.jint | java.lang.Integer, destOffset: int | java.jint | java.lang.Integer, count: int | java.jint | java.lang.Integer, /) -> None: ...

class Message(Parcelable):
    CREATOR: typing.ClassVar[Parcelable.Creator[Message]] = ...
    arg1: int = ...
    arg2: int = ...
    obj: java.lang.Object = ...
    replyTo: Messenger = ...
    sendingUid: int = ...
    what: int = ...
    def __init__(self) -> None: ...
    def copyFrom(self, o: Message, /) -> None: ...
    def describeContents(self) -> int: ...
    def getCallback(self) -> java.lang.Runnable: ...
    def getData(self) -> Bundle: ...
    def getTarget(self) -> Handler: ...
    def getWhen(self) -> int: ...
    def isAsynchronous(self) -> bool: ...
    @typing.overload
    @staticmethod
    def obtain() -> Message: ...
    @typing.overload
    @staticmethod
    def obtain(h: Handler, /) -> Message: ...
    @typing.overload
    @staticmethod
    def obtain(orig: Message, /) -> Message: ...
    @typing.overload
    @staticmethod
    def obtain(h: Handler, what: int | java.jint | java.lang.Integer, /) -> Message: ...
    @typing.overload
    @staticmethod
    def obtain(h: Handler, callback: java.lang.Runnable, /) -> Message: ...
    @typing.overload
    @staticmethod
    def obtain(h: Handler, what: int | java.jint | java.lang.Integer, obj: java.lang.Object | int | bool | float | str, /) -> Message: ...
    @typing.overload
    @staticmethod
    def obtain(h: Handler, what: int | java.jint | java.lang.Integer, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, /) -> Message: ...
    @typing.overload
    @staticmethod
    def obtain(h: Handler, what: int | java.jint | java.lang.Integer, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, obj: java.lang.Object | int | bool | float | str, /) -> Message: ...
    def peekData(self) -> Bundle | None: ...
    def recycle(self) -> None: ...
    def sendToTarget(self) -> None: ...
    def setAsynchronous(self, async_: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def setData(self, data: Bundle, /) -> None: ...
    def setTarget(self, target: Handler, /) -> None: ...
    def toString(self) -> str: ...
    def writeToParcel(self, dest: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...

class MessageQueue(java.lang.Object):
    def addIdleHandler(self, handler: MessageQueue.IdleHandler, /) -> None: ...
    def addOnFileDescriptorEventListener(self, fd: java.io.FileDescriptor, events: int | java.jint | java.lang.Integer, listener: MessageQueue.OnFileDescriptorEventListener, /) -> None: ...
    def finalize(self) -> None: ...
    def isIdle(self) -> bool: ...
    def removeIdleHandler(self, handler: MessageQueue.IdleHandler, /) -> None: ...
    def removeOnFileDescriptorEventListener(self, fd: java.io.FileDescriptor, /) -> None: ...

    class OnFileDescriptorEventListener(java.lang.Object):
        EVENT_ERROR: typing.ClassVar[int] = ...
        EVENT_INPUT: typing.ClassVar[int] = ...
        EVENT_OUTPUT: typing.ClassVar[int] = ...
        def onFileDescriptorEvents(self, arg1: java.io.FileDescriptor, arg2: int | java.jint | java.lang.Integer, /) -> int: ...

    class IdleHandler(java.lang.Object):
        def queueIdle(self) -> bool: ...

class Messenger(Parcelable):
    CREATOR: typing.ClassVar[Parcelable.Creator[Messenger]] = ...
    @typing.overload
    def __init__(self, target: Handler, /) -> None: ...
    @typing.overload
    def __init__(self, target: IBinder, /) -> None: ...
    def describeContents(self) -> int: ...
    def equals(self, otherObj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getBinder(self) -> IBinder: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def readMessengerOrNullFromParcel(in_: Parcel, /) -> Messenger | None: ...
    def send(self, message: Message, /) -> None: ...
    @staticmethod
    def writeMessengerOrNullToParcel(messenger: Messenger, out: Parcel, /) -> None: ...
    def writeToParcel(self, out: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...

class NetworkOnMainThreadException(java.lang.RuntimeException):
    def __init__(self) -> None: ...

class OperationCanceledException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...

_OutcomeReceiver__R = typing.TypeVar('_OutcomeReceiver__R')  # <R>
_OutcomeReceiver__E = typing.TypeVar('_OutcomeReceiver__E', bound=java.lang.Throwable)  # <E>
class OutcomeReceiver(java.lang.Object, typing.Generic[_OutcomeReceiver__R, _OutcomeReceiver__E]):
    def onError(self, error: _OutcomeReceiver__E, /) -> None: ...
    def onResult(self, arg1: _OutcomeReceiver__R, /) -> None: ...

class Parcel(java.lang.Object):
    STRING_CREATOR: typing.ClassVar[Parcelable.Creator[java.lang.String]] = ...
    def appendFrom(self, parcel: Parcel, offset: int | java.jint | java.lang.Integer, length: int | java.jint | java.lang.Integer, /) -> None: ...
    def createBinderArray(self) -> java.chaquopy.JavaArray[IBinder] | None: ...
    def createBinderArrayList(self) -> java.util.ArrayList[IBinder] | None: ...
    def createBooleanArray(self) -> java.chaquopy.JavaArrayJBoolean | None: ...
    def createByteArray(self) -> java.chaquopy.JavaArrayJByte | None: ...
    def createCharArray(self) -> java.chaquopy.JavaArrayJChar | None: ...
    def createDoubleArray(self) -> java.chaquopy.JavaArrayJDouble | None: ...
    _createFixedArray_0__T = typing.TypeVar('_createFixedArray_0__T')  # <T>
    _createFixedArray_1__T = typing.TypeVar('_createFixedArray_1__T')  # <T>
    _createFixedArray_2__T = typing.TypeVar('_createFixedArray_2__T')  # <T>
    @typing.overload
    def createFixedArray(self, cls: typing.Type[_createFixedArray_0__T], /, *dimensions: java.chaquopy.JavaArrayJInt) -> _createFixedArray_0__T | None: ...
    @typing.overload
    def createFixedArray(self, cls: typing.Type[_createFixedArray_1__T], c: Parcelable.Creator[java.lang.Object], /, *dimensions: java.chaquopy.JavaArrayJInt) -> _createFixedArray_1__T | None: ...
    @typing.overload
    def createFixedArray(self, cls: typing.Type[_createFixedArray_2__T], asInterface: java.util.function.Function[IBinder, java.lang.Object], /, *dimensions: java.chaquopy.JavaArrayJInt) -> _createFixedArray_2__T | None: ...
    def createFloatArray(self) -> java.chaquopy.JavaArrayJFloat | None: ...
    def createIntArray(self) -> java.chaquopy.JavaArrayJInt | None: ...
    _createInterfaceArray__T = typing.TypeVar('_createInterfaceArray__T')  # <T>
    def createInterfaceArray(self, newArray: java.util.function.IntFunction[java.chaquopy.JavaArray[_createInterfaceArray__T]], asInterface: java.util.function.Function[IBinder, _createInterfaceArray__T], /) -> java.chaquopy.JavaArray[_createInterfaceArray__T] | None: ...
    _createInterfaceArrayList__T = typing.TypeVar('_createInterfaceArrayList__T')  # <T>
    def createInterfaceArrayList(self, asInterface: java.util.function.Function[IBinder, _createInterfaceArrayList__T], /) -> java.util.ArrayList[_createInterfaceArrayList__T] | None: ...
    def createLongArray(self) -> java.chaquopy.JavaArrayJLong | None: ...
    def createStringArray(self) -> java.chaquopy.JavaArray[java.lang.String] | None: ...
    def createStringArrayList(self) -> java.util.ArrayList[java.lang.String] | None: ...
    _createTypedArray__T = typing.TypeVar('_createTypedArray__T')  # <T>
    def createTypedArray(self, c: Parcelable.Creator[_createTypedArray__T], /) -> java.chaquopy.JavaArray[_createTypedArray__T] | None: ...
    _createTypedArrayList__T = typing.TypeVar('_createTypedArrayList__T')  # <T>
    def createTypedArrayList(self, c: Parcelable.Creator[_createTypedArrayList__T], /) -> java.util.ArrayList[_createTypedArrayList__T] | None: ...
    _createTypedArrayMap__T = typing.TypeVar('_createTypedArrayMap__T')  # <T>
    def createTypedArrayMap(self, creator: Parcelable.Creator[_createTypedArrayMap__T], /) -> android.util.ArrayMap[java.lang.String, _createTypedArrayMap__T] | None: ...
    _createTypedSparseArray__T = typing.TypeVar('_createTypedSparseArray__T')  # <T>
    def createTypedSparseArray(self, creator: Parcelable.Creator[_createTypedSparseArray__T], /) -> android.util.SparseArray[_createTypedSparseArray__T] | None: ...
    def dataAvail(self) -> int: ...
    def dataCapacity(self) -> int: ...
    def dataPosition(self) -> int: ...
    def dataSize(self) -> int: ...
    def enforceInterface(self, interfaceName: str | java.lang.String, /) -> None: ...
    def enforceNoDataAvail(self) -> None: ...
    def finalize(self) -> None: ...
    @typing.overload
    def hasFileDescriptors(self) -> bool: ...
    @typing.overload
    def hasFileDescriptors(self, offset: int | java.jint | java.lang.Integer, length: int | java.jint | java.lang.Integer, /) -> bool: ...
    def marshall(self) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    @staticmethod
    def obtain() -> Parcel: ...
    @typing.overload
    @staticmethod
    def obtain(binder: IBinder, /) -> Parcel: ...
    _readArray_1__T = typing.TypeVar('_readArray_1__T')  # <T>
    @typing.overload
    def readArray(self, loader: java.lang.ClassLoader, /) -> java.chaquopy.JavaArray[java.lang.Object] | None: ...
    @typing.overload
    def readArray(self, loader: java.lang.ClassLoader, clazz: typing.Type[_readArray_1__T], /) -> java.chaquopy.JavaArray[_readArray_1__T] | None: ...
    _readArrayList_1__T = typing.TypeVar('_readArrayList_1__T')  # <T>
    @typing.overload
    def readArrayList(self, loader: java.lang.ClassLoader, /) -> java.util.ArrayList | None: ...
    @typing.overload
    def readArrayList(self, loader: java.lang.ClassLoader, clazz: typing.Type[_readArrayList_1__T], /) -> java.util.ArrayList[_readArrayList_1__T] | None: ...
    def readBinderArray(self, val: java.chaquopy.JavaArray[IBinder], /) -> None: ...
    def readBinderList(self, list: java.util.List[IBinder], /) -> None: ...
    def readBlob(self) -> java.chaquopy.JavaArrayJByte | None: ...
    def readBoolean(self) -> bool: ...
    def readBooleanArray(self, val: java.chaquopy.JavaArrayJBoolean, /) -> None: ...
    @typing.overload
    def readBundle(self) -> Bundle | None: ...
    @typing.overload
    def readBundle(self, loader: java.lang.ClassLoader, /) -> Bundle | None: ...
    def readByte(self) -> int: ...
    def readByteArray(self, val: java.chaquopy.JavaArrayJByte, /) -> None: ...
    def readCharArray(self, val: java.chaquopy.JavaArrayJChar, /) -> None: ...
    def readDouble(self) -> float: ...
    def readDoubleArray(self, val: java.chaquopy.JavaArrayJDouble, /) -> None: ...
    @typing.overload
    def readException(self) -> None: ...
    @typing.overload
    def readException(self, code: int | java.jint | java.lang.Integer, msg: str | java.lang.String, /) -> None: ...
    def readFileDescriptor(self) -> ParcelFileDescriptor: ...
    @typing.overload
    def readFixedArray(self, val: java.lang.Object, /) -> None: ...
    @typing.overload
    def readFixedArray(self, val: java.lang.Object, c: Parcelable.Creator[java.lang.Object], /) -> None: ...
    @typing.overload
    def readFixedArray(self, val: java.lang.Object, asInterface: java.util.function.Function[IBinder, java.lang.Object], /) -> None: ...
    def readFloat(self) -> float: ...
    def readFloatArray(self, val: java.chaquopy.JavaArrayJFloat, /) -> None: ...
    _readHashMap_1__K = typing.TypeVar('_readHashMap_1__K')  # <K>
    _readHashMap_1__V = typing.TypeVar('_readHashMap_1__V')  # <V>
    @typing.overload
    def readHashMap(self, loader: java.lang.ClassLoader, /) -> java.util.HashMap | None: ...
    @typing.overload
    def readHashMap(self, loader: java.lang.ClassLoader, clazzKey: typing.Type[_readHashMap_1__K], clazzValue: typing.Type[_readHashMap_1__V], /) -> java.util.HashMap[_readHashMap_1__K, _readHashMap_1__V] | None: ...
    def readInt(self) -> int: ...
    def readIntArray(self, val: java.chaquopy.JavaArrayJInt, /) -> None: ...
    _readInterfaceArray__T = typing.TypeVar('_readInterfaceArray__T')  # <T>
    def readInterfaceArray(self, val: java.chaquopy.JavaArray[_readInterfaceArray__T], asInterface: java.util.function.Function[IBinder, _readInterfaceArray__T], /) -> None: ...
    _readInterfaceList__T = typing.TypeVar('_readInterfaceList__T')  # <T>
    def readInterfaceList(self, list: java.util.List[_readInterfaceList__T], asInterface: java.util.function.Function[IBinder, _readInterfaceList__T], /) -> None: ...
    _readList_1__T = typing.TypeVar('_readList_1__T')  # <T>
    @typing.overload
    def readList(self, outVal: java.util.List, loader: java.lang.ClassLoader, /) -> None: ...
    @typing.overload
    def readList(self, outVal: java.util.List[_readList_1__T], loader: java.lang.ClassLoader, clazz: typing.Type[_readList_1__T], /) -> None: ...
    def readLong(self) -> int: ...
    def readLongArray(self, val: java.chaquopy.JavaArrayJLong, /) -> None: ...
    _readMap_1__K = typing.TypeVar('_readMap_1__K')  # <K>
    _readMap_1__V = typing.TypeVar('_readMap_1__V')  # <V>
    @typing.overload
    def readMap(self, outVal: java.util.Map, loader: java.lang.ClassLoader, /) -> None: ...
    @typing.overload
    def readMap(self, outVal: java.util.Map[_readMap_1__K, _readMap_1__V], loader: java.lang.ClassLoader, clazzKey: typing.Type[_readMap_1__K], clazzValue: typing.Type[_readMap_1__V], /) -> None: ...
    _readParcelable_1__T = typing.TypeVar('_readParcelable_1__T')  # <T>
    @typing.overload
    def readParcelable(self, loader: java.lang.ClassLoader, /) -> java.lang.Object | None: ...
    @typing.overload
    def readParcelable(self, loader: java.lang.ClassLoader, clazz: typing.Type[_readParcelable_1__T], /) -> _readParcelable_1__T | None: ...
    _readParcelableArray_1__T = typing.TypeVar('_readParcelableArray_1__T')  # <T>
    @typing.overload
    def readParcelableArray(self, loader: java.lang.ClassLoader, /) -> java.chaquopy.JavaArray[Parcelable] | None: ...
    @typing.overload
    def readParcelableArray(self, loader: java.lang.ClassLoader, clazz: typing.Type[_readParcelableArray_1__T], /) -> java.chaquopy.JavaArray[_readParcelableArray_1__T] | None: ...
    _readParcelableCreator_1__T = typing.TypeVar('_readParcelableCreator_1__T')  # <T>
    @typing.overload
    def readParcelableCreator(self, loader: java.lang.ClassLoader, /) -> Parcelable.Creator[java.lang.Object] | None: ...
    @typing.overload
    def readParcelableCreator(self, loader: java.lang.ClassLoader, clazz: typing.Type[_readParcelableCreator_1__T], /) -> Parcelable.Creator[_readParcelableCreator_1__T] | None: ...
    _readParcelableList_0__T = typing.TypeVar('_readParcelableList_0__T')  # <T>
    _readParcelableList_1__T = typing.TypeVar('_readParcelableList_1__T')  # <T>
    @typing.overload
    def readParcelableList(self, list: java.util.List[_readParcelableList_0__T], cl: java.lang.ClassLoader, /) -> java.util.List[_readParcelableList_0__T]: ...
    @typing.overload
    def readParcelableList(self, list: java.util.List[_readParcelableList_1__T], cl: java.lang.ClassLoader, clazz: typing.Type[_readParcelableList_1__T], /) -> java.util.List[_readParcelableList_1__T]: ...
    @typing.overload
    def readPersistableBundle(self) -> PersistableBundle | None: ...
    @typing.overload
    def readPersistableBundle(self, loader: java.lang.ClassLoader, /) -> PersistableBundle | None: ...
    _readSerializable_1__T = typing.TypeVar('_readSerializable_1__T')  # <T>
    @typing.overload
    def readSerializable(self) -> java.io.Serializable | None: ...
    @typing.overload
    def readSerializable(self, loader: java.lang.ClassLoader, clazz: typing.Type[_readSerializable_1__T], /) -> _readSerializable_1__T | None: ...
    def readSize(self) -> android.util.Size: ...
    def readSizeF(self) -> android.util.SizeF: ...
    _readSparseArray_1__T = typing.TypeVar('_readSparseArray_1__T')  # <T>
    @typing.overload
    def readSparseArray(self, loader: java.lang.ClassLoader, /) -> android.util.SparseArray[java.lang.Object] | None: ...
    @typing.overload
    def readSparseArray(self, loader: java.lang.ClassLoader, clazz: typing.Type[_readSparseArray_1__T], /) -> android.util.SparseArray[_readSparseArray_1__T] | None: ...
    def readSparseBooleanArray(self) -> android.util.SparseBooleanArray | None: ...
    def readString(self) -> str | None: ...
    def readStringArray(self, val: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def readStringList(self, list: java.util.List[java.lang.String], /) -> None: ...
    def readStrongBinder(self) -> IBinder: ...
    _readTypedArray__T = typing.TypeVar('_readTypedArray__T')  # <T>
    def readTypedArray(self, val: java.chaquopy.JavaArray[_readTypedArray__T], c: Parcelable.Creator[_readTypedArray__T], /) -> None: ...
    _readTypedList__T = typing.TypeVar('_readTypedList__T')  # <T>
    def readTypedList(self, list: java.util.List[_readTypedList__T], c: Parcelable.Creator[_readTypedList__T], /) -> None: ...
    _readTypedObject__T = typing.TypeVar('_readTypedObject__T')  # <T>
    def readTypedObject(self, c: Parcelable.Creator[_readTypedObject__T], /) -> _readTypedObject__T | None: ...
    def readValue(self, loader: java.lang.ClassLoader, /) -> java.lang.Object | None: ...
    def recycle(self) -> None: ...
    def setDataCapacity(self, size: int | java.jint | java.lang.Integer, /) -> None: ...
    def setDataPosition(self, pos: int | java.jint | java.lang.Integer, /) -> None: ...
    def setDataSize(self, size: int | java.jint | java.lang.Integer, /) -> None: ...
    def setPropagateAllowBlocking(self) -> None: ...
    def unmarshall(self, data: java.chaquopy.JavaArrayJByte, offset: int | java.jint | java.lang.Integer, length: int | java.jint | java.lang.Integer, /) -> None: ...
    def writeArray(self, val: java.chaquopy.JavaArray[java.lang.Object], /) -> None: ...
    def writeBinderArray(self, val: java.chaquopy.JavaArray[IBinder], /) -> None: ...
    def writeBinderList(self, val: java.util.List[IBinder], /) -> None: ...
    @typing.overload
    def writeBlob(self, b: java.chaquopy.JavaArrayJByte, /) -> None: ...
    @typing.overload
    def writeBlob(self, b: java.chaquopy.JavaArrayJByte, offset: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, /) -> None: ...
    def writeBoolean(self, val: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def writeBooleanArray(self, val: java.chaquopy.JavaArrayJBoolean, /) -> None: ...
    def writeBundle(self, val: Bundle, /) -> None: ...
    def writeByte(self, val: int | java.jbyte | java.lang.Byte, /) -> None: ...
    @typing.overload
    def writeByteArray(self, b: java.chaquopy.JavaArrayJByte, /) -> None: ...
    @typing.overload
    def writeByteArray(self, b: java.chaquopy.JavaArrayJByte, offset: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, /) -> None: ...
    def writeCharArray(self, val: java.chaquopy.JavaArrayJChar, /) -> None: ...
    def writeDouble(self, val: float | java.jdouble | java.lang.Double, /) -> None: ...
    def writeDoubleArray(self, val: java.chaquopy.JavaArrayJDouble, /) -> None: ...
    def writeException(self, e: java.lang.Exception, /) -> None: ...
    def writeFileDescriptor(self, val: java.io.FileDescriptor, /) -> None: ...
    def writeFixedArray(self, val: java.lang.Object, parcelableFlags: int | java.jint | java.lang.Integer, /, *dimensions: java.chaquopy.JavaArrayJInt) -> None: ...
    def writeFloat(self, val: float | java.jfloat | java.lang.Float, /) -> None: ...
    def writeFloatArray(self, val: java.chaquopy.JavaArrayJFloat, /) -> None: ...
    def writeInt(self, val: int | java.jint | java.lang.Integer, /) -> None: ...
    def writeIntArray(self, val: java.chaquopy.JavaArrayJInt, /) -> None: ...
    def writeInterfaceArray(self, val: java.chaquopy.JavaArray[java.lang.Object], /) -> None: ...
    def writeInterfaceList(self, val: java.util.List[java.lang.Object], /) -> None: ...
    def writeInterfaceToken(self, interfaceName: str | java.lang.String, /) -> None: ...
    def writeList(self, val: java.util.List, /) -> None: ...
    def writeLong(self, val: int | java.jlong | java.lang.Long, /) -> None: ...
    def writeLongArray(self, val: java.chaquopy.JavaArrayJLong, /) -> None: ...
    def writeMap(self, val: java.util.Map, /) -> None: ...
    def writeNoException(self) -> None: ...
    def writeParcelable(self, p: Parcelable, parcelableFlags: int | java.jint | java.lang.Integer, /) -> None: ...
    def writeParcelableArray(self, value: java.chaquopy.JavaArray[java.lang.Object], parcelableFlags: int | java.jint | java.lang.Integer, /) -> None: ...
    def writeParcelableCreator(self, p: Parcelable, /) -> None: ...
    def writeParcelableList(self, val: java.util.List[java.lang.Object], flags: int | java.jint | java.lang.Integer, /) -> None: ...
    def writePersistableBundle(self, val: PersistableBundle, /) -> None: ...
    def writeSerializable(self, s: java.io.Serializable, /) -> None: ...
    def writeSize(self, val: android.util.Size, /) -> None: ...
    def writeSizeF(self, val: android.util.SizeF, /) -> None: ...
    def writeSparseArray(self, val: android.util.SparseArray[java.lang.Object], /) -> None: ...
    def writeSparseBooleanArray(self, val: android.util.SparseBooleanArray, /) -> None: ...
    def writeString(self, val: str | java.lang.String, /) -> None: ...
    def writeStringArray(self, val: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def writeStringList(self, val: java.util.List[java.lang.String], /) -> None: ...
    def writeStrongBinder(self, val: IBinder, /) -> None: ...
    def writeStrongInterface(self, val: IInterface, /) -> None: ...
    def writeTypedArray(self, val: java.chaquopy.JavaArray[java.lang.Object], parcelableFlags: int | java.jint | java.lang.Integer, /) -> None: ...
    def writeTypedArrayMap(self, val: android.util.ArrayMap[java.lang.String, java.lang.Object], parcelableFlags: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def writeTypedList(self, val: java.util.List[java.lang.Object], /) -> None: ...
    @typing.overload
    def writeTypedList(self, val: java.util.List[java.lang.Object], parcelableFlags: int | java.jint | java.lang.Integer, /) -> None: ...
    def writeTypedObject(self, val: java.lang.Object, parcelableFlags: int | java.jint | java.lang.Integer, /) -> None: ...
    def writeTypedSparseArray(self, val: android.util.SparseArray[java.lang.Object], parcelableFlags: int | java.jint | java.lang.Integer, /) -> None: ...
    def writeValue(self, v: java.lang.Object | int | bool | float | str, /) -> None: ...

class ParcelFileDescriptor(Parcelable, java.io.Closeable):
    CREATOR: typing.ClassVar[Parcelable.Creator[ParcelFileDescriptor]] = ...
    MODE_APPEND: typing.ClassVar[int] = ...
    MODE_CREATE: typing.ClassVar[int] = ...
    MODE_READ_ONLY: typing.ClassVar[int] = ...
    MODE_READ_WRITE: typing.ClassVar[int] = ...
    MODE_TRUNCATE: typing.ClassVar[int] = ...
    MODE_WORLD_READABLE: typing.ClassVar[int] = ...
    MODE_WORLD_WRITEABLE: typing.ClassVar[int] = ...
    MODE_WRITE_ONLY: typing.ClassVar[int] = ...
    def __init__(self, wrapped: ParcelFileDescriptor, /) -> None: ...
    @staticmethod
    def adoptFd(fd: int | java.jint | java.lang.Integer, /) -> ParcelFileDescriptor: ...
    def canDetectErrors(self) -> bool: ...
    def checkError(self) -> None: ...
    def close(self) -> None: ...
    def closeWithError(self, msg: str | java.lang.String, /) -> None: ...
    @staticmethod
    def createPipe() -> java.chaquopy.JavaArray[ParcelFileDescriptor]: ...
    @staticmethod
    def createReliablePipe() -> java.chaquopy.JavaArray[ParcelFileDescriptor]: ...
    @staticmethod
    def createReliableSocketPair() -> java.chaquopy.JavaArray[ParcelFileDescriptor]: ...
    @staticmethod
    def createSocketPair() -> java.chaquopy.JavaArray[ParcelFileDescriptor]: ...
    def describeContents(self) -> int: ...
    def detachFd(self) -> int: ...
    @typing.overload
    def dup(self) -> ParcelFileDescriptor: ...
    @typing.overload
    @staticmethod
    def dup(orig: java.io.FileDescriptor, /) -> ParcelFileDescriptor: ...
    def finalize(self) -> None: ...
    @staticmethod
    def fromDatagramSocket(datagramSocket: java.net.DatagramSocket, /) -> ParcelFileDescriptor: ...
    @staticmethod
    def fromFd(fd: int | java.jint | java.lang.Integer, /) -> ParcelFileDescriptor: ...
    @staticmethod
    def fromSocket(socket: java.net.Socket, /) -> ParcelFileDescriptor: ...
    def getFd(self) -> int: ...
    def getFileDescriptor(self) -> java.io.FileDescriptor: ...
    def getStatSize(self) -> int: ...
    @typing.overload
    @staticmethod
    def open(file: java.io.File, mode: int | java.jint | java.lang.Integer, /) -> ParcelFileDescriptor: ...
    @typing.overload
    @staticmethod
    def open(file: java.io.File, mode: int | java.jint | java.lang.Integer, handler: Handler, listener: ParcelFileDescriptor.OnCloseListener, /) -> ParcelFileDescriptor: ...
    @staticmethod
    def parseMode(mode: str | java.lang.String, /) -> int: ...
    def toString(self) -> str: ...
    @staticmethod
    def wrap(pfd: ParcelFileDescriptor, handler: Handler, listener: ParcelFileDescriptor.OnCloseListener, /) -> ParcelFileDescriptor: ...
    def writeToParcel(self, out: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...

    class OnCloseListener(java.lang.Object):
        def onClose(self, arg1: java.io.IOException, /) -> None: ...

    class FileDescriptorDetachedException(java.io.IOException):
        def __init__(self) -> None: ...

    class AutoCloseOutputStream(java.io.FileOutputStream):
        def __init__(self, pfd: ParcelFileDescriptor, /) -> None: ...
        def close(self) -> None: ...

    class AutoCloseInputStream(java.io.FileInputStream):
        def __init__(self, pfd: ParcelFileDescriptor, /) -> None: ...
        def close(self) -> None: ...
        @typing.overload
        def read(self) -> int: ...
        @typing.overload
        def read(self, b: java.chaquopy.JavaArrayJByte, /) -> int: ...
        @typing.overload
        def read(self, b: java.chaquopy.JavaArrayJByte, off: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, /) -> int: ...

class ParcelFormatException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, reason: str | java.lang.String, /) -> None: ...

class ParcelUuid(Parcelable):
    CREATOR: typing.ClassVar[Parcelable.Creator[ParcelUuid]] = ...
    def __init__(self, uuid: java.util.UUID, /) -> None: ...
    def describeContents(self) -> int: ...
    def equals(self, object: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def fromString(uuid: str | java.lang.String, /) -> ParcelUuid: ...
    def getUuid(self) -> java.util.UUID: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...
    def writeToParcel(self, dest: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...


_Parcelable__Creator__T = typing.TypeVar('_Parcelable__Creator__T')  # <T>

_Parcelable__ClassLoaderCreator__T = typing.TypeVar('_Parcelable__ClassLoaderCreator__T')  # <T>
class Parcelable(java.lang.Object):
    CONTENTS_FILE_DESCRIPTOR: typing.ClassVar[int] = ...
    PARCELABLE_WRITE_RETURN_VALUE: typing.ClassVar[int] = ...
    def describeContents(self) -> int: ...
    def writeToParcel(self, arg1: Parcel, arg2: int | java.jint | java.lang.Integer, /) -> None: ...
    class Creator(java.lang.Object, typing.Generic[_Parcelable__Creator__T]):
        def createFromParcel(self, arg1: Parcel, /) -> _Parcelable__Creator__T: ...
        def newArray(self, arg1: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArray[_Parcelable__Creator__T]: ...
    class ClassLoaderCreator(android.os.Parcelable.Creator[_Parcelable__ClassLoaderCreator__T], typing.Generic[_Parcelable__ClassLoaderCreator__T]):
        def createFromParcel(self, arg1: Parcel, arg2: java.lang.ClassLoader, /) -> _Parcelable__ClassLoaderCreator__T: ...

class PatternMatcher(Parcelable):
    CREATOR: typing.ClassVar[Parcelable.Creator[PatternMatcher]] = ...
    PATTERN_ADVANCED_GLOB: typing.ClassVar[int] = ...
    PATTERN_LITERAL: typing.ClassVar[int] = ...
    PATTERN_PREFIX: typing.ClassVar[int] = ...
    PATTERN_SIMPLE_GLOB: typing.ClassVar[int] = ...
    PATTERN_SUFFIX: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, src: Parcel, /) -> None: ...
    @typing.overload
    def __init__(self, pattern: str | java.lang.String, type: int | java.jint | java.lang.Integer, /) -> None: ...
    def describeContents(self) -> int: ...
    def getPath(self) -> str: ...
    def getType(self) -> int: ...
    def match(self, str: str | java.lang.String, /) -> bool: ...
    def toString(self) -> str: ...
    def writeToParcel(self, dest: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...

class PerformanceHintManager(java.lang.Object):
    def createHintSession(self, tids: java.chaquopy.JavaArrayJInt, initialTargetWorkDurationNanos: int | java.jlong | java.lang.Long, /) -> PerformanceHintManager.Session | None: ...
    def getPreferredUpdateRateNanos(self) -> int: ...

    class Session(java.io.Closeable):
        def close(self) -> None: ...
        def finalize(self) -> None: ...
        @typing.overload
        def reportActualWorkDuration(self, actualDurationNanos: int | java.jlong | java.lang.Long, /) -> None: ...
        @typing.overload
        def reportActualWorkDuration(self, workDuration: WorkDuration, /) -> None: ...
        def setPreferPowerEfficiency(self, enabled: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
        def setThreads(self, tids: java.chaquopy.JavaArrayJInt, /) -> None: ...
        def updateTargetWorkDuration(self, targetDurationNanos: int | java.jlong | java.lang.Long, /) -> None: ...

class PersistableBundle(BaseBundle, java.lang.Cloneable, Parcelable):
    CREATOR: typing.ClassVar[Parcelable.Creator[PersistableBundle]] = ...
    EMPTY: typing.ClassVar[PersistableBundle] = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, capacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, b: PersistableBundle, /) -> None: ...
    def clone(self) -> java.lang.Object: ...
    def deepCopy(self) -> PersistableBundle: ...
    def describeContents(self) -> int: ...
    def getPersistableBundle(self, key: str | java.lang.String, /) -> PersistableBundle | None: ...
    def putPersistableBundle(self, key: str | java.lang.String, value: PersistableBundle, /) -> None: ...
    @staticmethod
    def readFromStream(inputStream: java.io.InputStream, /) -> PersistableBundle: ...
    def toString(self) -> str: ...
    def writeToParcel(self, parcel: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...
    def writeToStream(self, outputStream: java.io.OutputStream, /) -> None: ...

class PowerManager(java.lang.Object):
    ACQUIRE_CAUSES_WAKEUP: typing.ClassVar[int] = ...
    ACTION_DEVICE_IDLE_MODE_CHANGED: typing.ClassVar[str] = ...
    ACTION_DEVICE_LIGHT_IDLE_MODE_CHANGED: typing.ClassVar[str] = ...
    ACTION_LOW_POWER_STANDBY_ENABLED_CHANGED: typing.ClassVar[str] = ...
    ACTION_LOW_POWER_STANDBY_POLICY_CHANGED: typing.ClassVar[str] = ...
    ACTION_POWER_SAVE_MODE_CHANGED: typing.ClassVar[str] = ...
    FEATURE_WAKE_ON_LAN_IN_LOW_POWER_STANDBY: typing.ClassVar[str] = ...
    FULL_WAKE_LOCK: typing.ClassVar[int] = ...
    LOCATION_MODE_ALL_DISABLED_WHEN_SCREEN_OFF: typing.ClassVar[int] = ...
    LOCATION_MODE_FOREGROUND_ONLY: typing.ClassVar[int] = ...
    LOCATION_MODE_GPS_DISABLED_WHEN_SCREEN_OFF: typing.ClassVar[int] = ...
    LOCATION_MODE_NO_CHANGE: typing.ClassVar[int] = ...
    LOCATION_MODE_THROTTLE_REQUESTS_WHEN_SCREEN_OFF: typing.ClassVar[int] = ...
    LOW_POWER_STANDBY_ALLOWED_REASON_ONGOING_CALL: typing.ClassVar[int] = ...
    LOW_POWER_STANDBY_ALLOWED_REASON_TEMP_POWER_SAVE_ALLOWLIST: typing.ClassVar[int] = ...
    LOW_POWER_STANDBY_ALLOWED_REASON_VOICE_INTERACTION: typing.ClassVar[int] = ...
    ON_AFTER_RELEASE: typing.ClassVar[int] = ...
    PARTIAL_WAKE_LOCK: typing.ClassVar[int] = ...
    PROXIMITY_SCREEN_OFF_WAKE_LOCK: typing.ClassVar[int] = ...
    RELEASE_FLAG_WAIT_FOR_NO_PROXIMITY: typing.ClassVar[int] = ...
    SCREEN_BRIGHT_WAKE_LOCK: typing.ClassVar[int] = ...
    SCREEN_DIM_WAKE_LOCK: typing.ClassVar[int] = ...
    THERMAL_STATUS_CRITICAL: typing.ClassVar[int] = ...
    THERMAL_STATUS_EMERGENCY: typing.ClassVar[int] = ...
    THERMAL_STATUS_LIGHT: typing.ClassVar[int] = ...
    THERMAL_STATUS_MODERATE: typing.ClassVar[int] = ...
    THERMAL_STATUS_NONE: typing.ClassVar[int] = ...
    THERMAL_STATUS_SEVERE: typing.ClassVar[int] = ...
    THERMAL_STATUS_SHUTDOWN: typing.ClassVar[int] = ...
    @typing.overload
    def addThermalStatusListener(self, listener: PowerManager.OnThermalStatusChangedListener, /) -> None: ...
    @typing.overload
    def addThermalStatusListener(self, executor: java.util.concurrent.Executor, listener: PowerManager.OnThermalStatusChangedListener, /) -> None: ...
    def getBatteryDischargePrediction(self) -> java.time.Duration | None: ...
    def getCurrentThermalStatus(self) -> int: ...
    def getLocationPowerSaveMode(self) -> int: ...
    def getThermalHeadroom(self, forecastSeconds: int | java.jint | java.lang.Integer, /) -> float: ...
    def getThermalHeadroomThresholds(self) -> java.util.Map[java.lang.Integer, java.lang.Float]: ...
    @typing.overload
    def isAllowedInLowPowerStandby(self, reason: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    def isAllowedInLowPowerStandby(self, feature: str | java.lang.String, /) -> bool: ...
    def isBatteryDischargePredictionPersonalized(self) -> bool: ...
    def isDeviceIdleMode(self) -> bool: ...
    def isDeviceLightIdleMode(self) -> bool: ...
    def isExemptFromLowPowerStandby(self) -> bool: ...
    def isIgnoringBatteryOptimizations(self, packageName: str | java.lang.String, /) -> bool: ...
    def isInteractive(self) -> bool: ...
    def isLowPowerStandbyEnabled(self) -> bool: ...
    def isPowerSaveMode(self) -> bool: ...
    def isRebootingUserspaceSupported(self) -> bool: ...
    def isScreenOn(self) -> bool: ...
    def isSustainedPerformanceModeSupported(self) -> bool: ...
    def isWakeLockLevelSupported(self, level: int | java.jint | java.lang.Integer, /) -> bool: ...
    def newWakeLock(self, levelAndFlags: int | java.jint | java.lang.Integer, tag: str | java.lang.String, /) -> PowerManager.WakeLock: ...
    def reboot(self, reason: str | java.lang.String, /) -> None: ...
    def removeThermalStatusListener(self, listener: PowerManager.OnThermalStatusChangedListener, /) -> None: ...

    class WakeLockStateListener(java.lang.Object):
        def onStateChanged(self, arg1: bool | java.jboolean | java.lang.Boolean, /) -> None: ...

    class WakeLock(java.lang.Object):
        @typing.overload
        def acquire(self) -> None: ...
        @typing.overload
        def acquire(self, timeout: int | java.jlong | java.lang.Long, /) -> None: ...
        def finalize(self) -> None: ...
        def isHeld(self) -> bool: ...
        @typing.overload
        def release(self) -> None: ...
        @typing.overload
        def release(self, flags: int | java.jint | java.lang.Integer, /) -> None: ...
        def setReferenceCounted(self, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
        def setStateListener(self, executor: java.util.concurrent.Executor, listener: PowerManager.WakeLockStateListener, /) -> None: ...
        def setWorkSource(self, ws: WorkSource, /) -> None: ...
        def toString(self) -> str: ...

    class OnThermalStatusChangedListener(java.lang.Object):
        def onThermalStatusChanged(self, arg1: int | java.jint | java.lang.Integer, /) -> None: ...

class PowerMonitor(Parcelable):
    CREATOR: typing.ClassVar[Parcelable.Creator[PowerMonitor]] = ...
    POWER_MONITOR_TYPE_CONSUMER: typing.ClassVar[int] = ...
    POWER_MONITOR_TYPE_MEASUREMENT: typing.ClassVar[int] = ...
    def describeContents(self) -> int: ...
    def getName(self) -> str: ...
    def getType(self) -> int: ...
    def writeToParcel(self, dest: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...

class PowerMonitorReadings(java.lang.Object):
    ENERGY_UNAVAILABLE: typing.ClassVar[int] = ...
    def getConsumedEnergy(self, powerMonitor: PowerMonitor, /) -> int: ...
    def getTimestampMillis(self, powerMonitor: PowerMonitor, /) -> int: ...
    def toString(self) -> str: ...

class Process(java.lang.Object):
    BLUETOOTH_UID: typing.ClassVar[int] = ...
    FIRST_APPLICATION_UID: typing.ClassVar[int] = ...
    INVALID_PID: typing.ClassVar[int] = ...
    INVALID_UID: typing.ClassVar[int] = ...
    LAST_APPLICATION_UID: typing.ClassVar[int] = ...
    PHONE_UID: typing.ClassVar[int] = ...
    ROOT_UID: typing.ClassVar[int] = ...
    SHELL_UID: typing.ClassVar[int] = ...
    SIGNAL_KILL: typing.ClassVar[int] = ...
    SIGNAL_QUIT: typing.ClassVar[int] = ...
    SIGNAL_USR1: typing.ClassVar[int] = ...
    SYSTEM_UID: typing.ClassVar[int] = ...
    THREAD_PRIORITY_AUDIO: typing.ClassVar[int] = ...
    THREAD_PRIORITY_BACKGROUND: typing.ClassVar[int] = ...
    THREAD_PRIORITY_DEFAULT: typing.ClassVar[int] = ...
    THREAD_PRIORITY_DISPLAY: typing.ClassVar[int] = ...
    THREAD_PRIORITY_FOREGROUND: typing.ClassVar[int] = ...
    THREAD_PRIORITY_LESS_FAVORABLE: typing.ClassVar[int] = ...
    THREAD_PRIORITY_LOWEST: typing.ClassVar[int] = ...
    THREAD_PRIORITY_MORE_FAVORABLE: typing.ClassVar[int] = ...
    THREAD_PRIORITY_URGENT_AUDIO: typing.ClassVar[int] = ...
    THREAD_PRIORITY_URGENT_DISPLAY: typing.ClassVar[int] = ...
    THREAD_PRIORITY_VIDEO: typing.ClassVar[int] = ...
    WIFI_UID: typing.ClassVar[int] = ...
    def __init__(self) -> None: ...
    @staticmethod
    def getAppUidForSdkSandboxUid(uid: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def getElapsedCpuTime() -> int: ...
    @staticmethod
    def getExclusiveCores() -> java.chaquopy.JavaArrayJInt: ...
    @staticmethod
    def getGidForName(arg1: str | java.lang.String, /) -> int: ...
    @staticmethod
    def getSdkSandboxUidForAppUid(uid: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def getStartElapsedRealtime() -> int: ...
    @staticmethod
    def getStartRequestedElapsedRealtime() -> int: ...
    @staticmethod
    def getStartRequestedUptimeMillis() -> int: ...
    @staticmethod
    def getStartUptimeMillis() -> int: ...
    @staticmethod
    def getThreadPriority(arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def getUidForName(arg1: str | java.lang.String, /) -> int: ...
    @staticmethod
    def is64Bit() -> bool: ...
    @staticmethod
    def isApplicationUid(uid: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def isIsolated() -> bool: ...
    @staticmethod
    def isIsolatedUid(uid: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def isSdkSandbox() -> bool: ...
    @staticmethod
    def isSdkSandboxUid(uid: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def killProcess(pid: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def myPid() -> int: ...
    @staticmethod
    def myProcessName() -> str: ...
    @staticmethod
    def myTid() -> int: ...
    @staticmethod
    def myUid() -> int: ...
    @staticmethod
    def myUserHandle() -> UserHandle: ...
    @staticmethod
    def sendSignal(arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def setThreadPriority(arg1: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def setThreadPriority(arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def supportsProcesses() -> bool: ...

class ProfilingManager(java.lang.Object):
    PROFILING_TYPE_HEAP_PROFILE: typing.ClassVar[int] = ...
    PROFILING_TYPE_JAVA_HEAP_DUMP: typing.ClassVar[int] = ...
    PROFILING_TYPE_STACK_SAMPLING: typing.ClassVar[int] = ...
    PROFILING_TYPE_SYSTEM_TRACE: typing.ClassVar[int] = ...
    def registerForAllProfilingResults(self, executor: java.util.concurrent.Executor, listener: java.util.function.Consumer[ProfilingResult], /) -> None: ...
    def requestProfiling(self, profilingType: int | java.jint | java.lang.Integer, parameters: Bundle, tag: str | java.lang.String, cancellationSignal: CancellationSignal, executor: java.util.concurrent.Executor, listener: java.util.function.Consumer[ProfilingResult], /) -> None: ...
    def unregisterForAllProfilingResults(self, listener: java.util.function.Consumer[ProfilingResult], /) -> None: ...

class ProfilingResult(Parcelable):
    CREATOR: typing.ClassVar[Parcelable.Creator[ProfilingResult]] = ...
    ERROR_FAILED_EXECUTING: typing.ClassVar[int] = ...
    ERROR_FAILED_INVALID_REQUEST: typing.ClassVar[int] = ...
    ERROR_FAILED_NO_DISK_SPACE: typing.ClassVar[int] = ...
    ERROR_FAILED_POST_PROCESSING: typing.ClassVar[int] = ...
    ERROR_FAILED_PROFILING_IN_PROGRESS: typing.ClassVar[int] = ...
    ERROR_FAILED_RATE_LIMIT_PROCESS: typing.ClassVar[int] = ...
    ERROR_FAILED_RATE_LIMIT_SYSTEM: typing.ClassVar[int] = ...
    ERROR_NONE: typing.ClassVar[int] = ...
    ERROR_UNKNOWN: typing.ClassVar[int] = ...
    def describeContents(self) -> int: ...
    def getErrorCode(self) -> int: ...
    def getErrorMessage(self) -> str | None: ...
    def getResultFilePath(self) -> str | None: ...
    def getTag(self) -> str | None: ...
    def writeToParcel(self, dest: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...

class ProxyFileDescriptorCallback(java.lang.Object):
    def __init__(self) -> None: ...
    def onFsync(self) -> None: ...
    def onGetSize(self) -> int: ...
    def onRead(self, offset: int | java.jlong | java.lang.Long, size: int | java.jint | java.lang.Integer, data: java.chaquopy.JavaArrayJByte, /) -> int: ...
    def onRelease(self) -> None: ...
    def onWrite(self, offset: int | java.jlong | java.lang.Long, size: int | java.jint | java.lang.Integer, data: java.chaquopy.JavaArrayJByte, /) -> int: ...

class RecoverySystem(java.lang.Object):
    @staticmethod
    def installPackage(context: android.content.Context, packageFile: java.io.File, /) -> None: ...
    @staticmethod
    def rebootWipeCache(context: android.content.Context, /) -> None: ...
    @staticmethod
    def rebootWipeUserData(context: android.content.Context, /) -> None: ...
    @staticmethod
    def verifyPackage(packageFile: java.io.File, listener: RecoverySystem.ProgressListener, deviceCertsZipFile: java.io.File, /) -> None: ...

    class ProgressListener(java.lang.Object):
        def onProgress(self, arg1: int | java.jint | java.lang.Integer, /) -> None: ...

_RemoteCallbackList__E = typing.TypeVar('_RemoteCallbackList__E')  # <E>
class RemoteCallbackList(java.lang.Object, typing.Generic[_RemoteCallbackList__E]):
    def __init__(self) -> None: ...
    def beginBroadcast(self) -> int: ...
    def finishBroadcast(self) -> None: ...
    def getBroadcastCookie(self, index: int | java.jint | java.lang.Integer, /) -> java.lang.Object: ...
    def getBroadcastItem(self, index: int | java.jint | java.lang.Integer, /) -> _RemoteCallbackList__E: ...
    def getRegisteredCallbackCookie(self, index: int | java.jint | java.lang.Integer, /) -> java.lang.Object | None: ...
    def getRegisteredCallbackCount(self) -> int: ...
    def getRegisteredCallbackItem(self, index: int | java.jint | java.lang.Integer, /) -> _RemoteCallbackList__E | None: ...
    def kill(self) -> None: ...
    @typing.overload
    def onCallbackDied(self, callback: _RemoteCallbackList__E, /) -> None: ...
    @typing.overload
    def onCallbackDied(self, callback: _RemoteCallbackList__E, cookie: java.lang.Object | int | bool | float | str, /) -> None: ...
    @typing.overload
    def register(self, callback: _RemoteCallbackList__E, /) -> bool: ...
    @typing.overload
    def register(self, callback: _RemoteCallbackList__E, cookie: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def unregister(self, callback: _RemoteCallbackList__E, /) -> bool: ...

class RemoteException(android.util.AndroidException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, message: str | java.lang.String, /) -> None: ...
    def rethrowAsRuntimeException(self) -> java.lang.RuntimeException: ...
    def rethrowFromSystemServer(self) -> java.lang.RuntimeException: ...

class ResultReceiver(Parcelable):
    CREATOR: typing.ClassVar[Parcelable.Creator[ResultReceiver]] = ...
    def __init__(self, handler: Handler, /) -> None: ...
    def describeContents(self) -> int: ...
    def onReceiveResult(self, resultCode: int | java.jint | java.lang.Integer, resultData: Bundle, /) -> None: ...
    def send(self, resultCode: int | java.jint | java.lang.Integer, resultData: Bundle, /) -> None: ...
    def writeToParcel(self, out: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...

class SecurityStateManager(java.lang.Object):
    KEY_KERNEL_VERSION: typing.ClassVar[str] = ...
    KEY_SYSTEM_SPL: typing.ClassVar[str] = ...
    KEY_VENDOR_SPL: typing.ClassVar[str] = ...
    def getGlobalSecurityState(self) -> Bundle: ...

class SharedMemory(Parcelable, java.io.Closeable):
    CREATOR: typing.ClassVar[Parcelable.Creator[SharedMemory]] = ...
    def close(self) -> None: ...
    @staticmethod
    def create(name: str | java.lang.String, size: int | java.jint | java.lang.Integer, /) -> SharedMemory: ...
    def describeContents(self) -> int: ...
    @staticmethod
    def fromFileDescriptor(fd: ParcelFileDescriptor, /) -> SharedMemory: ...
    def getSize(self) -> int: ...
    def map(self, prot: int | java.jint | java.lang.Integer, offset: int | java.jint | java.lang.Integer, length: int | java.jint | java.lang.Integer, /) -> java.nio.ByteBuffer: ...
    def mapReadOnly(self) -> java.nio.ByteBuffer: ...
    def mapReadWrite(self) -> java.nio.ByteBuffer: ...
    def setProtect(self, prot: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def unmap(buffer: java.nio.ByteBuffer, /) -> None: ...
    def writeToParcel(self, dest: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...

class StatFs(java.lang.Object):
    def __init__(self, path: str | java.lang.String, /) -> None: ...
    def getAvailableBlocks(self) -> int: ...
    def getAvailableBlocksLong(self) -> int: ...
    def getAvailableBytes(self) -> int: ...
    def getBlockCount(self) -> int: ...
    def getBlockCountLong(self) -> int: ...
    def getBlockSize(self) -> int: ...
    def getBlockSizeLong(self) -> int: ...
    def getFreeBlocks(self) -> int: ...
    def getFreeBlocksLong(self) -> int: ...
    def getFreeBytes(self) -> int: ...
    def getTotalBytes(self) -> int: ...
    def restat(self, path: str | java.lang.String, /) -> None: ...

class StrictMode(java.lang.Object):
    @staticmethod
    def allowThreadDiskReads() -> StrictMode.ThreadPolicy: ...
    @staticmethod
    def allowThreadDiskWrites() -> StrictMode.ThreadPolicy: ...
    @staticmethod
    def enableDefaults() -> None: ...
    @staticmethod
    def getThreadPolicy() -> StrictMode.ThreadPolicy: ...
    @staticmethod
    def getVmPolicy() -> StrictMode.VmPolicy: ...
    @staticmethod
    def noteSlowCall(name: str | java.lang.String, /) -> None: ...
    @staticmethod
    def setThreadPolicy(policy: StrictMode.ThreadPolicy, /) -> None: ...
    @staticmethod
    def setVmPolicy(policy: StrictMode.VmPolicy, /) -> None: ...

    class VmPolicy(java.lang.Object):
        LAX: typing.ClassVar[StrictMode.VmPolicy] = ...
        def toString(self) -> str: ...

        class Builder(java.lang.Object):
            @typing.overload
            def __init__(self) -> None: ...
            @typing.overload
            def __init__(self, base: StrictMode.VmPolicy, /) -> None: ...
            def build(self) -> StrictMode.VmPolicy: ...
            def detectActivityLeaks(self) -> StrictMode.VmPolicy.Builder: ...
            def detectAll(self) -> StrictMode.VmPolicy.Builder: ...
            def detectCleartextNetwork(self) -> StrictMode.VmPolicy.Builder: ...
            def detectContentUriWithoutPermission(self) -> StrictMode.VmPolicy.Builder: ...
            def detectCredentialProtectedWhileLocked(self) -> StrictMode.VmPolicy.Builder: ...
            def detectFileUriExposure(self) -> StrictMode.VmPolicy.Builder: ...
            def detectImplicitDirectBoot(self) -> StrictMode.VmPolicy.Builder: ...
            def detectIncorrectContextUse(self) -> StrictMode.VmPolicy.Builder: ...
            def detectLeakedClosableObjects(self) -> StrictMode.VmPolicy.Builder: ...
            def detectLeakedRegistrationObjects(self) -> StrictMode.VmPolicy.Builder: ...
            def detectLeakedSqlLiteObjects(self) -> StrictMode.VmPolicy.Builder: ...
            def detectNonSdkApiUsage(self) -> StrictMode.VmPolicy.Builder: ...
            def detectUnsafeIntentLaunch(self) -> StrictMode.VmPolicy.Builder: ...
            def detectUntaggedSockets(self) -> StrictMode.VmPolicy.Builder: ...
            def penaltyDeath(self) -> StrictMode.VmPolicy.Builder: ...
            def penaltyDeathOnCleartextNetwork(self) -> StrictMode.VmPolicy.Builder: ...
            def penaltyDeathOnFileUriExposure(self) -> StrictMode.VmPolicy.Builder: ...
            def penaltyDropBox(self) -> StrictMode.VmPolicy.Builder: ...
            def penaltyListener(self, executor: java.util.concurrent.Executor, listener: StrictMode.OnVmViolationListener, /) -> StrictMode.VmPolicy.Builder: ...
            def penaltyLog(self) -> StrictMode.VmPolicy.Builder: ...
            def permitNonSdkApiUsage(self) -> StrictMode.VmPolicy.Builder: ...
            def permitUnsafeIntentLaunch(self) -> StrictMode.VmPolicy.Builder: ...
            def setClassInstanceLimit(self, klass: typing.Type, instanceLimit: int | java.jint | java.lang.Integer, /) -> StrictMode.VmPolicy.Builder: ...

    class ThreadPolicy(java.lang.Object):
        LAX: typing.ClassVar[StrictMode.ThreadPolicy] = ...
        def toString(self) -> str: ...

        class Builder(java.lang.Object):
            @typing.overload
            def __init__(self) -> None: ...
            @typing.overload
            def __init__(self, policy: StrictMode.ThreadPolicy, /) -> None: ...
            def build(self) -> StrictMode.ThreadPolicy: ...
            def detectAll(self) -> StrictMode.ThreadPolicy.Builder: ...
            def detectCustomSlowCalls(self) -> StrictMode.ThreadPolicy.Builder: ...
            def detectDiskReads(self) -> StrictMode.ThreadPolicy.Builder: ...
            def detectDiskWrites(self) -> StrictMode.ThreadPolicy.Builder: ...
            def detectExplicitGc(self) -> StrictMode.ThreadPolicy.Builder: ...
            def detectNetwork(self) -> StrictMode.ThreadPolicy.Builder: ...
            def detectResourceMismatches(self) -> StrictMode.ThreadPolicy.Builder: ...
            def detectUnbufferedIo(self) -> StrictMode.ThreadPolicy.Builder: ...
            def penaltyDeath(self) -> StrictMode.ThreadPolicy.Builder: ...
            def penaltyDeathOnNetwork(self) -> StrictMode.ThreadPolicy.Builder: ...
            def penaltyDialog(self) -> StrictMode.ThreadPolicy.Builder: ...
            def penaltyDropBox(self) -> StrictMode.ThreadPolicy.Builder: ...
            def penaltyFlashScreen(self) -> StrictMode.ThreadPolicy.Builder: ...
            def penaltyListener(self, executor: java.util.concurrent.Executor, listener: StrictMode.OnThreadViolationListener, /) -> StrictMode.ThreadPolicy.Builder: ...
            def penaltyLog(self) -> StrictMode.ThreadPolicy.Builder: ...
            def permitAll(self) -> StrictMode.ThreadPolicy.Builder: ...
            def permitCustomSlowCalls(self) -> StrictMode.ThreadPolicy.Builder: ...
            def permitDiskReads(self) -> StrictMode.ThreadPolicy.Builder: ...
            def permitDiskWrites(self) -> StrictMode.ThreadPolicy.Builder: ...
            def permitExplicitGc(self) -> StrictMode.ThreadPolicy.Builder: ...
            def permitNetwork(self) -> StrictMode.ThreadPolicy.Builder: ...
            def permitResourceMismatches(self) -> StrictMode.ThreadPolicy.Builder: ...
            def permitUnbufferedIo(self) -> StrictMode.ThreadPolicy.Builder: ...

    class OnVmViolationListener(java.lang.Object):
        def onVmViolation(self, arg1: android.os.strictmode.Violation, /) -> None: ...

    class OnThreadViolationListener(java.lang.Object):
        def onThreadViolation(self, arg1: android.os.strictmode.Violation, /) -> None: ...

class SystemClock(java.lang.Object):
    @staticmethod
    def currentGnssTimeClock() -> java.time.Clock: ...
    @staticmethod
    def currentNetworkTimeClock() -> java.time.Clock: ...
    @staticmethod
    def currentThreadTimeMillis() -> int: ...
    @staticmethod
    def elapsedRealtime() -> int: ...
    @staticmethod
    def elapsedRealtimeNanos() -> int: ...
    @staticmethod
    def setCurrentTimeMillis(millis: int | java.jlong | java.lang.Long, /) -> bool: ...
    @staticmethod
    def sleep(ms: int | java.jlong | java.lang.Long, /) -> None: ...
    @staticmethod
    def uptimeMillis() -> int: ...
    @staticmethod
    def uptimeNanos() -> int: ...

class TestLooperManager(java.lang.Object):
    def execute(self, message: Message, /) -> None: ...
    def getMessageQueue(self) -> MessageQueue: ...
    @typing.overload
    def hasMessages(self, h: Handler, object: java.lang.Object | int | bool | float | str, what: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    def hasMessages(self, h: Handler, object: java.lang.Object | int | bool | float | str, r: java.lang.Runnable, /) -> bool: ...
    def next(self) -> Message: ...
    def recycle(self, msg: Message, /) -> None: ...
    def release(self) -> None: ...

class TokenWatcher(java.lang.Object):
    def __init__(self, h: Handler, tag: str | java.lang.String, /) -> None: ...
    def acquire(self, token: IBinder, tag: str | java.lang.String, /) -> None: ...
    def acquired(self) -> None: ...
    def cleanup(self, token: IBinder, unlink: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def dump(self) -> None: ...
    @typing.overload
    def dump(self, pw: java.io.PrintWriter, /) -> None: ...
    def isAcquired(self) -> bool: ...
    def release(self, token: IBinder, /) -> None: ...
    def released(self) -> None: ...

class Trace(java.lang.Object):
    @staticmethod
    def beginAsyncSection(methodName: str | java.lang.String, cookie: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def beginSection(sectionName: str | java.lang.String, /) -> None: ...
    @staticmethod
    def endAsyncSection(methodName: str | java.lang.String, cookie: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def endSection() -> None: ...
    @staticmethod
    def isEnabled() -> bool: ...
    @staticmethod
    def setCounter(counterName: str | java.lang.String, counterValue: int | java.jlong | java.lang.Long, /) -> None: ...

class TransactionTooLargeException(RemoteException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, msg: str | java.lang.String, /) -> None: ...

class UserHandle(Parcelable):
    CREATOR: typing.ClassVar[Parcelable.Creator[UserHandle]] = ...
    def __init__(self, in_: Parcel, /) -> None: ...
    def describeContents(self) -> int: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @staticmethod
    def getUserHandleForUid(uid: int | java.jint | java.lang.Integer, /) -> UserHandle: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def readFromParcel(in_: Parcel, /) -> UserHandle | None: ...
    def toString(self) -> str: ...
    @typing.overload
    def writeToParcel(self, out: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    @staticmethod
    def writeToParcel(h: UserHandle, out: Parcel, /) -> None: ...

class UserManager(java.lang.Object):
    ALLOW_PARENT_PROFILE_APP_LINKING: typing.ClassVar[str] = ...
    DISALLOW_ADD_MANAGED_PROFILE: typing.ClassVar[str] = ...
    DISALLOW_ADD_PRIVATE_PROFILE: typing.ClassVar[str] = ...
    DISALLOW_ADD_USER: typing.ClassVar[str] = ...
    DISALLOW_ADD_WIFI_CONFIG: typing.ClassVar[str] = ...
    DISALLOW_ADJUST_VOLUME: typing.ClassVar[str] = ...
    DISALLOW_AIRPLANE_MODE: typing.ClassVar[str] = ...
    DISALLOW_AMBIENT_DISPLAY: typing.ClassVar[str] = ...
    DISALLOW_APPS_CONTROL: typing.ClassVar[str] = ...
    DISALLOW_ASSIST_CONTENT: typing.ClassVar[str] = ...
    DISALLOW_AUTOFILL: typing.ClassVar[str] = ...
    DISALLOW_BLUETOOTH: typing.ClassVar[str] = ...
    DISALLOW_BLUETOOTH_SHARING: typing.ClassVar[str] = ...
    DISALLOW_CAMERA_TOGGLE: typing.ClassVar[str] = ...
    DISALLOW_CELLULAR_2G: typing.ClassVar[str] = ...
    DISALLOW_CHANGE_WIFI_STATE: typing.ClassVar[str] = ...
    DISALLOW_CONFIG_BLUETOOTH: typing.ClassVar[str] = ...
    DISALLOW_CONFIG_BRIGHTNESS: typing.ClassVar[str] = ...
    DISALLOW_CONFIG_CELL_BROADCASTS: typing.ClassVar[str] = ...
    DISALLOW_CONFIG_CREDENTIALS: typing.ClassVar[str] = ...
    DISALLOW_CONFIG_DATE_TIME: typing.ClassVar[str] = ...
    DISALLOW_CONFIG_DEFAULT_APPS: typing.ClassVar[str] = ...
    DISALLOW_CONFIG_LOCALE: typing.ClassVar[str] = ...
    DISALLOW_CONFIG_LOCATION: typing.ClassVar[str] = ...
    DISALLOW_CONFIG_MOBILE_NETWORKS: typing.ClassVar[str] = ...
    DISALLOW_CONFIG_PRIVATE_DNS: typing.ClassVar[str] = ...
    DISALLOW_CONFIG_SCREEN_TIMEOUT: typing.ClassVar[str] = ...
    DISALLOW_CONFIG_TETHERING: typing.ClassVar[str] = ...
    DISALLOW_CONFIG_VPN: typing.ClassVar[str] = ...
    DISALLOW_CONFIG_WIFI: typing.ClassVar[str] = ...
    DISALLOW_CONTENT_CAPTURE: typing.ClassVar[str] = ...
    DISALLOW_CONTENT_SUGGESTIONS: typing.ClassVar[str] = ...
    DISALLOW_CREATE_WINDOWS: typing.ClassVar[str] = ...
    DISALLOW_CROSS_PROFILE_COPY_PASTE: typing.ClassVar[str] = ...
    DISALLOW_DATA_ROAMING: typing.ClassVar[str] = ...
    DISALLOW_DEBUGGING_FEATURES: typing.ClassVar[str] = ...
    DISALLOW_FACTORY_RESET: typing.ClassVar[str] = ...
    DISALLOW_FUN: typing.ClassVar[str] = ...
    DISALLOW_GRANT_ADMIN: typing.ClassVar[str] = ...
    DISALLOW_INSTALL_APPS: typing.ClassVar[str] = ...
    DISALLOW_INSTALL_UNKNOWN_SOURCES: typing.ClassVar[str] = ...
    DISALLOW_INSTALL_UNKNOWN_SOURCES_GLOBALLY: typing.ClassVar[str] = ...
    DISALLOW_MICROPHONE_TOGGLE: typing.ClassVar[str] = ...
    DISALLOW_MODIFY_ACCOUNTS: typing.ClassVar[str] = ...
    DISALLOW_MOUNT_PHYSICAL_MEDIA: typing.ClassVar[str] = ...
    DISALLOW_NEAR_FIELD_COMMUNICATION_RADIO: typing.ClassVar[str] = ...
    DISALLOW_NETWORK_RESET: typing.ClassVar[str] = ...
    DISALLOW_OUTGOING_BEAM: typing.ClassVar[str] = ...
    DISALLOW_OUTGOING_CALLS: typing.ClassVar[str] = ...
    DISALLOW_PRINTING: typing.ClassVar[str] = ...
    DISALLOW_REMOVE_MANAGED_PROFILE: typing.ClassVar[str] = ...
    DISALLOW_REMOVE_USER: typing.ClassVar[str] = ...
    DISALLOW_SAFE_BOOT: typing.ClassVar[str] = ...
    DISALLOW_SET_USER_ICON: typing.ClassVar[str] = ...
    DISALLOW_SET_WALLPAPER: typing.ClassVar[str] = ...
    DISALLOW_SHARE_INTO_MANAGED_PROFILE: typing.ClassVar[str] = ...
    DISALLOW_SHARE_LOCATION: typing.ClassVar[str] = ...
    DISALLOW_SHARING_ADMIN_CONFIGURED_WIFI: typing.ClassVar[str] = ...
    DISALLOW_SIM_GLOBALLY: typing.ClassVar[str] = ...
    DISALLOW_SMS: typing.ClassVar[str] = ...
    DISALLOW_SYSTEM_ERROR_DIALOGS: typing.ClassVar[str] = ...
    DISALLOW_ULTRA_WIDEBAND_RADIO: typing.ClassVar[str] = ...
    DISALLOW_UNIFIED_PASSWORD: typing.ClassVar[str] = ...
    DISALLOW_UNINSTALL_APPS: typing.ClassVar[str] = ...
    DISALLOW_UNMUTE_MICROPHONE: typing.ClassVar[str] = ...
    DISALLOW_USB_FILE_TRANSFER: typing.ClassVar[str] = ...
    DISALLOW_USER_SWITCH: typing.ClassVar[str] = ...
    DISALLOW_WIFI_DIRECT: typing.ClassVar[str] = ...
    DISALLOW_WIFI_TETHERING: typing.ClassVar[str] = ...
    ENSURE_VERIFY_APPS: typing.ClassVar[str] = ...
    KEY_RESTRICTIONS_PENDING: typing.ClassVar[str] = ...
    QUIET_MODE_DISABLE_ONLY_IF_CREDENTIAL_NOT_REQUIRED: typing.ClassVar[int] = ...
    USER_CREATION_FAILED_NOT_PERMITTED: typing.ClassVar[int] = ...
    USER_CREATION_FAILED_NO_MORE_USERS: typing.ClassVar[int] = ...
    USER_OPERATION_ERROR_CURRENT_USER: typing.ClassVar[int] = ...
    USER_OPERATION_ERROR_LOW_STORAGE: typing.ClassVar[int] = ...
    USER_OPERATION_ERROR_MANAGED_PROFILE: typing.ClassVar[int] = ...
    USER_OPERATION_ERROR_MAX_RUNNING_USERS: typing.ClassVar[int] = ...
    USER_OPERATION_ERROR_MAX_USERS: typing.ClassVar[int] = ...
    USER_OPERATION_ERROR_UNKNOWN: typing.ClassVar[int] = ...
    USER_OPERATION_SUCCESS: typing.ClassVar[int] = ...
    USER_TYPE_PROFILE_CLONE: typing.ClassVar[str] = ...
    USER_TYPE_PROFILE_MANAGED: typing.ClassVar[str] = ...
    USER_TYPE_PROFILE_PRIVATE: typing.ClassVar[str] = ...
    @staticmethod
    def createUserCreationIntent(userName: str | java.lang.String, accountName: str | java.lang.String, accountType: str | java.lang.String, accountOptions: PersistableBundle, /) -> android.content.Intent: ...
    def getApplicationRestrictions(self, packageName: str | java.lang.String, /) -> Bundle: ...
    def getSerialNumberForUser(self, user: UserHandle, /) -> int: ...
    def getUserCount(self) -> int: ...
    def getUserCreationTime(self, userHandle: UserHandle, /) -> int: ...
    def getUserForSerialNumber(self, serialNumber: int | java.jlong | java.lang.Long, /) -> UserHandle | None: ...
    def getUserName(self) -> str: ...
    def getUserProfiles(self) -> java.util.List[UserHandle]: ...
    @typing.overload
    def getUserRestrictions(self) -> Bundle: ...
    @typing.overload
    def getUserRestrictions(self, userHandle: UserHandle, /) -> Bundle: ...
    def hasUserRestriction(self, restrictionKey: str | java.lang.String, /) -> bool: ...
    def isAdminUser(self) -> bool: ...
    def isDemoUser(self) -> bool: ...
    @staticmethod
    def isHeadlessSystemUserMode() -> bool: ...
    def isManagedProfile(self) -> bool: ...
    def isProfile(self) -> bool: ...
    def isQuietModeEnabled(self, userHandle: UserHandle, /) -> bool: ...
    def isSystemUser(self) -> bool: ...
    def isUserAGoat(self) -> bool: ...
    def isUserForeground(self) -> bool: ...
    def isUserRunning(self, user: UserHandle, /) -> bool: ...
    def isUserRunningOrStopping(self, user: UserHandle, /) -> bool: ...
    @typing.overload
    def isUserUnlocked(self) -> bool: ...
    @typing.overload
    def isUserUnlocked(self, user: UserHandle, /) -> bool: ...
    @typing.overload
    def requestQuietModeEnabled(self, enableQuietMode: bool | java.jboolean | java.lang.Boolean, userHandle: UserHandle, /) -> bool: ...
    @typing.overload
    def requestQuietModeEnabled(self, enableQuietMode: bool | java.jboolean | java.lang.Boolean, userHandle: UserHandle, flags: int | java.jint | java.lang.Integer, /) -> bool: ...
    def setRestrictionsChallenge(self, newPin: str | java.lang.String, /) -> bool: ...
    def setUserRestriction(self, key: str | java.lang.String, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def setUserRestrictions(self, restrictions: Bundle, /) -> None: ...
    @typing.overload
    def setUserRestrictions(self, restrictions: Bundle, userHandle: UserHandle, /) -> None: ...
    @staticmethod
    def supportsMultipleUsers() -> bool: ...

    class UserOperationException(java.lang.RuntimeException):
        def getUserOperationResult(self) -> int: ...

class VibrationAttributes(Parcelable):
    CREATOR: typing.ClassVar[Parcelable.Creator[VibrationAttributes]] = ...
    FLAG_BYPASS_INTERRUPTION_POLICY: typing.ClassVar[int] = ...
    USAGE_ACCESSIBILITY: typing.ClassVar[int] = ...
    USAGE_ALARM: typing.ClassVar[int] = ...
    USAGE_CLASS_ALARM: typing.ClassVar[int] = ...
    USAGE_CLASS_FEEDBACK: typing.ClassVar[int] = ...
    USAGE_CLASS_MASK: typing.ClassVar[int] = ...
    USAGE_CLASS_MEDIA: typing.ClassVar[int] = ...
    USAGE_CLASS_UNKNOWN: typing.ClassVar[int] = ...
    USAGE_COMMUNICATION_REQUEST: typing.ClassVar[int] = ...
    USAGE_HARDWARE_FEEDBACK: typing.ClassVar[int] = ...
    USAGE_MEDIA: typing.ClassVar[int] = ...
    USAGE_NOTIFICATION: typing.ClassVar[int] = ...
    USAGE_PHYSICAL_EMULATION: typing.ClassVar[int] = ...
    USAGE_RINGTONE: typing.ClassVar[int] = ...
    USAGE_TOUCH: typing.ClassVar[int] = ...
    USAGE_UNKNOWN: typing.ClassVar[int] = ...
    @staticmethod
    def createForUsage(usage: int | java.jint | java.lang.Integer, /) -> VibrationAttributes: ...
    def describeContents(self) -> int: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getFlags(self) -> int: ...
    def getUsage(self) -> int: ...
    def getUsageClass(self) -> int: ...
    def hashCode(self) -> int: ...
    def isFlagSet(self, flag: int | java.jint | java.lang.Integer, /) -> bool: ...
    def toString(self) -> str: ...
    def writeToParcel(self, dest: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...

    class Builder(java.lang.Object):
        @typing.overload
        def __init__(self) -> None: ...
        @typing.overload
        def __init__(self, audio: android.media.AudioAttributes, /) -> None: ...
        @typing.overload
        def __init__(self, vib: VibrationAttributes, /) -> None: ...
        def build(self) -> VibrationAttributes: ...
        def setFlags(self, flags: int | java.jint | java.lang.Integer, mask: int | java.jint | java.lang.Integer, /) -> VibrationAttributes.Builder: ...
        def setUsage(self, usage: int | java.jint | java.lang.Integer, /) -> VibrationAttributes.Builder: ...

class VibrationEffect(Parcelable):
    CREATOR: typing.ClassVar[Parcelable.Creator[VibrationEffect]] = ...
    DEFAULT_AMPLITUDE: typing.ClassVar[int] = ...
    EFFECT_CLICK: typing.ClassVar[int] = ...
    EFFECT_DOUBLE_CLICK: typing.ClassVar[int] = ...
    EFFECT_HEAVY_CLICK: typing.ClassVar[int] = ...
    EFFECT_TICK: typing.ClassVar[int] = ...
    @staticmethod
    def createOneShot(milliseconds: int | java.jlong | java.lang.Long, amplitude: int | java.jint | java.lang.Integer, /) -> VibrationEffect: ...
    @staticmethod
    def createPredefined(effectId: int | java.jint | java.lang.Integer, /) -> VibrationEffect: ...
    @typing.overload
    @staticmethod
    def createWaveform(timings: java.chaquopy.JavaArrayJLong, repeat: int | java.jint | java.lang.Integer, /) -> VibrationEffect: ...
    @typing.overload
    @staticmethod
    def createWaveform(timings: java.chaquopy.JavaArrayJLong, amplitudes: java.chaquopy.JavaArrayJInt, repeat: int | java.jint | java.lang.Integer, /) -> VibrationEffect: ...
    def describeContents(self) -> int: ...
    @staticmethod
    def startComposition() -> VibrationEffect.Composition: ...

    class Composition(java.lang.Object):
        PRIMITIVE_CLICK: typing.ClassVar[int] = ...
        PRIMITIVE_LOW_TICK: typing.ClassVar[int] = ...
        PRIMITIVE_QUICK_FALL: typing.ClassVar[int] = ...
        PRIMITIVE_QUICK_RISE: typing.ClassVar[int] = ...
        PRIMITIVE_SLOW_RISE: typing.ClassVar[int] = ...
        PRIMITIVE_SPIN: typing.ClassVar[int] = ...
        PRIMITIVE_THUD: typing.ClassVar[int] = ...
        PRIMITIVE_TICK: typing.ClassVar[int] = ...
        @typing.overload
        def addPrimitive(self, primitiveId: int | java.jint | java.lang.Integer, /) -> VibrationEffect.Composition: ...
        @typing.overload
        def addPrimitive(self, primitiveId: int | java.jint | java.lang.Integer, scale: float | java.jfloat | java.lang.Float, /) -> VibrationEffect.Composition: ...
        @typing.overload
        def addPrimitive(self, primitiveId: int | java.jint | java.lang.Integer, scale: float | java.jfloat | java.lang.Float, delay: int | java.jint | java.lang.Integer, /) -> VibrationEffect.Composition: ...
        def compose(self) -> VibrationEffect: ...

class Vibrator(java.lang.Object):
    VIBRATION_EFFECT_SUPPORT_NO: typing.ClassVar[int] = ...
    VIBRATION_EFFECT_SUPPORT_UNKNOWN: typing.ClassVar[int] = ...
    VIBRATION_EFFECT_SUPPORT_YES: typing.ClassVar[int] = ...
    def areAllEffectsSupported(self, *effectIds: java.chaquopy.JavaArrayJInt) -> int: ...
    def areAllPrimitivesSupported(self, *primitiveIds: java.chaquopy.JavaArrayJInt) -> bool: ...
    def areEffectsSupported(self, *effectIds: java.chaquopy.JavaArrayJInt) -> java.chaquopy.JavaArrayJInt: ...
    def arePrimitivesSupported(self, *primitiveIds: java.chaquopy.JavaArrayJInt) -> java.chaquopy.JavaArrayJBoolean: ...
    def cancel(self) -> None: ...
    def getId(self) -> int: ...
    def getPrimitiveDurations(self, *primitiveIds: java.chaquopy.JavaArrayJInt) -> java.chaquopy.JavaArrayJInt: ...
    def getQFactor(self) -> float: ...
    def getResonantFrequency(self) -> float: ...
    def hasAmplitudeControl(self) -> bool: ...
    def hasVibrator(self) -> bool: ...
    @typing.overload
    def vibrate(self, milliseconds: int | java.jlong | java.lang.Long, /) -> None: ...
    @typing.overload
    def vibrate(self, vibe: VibrationEffect, /) -> None: ...
    @typing.overload
    def vibrate(self, milliseconds: int | java.jlong | java.lang.Long, attributes: android.media.AudioAttributes, /) -> None: ...
    @typing.overload
    def vibrate(self, vibe: VibrationEffect, attributes: android.media.AudioAttributes, /) -> None: ...
    @typing.overload
    def vibrate(self, vibe: VibrationEffect, attributes: VibrationAttributes, /) -> None: ...
    @typing.overload
    def vibrate(self, pattern: java.chaquopy.JavaArrayJLong, repeat: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def vibrate(self, pattern: java.chaquopy.JavaArrayJLong, repeat: int | java.jint | java.lang.Integer, attributes: android.media.AudioAttributes, /) -> None: ...

class VibratorManager(java.lang.Object):
    def cancel(self) -> None: ...
    def getDefaultVibrator(self) -> Vibrator: ...
    def getVibrator(self, arg1: int | java.jint | java.lang.Integer, /) -> Vibrator: ...
    def getVibratorIds(self) -> java.chaquopy.JavaArrayJInt: ...
    @typing.overload
    def vibrate(self, effect: CombinedVibration, /) -> None: ...
    @typing.overload
    def vibrate(self, effect: CombinedVibration, attributes: VibrationAttributes, /) -> None: ...

class WorkDuration(java.lang.Object):
    def __init__(self) -> None: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getActualCpuDurationNanos(self) -> int: ...
    def getActualGpuDurationNanos(self) -> int: ...
    def getActualTotalDurationNanos(self) -> int: ...
    def getWorkPeriodStartTimestampNanos(self) -> int: ...
    def hashCode(self) -> int: ...
    def setActualCpuDurationNanos(self, actualCpuDurationNanos: int | java.jlong | java.lang.Long, /) -> None: ...
    def setActualGpuDurationNanos(self, actualGpuDurationNanos: int | java.jlong | java.lang.Long, /) -> None: ...
    def setActualTotalDurationNanos(self, actualTotalDurationNanos: int | java.jlong | java.lang.Long, /) -> None: ...
    def setWorkPeriodStartTimestampNanos(self, workPeriodStartTimestampNanos: int | java.jlong | java.lang.Long, /) -> None: ...

class WorkSource(Parcelable):
    CREATOR: typing.ClassVar[Parcelable.Creator[WorkSource]] = ...
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, orig: WorkSource, /) -> None: ...
    def add(self, other: WorkSource, /) -> bool: ...
    def clear(self) -> None: ...
    def describeContents(self) -> int: ...
    def diff(self, other: WorkSource, /) -> bool: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def hashCode(self) -> int: ...
    def remove(self, other: WorkSource, /) -> bool: ...
    def set(self, other: WorkSource, /) -> None: ...
    def toString(self) -> str: ...
    def writeToParcel(self, dest: Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...
