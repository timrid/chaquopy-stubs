import android.os
import java
import java.chaquopy
import java.io
import java.lang
import java.time
import java.util
import java.util.function
import java.util.regex
import org.xml.sax
import org.xmlpull.v1
import typing



class AndroidException(java.lang.Exception):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, cause: java.lang.Exception, /) -> None: ...
    @typing.overload
    def __init__(self, name: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, name: str | java.lang.String, cause: java.lang.Throwable, /) -> None: ...

class AndroidRuntimeException(java.lang.RuntimeException):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, cause: java.lang.Exception, /) -> None: ...
    @typing.overload
    def __init__(self, name: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, name: str | java.lang.String, cause: java.lang.Throwable, /) -> None: ...

_ArrayMap__K = typing.TypeVar('_ArrayMap__K')  # <K>
_ArrayMap__V = typing.TypeVar('_ArrayMap__V')  # <V>
class ArrayMap(java.util.Map[_ArrayMap__K, _ArrayMap__V], typing.Generic[_ArrayMap__K, _ArrayMap__V]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, capacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, map: ArrayMap[_ArrayMap__K, _ArrayMap__V], /) -> None: ...
    def clear(self) -> None: ...
    def containsAll(self, collection: java.util.Collection[java.lang.Object], /) -> bool: ...
    def containsKey(self, key: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsValue(self, value: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def ensureCapacity(self, minimumCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    def entrySet(self) -> java.util.Set[java.util.Map.Entry[_ArrayMap__K, _ArrayMap__V]]: ...
    def equals(self, object: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def forEach(self, action: java.util.function.BiConsumer[_ArrayMap__K, _ArrayMap__V], /) -> None: ...
    def get(self, key: java.lang.Object | int | bool | float | str, /) -> _ArrayMap__V | None: ...
    def hashCode(self) -> int: ...
    def indexOfKey(self, key: java.lang.Object | int | bool | float | str, /) -> int: ...
    def indexOfValue(self, value: java.lang.Object | int | bool | float | str, /) -> int: ...
    def isEmpty(self) -> bool: ...
    def keyAt(self, index: int | java.jint | java.lang.Integer, /) -> _ArrayMap__K: ...
    def keySet(self) -> java.util.Set[_ArrayMap__K]: ...
    def put(self, key: _ArrayMap__K, value: _ArrayMap__V, /) -> _ArrayMap__V | None: ...
    @typing.overload
    def putAll(self, array: ArrayMap[_ArrayMap__K, _ArrayMap__V], /) -> None: ...
    @typing.overload
    def putAll(self, map: java.util.Map[_ArrayMap__K, _ArrayMap__V], /) -> None: ...
    def remove(self, key: java.lang.Object | int | bool | float | str, /) -> _ArrayMap__V | None: ...
    def removeAll(self, collection: java.util.Collection[java.lang.Object], /) -> bool: ...
    def removeAt(self, index: int | java.jint | java.lang.Integer, /) -> _ArrayMap__V: ...
    def replaceAll(self, function: java.util.function.BiFunction[_ArrayMap__K, _ArrayMap__V, _ArrayMap__V], /) -> None: ...
    def retainAll(self, collection: java.util.Collection[java.lang.Object], /) -> bool: ...
    def setValueAt(self, index: int | java.jint | java.lang.Integer, value: _ArrayMap__V, /) -> _ArrayMap__V: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def valueAt(self, index: int | java.jint | java.lang.Integer, /) -> _ArrayMap__V: ...
    def values(self) -> java.util.Collection[_ArrayMap__V]: ...

_ArraySet__E = typing.TypeVar('_ArraySet__E')  # <E>
class ArraySet(java.util.Collection[_ArraySet__E], java.util.Set[_ArraySet__E], typing.Generic[_ArraySet__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, capacity: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, set: ArraySet[_ArraySet__E], /) -> None: ...
    @typing.overload
    def __init__(self, set: java.util.Collection[_ArraySet__E], /) -> None: ...
    @typing.overload
    def __init__(self, array: java.chaquopy.JavaArray[_ArraySet__E], /) -> None: ...
    def add(self, value: _ArraySet__E, /) -> bool: ...
    @typing.overload
    def addAll(self, array: ArraySet[_ArraySet__E], /) -> None: ...
    @typing.overload
    def addAll(self, collection: java.util.Collection[_ArraySet__E], /) -> bool: ...
    def clear(self) -> None: ...
    def contains(self, key: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def containsAll(self, collection: java.util.Collection[java.lang.Object], /) -> bool: ...
    def ensureCapacity(self, minimumCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    def equals(self, object: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def forEach(self, action: java.util.function.Consumer[_ArraySet__E], /) -> None: ...
    def hashCode(self) -> int: ...
    def indexOf(self, key: java.lang.Object | int | bool | float | str, /) -> int: ...
    def isEmpty(self) -> bool: ...
    def iterator(self) -> java.util.Iterator[_ArraySet__E]: ...
    def remove(self, object: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def removeAll(self, array: ArraySet[_ArraySet__E], /) -> bool: ...
    @typing.overload
    def removeAll(self, collection: java.util.Collection[java.lang.Object], /) -> bool: ...
    def removeAt(self, index: int | java.jint | java.lang.Integer, /) -> _ArraySet__E: ...
    def removeIf(self, filter: java.util.function.Predicate[_ArraySet__E], /) -> bool: ...
    def retainAll(self, collection: java.util.Collection[java.lang.Object], /) -> bool: ...
    def size(self) -> int: ...
    _toArray_1__T = typing.TypeVar('_toArray_1__T')  # <T>
    @typing.overload
    def toArray(self) -> java.chaquopy.JavaArray[java.lang.Object]: ...
    @typing.overload
    def toArray(self, array: java.chaquopy.JavaArray[_toArray_1__T], /) -> java.chaquopy.JavaArray[_toArray_1__T]: ...
    def toString(self) -> str: ...
    def valueAt(self, index: int | java.jint | java.lang.Integer, /) -> _ArraySet__E: ...

class AtomicFile(java.lang.Object):
    def __init__(self, baseName: java.io.File, /) -> None: ...
    def delete(self) -> None: ...
    def failWrite(self, str: java.io.FileOutputStream, /) -> None: ...
    def finishWrite(self, str: java.io.FileOutputStream, /) -> None: ...
    def getBaseFile(self) -> java.io.File: ...
    def getLastModifiedTime(self) -> int: ...
    def openRead(self) -> java.io.FileInputStream: ...
    def readFully(self) -> java.chaquopy.JavaArrayJByte: ...
    def startWrite(self) -> java.io.FileOutputStream: ...
    def toString(self) -> str: ...

class AttributeSet(java.lang.Object):
    @typing.overload
    def getAttributeBooleanValue(self, arg1: int | java.jint | java.lang.Integer, arg2: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    @typing.overload
    def getAttributeBooleanValue(self, arg1: str | java.lang.String, arg2: str | java.lang.String, arg3: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def getAttributeCount(self) -> int: ...
    @typing.overload
    def getAttributeFloatValue(self, arg1: int | java.jint | java.lang.Integer, arg2: float | java.jfloat | java.lang.Float, /) -> float: ...
    @typing.overload
    def getAttributeFloatValue(self, arg1: str | java.lang.String, arg2: str | java.lang.String, arg3: float | java.jfloat | java.lang.Float, /) -> float: ...
    @typing.overload
    def getAttributeIntValue(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def getAttributeIntValue(self, arg1: str | java.lang.String, arg2: str | java.lang.String, arg3: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def getAttributeListValue(self, arg1: int | java.jint | java.lang.Integer, arg2: java.chaquopy.JavaArray[java.lang.String], arg3: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def getAttributeListValue(self, arg1: str | java.lang.String, arg2: str | java.lang.String, arg3: java.chaquopy.JavaArray[java.lang.String], arg4: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAttributeName(self, arg1: int | java.jint | java.lang.Integer, /) -> str | None: ...
    def getAttributeNameResource(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def getAttributeNamespace(self, index: int | java.jint | java.lang.Integer, /) -> str | None: ...
    @typing.overload
    def getAttributeResourceValue(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def getAttributeResourceValue(self, arg1: str | java.lang.String, arg2: str | java.lang.String, arg3: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def getAttributeUnsignedIntValue(self, arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def getAttributeUnsignedIntValue(self, arg1: str | java.lang.String, arg2: str | java.lang.String, arg3: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def getAttributeValue(self, arg1: int | java.jint | java.lang.Integer, /) -> str | None: ...
    @typing.overload
    def getAttributeValue(self, arg1: str | java.lang.String, arg2: str | java.lang.String, /) -> str | None: ...
    def getClassAttribute(self) -> str | None: ...
    def getIdAttribute(self) -> str | None: ...
    def getIdAttributeResourceValue(self, arg1: int | java.jint | java.lang.Integer, /) -> int: ...
    def getPositionDescription(self) -> str | None: ...
    def getStyleAttribute(self) -> int: ...

class Base64(java.lang.Object):
    CRLF: typing.ClassVar[int] = ...
    DEFAULT: typing.ClassVar[int] = ...
    NO_CLOSE: typing.ClassVar[int] = ...
    NO_PADDING: typing.ClassVar[int] = ...
    NO_WRAP: typing.ClassVar[int] = ...
    URL_SAFE: typing.ClassVar[int] = ...
    @typing.overload
    @staticmethod
    def decode(str: str | java.lang.String, flags: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    @staticmethod
    def decode(input: java.chaquopy.JavaArrayJByte, flags: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    @staticmethod
    def decode(input: java.chaquopy.JavaArrayJByte, offset: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, flags: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    @staticmethod
    def encode(input: java.chaquopy.JavaArrayJByte, flags: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    @staticmethod
    def encode(input: java.chaquopy.JavaArrayJByte, offset: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, flags: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJByte: ...
    @typing.overload
    @staticmethod
    def encodeToString(input: java.chaquopy.JavaArrayJByte, flags: int | java.jint | java.lang.Integer, /) -> str: ...
    @typing.overload
    @staticmethod
    def encodeToString(input: java.chaquopy.JavaArrayJByte, offset: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, flags: int | java.jint | java.lang.Integer, /) -> str: ...

class Base64DataException(java.io.IOException):
    def __init__(self, detailMessage: str | java.lang.String, /) -> None: ...

class Base64InputStream(java.io.FilterInputStream):
    def __init__(self, in_: java.io.InputStream, flags: int | java.jint | java.lang.Integer, /) -> None: ...
    def available(self) -> int: ...
    def close(self) -> None: ...
    def mark(self, readlimit: int | java.jint | java.lang.Integer, /) -> None: ...
    def markSupported(self) -> bool: ...
    @typing.overload
    def read(self) -> int: ...
    @typing.overload
    def read(self, b: java.chaquopy.JavaArrayJByte, off: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, /) -> int: ...
    def reset(self) -> None: ...
    def skip(self, n: int | java.jlong | java.lang.Long, /) -> int: ...

class Base64OutputStream(java.io.FilterOutputStream):
    def __init__(self, out: java.io.OutputStream, flags: int | java.jint | java.lang.Integer, /) -> None: ...
    def close(self) -> None: ...
    @typing.overload
    def write(self, b: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def write(self, b: java.chaquopy.JavaArrayJByte, off: int | java.jint | java.lang.Integer, len: int | java.jint | java.lang.Integer, /) -> None: ...

class CloseGuard(java.lang.Object):
    def __init__(self) -> None: ...
    def close(self) -> None: ...
    def open(self, closeMethodName: str | java.lang.String, /) -> None: ...
    def warnIfOpen(self) -> None: ...

class Config(java.lang.Object):
    DEBUG: typing.ClassVar[bool] = ...
    LOGD: typing.ClassVar[bool] = ...
    LOGV: typing.ClassVar[bool] = ...
    PROFILE: typing.ClassVar[bool] = ...
    RELEASE: typing.ClassVar[bool] = ...

class DebugUtils(java.lang.Object):
    @staticmethod
    def isObjectSelected(object: java.lang.Object | int | bool | float | str, /) -> bool: ...

class DisplayMetrics(java.lang.Object):
    DENSITY_140: typing.ClassVar[int] = ...
    DENSITY_180: typing.ClassVar[int] = ...
    DENSITY_200: typing.ClassVar[int] = ...
    DENSITY_220: typing.ClassVar[int] = ...
    DENSITY_260: typing.ClassVar[int] = ...
    DENSITY_280: typing.ClassVar[int] = ...
    DENSITY_300: typing.ClassVar[int] = ...
    DENSITY_340: typing.ClassVar[int] = ...
    DENSITY_360: typing.ClassVar[int] = ...
    DENSITY_390: typing.ClassVar[int] = ...
    DENSITY_400: typing.ClassVar[int] = ...
    DENSITY_420: typing.ClassVar[int] = ...
    DENSITY_440: typing.ClassVar[int] = ...
    DENSITY_450: typing.ClassVar[int] = ...
    DENSITY_520: typing.ClassVar[int] = ...
    DENSITY_560: typing.ClassVar[int] = ...
    DENSITY_600: typing.ClassVar[int] = ...
    DENSITY_DEFAULT: typing.ClassVar[int] = ...
    DENSITY_DEVICE_STABLE: typing.ClassVar[int] = ...
    DENSITY_HIGH: typing.ClassVar[int] = ...
    DENSITY_LOW: typing.ClassVar[int] = ...
    DENSITY_MEDIUM: typing.ClassVar[int] = ...
    DENSITY_TV: typing.ClassVar[int] = ...
    DENSITY_XHIGH: typing.ClassVar[int] = ...
    DENSITY_XXHIGH: typing.ClassVar[int] = ...
    DENSITY_XXXHIGH: typing.ClassVar[int] = ...
    density: float = ...
    densityDpi: int = ...
    heightPixels: int = ...
    scaledDensity: float = ...
    widthPixels: int = ...
    xdpi: float = ...
    ydpi: float = ...
    def __init__(self) -> None: ...
    @typing.overload
    def equals(self, other: DisplayMetrics, /) -> bool: ...
    @typing.overload
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def hashCode(self) -> int: ...
    def setTo(self, o: DisplayMetrics, /) -> None: ...
    def setToDefaults(self) -> None: ...
    def toString(self) -> str: ...

class Dumpable(java.lang.Object):
    def dump(self, arg1: java.io.PrintWriter, arg2: java.chaquopy.JavaArray[java.lang.String], /) -> None: ...
    def getDumpableName(self) -> str: ...

class DumpableContainer(java.lang.Object):
    def addDumpable(self, arg1: Dumpable, /) -> bool: ...
    def removeDumpable(self, arg1: Dumpable, /) -> bool: ...

class EventLog(java.lang.Object):
    @staticmethod
    def getTagCode(name: str | java.lang.String, /) -> int: ...
    @staticmethod
    def getTagName(tag: int | java.jint | java.lang.Integer, /) -> str | None: ...
    @staticmethod
    def readEvents(arg1: java.chaquopy.JavaArrayJInt, arg2: java.util.Collection[EventLog.Event], /) -> None: ...
    @typing.overload
    @staticmethod
    def writeEvent(arg1: int | java.jint | java.lang.Integer, arg2: float | java.jfloat | java.lang.Float, /) -> int: ...
    @typing.overload
    @staticmethod
    def writeEvent(arg1: int | java.jint | java.lang.Integer, arg2: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    @staticmethod
    def writeEvent(arg1: int | java.jint | java.lang.Integer, arg2: int | java.jlong | java.lang.Long, /) -> int: ...
    @typing.overload
    @staticmethod
    def writeEvent(arg1: int | java.jint | java.lang.Integer, arg2: str | java.lang.String, /) -> int: ...
    @typing.overload
    @staticmethod
    def writeEvent(arg1: int | java.jint | java.lang.Integer, /, *arg2: java.lang.Object) -> int: ...

    class Event(java.lang.Object):
        def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
        def getData(self) -> java.lang.Object: ...
        def getProcessId(self) -> int: ...
        def getTag(self) -> int: ...
        def getThreadId(self) -> int: ...
        def getTimeNanos(self) -> int: ...
        def hashCode(self) -> int: ...

class EventLogTags(java.lang.Object):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, input: java.io.BufferedReader, /) -> None: ...
    @typing.overload
    def get(self, tag: int | java.jint | java.lang.Integer, /) -> EventLogTags.Description: ...
    @typing.overload
    def get(self, name: str | java.lang.String, /) -> EventLogTags.Description: ...

    class Description(java.lang.Object):
        mName: str = ...
        mTag: int = ...

class FloatMath(java.lang.Object): ...

_FloatProperty__T = typing.TypeVar('_FloatProperty__T')  # <T>
class FloatProperty(Property[_FloatProperty__T, java.lang.Float], typing.Generic[_FloatProperty__T]):
    def __init__(self, name: str | java.lang.String, /) -> None: ...
    def set(self, object: _FloatProperty__T, value: float | java.jfloat | java.lang.Float, /) -> None: ...
    def setValue(self, arg1: _FloatProperty__T, arg2: float | java.jfloat | java.lang.Float, /) -> None: ...

class Half(java.lang.Number, java.lang.Comparable[Half]):
    EPSILON: typing.ClassVar[int] = ...
    LOWEST_VALUE: typing.ClassVar[int] = ...
    MAX_EXPONENT: typing.ClassVar[int] = ...
    MAX_VALUE: typing.ClassVar[int] = ...
    MIN_EXPONENT: typing.ClassVar[int] = ...
    MIN_NORMAL: typing.ClassVar[int] = ...
    MIN_VALUE: typing.ClassVar[int] = ...
    NEGATIVE_INFINITY: typing.ClassVar[int] = ...
    NEGATIVE_ZERO: typing.ClassVar[int] = ...
    NaN: typing.ClassVar[int] = ...
    POSITIVE_INFINITY: typing.ClassVar[int] = ...
    POSITIVE_ZERO: typing.ClassVar[int] = ...
    SIZE: typing.ClassVar[int] = ...
    @typing.overload
    def __init__(self, value: float | java.jdouble | java.lang.Double, /) -> None: ...
    @typing.overload
    def __init__(self, value: float | java.jfloat | java.lang.Float, /) -> None: ...
    @typing.overload
    def __init__(self, value: str | java.lang.String, /) -> None: ...
    @typing.overload
    def __init__(self, value: int | java.jshort | java.lang.Short, /) -> None: ...
    @staticmethod
    def abs(h: int | java.jshort | java.lang.Short, /) -> int: ...
    def byteValue(self) -> int: ...
    @staticmethod
    def ceil(h: int | java.jshort | java.lang.Short, /) -> int: ...
    @staticmethod
    def compare(x: int | java.jshort | java.lang.Short, y: int | java.jshort | java.lang.Short, /) -> int: ...
    def compareTo(self, h: Half, /) -> int: ...
    @staticmethod
    def copySign(magnitude: int | java.jshort | java.lang.Short, sign: int | java.jshort | java.lang.Short, /) -> int: ...
    def doubleValue(self) -> float: ...
    @typing.overload
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    @staticmethod
    def equals(x: int | java.jshort | java.lang.Short, y: int | java.jshort | java.lang.Short, /) -> bool: ...
    def floatValue(self) -> float: ...
    @staticmethod
    def floor(h: int | java.jshort | java.lang.Short, /) -> int: ...
    @staticmethod
    def getExponent(h: int | java.jshort | java.lang.Short, /) -> int: ...
    @staticmethod
    def getSign(h: int | java.jshort | java.lang.Short, /) -> int: ...
    @staticmethod
    def getSignificand(h: int | java.jshort | java.lang.Short, /) -> int: ...
    @staticmethod
    def greater(x: int | java.jshort | java.lang.Short, y: int | java.jshort | java.lang.Short, /) -> bool: ...
    @staticmethod
    def greaterEquals(x: int | java.jshort | java.lang.Short, y: int | java.jshort | java.lang.Short, /) -> bool: ...
    @staticmethod
    def halfToIntBits(h: int | java.jshort | java.lang.Short, /) -> int: ...
    @staticmethod
    def halfToRawIntBits(h: int | java.jshort | java.lang.Short, /) -> int: ...
    @staticmethod
    def halfToShortBits(h: int | java.jshort | java.lang.Short, /) -> int: ...
    def halfValue(self) -> int: ...
    @typing.overload
    def hashCode(self) -> int: ...
    @typing.overload
    @staticmethod
    def hashCode(h: int | java.jshort | java.lang.Short, /) -> int: ...
    @staticmethod
    def intBitsToHalf(bits: int | java.jint | java.lang.Integer, /) -> int: ...
    def intValue(self) -> int: ...
    @staticmethod
    def isInfinite(h: int | java.jshort | java.lang.Short, /) -> bool: ...
    @typing.overload
    def isNaN(self) -> bool: ...
    @typing.overload
    @staticmethod
    def isNaN(h: int | java.jshort | java.lang.Short, /) -> bool: ...
    @staticmethod
    def isNormalized(h: int | java.jshort | java.lang.Short, /) -> bool: ...
    @staticmethod
    def less(x: int | java.jshort | java.lang.Short, y: int | java.jshort | java.lang.Short, /) -> bool: ...
    @staticmethod
    def lessEquals(x: int | java.jshort | java.lang.Short, y: int | java.jshort | java.lang.Short, /) -> bool: ...
    def longValue(self) -> int: ...
    @staticmethod
    def max(x: int | java.jshort | java.lang.Short, y: int | java.jshort | java.lang.Short, /) -> int: ...
    @staticmethod
    def min(x: int | java.jshort | java.lang.Short, y: int | java.jshort | java.lang.Short, /) -> int: ...
    @staticmethod
    def parseHalf(s: str | java.lang.String, /) -> int: ...
    @staticmethod
    def round(h: int | java.jshort | java.lang.Short, /) -> int: ...
    def shortValue(self) -> int: ...
    @staticmethod
    def toFloat(h: int | java.jshort | java.lang.Short, /) -> float: ...
    @staticmethod
    def toHalf(f: float | java.jfloat | java.lang.Float, /) -> int: ...
    @staticmethod
    def toHexString(h: int | java.jshort | java.lang.Short, /) -> str: ...
    @typing.overload
    def toString(self) -> str: ...
    @typing.overload
    @staticmethod
    def toString(h: int | java.jshort | java.lang.Short, /) -> str: ...
    @staticmethod
    def trunc(h: int | java.jshort | java.lang.Short, /) -> int: ...
    @typing.overload
    @staticmethod
    def valueOf(f: float | java.jfloat | java.lang.Float, /) -> Half: ...
    @typing.overload
    @staticmethod
    def valueOf(s: str | java.lang.String, /) -> Half: ...
    @typing.overload
    @staticmethod
    def valueOf(h: int | java.jshort | java.lang.Short, /) -> Half: ...

_IntProperty__T = typing.TypeVar('_IntProperty__T')  # <T>
class IntProperty(Property[_IntProperty__T, java.lang.Integer], typing.Generic[_IntProperty__T]):
    def __init__(self, name: str | java.lang.String, /) -> None: ...
    def set(self, object: _IntProperty__T, value: int | java.jint | java.lang.Integer, /) -> None: ...
    def setValue(self, arg1: _IntProperty__T, arg2: int | java.jint | java.lang.Integer, /) -> None: ...

class JsonReader(java.io.Closeable):
    def __init__(self, in_: java.io.Reader, /) -> None: ...
    def beginArray(self) -> None: ...
    def beginObject(self) -> None: ...
    def close(self) -> None: ...
    def endArray(self) -> None: ...
    def endObject(self) -> None: ...
    def hasNext(self) -> bool: ...
    def isLenient(self) -> bool: ...
    def nextBoolean(self) -> bool: ...
    def nextDouble(self) -> float: ...
    def nextInt(self) -> int: ...
    def nextLong(self) -> int: ...
    def nextName(self) -> str: ...
    def nextNull(self) -> None: ...
    def nextString(self) -> str: ...
    def peek(self) -> JsonToken: ...
    def setLenient(self, lenient: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def skipValue(self) -> None: ...
    def toString(self) -> str: ...

class JsonToken(java.lang.Enum[JsonToken]):
    BEGIN_ARRAY: typing.ClassVar[JsonToken] = ...
    END_ARRAY: typing.ClassVar[JsonToken] = ...
    BEGIN_OBJECT: typing.ClassVar[JsonToken] = ...
    END_OBJECT: typing.ClassVar[JsonToken] = ...
    NAME: typing.ClassVar[JsonToken] = ...
    STRING: typing.ClassVar[JsonToken] = ...
    NUMBER: typing.ClassVar[JsonToken] = ...
    BOOLEAN: typing.ClassVar[JsonToken] = ...
    NULL: typing.ClassVar[JsonToken] = ...
    END_DOCUMENT: typing.ClassVar[JsonToken] = ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> JsonToken: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[JsonToken]: ...

class JsonWriter(java.io.Closeable):
    def __init__(self, out: java.io.Writer, /) -> None: ...
    def beginArray(self) -> JsonWriter: ...
    def beginObject(self) -> JsonWriter: ...
    def close(self) -> None: ...
    def endArray(self) -> JsonWriter: ...
    def endObject(self) -> JsonWriter: ...
    def flush(self) -> None: ...
    def isLenient(self) -> bool: ...
    def name(self, name: str | java.lang.String, /) -> JsonWriter: ...
    def nullValue(self) -> JsonWriter: ...
    def setIndent(self, indent: str | java.lang.String, /) -> None: ...
    def setLenient(self, lenient: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    @typing.overload
    def value(self, value: float | java.jdouble | java.lang.Double, /) -> JsonWriter: ...
    @typing.overload
    def value(self, value: int | java.jlong | java.lang.Long, /) -> JsonWriter: ...
    @typing.overload
    def value(self, value: java.lang.Number, /) -> JsonWriter: ...
    @typing.overload
    def value(self, value: str | java.lang.String, /) -> JsonWriter: ...
    @typing.overload
    def value(self, value: bool | java.jboolean | java.lang.Boolean, /) -> JsonWriter: ...

class LayoutDirection(java.lang.Object):
    INHERIT: typing.ClassVar[int] = ...
    LOCALE: typing.ClassVar[int] = ...
    LTR: typing.ClassVar[int] = ...
    RTL: typing.ClassVar[int] = ...

class Log(java.lang.Object):
    ASSERT: typing.ClassVar[int] = ...
    DEBUG: typing.ClassVar[int] = ...
    ERROR: typing.ClassVar[int] = ...
    INFO: typing.ClassVar[int] = ...
    VERBOSE: typing.ClassVar[int] = ...
    WARN: typing.ClassVar[int] = ...
    @typing.overload
    @staticmethod
    def d(tag: str | java.lang.String, msg: str | java.lang.String, /) -> int: ...
    @typing.overload
    @staticmethod
    def d(tag: str | java.lang.String, msg: str | java.lang.String, tr: java.lang.Throwable, /) -> int: ...
    @typing.overload
    @staticmethod
    def e(tag: str | java.lang.String, msg: str | java.lang.String, /) -> int: ...
    @typing.overload
    @staticmethod
    def e(tag: str | java.lang.String, msg: str | java.lang.String, tr: java.lang.Throwable, /) -> int: ...
    @staticmethod
    def getStackTraceString(tr: java.lang.Throwable, /) -> str: ...
    @typing.overload
    @staticmethod
    def i(tag: str | java.lang.String, msg: str | java.lang.String, /) -> int: ...
    @typing.overload
    @staticmethod
    def i(tag: str | java.lang.String, msg: str | java.lang.String, tr: java.lang.Throwable, /) -> int: ...
    @staticmethod
    def isLoggable(arg1: str | java.lang.String, arg2: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def println(priority: int | java.jint | java.lang.Integer, tag: str | java.lang.String, msg: str | java.lang.String, /) -> int: ...
    @typing.overload
    @staticmethod
    def v(tag: str | java.lang.String, msg: str | java.lang.String, /) -> int: ...
    @typing.overload
    @staticmethod
    def v(tag: str | java.lang.String, msg: str | java.lang.String, tr: java.lang.Throwable, /) -> int: ...
    @typing.overload
    @staticmethod
    def w(tag: str | java.lang.String, msg: str | java.lang.String, /) -> int: ...
    @typing.overload
    @staticmethod
    def w(tag: str | java.lang.String, tr: java.lang.Throwable, /) -> int: ...
    @typing.overload
    @staticmethod
    def w(tag: str | java.lang.String, msg: str | java.lang.String, tr: java.lang.Throwable, /) -> int: ...
    @typing.overload
    @staticmethod
    def wtf(tag: str | java.lang.String, msg: str | java.lang.String, /) -> int: ...
    @typing.overload
    @staticmethod
    def wtf(tag: str | java.lang.String, tr: java.lang.Throwable, /) -> int: ...
    @typing.overload
    @staticmethod
    def wtf(tag: str | java.lang.String, msg: str | java.lang.String, tr: java.lang.Throwable, /) -> int: ...

class LogPrinter(Printer):
    def __init__(self, priority: int | java.jint | java.lang.Integer, tag: str | java.lang.String, /) -> None: ...
    def println(self, x: str | java.lang.String, /) -> None: ...

_LongSparseArray__E = typing.TypeVar('_LongSparseArray__E')  # <E>
class LongSparseArray(java.lang.Cloneable, typing.Generic[_LongSparseArray__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    def append(self, key: int | java.jlong | java.lang.Long, value: _LongSparseArray__E, /) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> LongSparseArray[_LongSparseArray__E]: ...
    def delete(self, key: int | java.jlong | java.lang.Long, /) -> None: ...
    @typing.overload
    def get(self, key: int | java.jlong | java.lang.Long, /) -> _LongSparseArray__E: ...
    @typing.overload
    def get(self, key: int | java.jlong | java.lang.Long, valueIfKeyNotFound: _LongSparseArray__E, /) -> _LongSparseArray__E: ...
    def indexOfKey(self, key: int | java.jlong | java.lang.Long, /) -> int: ...
    def indexOfValue(self, value: _LongSparseArray__E, /) -> int: ...
    def keyAt(self, index: int | java.jint | java.lang.Integer, /) -> int: ...
    def put(self, key: int | java.jlong | java.lang.Long, value: _LongSparseArray__E, /) -> None: ...
    def remove(self, key: int | java.jlong | java.lang.Long, /) -> None: ...
    def removeAt(self, index: int | java.jint | java.lang.Integer, /) -> None: ...
    def setValueAt(self, index: int | java.jint | java.lang.Integer, value: _LongSparseArray__E, /) -> None: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def valueAt(self, index: int | java.jint | java.lang.Integer, /) -> _LongSparseArray__E: ...

_LruCache__K = typing.TypeVar('_LruCache__K')  # <K>
_LruCache__V = typing.TypeVar('_LruCache__V')  # <V>
class LruCache(java.lang.Object, typing.Generic[_LruCache__K, _LruCache__V]):
    def __init__(self, maxSize: int | java.jint | java.lang.Integer, /) -> None: ...
    def create(self, key: _LruCache__K, /) -> _LruCache__V: ...
    def createCount(self) -> int: ...
    def entryRemoved(self, evicted: bool | java.jboolean | java.lang.Boolean, key: _LruCache__K, oldValue: _LruCache__V, newValue: _LruCache__V, /) -> None: ...
    def evictAll(self) -> None: ...
    def evictionCount(self) -> int: ...
    def get(self, key: _LruCache__K, /) -> _LruCache__V: ...
    def hitCount(self) -> int: ...
    def maxSize(self) -> int: ...
    def missCount(self) -> int: ...
    def put(self, key: _LruCache__K, value: _LruCache__V, /) -> _LruCache__V: ...
    def putCount(self) -> int: ...
    def remove(self, key: _LruCache__K, /) -> _LruCache__V: ...
    def resize(self, maxSize: int | java.jint | java.lang.Integer, /) -> None: ...
    def size(self) -> int: ...
    def sizeOf(self, key: _LruCache__K, value: _LruCache__V, /) -> int: ...
    def snapshot(self) -> java.util.Map[_LruCache__K, _LruCache__V]: ...
    def toString(self) -> str: ...
    def trimToSize(self, maxSize: int | java.jint | java.lang.Integer, /) -> None: ...

class MalformedJsonException(java.io.IOException):
    def __init__(self, message: str | java.lang.String, /) -> None: ...

class MonthDisplayHelper(java.lang.Object):
    @typing.overload
    def __init__(self, year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def __init__(self, year: int | java.jint | java.lang.Integer, month: int | java.jint | java.lang.Integer, weekStartDay: int | java.jint | java.lang.Integer, /) -> None: ...
    def getColumnOf(self, day: int | java.jint | java.lang.Integer, /) -> int: ...
    def getDayAt(self, row: int | java.jint | java.lang.Integer, column: int | java.jint | java.lang.Integer, /) -> int: ...
    def getDigitsForRow(self, row: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJInt: ...
    def getFirstDayOfMonth(self) -> int: ...
    def getMonth(self) -> int: ...
    def getNumberOfDaysInMonth(self) -> int: ...
    def getOffset(self) -> int: ...
    def getRowOf(self, day: int | java.jint | java.lang.Integer, /) -> int: ...
    def getWeekStartDay(self) -> int: ...
    def getYear(self) -> int: ...
    def isWithinCurrentMonth(self, row: int | java.jint | java.lang.Integer, column: int | java.jint | java.lang.Integer, /) -> bool: ...
    def nextMonth(self) -> None: ...
    def previousMonth(self) -> None: ...

class MutableBoolean(java.lang.Object):
    value: bool = ...
    def __init__(self, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...

class MutableByte(java.lang.Object):
    value: int = ...
    def __init__(self, value: int | java.jbyte | java.lang.Byte, /) -> None: ...

class MutableChar(java.lang.Object):
    value: str = ...
    def __init__(self, value: str | java.jchar | java.lang.Character, /) -> None: ...

class MutableDouble(java.lang.Object):
    value: float = ...
    def __init__(self, value: float | java.jdouble | java.lang.Double, /) -> None: ...

class MutableFloat(java.lang.Object):
    value: float = ...
    def __init__(self, value: float | java.jfloat | java.lang.Float, /) -> None: ...

class MutableInt(java.lang.Object):
    value: int = ...
    def __init__(self, value: int | java.jint | java.lang.Integer, /) -> None: ...

class MutableLong(java.lang.Object):
    value: int = ...
    def __init__(self, value: int | java.jlong | java.lang.Long, /) -> None: ...

class MutableShort(java.lang.Object):
    value: int = ...
    def __init__(self, value: int | java.jshort | java.lang.Short, /) -> None: ...

class NoSuchPropertyException(java.lang.RuntimeException):
    def __init__(self, s: str | java.lang.String, /) -> None: ...

_Pair__F = typing.TypeVar('_Pair__F')  # <F>
_Pair__S = typing.TypeVar('_Pair__S')  # <S>
class Pair(java.lang.Object, typing.Generic[_Pair__F, _Pair__S]):
    first: _Pair__F = ...
    second: _Pair__S = ...
    def __init__(self, first: _Pair__F, second: _Pair__S, /) -> None: ...
    _create__A = typing.TypeVar('_create__A')  # <A>
    _create__B = typing.TypeVar('_create__B')  # <B>
    @staticmethod
    def create(a: _create__A, b: _create__B, /) -> Pair[_create__A, _create__B]: ...
    def equals(self, o: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def hashCode(self) -> int: ...
    def toString(self) -> str: ...

class Patterns(java.lang.Object):
    DOMAIN_NAME: typing.ClassVar[java.util.regex.Pattern] = ...
    EMAIL_ADDRESS: typing.ClassVar[java.util.regex.Pattern] = ...
    GOOD_IRI_CHAR: typing.ClassVar[str] = ...
    IP_ADDRESS: typing.ClassVar[java.util.regex.Pattern] = ...
    PHONE: typing.ClassVar[java.util.regex.Pattern] = ...
    TOP_LEVEL_DOMAIN: typing.ClassVar[java.util.regex.Pattern] = ...
    TOP_LEVEL_DOMAIN_STR: typing.ClassVar[str] = ...
    TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL: typing.ClassVar[str] = ...
    WEB_URL: typing.ClassVar[java.util.regex.Pattern] = ...
    @staticmethod
    def concatGroups(matcher: java.util.regex.Matcher, /) -> str: ...
    @staticmethod
    def digitsAndPlusOnly(matcher: java.util.regex.Matcher, /) -> str: ...

class PrintStreamPrinter(Printer):
    def __init__(self, pw: java.io.PrintStream, /) -> None: ...
    def println(self, x: str | java.lang.String, /) -> None: ...

class PrintWriterPrinter(Printer):
    def __init__(self, pw: java.io.PrintWriter, /) -> None: ...
    def println(self, x: str | java.lang.String, /) -> None: ...

class Printer(java.lang.Object):
    def println(self, arg1: str | java.lang.String, /) -> None: ...

_Property__T = typing.TypeVar('_Property__T')  # <T>
_Property__V = typing.TypeVar('_Property__V')  # <V>
class Property(java.lang.Object, typing.Generic[_Property__T, _Property__V]):
    def __init__(self, type: typing.Type[_Property__V], name: str | java.lang.String, /) -> None: ...
    def get(self, arg1: _Property__T, /) -> _Property__V: ...
    def getName(self) -> str: ...
    def getType(self) -> typing.Type[_Property__V]: ...
    def isReadOnly(self) -> bool: ...
    _of__T = typing.TypeVar('_of__T')  # <T>
    _of__V = typing.TypeVar('_of__V')  # <V>
    @staticmethod
    def of(hostType: typing.Type[_of__T], valueType: typing.Type[_of__V], name: str | java.lang.String, /) -> Property[_of__T, _of__V]: ...
    def set(self, object: _Property__T, value: _Property__V, /) -> None: ...

_Range__T = typing.TypeVar('_Range__T')  # <T>
class Range(java.lang.Object, typing.Generic[_Range__T]):
    def __init__(self, lower: _Range__T, upper: _Range__T, /) -> None: ...
    def clamp(self, value: _Range__T, /) -> _Range__T: ...
    @typing.overload
    def contains(self, range: Range[_Range__T], /) -> bool: ...
    @typing.overload
    def contains(self, value: _Range__T, /) -> bool: ...
    _create__T = typing.TypeVar('_create__T')  # <T>
    @staticmethod
    def create(lower: _create__T, upper: _create__T, /) -> Range[_create__T]: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def extend(self, range: Range[_Range__T], /) -> Range[_Range__T]: ...
    @typing.overload
    def extend(self, value: _Range__T, /) -> Range[_Range__T]: ...
    @typing.overload
    def extend(self, lower: _Range__T, upper: _Range__T, /) -> Range[_Range__T]: ...
    def getLower(self) -> _Range__T: ...
    def getUpper(self) -> _Range__T: ...
    def hashCode(self) -> int: ...
    @typing.overload
    def intersect(self, range: Range[_Range__T], /) -> Range[_Range__T]: ...
    @typing.overload
    def intersect(self, lower: _Range__T, upper: _Range__T, /) -> Range[_Range__T]: ...
    def toString(self) -> str: ...

class Rational(java.lang.Number, java.lang.Comparable[Rational]):
    NEGATIVE_INFINITY: typing.ClassVar[Rational] = ...
    NaN: typing.ClassVar[Rational] = ...
    POSITIVE_INFINITY: typing.ClassVar[Rational] = ...
    ZERO: typing.ClassVar[Rational] = ...
    def __init__(self, numerator: int | java.jint | java.lang.Integer, denominator: int | java.jint | java.lang.Integer, /) -> None: ...
    def compareTo(self, another: Rational, /) -> int: ...
    def doubleValue(self) -> float: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def floatValue(self) -> float: ...
    def getDenominator(self) -> int: ...
    def getNumerator(self) -> int: ...
    def hashCode(self) -> int: ...
    def intValue(self) -> int: ...
    def isFinite(self) -> bool: ...
    def isInfinite(self) -> bool: ...
    def isNaN(self) -> bool: ...
    def isZero(self) -> bool: ...
    def longValue(self) -> int: ...
    @staticmethod
    def parseRational(string: str | java.lang.String, /) -> Rational: ...
    def shortValue(self) -> int: ...
    def toString(self) -> str: ...

class Size(java.lang.Object):
    def __init__(self, width: int | java.jint | java.lang.Integer, height: int | java.jint | java.lang.Integer, /) -> None: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getHeight(self) -> int: ...
    def getWidth(self) -> int: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def parseSize(string: str | java.lang.String, /) -> Size: ...
    def toString(self) -> str: ...

class SizeF(android.os.Parcelable):
    CREATOR: typing.ClassVar[android.os.Parcelable.Creator[SizeF]] = ...
    def __init__(self, width: float | java.jfloat | java.lang.Float, height: float | java.jfloat | java.lang.Float, /) -> None: ...
    def describeContents(self) -> int: ...
    def equals(self, obj: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getHeight(self) -> float: ...
    def getWidth(self) -> float: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def parseSizeF(string: str | java.lang.String, /) -> SizeF: ...
    def toString(self) -> str: ...
    def writeToParcel(self, out: android.os.Parcel, flags: int | java.jint | java.lang.Integer, /) -> None: ...

_SparseArray__E = typing.TypeVar('_SparseArray__E')  # <E>
class SparseArray(java.lang.Cloneable, typing.Generic[_SparseArray__E]):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    def append(self, key: int | java.jint | java.lang.Integer, value: _SparseArray__E, /) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> SparseArray[_SparseArray__E]: ...
    def contains(self, key: int | java.jint | java.lang.Integer, /) -> bool: ...
    def contentEquals(self, other: SparseArray[java.lang.Object], /) -> bool: ...
    def contentHashCode(self) -> int: ...
    def delete(self, key: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def get(self, key: int | java.jint | java.lang.Integer, /) -> _SparseArray__E: ...
    @typing.overload
    def get(self, key: int | java.jint | java.lang.Integer, valueIfKeyNotFound: _SparseArray__E, /) -> _SparseArray__E: ...
    def indexOfKey(self, key: int | java.jint | java.lang.Integer, /) -> int: ...
    def indexOfValue(self, value: _SparseArray__E, /) -> int: ...
    def keyAt(self, index: int | java.jint | java.lang.Integer, /) -> int: ...
    def put(self, key: int | java.jint | java.lang.Integer, value: _SparseArray__E, /) -> None: ...
    def remove(self, key: int | java.jint | java.lang.Integer, /) -> None: ...
    def removeAt(self, index: int | java.jint | java.lang.Integer, /) -> None: ...
    def removeAtRange(self, index: int | java.jint | java.lang.Integer, size: int | java.jint | java.lang.Integer, /) -> None: ...
    def set(self, key: int | java.jint | java.lang.Integer, value: _SparseArray__E, /) -> None: ...
    def setValueAt(self, index: int | java.jint | java.lang.Integer, value: _SparseArray__E, /) -> None: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def valueAt(self, index: int | java.jint | java.lang.Integer, /) -> _SparseArray__E: ...

class SparseBooleanArray(java.lang.Cloneable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    def append(self, key: int | java.jint | java.lang.Integer, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> SparseBooleanArray: ...
    def delete(self, key: int | java.jint | java.lang.Integer, /) -> None: ...
    def equals(self, that: java.lang.Object | int | bool | float | str, /) -> bool: ...
    @typing.overload
    def get(self, key: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    def get(self, key: int | java.jint | java.lang.Integer, valueIfKeyNotFound: bool | java.jboolean | java.lang.Boolean, /) -> bool: ...
    def hashCode(self) -> int: ...
    def indexOfKey(self, key: int | java.jint | java.lang.Integer, /) -> int: ...
    def indexOfValue(self, value: bool | java.jboolean | java.lang.Boolean, /) -> int: ...
    def keyAt(self, index: int | java.jint | java.lang.Integer, /) -> int: ...
    def put(self, key: int | java.jint | java.lang.Integer, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def removeAt(self, index: int | java.jint | java.lang.Integer, /) -> None: ...
    def setValueAt(self, index: int | java.jint | java.lang.Integer, value: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def valueAt(self, index: int | java.jint | java.lang.Integer, /) -> bool: ...

class SparseIntArray(java.lang.Cloneable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    def append(self, key: int | java.jint | java.lang.Integer, value: int | java.jint | java.lang.Integer, /) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> SparseIntArray: ...
    def delete(self, key: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def get(self, key: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def get(self, key: int | java.jint | java.lang.Integer, valueIfKeyNotFound: int | java.jint | java.lang.Integer, /) -> int: ...
    def indexOfKey(self, key: int | java.jint | java.lang.Integer, /) -> int: ...
    def indexOfValue(self, value: int | java.jint | java.lang.Integer, /) -> int: ...
    def keyAt(self, index: int | java.jint | java.lang.Integer, /) -> int: ...
    def put(self, key: int | java.jint | java.lang.Integer, value: int | java.jint | java.lang.Integer, /) -> None: ...
    def removeAt(self, index: int | java.jint | java.lang.Integer, /) -> None: ...
    def setValueAt(self, index: int | java.jint | java.lang.Integer, value: int | java.jint | java.lang.Integer, /) -> None: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def valueAt(self, index: int | java.jint | java.lang.Integer, /) -> int: ...

class SparseLongArray(java.lang.Cloneable):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, initialCapacity: int | java.jint | java.lang.Integer, /) -> None: ...
    def append(self, key: int | java.jint | java.lang.Integer, value: int | java.jlong | java.lang.Long, /) -> None: ...
    def clear(self) -> None: ...
    def clone(self) -> SparseLongArray: ...
    def delete(self, key: int | java.jint | java.lang.Integer, /) -> None: ...
    @typing.overload
    def get(self, key: int | java.jint | java.lang.Integer, /) -> int: ...
    @typing.overload
    def get(self, key: int | java.jint | java.lang.Integer, valueIfKeyNotFound: int | java.jlong | java.lang.Long, /) -> int: ...
    def indexOfKey(self, key: int | java.jint | java.lang.Integer, /) -> int: ...
    def indexOfValue(self, value: int | java.jlong | java.lang.Long, /) -> int: ...
    def keyAt(self, index: int | java.jint | java.lang.Integer, /) -> int: ...
    def put(self, key: int | java.jint | java.lang.Integer, value: int | java.jlong | java.lang.Long, /) -> None: ...
    def removeAt(self, index: int | java.jint | java.lang.Integer, /) -> None: ...
    def size(self) -> int: ...
    def toString(self) -> str: ...
    def valueAt(self, index: int | java.jint | java.lang.Integer, /) -> int: ...

class StateSet(java.lang.Object):
    NOTHING: typing.ClassVar[java.chaquopy.JavaArrayJInt] = ...
    WILD_CARD: typing.ClassVar[java.chaquopy.JavaArrayJInt] = ...
    @staticmethod
    def dump(states: java.chaquopy.JavaArrayJInt, /) -> str: ...
    @staticmethod
    def isWildCard(stateSetOrSpec: java.chaquopy.JavaArrayJInt, /) -> bool: ...
    @typing.overload
    @staticmethod
    def stateSetMatches(stateSpec: java.chaquopy.JavaArrayJInt, state: int | java.jint | java.lang.Integer, /) -> bool: ...
    @typing.overload
    @staticmethod
    def stateSetMatches(stateSpec: java.chaquopy.JavaArrayJInt, stateSet: java.chaquopy.JavaArrayJInt, /) -> bool: ...
    @staticmethod
    def trimStateSet(states: java.chaquopy.JavaArrayJInt, newSize: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJInt: ...

class StatsLog(java.lang.Object):
    @staticmethod
    def logBinaryPushStateChanged(trainName: str | java.lang.String, trainVersionCode: int | java.jlong | java.lang.Long, options: int | java.jint | java.lang.Integer, state: int | java.jint | java.lang.Integer, experimentIds: java.chaquopy.JavaArrayJLong, /) -> bool: ...
    @staticmethod
    def logEvent(label: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def logStart(label: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def logStop(label: int | java.jint | java.lang.Integer, /) -> bool: ...

class StringBuilderPrinter(Printer):
    def __init__(self, builder: java.lang.StringBuilder, /) -> None: ...
    def println(self, x: str | java.lang.String, /) -> None: ...

class TimeFormatException(java.lang.RuntimeException): ...

class TimeUtils(java.lang.Object):
    @staticmethod
    def getTimeZone(offset: int | java.jint | java.lang.Integer, dst: bool | java.jboolean | java.lang.Boolean, when: int | java.jlong | java.lang.Long, country: str | java.lang.String, /) -> java.util.TimeZone: ...
    @staticmethod
    def getTimeZoneDatabaseVersion() -> str: ...
    @staticmethod
    def getTimeZoneIdsForCountryCode(countryCode: str | java.lang.String, /) -> java.util.List[java.lang.String] | None: ...
    @staticmethod
    def isTimeBetween(reference: java.time.LocalTime, start: java.time.LocalTime, end: java.time.LocalTime, /) -> bool: ...

class TimingLogger(java.lang.Object):
    def __init__(self, tag: str | java.lang.String, label: str | java.lang.String, /) -> None: ...
    def addSplit(self, splitLabel: str | java.lang.String, /) -> None: ...
    def dumpToLog(self) -> None: ...
    @typing.overload
    def reset(self) -> None: ...
    @typing.overload
    def reset(self, tag: str | java.lang.String, label: str | java.lang.String, /) -> None: ...

class TypedValue(java.lang.Object):
    COMPLEX_MANTISSA_MASK: typing.ClassVar[int] = ...
    COMPLEX_MANTISSA_SHIFT: typing.ClassVar[int] = ...
    COMPLEX_RADIX_0p23: typing.ClassVar[int] = ...
    COMPLEX_RADIX_16p7: typing.ClassVar[int] = ...
    COMPLEX_RADIX_23p0: typing.ClassVar[int] = ...
    COMPLEX_RADIX_8p15: typing.ClassVar[int] = ...
    COMPLEX_RADIX_MASK: typing.ClassVar[int] = ...
    COMPLEX_RADIX_SHIFT: typing.ClassVar[int] = ...
    COMPLEX_UNIT_DIP: typing.ClassVar[int] = ...
    COMPLEX_UNIT_FRACTION: typing.ClassVar[int] = ...
    COMPLEX_UNIT_FRACTION_PARENT: typing.ClassVar[int] = ...
    COMPLEX_UNIT_IN: typing.ClassVar[int] = ...
    COMPLEX_UNIT_MASK: typing.ClassVar[int] = ...
    COMPLEX_UNIT_MM: typing.ClassVar[int] = ...
    COMPLEX_UNIT_PT: typing.ClassVar[int] = ...
    COMPLEX_UNIT_PX: typing.ClassVar[int] = ...
    COMPLEX_UNIT_SHIFT: typing.ClassVar[int] = ...
    COMPLEX_UNIT_SP: typing.ClassVar[int] = ...
    DATA_NULL_EMPTY: typing.ClassVar[int] = ...
    DATA_NULL_UNDEFINED: typing.ClassVar[int] = ...
    DENSITY_DEFAULT: typing.ClassVar[int] = ...
    DENSITY_NONE: typing.ClassVar[int] = ...
    TYPE_ATTRIBUTE: typing.ClassVar[int] = ...
    TYPE_DIMENSION: typing.ClassVar[int] = ...
    TYPE_FIRST_COLOR_INT: typing.ClassVar[int] = ...
    TYPE_FIRST_INT: typing.ClassVar[int] = ...
    TYPE_FLOAT: typing.ClassVar[int] = ...
    TYPE_FRACTION: typing.ClassVar[int] = ...
    TYPE_INT_BOOLEAN: typing.ClassVar[int] = ...
    TYPE_INT_COLOR_ARGB4: typing.ClassVar[int] = ...
    TYPE_INT_COLOR_ARGB8: typing.ClassVar[int] = ...
    TYPE_INT_COLOR_RGB4: typing.ClassVar[int] = ...
    TYPE_INT_COLOR_RGB8: typing.ClassVar[int] = ...
    TYPE_INT_DEC: typing.ClassVar[int] = ...
    TYPE_INT_HEX: typing.ClassVar[int] = ...
    TYPE_LAST_COLOR_INT: typing.ClassVar[int] = ...
    TYPE_LAST_INT: typing.ClassVar[int] = ...
    TYPE_NULL: typing.ClassVar[int] = ...
    TYPE_REFERENCE: typing.ClassVar[int] = ...
    TYPE_STRING: typing.ClassVar[int] = ...
    assetCookie: int = ...
    changingConfigurations: int = ...
    data: int = ...
    density: int = ...
    resourceId: int = ...
    sourceResourceId: int = ...
    string: java.lang.CharSequence = ...
    type: int = ...
    def __init__(self) -> None: ...
    @staticmethod
    def applyDimension(unit: int | java.jint | java.lang.Integer, value: float | java.jfloat | java.lang.Float, metrics: DisplayMetrics, /) -> float: ...
    @typing.overload
    def coerceToString(self) -> java.lang.CharSequence | None: ...
    @typing.overload
    @staticmethod
    def coerceToString(type: int | java.jint | java.lang.Integer, data: int | java.jint | java.lang.Integer, /) -> str | None: ...
    @staticmethod
    def complexToDimension(data: int | java.jint | java.lang.Integer, metrics: DisplayMetrics, /) -> float: ...
    @staticmethod
    def complexToDimensionPixelOffset(data: int | java.jint | java.lang.Integer, metrics: DisplayMetrics, /) -> int: ...
    @staticmethod
    def complexToDimensionPixelSize(data: int | java.jint | java.lang.Integer, metrics: DisplayMetrics, /) -> int: ...
    @staticmethod
    def complexToFloat(complex: int | java.jint | java.lang.Integer, /) -> float: ...
    @staticmethod
    def complexToFraction(data: int | java.jint | java.lang.Integer, base: float | java.jfloat | java.lang.Float, pbase: float | java.jfloat | java.lang.Float, /) -> float: ...
    @staticmethod
    def convertDimensionToPixels(unitToConvertFrom: int | java.jint | java.lang.Integer, value: float | java.jfloat | java.lang.Float, metrics: DisplayMetrics, /) -> float: ...
    @staticmethod
    def convertPixelsToDimension(unitToConvertTo: int | java.jint | java.lang.Integer, pixelValue: float | java.jfloat | java.lang.Float, metrics: DisplayMetrics, /) -> float: ...
    @staticmethod
    def deriveDimension(unitToConvertTo: int | java.jint | java.lang.Integer, pixelValue: float | java.jfloat | java.lang.Float, metrics: DisplayMetrics, /) -> float: ...
    def getComplexUnit(self) -> int: ...
    def getDimension(self, metrics: DisplayMetrics, /) -> float: ...
    def getFloat(self) -> float: ...
    def getFraction(self, base: float | java.jfloat | java.lang.Float, pbase: float | java.jfloat | java.lang.Float, /) -> float: ...
    def isColorType(self) -> bool: ...
    def setTo(self, other: TypedValue, /) -> None: ...
    def toString(self) -> str: ...

class Xml(java.lang.Object):
    FEATURE_RELAXED: typing.ClassVar[str] = ...
    @staticmethod
    def asAttributeSet(parser: org.xmlpull.v1.XmlPullParser, /) -> AttributeSet: ...
    @staticmethod
    def findEncodingByName(encodingName: str | java.lang.String, /) -> Xml.Encoding: ...
    @staticmethod
    def newPullParser() -> org.xmlpull.v1.XmlPullParser: ...
    @staticmethod
    def newSerializer() -> org.xmlpull.v1.XmlSerializer: ...
    @typing.overload
    @staticmethod
    def parse(in_: java.io.Reader, contentHandler: org.xml.sax.ContentHandler, /) -> None: ...
    @typing.overload
    @staticmethod
    def parse(xml: str | java.lang.String, contentHandler: org.xml.sax.ContentHandler, /) -> None: ...
    @typing.overload
    @staticmethod
    def parse(in_: java.io.InputStream, encoding: Xml.Encoding, contentHandler: org.xml.sax.ContentHandler, /) -> None: ...

    class Encoding(java.lang.Enum[Xml.Encoding]):
        US_ASCII: typing.ClassVar[Xml.Encoding] = ...
        UTF_8: typing.ClassVar[Xml.Encoding] = ...
        UTF_16: typing.ClassVar[Xml.Encoding] = ...
        ISO_8859_1: typing.ClassVar[Xml.Encoding] = ...
        @staticmethod
        def valueOf(name: str | java.lang.String, /) -> Xml.Encoding: ...
        @staticmethod
        def values() -> java.chaquopy.JavaArray[Xml.Encoding]: ...
