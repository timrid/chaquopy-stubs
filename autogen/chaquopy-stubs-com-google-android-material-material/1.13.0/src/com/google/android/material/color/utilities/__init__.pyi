import java
import java.chaquopy
import java.lang
import java.util
import java.util.function
import typing



class Blend(java.lang.Object):
    @staticmethod
    def cam16Ucs(from_: int | java.jint | java.lang.Integer, to: int | java.jint | java.lang.Integer, amount: float | java.jdouble | java.lang.Double, /) -> int: ...
    @staticmethod
    def harmonize(designColor: int | java.jint | java.lang.Integer, sourceColor: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def hctHue(from_: int | java.jint | java.lang.Integer, to: int | java.jint | java.lang.Integer, amount: float | java.jdouble | java.lang.Double, /) -> int: ...

class Cam16(java.lang.Object):
    def distance(self, other: Cam16, /) -> float: ...
    @staticmethod
    def fromInt(argb: int | java.jint | java.lang.Integer, /) -> Cam16: ...
    @staticmethod
    def fromUcs(jstar: float | java.jdouble | java.lang.Double, astar: float | java.jdouble | java.lang.Double, bstar: float | java.jdouble | java.lang.Double, /) -> Cam16: ...
    @staticmethod
    def fromUcsInViewingConditions(jstar: float | java.jdouble | java.lang.Double, astar: float | java.jdouble | java.lang.Double, bstar: float | java.jdouble | java.lang.Double, viewingConditions: ViewingConditions, /) -> Cam16: ...
    def getAstar(self) -> float: ...
    def getBstar(self) -> float: ...
    def getChroma(self) -> float: ...
    def getHue(self) -> float: ...
    def getJ(self) -> float: ...
    def getJstar(self) -> float: ...
    def getM(self) -> float: ...
    def getQ(self) -> float: ...
    def getS(self) -> float: ...
    def toInt(self) -> int: ...

class ColorUtils(java.lang.Object):
    @staticmethod
    def alphaFromArgb(argb: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def argbFromLab(l: float | java.jdouble | java.lang.Double, a: float | java.jdouble | java.lang.Double, b: float | java.jdouble | java.lang.Double, /) -> int: ...
    @staticmethod
    def argbFromLinrgb(linrgb: java.chaquopy.JavaArrayJDouble, /) -> int: ...
    @staticmethod
    def argbFromLstar(lstar: float | java.jdouble | java.lang.Double, /) -> int: ...
    @staticmethod
    def argbFromRgb(red: int | java.jint | java.lang.Integer, green: int | java.jint | java.lang.Integer, blue: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def argbFromXyz(x: float | java.jdouble | java.lang.Double, y: float | java.jdouble | java.lang.Double, z: float | java.jdouble | java.lang.Double, /) -> int: ...
    @staticmethod
    def blueFromArgb(argb: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def delinearized(rgbComponent: float | java.jdouble | java.lang.Double, /) -> int: ...
    @staticmethod
    def greenFromArgb(argb: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def isOpaque(argb: int | java.jint | java.lang.Integer, /) -> bool: ...
    @staticmethod
    def labFromArgb(argb: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJDouble: ...
    @staticmethod
    def linearized(rgbComponent: int | java.jint | java.lang.Integer, /) -> float: ...
    @staticmethod
    def lstarFromArgb(argb: int | java.jint | java.lang.Integer, /) -> float: ...
    @staticmethod
    def lstarFromY(y: float | java.jdouble | java.lang.Double, /) -> float: ...
    @staticmethod
    def redFromArgb(argb: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def whitePointD65() -> java.chaquopy.JavaArrayJDouble: ...
    @staticmethod
    def xyzFromArgb(argb: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJDouble: ...
    @staticmethod
    def yFromLstar(lstar: float | java.jdouble | java.lang.Double, /) -> float: ...

class Contrast(java.lang.Object):
    RATIO_MIN: typing.ClassVar[float] = ...
    RATIO_MAX: typing.ClassVar[float] = ...
    RATIO_30: typing.ClassVar[float] = ...
    RATIO_45: typing.ClassVar[float] = ...
    RATIO_70: typing.ClassVar[float] = ...
    @staticmethod
    def darker(tone: float | java.jdouble | java.lang.Double, ratio: float | java.jdouble | java.lang.Double, /) -> float: ...
    @staticmethod
    def darkerUnsafe(tone: float | java.jdouble | java.lang.Double, ratio: float | java.jdouble | java.lang.Double, /) -> float: ...
    @staticmethod
    def lighter(tone: float | java.jdouble | java.lang.Double, ratio: float | java.jdouble | java.lang.Double, /) -> float: ...
    @staticmethod
    def lighterUnsafe(tone: float | java.jdouble | java.lang.Double, ratio: float | java.jdouble | java.lang.Double, /) -> float: ...
    @staticmethod
    def ratioOfTones(t1: float | java.jdouble | java.lang.Double, t2: float | java.jdouble | java.lang.Double, /) -> float: ...
    @staticmethod
    def ratioOfYs(y1: float | java.jdouble | java.lang.Double, y2: float | java.jdouble | java.lang.Double, /) -> float: ...

class ContrastCurve(java.lang.Object):
    def __init__(self, low: float | java.jdouble | java.lang.Double, normal: float | java.jdouble | java.lang.Double, medium: float | java.jdouble | java.lang.Double, high: float | java.jdouble | java.lang.Double, /) -> None: ...
    def get(self, contrastLevel: float | java.jdouble | java.lang.Double, /) -> float: ...

class CorePalette(java.lang.Object):
    a1: TonalPalette = ...
    a2: TonalPalette = ...
    a3: TonalPalette = ...
    n1: TonalPalette = ...
    n2: TonalPalette = ...
    error: TonalPalette = ...
    @staticmethod
    def contentOf(argb: int | java.jint | java.lang.Integer, /) -> CorePalette: ...
    @staticmethod
    def of(argb: int | java.jint | java.lang.Integer, /) -> CorePalette: ...

class DislikeAnalyzer(java.lang.Object):
    @staticmethod
    def fixIfDisliked(hct: Hct, /) -> Hct: ...
    @staticmethod
    def isDisliked(hct: Hct, /) -> bool: ...

class DynamicColor(java.lang.Object):
    name: str = ...
    palette: java.util.function.Function[DynamicScheme, TonalPalette] = ...
    tone: java.util.function.Function[DynamicScheme, java.lang.Double] = ...
    isBackground: bool = ...
    background: java.util.function.Function[DynamicScheme, DynamicColor] = ...
    secondBackground: java.util.function.Function[DynamicScheme, DynamicColor] = ...
    contrastCurve: ContrastCurve = ...
    toneDeltaPair: java.util.function.Function[DynamicScheme, ToneDeltaPair] = ...
    opacity: java.util.function.Function[DynamicScheme, java.lang.Double] = ...
    @typing.overload
    def __init__(self, name: str | java.lang.String, palette: java.util.function.Function[DynamicScheme, TonalPalette], tone: java.util.function.Function[DynamicScheme, java.lang.Double], isBackground: bool | java.jboolean | java.lang.Boolean, background: java.util.function.Function[DynamicScheme, DynamicColor], secondBackground: java.util.function.Function[DynamicScheme, DynamicColor], contrastCurve: ContrastCurve, toneDeltaPair: java.util.function.Function[DynamicScheme, ToneDeltaPair], /) -> None: ...
    @typing.overload
    def __init__(self, name: str | java.lang.String, palette: java.util.function.Function[DynamicScheme, TonalPalette], tone: java.util.function.Function[DynamicScheme, java.lang.Double], isBackground: bool | java.jboolean | java.lang.Boolean, background: java.util.function.Function[DynamicScheme, DynamicColor], secondBackground: java.util.function.Function[DynamicScheme, DynamicColor], contrastCurve: ContrastCurve, toneDeltaPair: java.util.function.Function[DynamicScheme, ToneDeltaPair], opacity: java.util.function.Function[DynamicScheme, java.lang.Double], /) -> None: ...
    @staticmethod
    def enableLightForeground(tone: float | java.jdouble | java.lang.Double, /) -> float: ...
    @staticmethod
    def foregroundTone(bgTone: float | java.jdouble | java.lang.Double, ratio: float | java.jdouble | java.lang.Double, /) -> float: ...
    @staticmethod
    def fromArgb(name: str | java.lang.String, argb: int | java.jint | java.lang.Integer, /) -> DynamicColor: ...
    @typing.overload
    @staticmethod
    def fromPalette(name: str | java.lang.String, palette: java.util.function.Function[DynamicScheme, TonalPalette], tone: java.util.function.Function[DynamicScheme, java.lang.Double], /) -> DynamicColor: ...
    @typing.overload
    @staticmethod
    def fromPalette(name: str | java.lang.String, palette: java.util.function.Function[DynamicScheme, TonalPalette], tone: java.util.function.Function[DynamicScheme, java.lang.Double], isBackground: bool | java.jboolean | java.lang.Boolean, /) -> DynamicColor: ...
    def getArgb(self, scheme: DynamicScheme, /) -> int: ...
    def getHct(self, scheme: DynamicScheme, /) -> Hct: ...
    def getTone(self, scheme: DynamicScheme, /) -> float: ...
    @staticmethod
    def toneAllowsLightForeground(tone: float | java.jdouble | java.lang.Double, /) -> bool: ...
    @staticmethod
    def tonePrefersLightForeground(tone: float | java.jdouble | java.lang.Double, /) -> bool: ...

class DynamicScheme(java.lang.Object):
    sourceColorArgb: int = ...
    sourceColorHct: Hct = ...
    variant: Variant = ...
    isDark: bool = ...
    contrastLevel: float = ...
    primaryPalette: TonalPalette = ...
    secondaryPalette: TonalPalette = ...
    tertiaryPalette: TonalPalette = ...
    neutralPalette: TonalPalette = ...
    neutralVariantPalette: TonalPalette = ...
    errorPalette: TonalPalette = ...
    def __init__(self, sourceColorHct: Hct, variant: Variant, isDark: bool | java.jboolean | java.lang.Boolean, contrastLevel: float | java.jdouble | java.lang.Double, primaryPalette: TonalPalette, secondaryPalette: TonalPalette, tertiaryPalette: TonalPalette, neutralPalette: TonalPalette, neutralVariantPalette: TonalPalette, /) -> None: ...
    def getArgb(self, dynamicColor: DynamicColor, /) -> int: ...
    def getBackground(self) -> int: ...
    def getControlActivated(self) -> int: ...
    def getControlHighlight(self) -> int: ...
    def getControlNormal(self) -> int: ...
    def getError(self) -> int: ...
    def getErrorContainer(self) -> int: ...
    def getHct(self, dynamicColor: DynamicColor, /) -> Hct: ...
    def getInverseOnSurface(self) -> int: ...
    def getInversePrimary(self) -> int: ...
    def getInverseSurface(self) -> int: ...
    def getNeutralPaletteKeyColor(self) -> int: ...
    def getNeutralVariantPaletteKeyColor(self) -> int: ...
    def getOnBackground(self) -> int: ...
    def getOnError(self) -> int: ...
    def getOnErrorContainer(self) -> int: ...
    def getOnPrimary(self) -> int: ...
    def getOnPrimaryContainer(self) -> int: ...
    def getOnPrimaryFixed(self) -> int: ...
    def getOnPrimaryFixedVariant(self) -> int: ...
    def getOnSecondary(self) -> int: ...
    def getOnSecondaryContainer(self) -> int: ...
    def getOnSecondaryFixed(self) -> int: ...
    def getOnSecondaryFixedVariant(self) -> int: ...
    def getOnSurface(self) -> int: ...
    def getOnSurfaceVariant(self) -> int: ...
    def getOnTertiary(self) -> int: ...
    def getOnTertiaryContainer(self) -> int: ...
    def getOnTertiaryFixed(self) -> int: ...
    def getOnTertiaryFixedVariant(self) -> int: ...
    def getOutline(self) -> int: ...
    def getOutlineVariant(self) -> int: ...
    def getPrimary(self) -> int: ...
    def getPrimaryContainer(self) -> int: ...
    def getPrimaryFixed(self) -> int: ...
    def getPrimaryFixedDim(self) -> int: ...
    def getPrimaryPaletteKeyColor(self) -> int: ...
    @staticmethod
    def getRotatedHue(sourceColorHct: Hct, hues: java.chaquopy.JavaArrayJDouble, rotations: java.chaquopy.JavaArrayJDouble, /) -> float: ...
    def getScrim(self) -> int: ...
    def getSecondary(self) -> int: ...
    def getSecondaryContainer(self) -> int: ...
    def getSecondaryFixed(self) -> int: ...
    def getSecondaryFixedDim(self) -> int: ...
    def getSecondaryPaletteKeyColor(self) -> int: ...
    def getShadow(self) -> int: ...
    def getSurface(self) -> int: ...
    def getSurfaceBright(self) -> int: ...
    def getSurfaceContainer(self) -> int: ...
    def getSurfaceContainerHigh(self) -> int: ...
    def getSurfaceContainerHighest(self) -> int: ...
    def getSurfaceContainerLow(self) -> int: ...
    def getSurfaceContainerLowest(self) -> int: ...
    def getSurfaceDim(self) -> int: ...
    def getSurfaceTint(self) -> int: ...
    def getSurfaceVariant(self) -> int: ...
    def getTertiary(self) -> int: ...
    def getTertiaryContainer(self) -> int: ...
    def getTertiaryFixed(self) -> int: ...
    def getTertiaryFixedDim(self) -> int: ...
    def getTertiaryPaletteKeyColor(self) -> int: ...
    def getTextHintInverse(self) -> int: ...
    def getTextPrimaryInverse(self) -> int: ...
    def getTextPrimaryInverseDisableOnly(self) -> int: ...
    def getTextSecondaryAndTertiaryInverse(self) -> int: ...
    def getTextSecondaryAndTertiaryInverseDisabled(self) -> int: ...

class Hct(java.lang.Object):
    @staticmethod
    def fromInt(argb: int | java.jint | java.lang.Integer, /) -> Hct: ...
    @staticmethod
    def from_(hue: float | java.jdouble | java.lang.Double, chroma: float | java.jdouble | java.lang.Double, tone: float | java.jdouble | java.lang.Double, /) -> Hct: ...
    def getChroma(self) -> float: ...
    def getHue(self) -> float: ...
    def getTone(self) -> float: ...
    def inViewingConditions(self, vc: ViewingConditions, /) -> Hct: ...
    def setChroma(self, newChroma: float | java.jdouble | java.lang.Double, /) -> None: ...
    def setHue(self, newHue: float | java.jdouble | java.lang.Double, /) -> None: ...
    def setTone(self, newTone: float | java.jdouble | java.lang.Double, /) -> None: ...
    def toInt(self) -> int: ...

class HctSolver(java.lang.Object):
    @staticmethod
    def solveToCam(hueDegrees: float | java.jdouble | java.lang.Double, chroma: float | java.jdouble | java.lang.Double, lstar: float | java.jdouble | java.lang.Double, /) -> Cam16: ...
    @staticmethod
    def solveToInt(hueDegrees: float | java.jdouble | java.lang.Double, chroma: float | java.jdouble | java.lang.Double, lstar: float | java.jdouble | java.lang.Double, /) -> int: ...

class MaterialDynamicColors(java.lang.Object):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, isExtendedFidelity: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def background(self) -> DynamicColor: ...
    def controlActivated(self) -> DynamicColor: ...
    def controlHighlight(self) -> DynamicColor: ...
    def controlNormal(self) -> DynamicColor: ...
    def error(self) -> DynamicColor: ...
    def errorContainer(self) -> DynamicColor: ...
    def highestSurface(self, s: DynamicScheme, /) -> DynamicColor: ...
    def inverseOnSurface(self) -> DynamicColor: ...
    def inversePrimary(self) -> DynamicColor: ...
    def inverseSurface(self) -> DynamicColor: ...
    def neutralPaletteKeyColor(self) -> DynamicColor: ...
    def neutralVariantPaletteKeyColor(self) -> DynamicColor: ...
    def onBackground(self) -> DynamicColor: ...
    def onError(self) -> DynamicColor: ...
    def onErrorContainer(self) -> DynamicColor: ...
    def onPrimary(self) -> DynamicColor: ...
    def onPrimaryContainer(self) -> DynamicColor: ...
    def onPrimaryFixed(self) -> DynamicColor: ...
    def onPrimaryFixedVariant(self) -> DynamicColor: ...
    def onSecondary(self) -> DynamicColor: ...
    def onSecondaryContainer(self) -> DynamicColor: ...
    def onSecondaryFixed(self) -> DynamicColor: ...
    def onSecondaryFixedVariant(self) -> DynamicColor: ...
    def onSurface(self) -> DynamicColor: ...
    def onSurfaceVariant(self) -> DynamicColor: ...
    def onTertiary(self) -> DynamicColor: ...
    def onTertiaryContainer(self) -> DynamicColor: ...
    def onTertiaryFixed(self) -> DynamicColor: ...
    def onTertiaryFixedVariant(self) -> DynamicColor: ...
    def outline(self) -> DynamicColor: ...
    def outlineVariant(self) -> DynamicColor: ...
    def primary(self) -> DynamicColor: ...
    def primaryContainer(self) -> DynamicColor: ...
    def primaryFixed(self) -> DynamicColor: ...
    def primaryFixedDim(self) -> DynamicColor: ...
    def primaryPaletteKeyColor(self) -> DynamicColor: ...
    def scrim(self) -> DynamicColor: ...
    def secondary(self) -> DynamicColor: ...
    def secondaryContainer(self) -> DynamicColor: ...
    def secondaryFixed(self) -> DynamicColor: ...
    def secondaryFixedDim(self) -> DynamicColor: ...
    def secondaryPaletteKeyColor(self) -> DynamicColor: ...
    def shadow(self) -> DynamicColor: ...
    def surface(self) -> DynamicColor: ...
    def surfaceBright(self) -> DynamicColor: ...
    def surfaceContainer(self) -> DynamicColor: ...
    def surfaceContainerHigh(self) -> DynamicColor: ...
    def surfaceContainerHighest(self) -> DynamicColor: ...
    def surfaceContainerLow(self) -> DynamicColor: ...
    def surfaceContainerLowest(self) -> DynamicColor: ...
    def surfaceDim(self) -> DynamicColor: ...
    def surfaceTint(self) -> DynamicColor: ...
    def surfaceVariant(self) -> DynamicColor: ...
    def tertiary(self) -> DynamicColor: ...
    def tertiaryContainer(self) -> DynamicColor: ...
    def tertiaryFixed(self) -> DynamicColor: ...
    def tertiaryFixedDim(self) -> DynamicColor: ...
    def tertiaryPaletteKeyColor(self) -> DynamicColor: ...
    def textHintInverse(self) -> DynamicColor: ...
    def textPrimaryInverse(self) -> DynamicColor: ...
    def textPrimaryInverseDisableOnly(self) -> DynamicColor: ...
    def textSecondaryAndTertiaryInverse(self) -> DynamicColor: ...
    def textSecondaryAndTertiaryInverseDisabled(self) -> DynamicColor: ...

class MathUtils(java.lang.Object):
    @staticmethod
    def clampDouble(min: float | java.jdouble | java.lang.Double, max: float | java.jdouble | java.lang.Double, input: float | java.jdouble | java.lang.Double, /) -> float: ...
    @staticmethod
    def clampInt(min: int | java.jint | java.lang.Integer, max: int | java.jint | java.lang.Integer, input: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def differenceDegrees(a: float | java.jdouble | java.lang.Double, b: float | java.jdouble | java.lang.Double, /) -> float: ...
    @staticmethod
    def lerp(start: float | java.jdouble | java.lang.Double, stop: float | java.jdouble | java.lang.Double, amount: float | java.jdouble | java.lang.Double, /) -> float: ...
    @staticmethod
    def matrixMultiply(row: java.chaquopy.JavaArrayJDouble, matrix: java.chaquopy.JavaArray[java.chaquopy.JavaArrayJDouble], /) -> java.chaquopy.JavaArrayJDouble: ...
    @staticmethod
    def rotationDirection(from_: float | java.jdouble | java.lang.Double, to: float | java.jdouble | java.lang.Double, /) -> float: ...
    @staticmethod
    def sanitizeDegreesDouble(degrees: float | java.jdouble | java.lang.Double, /) -> float: ...
    @staticmethod
    def sanitizeDegreesInt(degrees: int | java.jint | java.lang.Integer, /) -> int: ...
    @staticmethod
    def signum(num: float | java.jdouble | java.lang.Double, /) -> int: ...

class PointProvider(java.lang.Object):
    def distance(self, arg1: java.chaquopy.JavaArrayJDouble, arg2: java.chaquopy.JavaArrayJDouble, /) -> float: ...
    def fromInt(self, arg1: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJDouble: ...
    def toInt(self, arg1: java.chaquopy.JavaArrayJDouble, /) -> int: ...

class PointProviderLab(PointProvider):
    def __init__(self) -> None: ...
    def distance(self, one: java.chaquopy.JavaArrayJDouble, two: java.chaquopy.JavaArrayJDouble, /) -> float: ...
    def fromInt(self, argb: int | java.jint | java.lang.Integer, /) -> java.chaquopy.JavaArrayJDouble: ...
    def toInt(self, lab: java.chaquopy.JavaArrayJDouble, /) -> int: ...

class Quantizer(java.lang.Object):
    def quantize(self, arg1: java.chaquopy.JavaArrayJInt, arg2: int | java.jint | java.lang.Integer, /) -> QuantizerResult: ...

class QuantizerCelebi(java.lang.Object):
    @staticmethod
    def quantize(pixels: java.chaquopy.JavaArrayJInt, maxColors: int | java.jint | java.lang.Integer, /) -> java.util.Map[java.lang.Integer, java.lang.Integer]: ...

class QuantizerMap(Quantizer):
    def __init__(self) -> None: ...
    def getColorToCount(self) -> java.util.Map[java.lang.Integer, java.lang.Integer]: ...
    def quantize(self, pixels: java.chaquopy.JavaArrayJInt, colorCount: int | java.jint | java.lang.Integer, /) -> QuantizerResult: ...

class QuantizerResult(java.lang.Object):
    colorToCount: java.util.Map[java.lang.Integer, java.lang.Integer] = ...

class QuantizerWsmeans(java.lang.Object):
    @staticmethod
    def quantize(inputPixels: java.chaquopy.JavaArrayJInt, startingClusters: java.chaquopy.JavaArrayJInt, maxColors: int | java.jint | java.lang.Integer, /) -> java.util.Map[java.lang.Integer, java.lang.Integer]: ...

class QuantizerWu(Quantizer):
    def __init__(self) -> None: ...
    def quantize(self, pixels: java.chaquopy.JavaArrayJInt, colorCount: int | java.jint | java.lang.Integer, /) -> QuantizerResult: ...

class Scheme(java.lang.Object):
    @typing.overload
    def __init__(self) -> None: ...
    @typing.overload
    def __init__(self, primary: int | java.jint | java.lang.Integer, onPrimary: int | java.jint | java.lang.Integer, primaryContainer: int | java.jint | java.lang.Integer, onPrimaryContainer: int | java.jint | java.lang.Integer, secondary: int | java.jint | java.lang.Integer, onSecondary: int | java.jint | java.lang.Integer, secondaryContainer: int | java.jint | java.lang.Integer, onSecondaryContainer: int | java.jint | java.lang.Integer, tertiary: int | java.jint | java.lang.Integer, onTertiary: int | java.jint | java.lang.Integer, tertiaryContainer: int | java.jint | java.lang.Integer, onTertiaryContainer: int | java.jint | java.lang.Integer, error: int | java.jint | java.lang.Integer, onError: int | java.jint | java.lang.Integer, errorContainer: int | java.jint | java.lang.Integer, onErrorContainer: int | java.jint | java.lang.Integer, background: int | java.jint | java.lang.Integer, onBackground: int | java.jint | java.lang.Integer, surface: int | java.jint | java.lang.Integer, onSurface: int | java.jint | java.lang.Integer, surfaceVariant: int | java.jint | java.lang.Integer, onSurfaceVariant: int | java.jint | java.lang.Integer, outline: int | java.jint | java.lang.Integer, outlineVariant: int | java.jint | java.lang.Integer, shadow: int | java.jint | java.lang.Integer, scrim: int | java.jint | java.lang.Integer, inverseSurface: int | java.jint | java.lang.Integer, inverseOnSurface: int | java.jint | java.lang.Integer, inversePrimary: int | java.jint | java.lang.Integer, /) -> None: ...
    @staticmethod
    def dark(argb: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    @staticmethod
    def darkContent(argb: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def equals(self, object: java.lang.Object | int | bool | float | str, /) -> bool: ...
    def getBackground(self) -> int: ...
    def getError(self) -> int: ...
    def getErrorContainer(self) -> int: ...
    def getInverseOnSurface(self) -> int: ...
    def getInversePrimary(self) -> int: ...
    def getInverseSurface(self) -> int: ...
    def getOnBackground(self) -> int: ...
    def getOnError(self) -> int: ...
    def getOnErrorContainer(self) -> int: ...
    def getOnPrimary(self) -> int: ...
    def getOnPrimaryContainer(self) -> int: ...
    def getOnSecondary(self) -> int: ...
    def getOnSecondaryContainer(self) -> int: ...
    def getOnSurface(self) -> int: ...
    def getOnSurfaceVariant(self) -> int: ...
    def getOnTertiary(self) -> int: ...
    def getOnTertiaryContainer(self) -> int: ...
    def getOutline(self) -> int: ...
    def getOutlineVariant(self) -> int: ...
    def getPrimary(self) -> int: ...
    def getPrimaryContainer(self) -> int: ...
    def getScrim(self) -> int: ...
    def getSecondary(self) -> int: ...
    def getSecondaryContainer(self) -> int: ...
    def getShadow(self) -> int: ...
    def getSurface(self) -> int: ...
    def getSurfaceVariant(self) -> int: ...
    def getTertiary(self) -> int: ...
    def getTertiaryContainer(self) -> int: ...
    def hashCode(self) -> int: ...
    @staticmethod
    def light(argb: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    @staticmethod
    def lightContent(argb: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def setBackground(self, background: int | java.jint | java.lang.Integer, /) -> None: ...
    def setError(self, error: int | java.jint | java.lang.Integer, /) -> None: ...
    def setErrorContainer(self, errorContainer: int | java.jint | java.lang.Integer, /) -> None: ...
    def setInverseOnSurface(self, inverseOnSurface: int | java.jint | java.lang.Integer, /) -> None: ...
    def setInversePrimary(self, inversePrimary: int | java.jint | java.lang.Integer, /) -> None: ...
    def setInverseSurface(self, inverseSurface: int | java.jint | java.lang.Integer, /) -> None: ...
    def setOnBackground(self, onBackground: int | java.jint | java.lang.Integer, /) -> None: ...
    def setOnError(self, onError: int | java.jint | java.lang.Integer, /) -> None: ...
    def setOnErrorContainer(self, onErrorContainer: int | java.jint | java.lang.Integer, /) -> None: ...
    def setOnPrimary(self, onPrimary: int | java.jint | java.lang.Integer, /) -> None: ...
    def setOnPrimaryContainer(self, onPrimaryContainer: int | java.jint | java.lang.Integer, /) -> None: ...
    def setOnSecondary(self, onSecondary: int | java.jint | java.lang.Integer, /) -> None: ...
    def setOnSecondaryContainer(self, onSecondaryContainer: int | java.jint | java.lang.Integer, /) -> None: ...
    def setOnSurface(self, onSurface: int | java.jint | java.lang.Integer, /) -> None: ...
    def setOnSurfaceVariant(self, onSurfaceVariant: int | java.jint | java.lang.Integer, /) -> None: ...
    def setOnTertiary(self, onTertiary: int | java.jint | java.lang.Integer, /) -> None: ...
    def setOnTertiaryContainer(self, onTertiaryContainer: int | java.jint | java.lang.Integer, /) -> None: ...
    def setOutline(self, outline: int | java.jint | java.lang.Integer, /) -> None: ...
    def setOutlineVariant(self, outlineVariant: int | java.jint | java.lang.Integer, /) -> None: ...
    def setPrimary(self, primary: int | java.jint | java.lang.Integer, /) -> None: ...
    def setPrimaryContainer(self, primaryContainer: int | java.jint | java.lang.Integer, /) -> None: ...
    def setScrim(self, scrim: int | java.jint | java.lang.Integer, /) -> None: ...
    def setSecondary(self, secondary: int | java.jint | java.lang.Integer, /) -> None: ...
    def setSecondaryContainer(self, secondaryContainer: int | java.jint | java.lang.Integer, /) -> None: ...
    def setShadow(self, shadow: int | java.jint | java.lang.Integer, /) -> None: ...
    def setSurface(self, surface: int | java.jint | java.lang.Integer, /) -> None: ...
    def setSurfaceVariant(self, surfaceVariant: int | java.jint | java.lang.Integer, /) -> None: ...
    def setTertiary(self, tertiary: int | java.jint | java.lang.Integer, /) -> None: ...
    def setTertiaryContainer(self, tertiaryContainer: int | java.jint | java.lang.Integer, /) -> None: ...
    def toString(self) -> str: ...
    def withBackground(self, background: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withError(self, error: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withErrorContainer(self, errorContainer: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withInverseOnSurface(self, inverseOnSurface: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withInversePrimary(self, inversePrimary: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withInverseSurface(self, inverseSurface: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withOnBackground(self, onBackground: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withOnError(self, onError: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withOnErrorContainer(self, onErrorContainer: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withOnPrimary(self, onPrimary: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withOnPrimaryContainer(self, onPrimaryContainer: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withOnSecondary(self, onSecondary: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withOnSecondaryContainer(self, onSecondaryContainer: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withOnSurface(self, onSurface: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withOnSurfaceVariant(self, onSurfaceVariant: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withOnTertiary(self, onTertiary: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withOnTertiaryContainer(self, onTertiaryContainer: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withOutline(self, outline: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withOutlineVariant(self, outlineVariant: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withPrimary(self, primary: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withPrimaryContainer(self, primaryContainer: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withScrim(self, scrim: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withSecondary(self, secondary: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withSecondaryContainer(self, secondaryContainer: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withShadow(self, shadow: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withSurface(self, surface: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withSurfaceVariant(self, surfaceVariant: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withTertiary(self, tertiary: int | java.jint | java.lang.Integer, /) -> Scheme: ...
    def withTertiaryContainer(self, tertiaryContainer: int | java.jint | java.lang.Integer, /) -> Scheme: ...

class SchemeContent(DynamicScheme):
    def __init__(self, sourceColorHct: Hct, isDark: bool | java.jboolean | java.lang.Boolean, contrastLevel: float | java.jdouble | java.lang.Double, /) -> None: ...

class SchemeExpressive(DynamicScheme):
    def __init__(self, sourceColorHct: Hct, isDark: bool | java.jboolean | java.lang.Boolean, contrastLevel: float | java.jdouble | java.lang.Double, /) -> None: ...

class SchemeFidelity(DynamicScheme):
    def __init__(self, sourceColorHct: Hct, isDark: bool | java.jboolean | java.lang.Boolean, contrastLevel: float | java.jdouble | java.lang.Double, /) -> None: ...

class SchemeFruitSalad(DynamicScheme):
    def __init__(self, sourceColorHct: Hct, isDark: bool | java.jboolean | java.lang.Boolean, contrastLevel: float | java.jdouble | java.lang.Double, /) -> None: ...

class SchemeMonochrome(DynamicScheme):
    def __init__(self, sourceColorHct: Hct, isDark: bool | java.jboolean | java.lang.Boolean, contrastLevel: float | java.jdouble | java.lang.Double, /) -> None: ...

class SchemeNeutral(DynamicScheme):
    def __init__(self, sourceColorHct: Hct, isDark: bool | java.jboolean | java.lang.Boolean, contrastLevel: float | java.jdouble | java.lang.Double, /) -> None: ...

class SchemeRainbow(DynamicScheme):
    def __init__(self, sourceColorHct: Hct, isDark: bool | java.jboolean | java.lang.Boolean, contrastLevel: float | java.jdouble | java.lang.Double, /) -> None: ...

class SchemeTonalSpot(DynamicScheme):
    def __init__(self, sourceColorHct: Hct, isDark: bool | java.jboolean | java.lang.Boolean, contrastLevel: float | java.jdouble | java.lang.Double, /) -> None: ...

class SchemeVibrant(DynamicScheme):
    def __init__(self, sourceColorHct: Hct, isDark: bool | java.jboolean | java.lang.Boolean, contrastLevel: float | java.jdouble | java.lang.Double, /) -> None: ...

class Score(java.lang.Object):
    @typing.overload
    @staticmethod
    def score(colorsToPopulation: java.util.Map[java.lang.Integer, java.lang.Integer], /) -> java.util.List[java.lang.Integer]: ...
    @typing.overload
    @staticmethod
    def score(colorsToPopulation: java.util.Map[java.lang.Integer, java.lang.Integer], maxColorCount: int | java.jint | java.lang.Integer, /) -> java.util.List[java.lang.Integer]: ...
    @typing.overload
    @staticmethod
    def score(colorsToPopulation: java.util.Map[java.lang.Integer, java.lang.Integer], maxColorCount: int | java.jint | java.lang.Integer, fallbackColorArgb: int | java.jint | java.lang.Integer, /) -> java.util.List[java.lang.Integer]: ...
    @typing.overload
    @staticmethod
    def score(colorsToPopulation: java.util.Map[java.lang.Integer, java.lang.Integer], maxColorCount: int | java.jint | java.lang.Integer, fallbackColorArgb: int | java.jint | java.lang.Integer, filter: bool | java.jboolean | java.lang.Boolean, /) -> java.util.List[java.lang.Integer]: ...

class TemperatureCache(java.lang.Object):
    def __init__(self, input: Hct, /) -> None: ...
    @typing.overload
    def getAnalogousColors(self) -> java.util.List[Hct]: ...
    @typing.overload
    def getAnalogousColors(self, count: int | java.jint | java.lang.Integer, divisions: int | java.jint | java.lang.Integer, /) -> java.util.List[Hct]: ...
    def getComplement(self) -> Hct: ...
    def getRelativeTemperature(self, hct: Hct, /) -> float: ...
    @staticmethod
    def rawTemperature(color: Hct, /) -> float: ...

class TonalPalette(java.lang.Object):
    @staticmethod
    def fromHct(hct: Hct, /) -> TonalPalette: ...
    @staticmethod
    def fromHueAndChroma(hue: float | java.jdouble | java.lang.Double, chroma: float | java.jdouble | java.lang.Double, /) -> TonalPalette: ...
    @staticmethod
    def fromInt(argb: int | java.jint | java.lang.Integer, /) -> TonalPalette: ...
    def getChroma(self) -> float: ...
    def getHct(self, tone: float | java.jdouble | java.lang.Double, /) -> Hct: ...
    def getHue(self) -> float: ...
    def getKeyColor(self) -> Hct: ...
    def tone(self, tone: int | java.jint | java.lang.Integer, /) -> int: ...

class ToneDeltaPair(java.lang.Object):
    def __init__(self, roleA: DynamicColor, roleB: DynamicColor, delta: float | java.jdouble | java.lang.Double, polarity: TonePolarity, stayTogether: bool | java.jboolean | java.lang.Boolean, /) -> None: ...
    def getDelta(self) -> float: ...
    def getPolarity(self) -> TonePolarity: ...
    def getRoleA(self) -> DynamicColor: ...
    def getRoleB(self) -> DynamicColor: ...
    def getStayTogether(self) -> bool: ...

class TonePolarity(java.lang.Enum[TonePolarity]):
    DARKER: typing.ClassVar[TonePolarity] = ...
    LIGHTER: typing.ClassVar[TonePolarity] = ...
    NEARER: typing.ClassVar[TonePolarity] = ...
    FARTHER: typing.ClassVar[TonePolarity] = ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> TonePolarity: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[TonePolarity]: ...

class Variant(java.lang.Enum[Variant]):
    MONOCHROME: typing.ClassVar[Variant] = ...
    NEUTRAL: typing.ClassVar[Variant] = ...
    TONAL_SPOT: typing.ClassVar[Variant] = ...
    VIBRANT: typing.ClassVar[Variant] = ...
    EXPRESSIVE: typing.ClassVar[Variant] = ...
    FIDELITY: typing.ClassVar[Variant] = ...
    CONTENT: typing.ClassVar[Variant] = ...
    RAINBOW: typing.ClassVar[Variant] = ...
    FRUIT_SALAD: typing.ClassVar[Variant] = ...
    @staticmethod
    def valueOf(name: str | java.lang.String, /) -> Variant: ...
    @staticmethod
    def values() -> java.chaquopy.JavaArray[Variant]: ...

class ViewingConditions(java.lang.Object):
    DEFAULT: typing.ClassVar[ViewingConditions] = ...
    @staticmethod
    def defaultWithBackgroundLstar(lstar: float | java.jdouble | java.lang.Double, /) -> ViewingConditions: ...
    def getAw(self) -> float: ...
    def getFlRoot(self) -> float: ...
    def getN(self) -> float: ...
    def getNbb(self) -> float: ...
    def getRgbD(self) -> java.chaquopy.JavaArrayJDouble: ...
    @staticmethod
    def make(whitePoint: java.chaquopy.JavaArrayJDouble, adaptingLuminance: float | java.jdouble | java.lang.Double, backgroundLstar: float | java.jdouble | java.lang.Double, surround: float | java.jdouble | java.lang.Double, discountingIlluminant: bool | java.jboolean | java.lang.Boolean, /) -> ViewingConditions: ...
